<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《深入理解Java虚拟机》阅读笔记 | Inequalitiesの博客</title><meta name="author" content="Inequalities"><meta name="copyright" content="Inequalities"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JVM学习链路  Class 文件结构1.魔数与次主版本号每个Class文件的头4个字节被称为魔数(CAFEBABE)，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。 紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号，第7和第8个字节是主版本号。高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。 2.常量池计数">
<meta property="og:type" content="article">
<meta property="og:title" content="《深入理解Java虚拟机》阅读笔记">
<meta property="og:url" content="https://monkey918857.github.io/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Inequalitiesの博客">
<meta property="og:description" content="JVM学习链路  Class 文件结构1.魔数与次主版本号每个Class文件的头4个字节被称为魔数(CAFEBABE)，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。 紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号，第7和第8个字节是主版本号。高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。 2.常量池计数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-baofun.zhhainiao.com/pcwallpaper_ugc/static/53f31f4f8ca1bb064ea18a398db64db9.jpg?x-oss-process=image%2fresize%2cm_lfit%2cw_3840%2ch_2160">
<meta property="article:published_time" content="2023-10-24T13:40:17.000Z">
<meta property="article:modified_time" content="2024-02-13T14:16:59.284Z">
<meta property="article:author" content="Inequalities">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-baofun.zhhainiao.com/pcwallpaper_ugc/static/53f31f4f8ca1bb064ea18a398db64db9.jpg?x-oss-process=image%2fresize%2cm_lfit%2cw_3840%2ch_2160"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://monkey918857.github.io/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《深入理解Java虚拟机》阅读笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-13 22:16:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img-baofun.zhhainiao.com/pcwallpaper_ugc/static/53f31f4f8ca1bb064ea18a398db64db9.jpg?x-oss-process=image%2fresize%2cm_lfit%2cw_3840%2ch_2160')"><nav id="nav"><span id="blog-info"><a href="/" title="Inequalitiesの博客"><span class="site-name">Inequalitiesの博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《深入理解Java虚拟机》阅读笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-24T13:40:17.000Z" title="发表于 2023-10-24 21:40:17">2023-10-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-13T14:16:59.284Z" title="更新于 2024-02-13 22:16:59">2024-02-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">33.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>104分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《深入理解Java虚拟机》阅读笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="JVM学习链路"><a href="#JVM学习链路" class="headerlink" title="JVM学习链路"></a>JVM学习链路</h3><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231210224137170.png" class title="image-20231210224137170">

<h3 id="Class-文件结构"><a href="#Class-文件结构" class="headerlink" title="Class 文件结构"></a>Class 文件结构</h3><h4 id="1-魔数与次主版本号"><a href="#1-魔数与次主版本号" class="headerlink" title="1.魔数与次主版本号"></a>1.<strong>魔数与次主版本号</strong></h4><p>每个Class文件的头4个字节被称为魔数(CAFEBABE)，它的<strong>唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。</strong></p>
<p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号，第7和第8个字节是主版本号。高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。</p>
<h4 id="2-常量池计数器"><a href="#2-常量池计数器" class="headerlink" title="2.常量池计数器"></a>2.<strong>常量池计数器</strong></h4><p>紧接着主、次版本号之后的是常量池入口,由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项<strong>u2类型的数据</strong>，代表常量池的容量，就是常量池计数器。与Java中语言习惯不同，<strong>这个容量计数是从1而不是0开始的</strong>。因为常量池中的内容是需要被其他东西所指向的，所以在常量池0这个位置提供了一个空，为了给那些没有东西指的一个指向，例如：</p>
<p>例子1 ：Object类没有父类，他的父类索引指向哪里呢？</p>
<p>指向 00 00 （指向常量池里的第 0 个常量，第0 个常量什么都没有，这个第 0 个常量，就是为了给所有无法指向的情况提供的一个空常量指向）</p>
<p>例子2： 匿名内部类。（类名称指向哪里？指向 00 00）</p>
<h4 id="3-常量池"><a href="#3-常量池" class="headerlink" title="3.常量池"></a>3.<strong>常量池</strong></h4><ul>
<li>常量池存放内容</li>
</ul>
<p>常量池中主要存放两大类常量：<strong>字面量</strong> 和 <strong>符号引用</strong></p>
<p><strong>字面量</strong>比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。</p>
<p><strong>符号引用</strong>主要包括：包名，类名，接口名，字段名，方法名，方法类型等等</p>
<p>在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用<strong>不经过虚拟机在运行期转换</strong>的话是无法得到真正的内存入口地址（也就是说，你的虚拟机不运行，你的类就是无用的。一切都要基于jvm运行的时候，类才有他的意义），也就无法直接被虚拟机使用的。</p>
<ul>
<li><p><strong>常量池的项目类型</strong></p>
<ul>
<li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231211215024248.png" class title="image-20231211215024248"></li>
<li>重点类型介绍<ul>
<li><strong>CONSTANT_Class_info型常量的结构</strong></li>
<li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231211215110658.png" class title="image-20231211215110658"></li>
<li>tag是标志位，它用于区分常量类型；name_index是常量池的索引值，它指向常量池中一个CONSTANT_Utf8_info类型常量（因为CONSTANT_Utf8_info里存放着这个class的名称），此常量代表了这个类（或者接口）的全限定名。</li>
<li><strong>CONSTANT_Utf8_info型常量的结构</strong></li>
<li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231211215320105.png" class title="image-20231211215320105"></li>
<li>length值说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度。而这里的最大长度就是length的最大值，既u2类型能表达的最大值65535(u2代表两个字节，一共16位，也就是2的16次方减一)。<strong>所以Java程序中如果定义了超过64KB英文字符的变量或方法名，即使规则和全部字符都是合法的，也会无法编译。（超出了 常量池里的utf8 info里的u2的最大限度）</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>jvm是如何确定我们类的符号引用的（寻找到类的名称的）（索引类的）？</p>
<ul>
<li>当我们的jvm运行过程中，如果需要加载额外的类，那么首先会通过 我们的 对当前类的一个引用，去指向常量池中的class info类型，然后由class info类型指向utf8 info 类型，找到类的全限定名。在解析的过程中，<strong>将全限定名的符号引用转为直接引用。</strong></li>
</ul>
</li>
</ul>
<h4 id="4-访问标志、类索引、父类索引与接口索引集合"><a href="#4-访问标志、类索引、父类索引与接口索引集合" class="headerlink" title="4.访问标志、类索引、父类索引与接口索引集合"></a>4.<strong>访问标志</strong>、类索引、父类索引与接口索引集合</h4><p>在常量池结束之后，紧接着的2个字节代表访问标志，这个<strong>标志用于识别这个类或者接口层次的访问信息</strong>，主要有以下几个信息</p>
<img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231211220807086.png" class title="image-20231211220807086">

<p>访问标志之后是类索引和父类索引，他们都是一个<strong>u2类型的数据</strong>，而接口索引集合（interfaces）是一组<strong>u2类型的数据的集合</strong>，类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字后的接口顺序从左到右排列在接口索引集合中（如果这个Class文件表示的是一个接口，则应当是extends关键字）。</p>
<h4 id="5-字段表集合、方法表集合"><a href="#5-字段表集合、方法表集合" class="headerlink" title="5.字段表集合、方法表集合"></a>5.<strong>字段表集合、方法表集合</strong></h4><ul>
<li><p>字段表集合</p>
<ul>
<li><p>字段表用于描述接口或者类中声明的变量。Java语言中的“字段”包括<strong>类变量</strong>以及<strong>实例变量</strong>，但不包括在方法内部声明的局部变量。</p>
<ul>
<li>类变量和 实例变量有啥区别？</li>
<li>类变量是一个static的变量，<code>class Test &#123;    public static string name = &#39;123&#39; // 类变量 &#125;</code> 实例变量是非静态的全局的变量。<code>class Test &#123;    public  string name = &#39;123&#39; // 实例变量 &#125; </code>类变量可以直接用 类名.变量名进行调用； 实例变量必须通过new 对象的形式进行调用。</li>
</ul>
</li>
<li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231211222828550.png" class title="image-20231211222828550">

<ul>
<li><p>access_flags和name_index</p>
<ul>
<li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231211223033409.png" class title="image-20231211223033409"></li>
<li>access_flags标志就是上表中标志值，如果含有多个修饰词就把标志值进行相加即可；name_index和descriptor_index，它们都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符。</li>
</ul>
</li>
<li><p>descriptor_index</p>
<ul>
<li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231211223310562.png" class title="image-20231211223310562">
</li>
<li><p>对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组将被记录成“[[Ljava&#x2F;lang&#x2F;String；”，一个整型数组“int[]”将被记录成“[I”。</p>
<p>用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法void inc()的描述符为“()V”，方法java.lang.String toString()的描述符为“()Ljava&#x2F;lang&#x2F;String；”，方法int indexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex)的描述符为“([CII[CIII)I”</p>
</li>
</ul>
</li>
<li><p>attributes_count</p>
<ul>
<li>字段表所包含的固定数据项目到descriptor_index为止就全部结束了，不过在descrip-tor_index之后跟随着一个属性表集合，用于存储一些额外的信息，字段表可以在属性表中附加描述零至多项的额外信息。如果将字段m的声明改为“final static int m&#x3D;123；”，那就可能会存在一项名称为<strong>ConstantValue的属性</strong>，其值指向常量123。关于attribute_info的其他内容<strong>重点看属性表集合那部分。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对于方法表集合，其和字段表基本相同，方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在<strong>方法属性表集合</strong>中一个名为“<strong>Code</strong>”的属性里面，code里面存放的常用属性有操作数栈的最大深度，局部变量表所需要的最大空间，整个方法代码的长度等，属性表作为Class文件格式中最具扩展性的一种数据项目。</p>
</li>
</ul>
<h4 id="6-属性表集合"><a href="#6-属性表集合" class="headerlink" title="6.属性表集合"></a>6.<strong>属性表集合</strong></h4><p>Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。</p>
<p>Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性(在方法表下边)内。Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性，如果方法表有Code属性存在，那么它的结构将如下表：</p>
<img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231211225851335.png" class title="image-20231211225851335">

<ul>
<li><p>几个重点参数</p>
<ul>
<li><p><strong>attribute_name_index</strong>是一项指向CONSTANT_Utf8_info型常量的索引，<strong>此常量值固定为“Code”</strong>，它代表了该属性的属性名称，attribute_length指示了属性值的长度</p>
</li>
<li><p><strong>max_stack</strong>代表了操作数栈深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧中的操作栈深度（如果超过该深度会出现stackOverflow 异常）。</p>
</li>
<li><p><strong>max_locals</strong>代表了<strong>局部变量表所需的存储空间</strong>。max_locals的单位是<strong>变量槽（Slot）</strong>，变量槽是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，<strong>每个局部变量占用一个变量槽</strong>，而<strong>double和long这两种64位的数据类型则需要两个变量槽来存放</strong>。方法参数（包括实例方法中<strong>的隐藏参数“this”</strong>）、<strong>显式异常处理程序的参数</strong>（就是try-catch语句中catch块中所定义的异常）、方法体中定义的局部变量都需要依赖局部变量表来存放。<strong>注意，</strong>首先从以下代码里能够看到有四个局部变量分别是 ： a和b（string）， i和x （int类型）。直观上看，需要分配至少这个 4 个变量槽。但是。只需要分配两个就行了。因为，第一个for循环使用了 i 和 a； 第二个for循环执行的时候，就超出了变量i和a的作用域。 此时 x 变量可以重用 i 变量的变量槽， b可以重用 a 变量的变量槽。根据同时生存的最大局部变量数量和类型计算出max_locals的大小。</p>
<ul>
<li><pre><code class="java">public void testMethod（） &#123;
    String a = &#39;123&#39;;
    String b = &#39;456&#39;;
    for(int i = 0; i &lt; 10; i++) &#123;
        System.out.println(i);
        System.out.println(a);
    &#125;
    
     for(int x = 0; x &lt; 10; x++) &#123;
        System.out.println(x);
        System.out.println(b);
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - **code_length**和**code**用来存储Java源程序编译后生成的字节码指令。code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令,从这里就可以看出，**我们的方法里边的代码，并不是以二进制的形式被完全照搬转化的，而是，通过我们的code属性保存的 jvm 指令码。**</span><br><span class="line"></span><br><span class="line">* 对  max_locals中隐藏参数this，显式异常处理程序的参数  的说明</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public class JVMThisAndException &#123;</span><br><span class="line">        private int m; // 实例变量，不是局部变量</span><br><span class="line">        private static int n;</span><br><span class="line">    </span><br><span class="line">        public int inc()&#123; // 方法。这个东西肉眼看见： 没有参数</span><br><span class="line">            return this.m + 1; // 没有局部变量。</span><br><span class="line">            // 使用javap命令对class字节码文件进行反编译得到locals=1, args_size=1</span><br><span class="line">            // 参数问题，对于我们的 所有普通方法 都会有一个隐藏的this参数。这样我们在使用this的时候，就能够像我们的inc方			法那样，进行this.m的调用了。</span><br><span class="line">            // 局部变量表来说，也会为我们的this开辟一个单独的区域进行this的存储。这个存储的是我们this指向的这个当前对象。</span><br><span class="line">        &#125;</span><br><span class="line">        public static int inc2() &#123;</span><br><span class="line">            return n; //这个地方不能使用this，因为该方法是static的，这时对象可能还没有创建</span><br><span class="line">            // locals=0, args_size=0</span><br><span class="line">        &#125;</span><br><span class="line">        public int inc3 () &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return m + 1;</span><br><span class="line">            &#125; catch (Exception e) &#123; // e 是个局部使用的变量名称，局部变量</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            return 0;</span><br><span class="line">            // locals=2(this, e), args_size=1 (this)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>字段表集合中属性表的ConstantValue 属性</p>
<ul>
<li><p><strong>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值（提前赋值，不需要运行时赋值，加快运行时的获取速度）</strong>。只有被static关键字修饰的变量（类变量）才可以使用这项属性。对非static类型的变量的赋值是在实例构造器<init>()方法中进行的；而对于static类型变量，则有两种方式可以选择：<strong>在类构造器<clinit>()方法中或者使用ConstantValue属性。</clinit></strong></init></p>
<p>目前<strong>Oracle公司实现的Javac编译器</strong>的选择是，如果同时使用final和static来修饰一个变量，并且这个变量的数据类型是<strong>基本类型或者String类型</strong>的话，<strong>就将会生成ConstantValue属性来进行初始化</strong>；如果这个变量没有被final修饰，或者并非基本类型及字符串，则将会选择在<clinit>()方法中进行初始化。</clinit></p>
</li>
<li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231211234007233.png" class title="image-20231211234007233"></li>
<li><p>constantvalue_index数据项代表了常量池中一个字面量常量的引用</p>
</li>
</ul>
</li>
</ul>
<h4 id="7-JVM-字节码指令"><a href="#7-JVM-字节码指令" class="headerlink" title="7.JVM 字节码指令"></a>7.<strong>JVM</strong> <strong>字节码指令</strong></h4><p>在Java虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。举个例子，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在Class文件中它们必须拥有各自独立的操作码。</p>
<ul>
<li><p>常见的JVM 字节码指令</p>
<ul>
<li><p>·将一个局部变量加载到操作栈：<strong>iload</strong></p>
<p>·将一个数值从操作数栈存储到局部变量表：<strong>istore</strong></p>
</li>
<li><p>加法指令：iadd</p>
<p>·减法指令：isub</p>
<p>·按位或指令：ior</p>
<p>·按位与指令：iand</p>
<p>·按位异或指令：ixor</p>
</li>
<li><p>类型转换指令包括i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。</p>
</li>
<li><p>·创建类实例的指令：new</p>
<p>·创建数组的指令<strong>：</strong>newarray<strong>、</strong>anewarray<strong>、</strong>multianewarray</p>
<p>·访问类字段（static字段）和实例字段（非static字段）的指令：getfield<strong>、</strong>putfield<strong>、</strong>getstatic<strong>、</strong>putstatic</p>
</li>
<li><p>·invokevirtual指令：用于调用对象的实例方法</p>
<p>·invokeinterface指令：用于调用接口方法</p>
<p>·invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法(init)、私有方法(private)和父类方法(父类方调用)。</p>
<p>·invokestatic指令：用于调用类静态方法（static方法）。</p>
</li>
</ul>
</li>
</ul>
<h3 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h3><h4 id="1-类加载流程概述"><a href="#1-类加载流程概述" class="headerlink" title="1.类加载流程概述"></a>1.类加载流程概述</h4><p>Java虚拟机把描述类的数据从<strong>Class文件加载到内存</strong>，并对数据进行<strong>校验、转换解析和初始化</strong>，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。与那些在编译时需要进行连接的语言不同，在Java语言里面，<strong>类型的加载、连接和初始化过</strong>程都是在<strong>程序运行期间完成的</strong>，这会让类加载时稍微增加一些性能开销，但是却为Java应用提供了极高的扩展性和灵活性，Java天生可以动态扩展的根本就是依赖运行期<strong>动态加载和动态连接</strong>这个特点实现的。</p>
<p><em>动态加载是指在程序运行时根据条件选择性地加载类</em></p>
<p><em>动态链接就是将指令中的符号引用转化为真实的方法地址。（依据常量池）</em></p>
<img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231212133815269.png" class title="image-20231212133815269">



<p><strong>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的</strong>，类型的加载过程必须按照这种顺序<strong>按部就班</strong>地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性。请注意，这里按部就班是指按部就班地“开始”，而不是按部就班地“进行”或按部就班地“完成”，强调这点是<strong>因为这些阶段通常都是互相交叉地混合进行的</strong>，会在一个阶段执行的过程中调用、激活另一个阶段。</p>
<h4 id="2-类加载过程-加载"><a href="#2-类加载过程-加载" class="headerlink" title="2.类加载过程 - 加载"></a>2.<strong>类加载过程</strong> <strong>-</strong> <strong>加载</strong></h4><p>类加载的加载流程：</p>
<p>1）通过一个<strong>类的全限定名</strong>来获取定义此类的二进制字节流。（class文件字节流）（加载）<br>2）连接 - 验证 - <strong>文件格式验证</strong><br>3）将这个字节流所代表的<strong>静态存储结构转化为方法区的运行时数据结构</strong>。（class文件是一个静态的二进制文件，里边存放的是我们的类中所有的一些常量，字段，方法，属性，这些都是静态存储在class文件中的。 转化为方法区所需要的运行时的一种数据结构。）（加载）<br>4） 连接 - 验证 - 元数据验证<br>5） 连接 - 验证 - 字节码验证<br>6）在<strong>内存</strong>中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。（生成的对象在堆内存，所有的对象的里边的字段，方法的访问入口在我们的堆里，这个入口，直通方法区。）（加载）<br>7） 连接 - 准备 （类变量的初始化，有类变量的前提是有个类）（初始化 “零”值）</p>
<p>？） 连接 - 解析<br>？）连接 - 验证 - 符号引用验证</p>
<p>相对于类加载过程的其他阶段，<strong>非数组类型的加载阶段</strong>是开发人员可控性最强的阶段。加载阶段既可以使用Java虚拟机里内置的类加载器来完成，也可以由用户自定义的类加载器去完成（<strong>重写一个类加载器的findClass()或loadClass()方法</strong>）</p>
<p>对于<strong>数组类</strong>而言，情况就有所不同，数组类<strong>本身不通过类加载器创建</strong>，它是<strong>由Java虚拟机直接在内存中动态构造出来的</strong>。但数组类与类加载器仍然有很密切的关系，因为数组类的<strong>元素类型</strong>最终还是要靠类加载器来完成加载，一个数组类（下面简称为C）创建过程遵循以下规则：</p>
<p>Ø·如果数组的组件类型是引用类型，那就递归采用定义的加载过程去加载这个组件类型，<strong>数组C将被标识在加载该组件类型的类加载器的类名称空间上</strong>（例如一个String类型的数组，哪个类加载器加载的String这个类，那么就把数组C标识到哪个类加载器的类名称空间上）（这点很重要，<strong>一个类型必须与类加载器一起确定唯一性</strong>）。</p>
<p>Ø·如果数组的组件类型不是引用类型（例如int[]数组的组件类型为int），Java虚拟机将会把数组C标记为与<strong>启动类加载器</strong>关联。</p>
<h4 id="3-类加载过程-连接-验证"><a href="#3-类加载过程-连接-验证" class="headerlink" title="3.类加载过程 - 连接 - 验证"></a>3.<strong>类加载过程</strong> <strong>-</strong> <strong>连接</strong> <strong>-</strong> <strong>验证</strong></h4><p><strong>加载阶段与连接阶段的部分动作</strong>（如一部分字节码文件格式验证动作）<strong>是交叉进行的</strong>，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的<strong>开始时间</strong>仍然保持着固定的先后顺序。</p>
<p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>
<p>验证阶段大致上会完成下面四个阶段的检验动作：<strong>文件格式验证、元数据验证、字节码验证和符号引用验证</strong>。</p>
<ul>
<li><p><strong>文件格式验证</strong></p>
<ul>
<li>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。主要有以下几个方面：<ul>
<li>是否以魔数0xCAFEBABE开头。</li>
<li>主、次版本号是否在当前Java虚拟机接受范围之内。</li>
<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。</li>
</ul>
</li>
<li>实际上第一阶段的验证点还远不止这些，上面所列的只是从HotSpot虚拟机源码中摘抄的一小部分内容，该验证阶段的主要目的是保证输入的<strong>字节流能正确地解析并存储于方法区之内</strong>。<strong>这阶段的验证是基于二进制字节流进行的</strong>，<strong>只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储</strong>，所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。</li>
</ul>
</li>
<li><p><strong>元数据验证</strong></p>
<ul>
<li>对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求，主要包括：<ul>
<li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li>
</ul>
</li>
<li>总之该阶段的验证就是检查是否存在与《Java语言规范》相悖的元数据信息</li>
</ul>
</li>
<li><p><strong>字节码验证</strong></p>
</li>
</ul>
<ul>
<li>阶段对类的方法体<strong>（Class文件中的Code属性）进行校验分析</strong>，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，例如：<ul>
<li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。</li>
<li>保证方法体中的类型转换总是有效的。</li>
<li>但是，它所消耗的验证时间在 类加载的过程里。能不能把这部分验证，在我们的javac 编译为class文件的时候，就做一些东西呢？<ul>
<li>Java虚拟机的设计团队为了避免过多的执行时间消耗在字节码验证阶段中，<strong>在JDK 6之后的Javac编译器和Java虚拟机里进行了一项联合优化</strong>，<strong>把尽可能多的校验辅助措施挪到Javac编译器里进行。</strong>具体做法是给方法体Code属性的属性表中新增加了一项名为“StackMapTable”的新属性，这项属性记录了方法体所有的基本块开始时<strong>本地变量表和操作数栈</strong>应有的状态，在字节码验证期间，Java虚拟机就不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中的记录是否合法即可。<strong>这样就将字节码验证的类型推导转变为类型检查</strong>，从而节省了大量校验时间。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>符号引用验证</strong></p>
<ul>
<li><strong>最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的解析阶段中发生</strong>。符号引用保存在常量池中，无非包括了java.lang.String或者java.lang.Object，这个阶段的验证目的是确保解析行为能正常执行，主要包括：<ul>
<li>能否根据符号引用中全限定名找到对应的类。</li>
<li>指定类中是否存在符合引用的方法和字段。</li>
<li>符号引用中的类、字段、方法的可访问性是否可被当前类访问。</li>
</ul>
</li>
<li><strong>验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但却不是必须要执行的阶段</strong>，如果对自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码都十分自信，可以通过-<strong>Xverify：none</strong>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</li>
</ul>
</li>
</ul>
<h4 id="4-类加载过程-连接-准备"><a href="#4-类加载过程-连接-准备" class="headerlink" title="4.类加载过程 - 连接 - 准备"></a>4.<strong>类加载过程</strong> <strong>-</strong> <strong>连接</strong> <strong>-</strong> <strong>准备</strong></h4><p><strong>准备阶段是</strong>正式为类中定义的变量（即<strong>静态变量，被static修饰的变量</strong>）<strong>分配内存并设置类变量初始值的阶段</strong>，从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，在JDK 7及之前，HotSpot使用永久代来实现方法区；而在JDK 8及之后，<strong>类变量</strong>则<strong>会随着Class对象一起存放在Java堆中</strong></p>
<p>关于准备阶段，还有两个容易产生混淆的概念，<strong>首先</strong>是这时候进行内存分配的仅包括类变量(静态变量)，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。<strong>其次</strong>是这里所说的初始值<strong>“通常情况”</strong>下是数据类型的<strong>零值</strong>，假设一个类变量的定义为：</p>
<p>public static int value &#x3D; 123;</p>
<p>那变量value在准备阶段过后的初始值为0而不是123，因为这时尚未开始执行任何Java方法，而<strong>把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值为123的动作要到类的初始化阶段才会被执行。</clinit></strong></p>
<img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231212184431988.png" class title="image-20231212184431988">

<p><strong>上面提到在“通常情况”下初始值是零值，那言外之意是相对的会有某些“特殊情况”：</strong>比如，如果类字段的字段表下边属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值，假设上面类变量value的定义修改为 </p>
<p>public static final int value &#x3D; 123;</p>
<p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p>
<h4 id="5-类加载过程-连接-解析"><a href="#5-类加载过程-连接-解析" class="headerlink" title="5.类加载过程 - 连接 - 解析"></a>5.类加载过程 - 连接 - 解析</h4><p>解析阶段是Java虚拟机将常量池内的<strong>符号引用</strong>替换为<strong>直接引用</strong>的过程</p>
<p>Ø·符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量如String，只要使用时能无歧义地定位到目标即可。</p>
<p>Ø·直接引用：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。</p>
<p>《Java虚拟机规范》之中并未规定解析阶段发生的具体时间，<strong>只要求了在执行anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield和putstatic</strong>这17个用于操作符号引用的字节码<strong>指令之前</strong>，完成解析即可。</p>
<p>对同一个符号引用进行多次解析请求是很常见的事情，除invokedynamic指令以外，虚拟机实现可以对第一次解析的结果进行缓存，譬如在运行时直接引用常量池中的记录，并把常量标识为已解析状态，从而避免解析动作重复进行。而invokedynamic指令动态的进行加载，动态的进行解析，这里“动态”的含义是指必须等到程序实际运行到这条指令时，解析动作才能进行。解析动作主要针对<strong>类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行</strong>，分别对应于常量池的<strong>CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info</strong>、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_Dyna-mic_info和CONSTANT_InvokeDynamic_info 8种常量类型</p>
<h4 id="6-类加载过程-初始化"><a href="#6-类加载过程-初始化" class="headerlink" title="6.类加载过程 - 初始化"></a>6.<strong>类加载过程</strong> <strong>-</strong> <strong>初始化</strong></h4><p>进行<strong>准备</strong>阶段时，<strong>静态变量</strong>已经赋过一次系统要求的<strong>初始零值</strong>，而在初始化阶段，则会根据编码去初始化类变量和其他资源。我们也可以从另外一种更直接的形式来表达：<strong>初始化阶段就是执行类构造器<clinit>()方法的过程。</clinit></strong></p>
<p><clinit>()并不是程序员在Java代码中直接编写的方法，它是<strong>Javac</strong>编译器的自动生成物</clinit></p>
<p><clinit>()方法是由编译器自动收集类中的<strong>所有类变量的赋值动作</strong>和<strong>静态代码块（static{}块）中的语句合并产生的， <clinit>()方法与类的构造函数（即实例构造器<init>()方法）不同，它不需要显式地调用父类构造器</init></clinit></strong>，Java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。因此在Java虚拟机中<strong>第一个被执行的<clinit>方法的类型肯定是java.lang.Object</clinit></strong>。由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</clinit></clinit></clinit></clinit></p>
<p><clinit>()方法对于类或接口来说<strong>并不是必需</strong>的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。</clinit></clinit></p>
<p>接口中不能使用静态语句块，但仍然有<strong>变量初始化的赋值操作</strong>，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，<strong>执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。</clinit></clinit></strong>此外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。</clinit></clinit></p>
<p>Java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<clinit>()方法（并发编程篇 <strong>–</strong> 双重检查锁 <strong>–</strong> 通过实例化我们的类进行的双重检查锁实现。static变量，只有一个线程能执行clinit 方法），其他线程都需要阻塞等待，直到活动线程执行完毕<clinit>()方法。</clinit></clinit></clinit></p>
<ul>
<li>但是对于初始化阶段，《Java虚拟机规范》则是严格规定了<strong>有且只有</strong>以下六种情况必须立即对类进行“初始化”：</li>
</ul>
<p>1）遇到new、getstatic、putstatic或invokestatic这四条字节码指令时。能够生成这四条指令的典型Java代码场景有<strong>：</strong></p>
<p>·使用new关键字实例化对象的时候<strong>。</strong></p>
<p>·读取或设置一个类型的静态字段（被final修饰<strong>、</strong>已在编译期把结果放入常量池的静态字段除外）的时候<strong>。</strong></p>
<p>·调用一个类型的静态方法的时候。</p>
<p>2）使用java.lang.reflect包的方法对类型进行反射调用的时候。</p>
<p>3）当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化<strong>。</strong></p>
<p>4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p>
<p>5）当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</p>
<p>6）当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个<strong>接口的实现类发生了初始化</strong>，那该接口要在其之前被初始化。</p>
<p>以上六种场景中的行为称为<strong>对一个类型进行主动引用</strong>。</p>
<ul>
<li><p>初始化的典型代码案例</p>
<ul>
<li><pre><code class="java">class Parent &#123;
    static &#123;
        System.out.println(&quot;Parent init!&quot;);
    &#125;
    public static int value = 123;
    public static final int value2 = 456;
&#125;
class Child extends Parent &#123;
    static &#123;
        System.out.println(&quot;Child init!&quot;);
    &#125;
&#125;
public class SuperClass &#123;
    public static void main(String[] args) &#123;
//        System.out.println(Child.value2);
        //知打印了 456. 还是没有触发 Parent的初始化。
        //static final int 在 编译器 提前存储到 字段表的 属性表里的 constantvalue属性里。使用的时候
        //直接使用，不会触发类的初始化。

//        Parent[] pars = new Parent[2];
        // 没有打印结果。说static代码块没有执行，说明Parent类没有初始化。但是我们看到了new关键字啊。
        //new Parent[2]; JVM对应的指令是 ： newarray。 而newarray不会触发类的初始化。

//        System.out.println(Child.value);
        //打印结果： Parent init! // 123
        // 因为我们value 这个static属性属于我们的parent类，如果想要调用 value，就需要初始化 Parent类
        // 而不需要初始化 Child类。
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 7.类加载器</span><br><span class="line"></span><br><span class="line">启动类加载器：这个类加载器负责加载存放在**&lt;JAVA_HOME&gt;\lib目录**，或者**被-Xbootclasspath参数所指定的路径中存放的**，而且是Java虚拟机能够识别的（**按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载**）类库加载到虚拟机的内存中。</span><br><span class="line"></span><br><span class="line">·扩展类加载器：它负责加载**&lt;JAVA_HOME&gt;\lib\ext目录中**，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</span><br><span class="line"></span><br><span class="line">·应用程序类加载器：它负责加载**用户类路径**（ClassPath）上所有的类库。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</span><br><span class="line"></span><br><span class="line">  &#123;% asset_img image-20231212231709365.png image-20231212231709365 %&#125;</span><br><span class="line"></span><br><span class="line">* 双亲委派机制</span><br><span class="line">  - **双亲委派过程：**如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的**启动类加载器**中，只有当父加载器搜索范围中没有找到所需的类时，子加载器才会尝试自己去完成加载。</span><br><span class="line">  - 使用双亲委派模型好处</span><br><span class="line">    - 例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的**各种类加载器环境中**都能够保证是同一个类。反之，如果没有使用双亲委派模型，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object的类，并放在程序的ClassPath中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。（保证程序的安全性，类加载的有规则性）</span><br><span class="line">  - 对于任意一个类，**都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性**。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。**（确保类的唯一可确定性**）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 自定义类加载器(重写findClass方法)</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public class SelfClassLoader &#123;</span><br><span class="line">        public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">            ClassLoader myClassLoader = new ClassLoader() &#123;</span><br><span class="line">                @SneakyThrows</span><br><span class="line">                @Override</span><br><span class="line">                // 首先我们自定义的类加载器加载的SelfClassLoader 这个文件，如果没有自定义的类加载器，这个文件是应该被我们的 系统类加载器进行加载的。现在我们自定义了一个加载器，jvm为了保证只有一个类能够被加载，所以，我们的jvm中只有一份儿该类的信息。对于我们进行自定义类加载器的书写的时候，复写 findClass 永远不会破坏双亲委派。因为双亲委派的代码逻辑存在于 loadClass 这个方法中。对于我们这个例子来说，这个类其实就是被 系统类 加载器加载的。 哪怕我们的在代码中用自己的类加载器进行再次加载，也会在 Class&lt;?&gt; c = findLoadedClass(name); 从系统类加载器里获取该类。</span><br><span class="line">                protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">                    String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;;</span><br><span class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">                    byte[] b = new byte[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    return defineClass(name, b, 0, b.length);</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                @SneakyThrows</span><br><span class="line">                @Override</span><br><span class="line">                // 现在我的自定义类加载器复写了 loadClass 方法，里边没有双亲委派的任何逻辑。</span><br><span class="line">                // 对于我们这个自定义的类加载器加载的类，就会出现类名重复的问题。</span><br><span class="line">                // 我们不小心复写了 loadclass方法，破坏了我们双亲委派模型。导致 com.boot.jvm.SelfClassLoader 被我们的</span><br><span class="line">                // 系统类加载器和 自定义类加载器，进行了两次加载。而且最要命的是，我们系统类加载器标注的类名称空间是一份，</span><br><span class="line">                // 我们自定义的类加载器也标注了一份儿类名称空间。</span><br><span class="line">                // 由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性.</span><br><span class="line">                public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">                    String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;;</span><br><span class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">                    if(is == null) &#123;</span><br><span class="line">                        return super.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                        byte[] b = new byte[is.available()];</span><br><span class="line">                        is.read(b);</span><br><span class="line">    </span><br><span class="line">                    return defineClass(name, b, 0, b.length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">            Object obj = myClassLoader.loadClass(&quot;com.boot.jvm.SelfClassLoader&quot;).newInstance();</span><br><span class="line">            System.out.println(obj.getClass()); //com.boot.jvm.SelfClassLoader</span><br><span class="line">    </span><br><span class="line">            System.out.println(obj // com.boot.jvm.SelfClassLoader</span><br><span class="line">                    instanceof com.boot.jvm.SelfClassLoader);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>自定义类加载器的使用场景</p>
<ul>
<li>大家都用过class文件的反编译工具，发现 class文件反编译为 java 文件，可读性还是很不错的。有一些企业，为了保障核心代码不被反编译器反编译，要将我们的class文件再进行一次文件加密。 加密后的class文件不能够被 jvm直接加载，此时需要我们自定义一个类加载器将该class文件进行解密之后，再加载到jvm。</li>
<li>有时候，我们需要通过一些网络的文件，zip文件，db存储的class二进制文件，进行jvm的加载，这个时候，由于我们的加载源不同，加载文件类型不同，会有不同的自定义的类加载器。</li>
</ul>
</li>
</ul>
<h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><h4 id="1-运行时数据区概述及程序计数器"><a href="#1-运行时数据区概述及程序计数器" class="headerlink" title="1.运行时数据区概述及程序计数器"></a>1.运行时数据区概述及程序计数器</h4><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分以下几个不同的数据区域。</p>
<img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231213134147424.png" class title="image-20231213134147424">

<ul>
<li><p>程序计数器</p>
<ul>
<li><p>程序计数器可以看作是记录当前线程所执行的字节码的行号指示器<strong>。通过改变这个计数器的值来选取下一条需要执行的字节码指令，</strong>分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>由于Java虚拟机的多线程是通过线程轮流切换、处理器分配执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，所以存放在线程的私有区域</strong></p>
<p>如果线程正在执行的是一个Java方法，这个<strong>计数器记录的是正在执行的虚拟机字节码指令的地址</strong>；<strong>如果正在执行的是本地（Native）方法，这个计数器值则应为空</strong>。</p>
<p><strong>此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="2-堆"><a href="#2-堆" class="headerlink" title="2.堆"></a>2.堆</h4><p>Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的<strong>唯一目的就是存放对象实例</strong>，Java世界里几乎所有的对象实例都在这里分配内存。但是随着逃逸分析技术的日渐强大，<strong>栈上分配、标量替换</strong>优化手段的出现，让Java对象实例都分配在堆上也渐渐变得不是那么绝对了。</p>
<p>Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。</p>
<img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231213155621199.png" class title="image-20231213155621199">

<ul>
<li><p><strong>堆大小 &#x3D; 新生代 + 老年代</strong>。堆的大小可通过参数–Xms（堆的初始容量）、-Xmx（堆的最大容量） 来指定。</p>
<ul>
<li>其中，<strong>新生代被细分为 Eden 和 两个 Survivor 区域</strong>，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。<strong>默认的，Edem : from : to &#x3D; 8 : 1 : 1</strong> 。(可以通过参数 –XX:SurvivorRatio 来设定 )</li>
</ul>
</li>
<li><p>JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。新生代实际可用的内存空间为 9&#x2F;10 (即 90%) 的新生代空间。</p>
</li>
</ul>
<h4 id="3-Java对象的创建过程"><a href="#3-Java对象的创建过程" class="headerlink" title="3.Java对象的创建过程"></a>3.Java对象的创建过程</h4><p>Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常<strong>（除了复制、反序列化以外）</strong>仅仅是一个new关键字而已，而在虚拟机中，对象（仅限于普通Java对象，不包括数组和Class对象等）的创建共有五步：</p>
<ol>
<li><p>当Java虚拟机遇到一条字节码new指令时，<strong>首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用</strong>(例如：new String()的时候，能不能常量池中找到Ljava&#x2F;lang&#x2F;String这个符号引用)，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程；</p>
</li>
<li><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存(<strong>对象所需内存的大小在类加载完成后便可完全确定</strong>)。为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。</p>
<ul>
<li><p>假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为<strong>“指针碰撞”</strong>。</p>
</li>
<li><p>假设Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，<strong>虚拟机就必须维护一个列表</strong>，<strong>记录上哪些内存块是可用的</strong>，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为<strong>“空闲列表”</strong>。</p>
</li>
<li><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除算法的收集器时，只能采用较为复杂的空闲列表来分配内存。</p>
<ul>
<li><p>对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p>
<ul>
<li><p>解决这个问题有两种可选方案：</p>
<p>1）一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；</p>
<p>2）每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，<strong>只有本地缓冲区用完了要分配新的缓存区时才需要同步锁定(使用CAS)。</strong>虚拟机是否使用TLAB，可以通过-XX：+&#x2F;-UseTLAB参数来设定。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>内存分配完成之后，虚拟机必须将分配到的内存空间都初始化为零值（连接 - 准备），如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。<strong>这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用</strong></p>
</li>
<li><p>接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
</li>
<li><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象创建才刚刚开始,这时执行构造函数，即Class文件中的<init>()方法。一般来说，new指令之后会接着执行<init>()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</init></init></p>
</li>
</ol>
<h4 id="4-Java对象的内存布局"><a href="#4-Java对象的内存布局" class="headerlink" title="4.Java对象的内存布局"></a>4.<strong>Java对象的内存布局</strong></h4><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头、实例数据和对齐填充。</p>
<ul>
<li>对象头<ul>
<li>HotSpot虚拟机对象的对象头部分包括两类信息。<ul>
<li>第一类是用于存储对象<strong>自身的运行时数据</strong>，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别为32个比特和64个比特，官方称它为“Mark Word”。</li>
<li>对象头的另外一部分是类型指针，即<strong>对象指向它的类型元数据的指针</strong>，Java虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，具体讨论看下节（如何定位对象）。此外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。</li>
</ul>
</li>
</ul>
</li>
<li>实例数据<ul>
<li>实例数据部分是对象真正存储的有效信息，即我们在<strong>程序代码里面所定义的各种类型的字段内容</strong>，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。这部分的存储顺序会受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配顺序为longs&#x2F;doubles、ints、shorts&#x2F;chars、bytes&#x2F;booleans、oops（Ordinary Object Pointers，普通对象指针），从以上默认的分配策略中可以看到，<strong>相同宽度的字段总是被分配到一起存放</strong>，在满足这个前提条件的情况下，<strong>在父类中定义的变量会出现在子类之前</strong>。如果HotSpot虚拟机的+XX：CompactFields参数值为true（默认就为true），那<strong>子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。</strong></li>
</ul>
</li>
<li>对齐填充<ul>
<li>这并不是必然存在的，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求<strong>对象起始地址</strong>必须是8字节的整数倍，换句话说就是<strong>任何对象的大小都必须是8字节的整数倍。</strong>对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</li>
</ul>
</li>
</ul>
<h4 id="5-Java对象的访问定位"><a href="#5-Java对象的访问定位" class="headerlink" title="5.Java对象的访问定位"></a>5.<strong>Java对象的访问定位</strong></h4><p>对象访问方式主要有使用句柄和直接指针两种：</p>
<ul>
<li>直接指针<ul>
<li>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销，如图</li>
<li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231213171813766.png" class title="image-20231213171813766"></li>
<li>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本</li>
</ul>
</li>
<li>句柄<ul>
<li>如果使用句柄访问的话，Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息</li>
<li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231213172104081.png" class title="image-20231213172104081"></li>
<li>使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时使用标记整理算法，移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</li>
</ul>
</li>
</ul>
<h4 id="6-方法区"><a href="#6-方法区" class="headerlink" title="6.方法区"></a>6.方法区</h4><p>方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等数据。到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了JDK 8，终于完全废弃了永久代的概念，改用元空间来代替，把JDK 7中永久代还剩余的内容全部移到元空间中。<strong>方法区就像一个抽象接口，永久代和元空间就像方法区接口的两个具体实现</strong></p>
<p>《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。<strong>这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，</strong>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的(例如动态加载类型信息)。</p>
<h4 id="7-运行时常量池"><a href="#7-运行时常量池" class="headerlink" title="7.运行时常量池"></a>7.运行时常量池</h4><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。对于运行时常量池，<strong>除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。</strong></p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备<strong>动态性</strong>，在运行期间调用String类的intern()方法也可以将新的常量放入池中</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p>
<h4 id="8-Java虚拟机栈与本地方法栈"><a href="#8-Java虚拟机栈与本地方法栈" class="headerlink" title="8.Java虚拟机栈与本地方法栈"></a>8.<strong>Java</strong>虚拟机栈与本地方法栈</h4><p>与程序计数器一样，Java虚拟机栈也是线程<strong>私有</strong>的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于<strong>存储局部变量表、操作数栈、动态连接、方法出口等信息</strong>(后续详细解读)。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>局部变量表存放了编译期可知的各种Java虚拟机<strong>基本数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄）和<strong>returnAddress类型</strong>（指向了一条字节码指令的地址）。</p>
<p>这些数据类型在局部变量表中的存储空间<strong>以局部变量槽来表示</strong>，<strong>其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。</strong>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<p>这个内存区域的异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；</p>
<p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别<strong>只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</strong></p>
<h3 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h3><h4 id="1-判断对象是否存活"><a href="#1-判断对象是否存活" class="headerlink" title="1.判断对象是否存活"></a>1.<strong>判断对象是否存活</strong></h4><ul>
<li><p><strong>引用计数算法</strong>(基本没人用)</p>
<ul>
<li><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；<strong>任何时刻计数器为零的对象就是不可能再被使用的。</strong>这个简单的算法有很多例外情况没有考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决<strong>对象之间相互循环引用</strong>的问题。</p>
<p>举个简单的例子：对象objA和objB都有字段instance，赋值令objA.instance&#x3D;objB及objB.instance&#x3D;objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。 <strong>所以</strong>主流的Java虚拟机不选用该算法。</p>
</li>
</ul>
</li>
<li><p><strong>可达性分析算法</strong>(比较主流)</p>
<ul>
<li><p>这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再被使用的。</p>
<p>如图所示，对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的，因此它们将会被判定为可回收的对象。</p>
<img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231213215736441.png" class title="image-20231213215736441">
</li>
<li><p>固定可作为GC Roots的对象(主要记忆前五个和临时GC Roots对象)：</p>
<ul>
<li>所有被同步锁（<strong>synchronized</strong>关键字）持有的对象。</li>
<li>在方法区中<strong>静态属性引用的对象</strong>，譬如Java类的引用类型的静态变量。</li>
<li>在方法区中<strong>常量引用的对象</strong>，譬如字符串常量池里的引用。</li>
<li>在虚拟机栈中<strong>reference引用的对象</strong>，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li>
<li>Java<strong>虚拟机内部的引用</strong>，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li>
<li><em>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</em></li>
<li><em>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</em></li>
<li>除了这些固定的GC Roots集合以外，根据<strong>用户所选用的垃圾收集器以及当前回收的内存区域不同</strong>，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。例如，如果只针对Java堆中某一块区域发起垃圾收集时（如最典型的只针对新生代的垃圾收集），这个区域里的对象完全有可能被位于堆中其他区域的对象所引用(例如老年代)，这时候就需要将这些关联区域的对象(也就是老年代对象)也临时加入GC Roots集合中去，才能保证可达性分析的正确性。</li>
</ul>
</li>
<li><p>Java中的引用类型(强度由强到弱)：</p>
<ul>
<li>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj&#x3D;new Object()”这种引用关系。无论任何情况下，<strong>只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</strong></li>
<li>软引用是用来描述一些还有用，但非必须的对象。<strong>如果一次垃圾回收之后，系统发现仍会发生OOM时，这时就会回收这些被软引用引用的对象。</strong>在JDK 1.2版之后提供了SoftReference类来实现软引用。</li>
<li>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象，<strong>无论当前内存是否足够，只能生存到下一次垃圾收集发生为止。</strong>在JDK 1.2版之后提供了WeakReference类来实现弱引用。</li>
<li>虚引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的<strong>唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-如果对象不可达，一定会被回收吗？"><a href="#2-如果对象不可达，一定会被回收吗？" class="headerlink" title="2.如果对象不可达，一定会被回收吗？"></a>2.<strong>如果对象不可达，一定会被回收吗？</strong></h4><p>不一定。即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历<strong>两次标记</strong>过程：<strong>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记</strong>，随后进行一次筛选，<strong>筛选的条件是此对象是否有必要执行finalize()方法</strong>。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由<strong>一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。</strong>这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。<strong>finalize()方法是对象逃脱死亡命运的最后一次机会</strong>，<strong>稍后收集器将对F-Queue中的对象进行第二次小规模的标记</strong>，<strong>只要这次标记发现队列中的某个对象重新与引用链上的任何一个对象建立关联，就会被移出“即将回收”的集合；</strong>如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</p>
<p>但是，finalize()方法它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已被官方明确声明为不推荐使用的语法。</p>
<h4 id="3-再谈方法区回收"><a href="#3-再谈方法区回收" class="headerlink" title="3.再谈方法区回收"></a>3.<strong>再谈方法区回收</strong></h4><p>方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。</p>
<p><strong>判定一个常量是否“废弃”还是相对简单，但是要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻。需要同时满足下面三个条件：</strong></p>
<ol>
<li><p>该类及其派生子类的所有实例都已经被回收。</p>
</li>
<li><p>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，否则通常是很难达成的。</p>
</li>
<li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
</li>
</ol>
<h4 id="4-垃圾收集算法-分代收集理论"><a href="#4-垃圾收集算法-分代收集理论" class="headerlink" title="4.垃圾收集算法 - 分代收集理论"></a>4.<strong>垃圾收集算法</strong> <strong>-</strong> <strong>分代收集理论</strong></h4><p>1）<strong>弱分代假说</strong>：绝大多数对象都是朝生夕灭的。</p>
<p>2）<strong>强分代假说</strong>：熬过越多次垃圾收集过程的对象就越难以消亡。</p>
<p>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄分配到不同的区域之中存储。显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</p>
<p>3）<strong>跨代引用假说</strong>：跨代引用相对于同代引用来说仅占极少数。</p>
<p>因为如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。</p>
<p>依据这条假说，我们就<strong>不应再为了少量的跨代引用去扫描整个老年代</strong>，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为<strong>“记忆集”</strong>），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描</p>
<h4 id="5-几种垃圾收集算法-按出现时间"><a href="#5-几种垃圾收集算法-按出现时间" class="headerlink" title="5.几种垃圾收集算法(按出现时间)"></a>5.几种垃圾收集算法(按出现时间)</h4><ul>
<li><p><strong>标记清除算法</strong></p>
<ul>
<li>1960年出现，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</li>
<li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231214210455031.png" class title="image-20231214210455031">
<ul>
<li>优点：最基础的收集算法，是因为后续的收集算法大多都是以标记-清除算法为基础</li>
<li>缺点：第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低(这像一句废话，因为任何收集算法都会随着对象数量的增多，效率下降)；第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，<strong>空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>标记复制算法</strong></p>
<ul>
<li>1969年出现，它将可用<strong>内存按容量划分为大小相等的两块，每次只使用其中的一块</strong>。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</li>
<li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231214211040907.png" class title="image-20231214211040907">
<ul>
<li>优点：解决了垃圾清除算法产生的内存碎片问题</li>
<li>缺点：如果内存中多数对象都是存活的，这种算法将会产生大量的内存间<strong>复制的开销</strong>，而且这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一点。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>标记整理算法</strong></p>
<ul>
<li><p>1974年出现，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存</p>
<p>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策</p>
</li>
<li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231214211837723.png" class title="image-20231214211837723">

<ul>
<li>优点：没有内存碎片，也不会浪费空间</li>
<li>缺点：如果移动存活对象，尤其是在老年代这种每次回收都有<strong>大量对象存活</strong>区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行<strong>“Stop The World”</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Appel式回收</strong></p>
<ul>
<li>1989年出现，Appel式回收的具体做法是把新生代分为一块较大的<strong>Eden空间和两块较小的Survivor空间</strong>，<strong>每次分配内存只使用Eden和其中一块Survivor。</strong>发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1</li>
<li>结合了标记复制和标记整理算法的思想，既解决了标记复制出现的空间浪费问题，又解决了标记整理出现的Stop The World问题</li>
</ul>
</li>
</ul>
<ul>
<li>Appel式回收为什么不需要Stop The World？<ul>
<li>因为Appel式回收是要把存活的对象放到一个指定的Survivor区，然后剩余的其他区域在垃圾收集结束以后一定是空的，可以存放对象的，所以即使存活的对象在往Survivor进行复制，也不影响其他对象继续向Eden添加对象，而标记整理算法，在完全整理完成之前无法确定那些空间可以使用，所以需要Stop The World</li>
</ul>
</li>
</ul>
<h4 id="6-垃圾收集-根节点枚举"><a href="#6-垃圾收集-根节点枚举" class="headerlink" title="6.垃圾收集 - 根节点枚举"></a>6.<strong>垃圾收集</strong> <strong>-</strong> <strong>根节点枚举</strong></h4><p>固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与虚拟机栈中reference引用的对象，迄今为止，<strong>所有</strong>收集器在根节点枚举这一步骤时都是必须暂停用户线程的，因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰。<strong>根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行</strong>，因为如果根节点集合的对象引用关系还在不断变化，那么分析结果准确性也就无法保证。这是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因</p>
<ul>
<li>但是现在Java应用越做越庞大，光是方法区的大小就常有数百上千兆，里面的类、常量等更是恒河沙数，若要逐个检查以这里为起源的引用肯定得消耗不少时间。这样合适吗？<ul>
<li>当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有reference引用和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。在HotSpot的解决方案里，是使用一组称为OopMap的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象什么偏移量是什么类型的数据计算出来，在即时编译过程中，<strong>也会在特定的位置记录下栈里和寄存器里哪些位置是引用</strong>。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等开始查找。</li>
</ul>
</li>
</ul>
<h4 id="7-垃圾收集-安全点"><a href="#7-垃圾收集-安全点" class="headerlink" title="7.垃圾收集 - 安全点"></a>7.<strong>垃圾收集</strong> <strong>-</strong> <strong>安全点</strong></h4><p>在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举，但一个很现实的问题随之而来：导致OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外存储空间，这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。</p>
<p>实际上HotSpot也的确没有为每条指令都生成OopMap，只是上述在“特定的位置”记录了这些信息，这些位置被称为安全点。有了安全点的设定，也就决定了<strong>用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集</strong>，而是强制要求必须执行到达安全点后才能够暂停。因此，安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的，<strong>“长时间执行”的最明显特征就是指令序列的复用，例如方法调用(线程在调用方法等待方法返回值的时间是无法预估的)、循环跳转、异常跳转等都属于指令序列复用</strong>，所以只有具有这些功能的指令才会产生安全点。</p>
<ul>
<li>如何在垃圾收集发生时让所有线程都跑到最近的安全点，然后停顿下来？<ol>
<li>抢先式中断在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。(几乎没人用)</li>
<li>主动式中断的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询检查这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。由于<strong>轮询操作在代码中会频繁出现</strong>，这要求它必须足够高效。HotSpot使用内存<strong>保护陷阱</strong>的方式，把<strong>轮询操作精简至只有一条汇编指令的程度。</strong>当需要暂停用户线程时，虚拟机把0x160100的内存页设置为不可读，那线程执行到<strong>test指令</strong>时就会产生一个自陷异常信号，然后线程就会到最近的一个安全点进行挂起等待</li>
</ol>
</li>
</ul>
<h4 id="8-垃圾收集-安全区域"><a href="#8-垃圾收集-安全区域" class="headerlink" title="8.垃圾收集 - 安全区域"></a>8.<strong>垃圾收集</strong> <strong>-</strong> <strong>安全区域</strong></h4><p>安全区域的出现是由于用户线程<strong>处于Sleep状态或者Blocked状态</strong>，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。</p>
<p><strong>安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化(例如上述的睡觉和阻塞)，</strong>因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的<strong>安全点</strong>。</p>
<p>当用户线程执行到安全区域里面的代码时，<strong>首先会标识自己已经进入了安全区域</strong>，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，线程继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</p>
<h4 id="9-垃圾收集-记忆集与卡表"><a href="#9-垃圾收集-记忆集与卡表" class="headerlink" title="9.垃圾收集 - 记忆集与卡表"></a>9.<strong>垃圾收集</strong> <strong>-</strong> <strong>记忆集与卡表</strong></h4><p>为解决对象跨代引用所带来的问题，垃圾收集器在<strong>新生代</strong>中建立了名为记忆集的数据结构，用以避免把整个老年代加进GC Roots扫描范围。事实上并不只是新生代、老年代之间才有跨代引用的问题，<strong>所有涉及部分区域收集行为的垃圾收集器，典型的如G1、ZGC，都会面临相同的问题，</strong>所以，记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。</p>
<p>记忆集不需要知道具体的引用细节，只需要知道某一区域是否存在跨代指向即可，所以为了降低维护成本，提供以下几种记忆精度：</p>
<ol>
<li><p>字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位），该字包含跨代指针。</p>
</li>
<li><p>对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。</p>
</li>
<li><p>卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</p>
</li>
</ol>
<ul>
<li>卡精度的实现<ul>
<li>“卡精度”所指的是用一种称为“卡表”的方式去实现记忆集，这也是目前最常用的一种记忆集实现形式，卡表最简单的形式可以只是一个字节数组，字节数组的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页”。一个卡页的内存中通常包含不止一个对象，<strong>只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏</strong>，没有则标识为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素即可</li>
<li>卡表是如何维护的，例如它们何时变脏、谁来把它们变脏？<ul>
<li>卡表元素何时变脏的答案是很明确的——有其他<strong>分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏</strong>，变脏时间点发生在引用类型字段赋值的那一刻。在HotSpot虚拟机里是通过<strong>写屏障技术</strong>维护卡表状态的。<strong>写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面</strong>，在引用对象赋值时会产生一个环形（Around）通知。应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦出现了跨代引用就会执行更新卡表的操作，虽然每次只要对引用进行更新，就会产生额外的开销，不过这个开销与Minor GC时扫描整个老年代的代价相比还是低得多的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="10-并发的可达性分析-三色标记"><a href="#10-并发的可达性分析-三色标记" class="headerlink" title="10.并发的可达性分析 - 三色标记"></a>10.<strong>并发的可达性分析</strong> <strong>-</strong> <strong>三色标记</strong></h4><p>从GC Roots出发，扫描整个堆上的对象，如果这个时候停止用户线程，虽然可以保证扫描结果的准确，但是随着堆的增大会导致用户线程的停顿时间过长，但是如果不停顿用户线程，就会出现某些错误情况：一种是把原本消亡的对象错误标记为存活，这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾而已，下次收集清理掉就好(例如，扫描过的黑色对象断开了某个引用)。另一种是把原本存活的对象错误标记为已消亡，这就是非常致命的后果了(例如，正在扫描的灰色对象断开了某个引用，同时扫描过的黑色引用又引用了灰色断开的引用)</p>
<ul>
<li><p>可达性分析过程中的三色标记：</p>
<ul>
<li>白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</li>
<li>黑色：表示对象已经被垃圾收集器访问过，<strong>且这个对象的所有引用都已经扫描过</strong>。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。</li>
<li>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。（大概率将来也是存活对象）</li>
</ul>
</li>
<li><p>当且仅当以下<strong>两个条件同时满足</strong>时，会产生“该存活的对象消失”的问题，即原本应该是黑色的对象被误标为白色：</p>
<ol>
<li><p>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</p>
</li>
<li><p>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</p>
</li>
</ol>
</li>
<li><p>解决对象消失的办法</p>
<ul>
<li><strong>增量更新</strong>：要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</li>
<li><strong>原始快照</strong>：要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，也将这个要删除的引用记录下来，在并发扫描结束之后，对这些记录进行重新扫描</li>
</ul>
</li>
</ul>
<h4 id="11-垃圾收集器概述"><a href="#11-垃圾收集器概述" class="headerlink" title="11.垃圾收集器概述"></a>11.垃圾收集器概述</h4><p>下图展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用</p>
<img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231215003344397.png" class title="image-20231215003344397">

<h4 id="12-三款新生代收集器"><a href="#12-三款新生代收集器" class="headerlink" title="12.三款新生代收集器"></a>12.三款新生代收集器</h4><ul>
<li><p><strong>Serial收集器</strong></p>
<ul>
<li>Serial收集器是最基础、历史最悠久的收集器。这个收集器是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它<strong>只会使用一个处理器或一条收集线程去完成垃圾收集工作</strong>，更重要的是强调在它进行垃圾收集时，<strong>必须暂停其他所有工作线程，</strong>直到它收集结束。</li>
<li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231215003854923.png" class title="image-20231215003854923"></li>
<li>迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方，那就是简单而高效（与其他收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的；对于单核处理器或处理器核心数较少的环境来说，<strong>Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</strong></li>
</ul>
</li>
<li><p><strong>ParNew收集器</strong></p>
<ul>
<li><strong>ParNew收集器实质上是Serial收集器的多线程并行版本</strong>，除了同时使用多条线程进行垃圾收集之外，其余的行为与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。</li>
<li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231215004521431.png" class title="image-20231215004521431"></li>
<li><strong>除了Serial收集器外，目前只有它能与CMS收集器配合工作。</strong>ParNew收集器在单核心处理器的环境中绝对不会有比Serial收集器更好的效果。当然，随着可以被使用的处理器核心数量的增加，ParNew对于垃圾收集时系统资源的高效利用还是很有好处的。它默认开启的收集线程数与处理器核心数量相同，可以使用-XX：ParallelGCThreads参数来限制垃圾收集的线程数。但是一般情况下都是直接使用默认配置，因为ParNew收集器在开启GC线程进行垃圾收集的时候，用户线程处于挂起状态，所以即使GC线程和处理器核数一样多也不会占用其他线程的资源</li>
</ul>
</li>
<li><p><strong>Parallel Scavenge收集器</strong></p>
<ul>
<li><p>Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器，Parallel Scavenge的诸多特性从表面上看和ParNew非常相似。但是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，<strong>而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量</strong>。</p>
</li>
<li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231215010027207.png" class title="image-20231215010027207">
</li>
<li><p>停顿时间越短就越适合需要保证服务响应质量的程序，良好的响应速度能提升用户体验；而<strong>高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算的分析任务。</strong></p>
<p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是<strong>控制最大垃圾收集停顿时间</strong>的-XX：MaxGCPauseMillis参数以及直接<strong>设置吞吐量大小</strong>的-XX：GCTimeRatio参数。</p>
<p>-XX：MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值。不过，<strong>垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的</strong>：系统把新生代调得小一些，收集300MB新生代肯定比收集500MB快，但这也直接导致垃圾收集发生得更频繁，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。</p>
<p>-XX：GCTimeRatio参数的值则应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。譬如把此参数设置为19，那允许的最大垃圾收集时间就占总时间的5%（即1&#x2F;(1+19)），默认值为99，即允许最大1%（即1&#x2F;(1+99)）的垃圾收集时间。</p>
<p>除上述两个参数之外，Parallel Scavenge收集器还有一个参数-XX：+UseAdaptiveSizePolicy值得我们关注。这是一个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold）等细节参数了，<strong>虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量</strong>。这种调节方式称为垃圾收集的<strong>自适应的调节策略</strong>。但是使用之前需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用-XX：MaxGCPauseMillis参数（更关注最大停顿时间）或-XX：GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。<strong>自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性。</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="13-三款老年代处理器"><a href="#13-三款老年代处理器" class="headerlink" title="13.三款老年代处理器"></a>13.三款老年代处理器</h4><ul>
<li><p><strong>Serial Old收集器</strong></p>
<ul>
<li>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用<strong>标记-整理算法</strong>。这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。如果在服务端模式下，它也可能有两种用途：一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用，另外一种就是作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用</li>
<li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231215035037374.png" class title="image-20231215035037374"></li>
</ul>
</li>
<li><p><strong>Parallel Old收集器</strong></p>
<ul>
<li><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于<strong>标记-整理</strong>算法实现。这个收集器是直到JDK 6时才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于相当尴尬的状态，原因是如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old收集器以外别无选择，其他表现良好的老年代收集器，如CMS无法与它配合工作。由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用Parallel Scavenge收集器也未必能在整体上获得吞吐量最大化的效果。同样，由于单线程的老年代收集中无法充分利用服务器多处理器的并行处理能力，在老年代内存空间很大而且硬件规格比较高级的运行环境中，这种组合的总吞吐量甚至不一定比ParNew加CMS的组合来得优秀。</p>
<p><strong>直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的搭配组合，在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。</strong></p>
</li>
<li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231215035400044.png" class title="image-20231215035400044"></li>
</ul>
</li>
<li><p>CMS</p>
<ul>
<li><p>CMS收集器是一种以获取<strong>最短回收停顿时间</strong>为目标的收集器。希望系统停顿时间尽可能短，以给用户带来良好的交互体验。CMS收集器就非常符合这类应用的需求。</p>
<p>从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于标记-清除算法实现的，它的运作过程分为四个步骤，包括：</p>
<p>1）初始标记：“Stop The World” 初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快</p>
<p>2）并发标记：并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是<strong>不需要停顿用户线程，可以与垃圾收集线程一起并发运行</strong></p>
<p>3）重新标记：“Stop The World” 而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，如浮动垃圾和漏检的情况</p>
<p>4）并发清除：最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于标记清除不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</p>
</li>
<li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231215041314884.png" class title="image-20231215041314884">
</li>
<li><p>CMS收集器的缺点：</p>
<ul>
<li>CMS收集器对处理器资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程而导致应用程序变慢，降低总吞吐量。<strong>CMS默认启动的回收线程数是（处理器核心数量+3）&#x2F;4</strong>，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，这时影响不大。但是当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大。</li>
<li>由于CMS收集器无法处理“浮动垃圾”，有可能出现“Con-current Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。同样也是<strong>由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集</strong>。可以调节参数-XX：CMSInitiatingOccu-pancyFraction的值来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。到了JDK 6时，CMS收集器的启动阈值就已经默认提升至92%。但这又会更容易面临另一种风险：要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“Con-current Mode Failure”，这时候虚拟机将不得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了。(总之，存活的对象＋浮动垃圾+用户线程新产生的对象 如果超过了内存上限就会出现Con-current Mode Failure，然后就只能叫Serial Old收集器来进行单线程的收集)</li>
<li>还有最后一个缺点，CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="14-Garbage-First收集器"><a href="#14-Garbage-First收集器" class="headerlink" title="14.Garbage First收集器"></a>14.<strong>Garbage First收集器</strong></h4><ul>
<li><p>概述</p>
<ul>
<li><p>Garbage First收集器开创了收集器面向局部收集的设计思路和<strong>基于Region的内存布局形式。</strong>G1是一款主要面向服务端应用的垃圾收集器。<strong>JDK 9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器</strong>，而CMS则沦落至被声明为不推荐使用（Deprecate）的收集器。</p>
<p>在G1收集器出现之前的所有其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），再要么就是整个Java堆（Full GC）。而G1跳出了这个樊笼，它可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。</p>
<p>G1开创的基于Region的堆内存布局是它能够实现这个目标的关键。虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：<strong>G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。</strong>收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。Region中还有一类特殊的Humongous区域，专门用来存储大对象。<strong>G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。</strong>每个Region的大小可以通过参数-XX：G1HeapRegionSize设定，取值范围为1MB～32MB，且应为2的N次幂。<strong>而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待</strong></p>
<p>虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。G1收集器之所以能建立可预测的停顿时间模型，是因为<strong>它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集</strong>。<strong>更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region</strong>。保证了G1收集器在有限的时间内获取尽可能高的收集效率。</p>
</li>
</ul>
</li>
<li><p>将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象如何解决？</p>
<ul>
<li>同样使用记忆集避免全堆作为GC Roots扫描，它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。和跨代引用维护的卡表，跨Region引用是“双向”卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”）比原来的卡表实现起来更复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃圾收集器有着更高的内存占用负担。</li>
</ul>
</li>
<li><p>在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？</p>
<ul>
<li><strong>CMS收集器采用增量更新算法实现，而G1收集器则是通过原始快照（SATB）算法来实现的。</strong>此外，垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上，程序要继续运行就肯定会持续有新对象被创建，G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。与CMS中的“Concurrent Mode Failure”失败会导致Full GC类似，如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行，导致Full GC而产生长时间“Stop The World”。</li>
</ul>
</li>
<li><p>怎样建立起可靠的停顿预测模型？</p>
<ul>
<li>G1收集器会记录每个区域进行回收能获得价值，并且还会记录每个区域回收需要的时候，同时根据指定的-XX：MaxGCPauseMillis参数(停顿时间的预期值)尽可能保证停顿时间在预期值以内</li>
</ul>
</li>
<li><p><strong>G1收集器运作的四个步骤：</strong></p>
<ul>
<li><p>初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短。–stop the world</p>
<p>并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</p>
<p>最终标记：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。(就是使用原始快照的方式对对象进行重新扫描) –stop the world</p>
<p>筛选回收：对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。 –stop the world</p>
</li>
<li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231215060206527.png" class title="image-20231215060206527">
</li>
<li><p>G1收集器除了并发标记之外都需要stop the world</p>
</li>
</ul>
</li>
<li><p>G1和CMS的对比</p>
<ul>
<li><p>相比CMS，G1的优点有很多，<strong>可以指定最大停顿时间、分Region的内存布局、按收益动态确定回收集</strong>这些创新性设计。与CMS的“标记-清除”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片</p>
<p>比起CMS，G1的弱项在于在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比CMS要高。就内存占用来说，虽然G1和CMS都使用卡表来处理跨代指针，但G1的卡表实现更为复杂，而且堆中每个Region，无论扮演的是新生代还是老年代角色，都必须有一份卡表；相比起来CMS的卡表就相当简单，只有唯一一份，而且只需要处理老年代到新生代的引用</p>
</li>
</ul>
</li>
</ul>
<h4 id="15-内存分配策略"><a href="#15-内存分配策略" class="headerlink" title="15.内存分配策略"></a>15.<strong>内存分配策略</strong></h4><ul>
<li><p><strong>对象优先在Eden分配，大对象直接进入老年代</strong></p>
<ul>
<li><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p>
<p>大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组，HotSpot虚拟机提供了-XX：PretenureSizeThreshold参数，<strong>指定大于该设置值的对象直接在老年代分配</strong>，这样做的目的就是<strong>避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作。</strong></p>
</li>
</ul>
</li>
<li><p><strong>长期存活的对象将进入老年代</strong></p>
<ul>
<li>虚拟机给每个对象定义了一个分代年龄计数器，存储在对象头中。对象通常在Eden区里诞生，如果经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置。（对于这个对象年龄的设置，一般情况下，不要去做任何变更。如果我们的年轻代里边的新生对象大部分都是存活1岁，只有特别小的部分会存活时间很长，并且程序长时间运行的时候，这部分大对象所占用的空间几乎不变。可以考虑适当增大这个年龄。）</li>
</ul>
</li>
<li><p>如果年龄不够配置的年龄，并且也不属于大对象，那么一定不会进入老年代吗？</p>
<ul>
<li>为了能更好地适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄必须达到-XX：MaxTenuringThreshold才能晋升老年代，<strong>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX：MaxTenuringThreshold中要求的年龄。</strong></li>
</ul>
</li>
<li><p><strong>空间分配担保策略及垃圾回收过程</strong></p>
<ul>
<li>在发生Minor Gc之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看-XX: HandlePromotionFailure参数的设置值<strong>是否允许担保失败</strong>（Handle Promotion Failure) ;如果允许，那会继续检查老年代最大可用的连续空间是否大于<strong>历次晋升到老年代对象的平均大小</strong>，如果大于， 将尝试进行一次Minor Gc，尽管这次Minor Gc是有风险的;如果小于，或者-XX:HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。</li>
</ul>
</li>
</ul>
<h3 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h3><h4 id="1-运行时栈帧结构"><a href="#1-运行时栈帧结构" class="headerlink" title="1.运行时栈帧结构"></a>1.<strong>运行时栈帧结构</strong></h4><ul>
<li><p>概述</p>
<ul>
<li><p>Java虚拟机以方法作为最基本的执行单元，“栈帧”则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈的栈元素。<strong>栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。</strong>每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p>
<p>在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中。换言之，<strong>一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式</strong>。</p>
<p>一个线程中的方法调用链可能会很长，以Java程序的角度来看，同一时刻、同一条线程里面，在调用堆栈的所有方法都同时处于执行状态。<strong>而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的</strong>。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作</p>
</li>
<li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231215071625783.png" class title="image-20231215071625783"></li>
</ul>
</li>
</ul>
<h4 id="2-局部变量表"><a href="#2-局部变量表" class="headerlink" title="2.局部变量表"></a>2.局部变量表</h4><p>局部变量表的容量以变量槽为最小单位，没有规定每个槽的具体大小，只要求每个变量槽都能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据，它允许变量槽的长度可以随着处理器、操作系统或虚拟机实现的不同而发生变化</p>
<p>Java虚拟机通过索引定位的方式使用局部变量表，<strong>索引值的范围是从0开始至局部变量表最大的变量槽数量</strong>。如果访问的是32位数据类型的变量，索引N就代表了使用第N个变量槽（对于非静态的方法，第0个变量槽，放置的是this。），如果访问的是64位数据类型的变量，则说明会同时使用第N和N+1两个变量槽。<strong>对于两个相邻的共同存放一个64位数据的两个变量槽，虚拟机不允许采用任何方式单独访问其中的某一个。</strong></p>
<p>当一个方法被调用时，Java虚拟机会使用局部变量表来完成实参到形参的传递。如果执行的是实例方法（没有被static修饰的方法），那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从1开始的局部变量槽，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。</p>
<p><strong>为了尽可能节省栈帧耗用的内存空间，局部变量表中的变量槽是可以重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的变量槽就可以交给其他变量来重用。</strong></p>
<h4 id="3-操作数栈"><a href="#3-操作数栈" class="headerlink" title="3.操作数栈"></a>3.操作数栈</h4><p>操作数栈，同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。操作数栈元素可以是包括long和double在内的任意Java数据类型。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。Javac编译器的数据流分析工作保证了在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。</p>
<p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。譬如在<strong>做算术运算的时候是通过将运算涉及的操作数压入栈顶后调用运算指令来进行的</strong>，又譬如<strong>在调用其他方法的时候是通过操作数栈来进行方法参数的传递</strong>。举个例子，例如整数加法的字节码指令iadd，这条指令在运行的时候要求操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会把这两个int值出栈并相加，然后将相加的结果重新入栈。</p>
<p>两个不同栈帧作为不同方法的虚拟机栈的元素，是完全相互独立的。但是在大多虚拟机的实现里都会进行一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样上面的栈帧中不需要存储下面栈帧操作数栈里面的元素到自己的局部变量表，可以节约了一些空间，也无须进行额外的参数复制传递</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> i)</span> &#123; </span><br><span class="line">	</span><br><span class="line">	i = i + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> getAdd(i);</span><br><span class="line">          <span class="keyword">return</span> j;	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> in <span class="title function_">getAdd</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> i +<span class="number">100</span>;   </span><br><span class="line">   <span class="comment">//最接近栈顶的两个元素已经存入了两个int型的数值</span></span><br><span class="line">  <span class="comment">// 好处就是 getAdd这个栈帧不需要存储 i 到局部变量表了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231215215427479.png" class title="image-20231215215427479">

<h4 id="4-动态连接和方法返回地址"><a href="#4-动态连接和方法返回地址" class="headerlink" title="4.动态连接和方法返回地址"></a>4.<strong>动态连接</strong>和方法返回地址</h4><ul>
<li><p>动态连接</p>
<ul>
<li>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。通过第6章的讲解，我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。（后续方法调用中详细分解）。</li>
</ul>
</li>
<li><p>方法返回地址</p>
<ul>
<li><p>当一个方法开始执行后，只有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令退出该方法，被称为“正常调用完成”。另外一种退出方式是在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理。这种退出方法的方式称为“异常调用完成“。</p>
<p><strong>无论采用何种退出方式，在方法退出之后，都必须返回到最初方法被调用时的位置，程序才能继续执行，方法退出的过程实际上等同于把当前栈帧出栈，</strong>因此退出时可能执行的操作有：<strong>恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="5-方法调用-解析调用"><a href="#5-方法调用-解析调用" class="headerlink" title="5.方法调用 - 解析调用"></a>5.<strong>方法调用</strong> <strong>-</strong> <strong>解析调用</strong></h4><p>方法调用并不等同于方法中的代码被执行，<strong>方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还未涉及方法内部的具体运行过程</strong>。一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（也就是之前说的直接引用）。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂，某些调用需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</p>
<p><strong>所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用</strong>，在类加载的解析阶段，会将其中的<strong>一部分</strong>符号引用转化为直接引用，即方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为解析调用。</p>
<p>调用不同类型的方法，字节码指令集里设计了不同的指令：</p>
<ul>
<li><p>invokestatic。用于调用静态方法。</p>
</li>
<li><p>invokespecial。用于调用实例构造器<init>()方法、私有方法和父类中的方法。</init></p>
</li>
<li><p>invokevirtual。用于调用所有的虚方法。</p>
</li>
<li><p>invokeinterface。用于调用接口方法，会在运行时再确定一个实现该接口的对象。</p>
</li>
<li><p>invokedynamic。先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。</p>
</li>
</ul>
<p><strong>只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本</strong>，Java语言里符合调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来这个条件的方法共有<strong>静态方法、私有方法、实例构造器、父类方法4种，再加上被final修饰的方法（尽管它使用invokevirtual指令调用）</strong>，这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为“非虚方法”，与之相反，其他方法就被称为“虚方法”。</p>
<p><strong>解析调用一定是个静态的过程，在编译期间就完全确定</strong>，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成。</p>
<p>而另一种主要的方法调用形式：分派调用则要复杂许多，它可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派。这两类分派方式两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派4种分派组合情况。</p>
<h4 id="6-方法调用-分派调用"><a href="#6-方法调用-分派调用" class="headerlink" title="6.方法调用 - 分派调用"></a>6.<strong>方法调用</strong> <strong>-</strong> <strong>分派调用</strong></h4><ul>
<li><p>静态分派</p>
<ul>
<li><p><strong>静态分派的最典型应用表现就是方法重载。静态分派发生在编译阶段，</strong>因此确定静态分派的动作实际上不是由虚拟机来执行的(静态分派是发生在编译期间，也就是说编译期间就固定了我们方法的版本；我们解析调用也是在编译期间确定了方法的版本。<strong>解析它是在类加载的过程中将我们的符号引用转化为直接引用; 静态分派方法调用的符号引用转为直接引用是发生在 运行期间</strong>)</p>
</li>
<li><pre><code class="java">public class StaticDispatch &#123;
    static abstract class Human &#123;
    &#125;
    static class Man extends Human &#123;
    &#125;
    static class Woman extends Human &#123;
    &#125;

    public void sayHello(Human guy) &#123;
        System.out.println(&quot;hello,guy!&quot;);
    &#125;
    public void sayHello(Man guy) &#123;
        System.out.println(&quot;hello,gentleman!&quot;);
    &#125;
    public void sayHello(Woman guy) &#123;
        System.out.println(&quot;hello,lady!&quot;);
    &#125;
    public static void main(String[] args) &#123;
        Human man = new Man();
        Human woman = new Woman();
        StaticDispatch sr = new StaticDispatch();
        sr.sayHello(man);
        sr.sayHello(woman);
        //此时两次输出都是hello,guy!
        // Human 属于静态类型（外观类型）； new Man 和 new Woman 属于 实际类型（运行时类型）
        //对于方法的重载，在编译器会直接通过我们的静态类型（外观类型） 进行方法版本的确认。
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 但是，Javac编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本可能并不是“唯一”的，往往只能确定一个“相对更合适的”版本。</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public class StaticDispatch1 &#123;</span><br><span class="line">      public static void sayHello(Object arg) &#123;</span><br><span class="line">          System.out.println(&quot;hello Object&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      public static void sayHello(int arg) &#123;</span><br><span class="line">          System.out.println(&quot;hello int&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      public static void sayHello(long arg) &#123;</span><br><span class="line">          System.out.println(&quot;hello long&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      public static void sayHello(Character arg) &#123;</span><br><span class="line">          System.out.println(&quot;hello Character&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      public static void sayHello(char arg) &#123;</span><br><span class="line">          System.out.println(&quot;hello char&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      public static void sayHello(char... arg) &#123;</span><br><span class="line">          System.out.println(&quot;hello char ...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      public static void sayHello(Serializable arg) &#123;</span><br><span class="line">          System.out.println(&quot;hello Serializable&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          sayHello(&#x27;a&#x27;);</span><br><span class="line">          //通过依次注释它调用的方法，然后得出编译器选择的方法</span><br><span class="line">          //初看他就是一个 char，所以选择char参数的</span><br><span class="line">          //第二选择是 int，因为char类型本身就可以转化成数字类型</span><br><span class="line">          //第三选择是long，因为int类型向上提升类型，到long型</span><br><span class="line">          //第四选择是 hello Character，找自己的封装类型</span><br><span class="line">          // 第五选择，序列化，发现 Character implements java.io.Serializable。</span><br><span class="line">          //第六选择，找祖宗 Object</span><br><span class="line">          //第七选择：多参数的char，因为对于方法的重载，编译器肯定是首选择参数个数以及参数类型更为接近的类型。</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>动态分派</p>
<ul>
<li><p>动态分派和重写有着很密切的关联</p>
</li>
<li><pre><code class="java">public class DynamicDispatch &#123;
    static abstract class Human &#123;
        protected abstract void sayHello();
    &#125;
    static class Man extends Human &#123;
        @Override
        protected void sayHello() &#123;
            System.out.println(&quot;man say hello&quot;);
        &#125;
    &#125;
    static class Woman extends Human &#123;
        @Override
        protected void sayHello() &#123;
            System.out.println(&quot;woman say hello&quot;);
        &#125;
    &#125;
    public static void main(String[] args) &#123;
        Human man = new Man();
        Human woman = new Woman(); // 与我们之前做静态分派的时候很相似，他的静态类型（外观类型） 都是选择的Human
        man.sayHello();  // &quot;man say hello&quot;
        woman.sayHello(); // woman say hello
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 上面main方法对应的字节码指令</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  0: new           #2              // class com/boot/jvm/DynamicDispatch$Man  创建Man</span><br><span class="line">  3: dup    复制我们的变量 man --》 操作数栈的栈顶</span><br><span class="line">  4: invokespecial #3              // Method com/boot/jvm/DynamicDispatch$Man.&quot;&lt;init&gt;&quot;:()V  初始化man对象</span><br><span class="line">  7: astore_1  // 将我们的man变量存入我们的局部变量表（栈帧里边呢）</span><br><span class="line">  8: new           #4              // class com/boot/jvm/DynamicDispatch$Woman  创建Woman</span><br><span class="line">  11: dup</span><br><span class="line">  12: invokespecial #5              // Method com/boot/jvm/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  15: astore_2</span><br><span class="line">           //以上步骤，进行了man对象的创建和woman对象的创建，并且将其存入线程的栈帧的里边的局部变量表</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  16: aload_1  //将我们的 man 这个变量压入 操作数栈的栈顶</span><br><span class="line">  17: invokevirtual #6              // Method com/boot/jvm/DynamicDispatch$Human.sayHello:()V</span><br><span class="line">           //invokevirtual 后边跟的是 Human.sayHello， 不是Man.sayHello</span><br><span class="line">  </span><br><span class="line">  20: aload_2  //将我们的 woman 这个变量压入 操作数栈的栈顶</span><br><span class="line">  21: invokevirtual #6              // Method com/boot/jvm/DynamicDispatch$Human.sayHello:()V</span><br><span class="line">           //invokevirtual 后边跟的是 Human.sayHello， 不是Woman.sayHello</span><br><span class="line">                   //invokevirtual 调用的是 ： 虚方法 。</span><br><span class="line">  </span><br><span class="line">  24:return</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>实现动态分派的关键在于invokevirtual这个指令调用的虚方法，下面是invokevirtual指令的执行步骤</p>
<ul>
<li><p>1）<strong>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。</strong></p>
<p>2）如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回java.lang.IllegalAccessError异常。</p>
<p>3）否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。</p>
<p>4）如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</p>
</li>
<li><p>重点就是第一步，直接找实际类型，后面的几步就是校验访问权限和查找父类的过程。正是因为invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法版本，这个过程就是Java语言中方法重写的本质。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>单分派与多分派</strong></p>
<ul>
<li><p><strong>重载</strong> <strong>是静态多分派</strong></p>
<p><strong>重写</strong> <strong>是动态单分派</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="OOM异常与Jvm调优"><a href="#OOM异常与Jvm调优" class="headerlink" title="OOM异常与Jvm调优"></a>OOM异常与Jvm调优</h3><h4 id="1-Oom案例一"><a href="#1-Oom案例一" class="headerlink" title="1.Oom案例一"></a>1.<strong>Oom</strong>案例<strong>一</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OomTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);<span class="comment">//此处关键点不是说的线程池问题</span></span><br><span class="line">    <span class="keyword">static</span> CompletionService&lt;String&gt; service = <span class="keyword">new</span> <span class="title class_">ExecutorCompletionService</span>&lt;&gt;(executor); </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        service.submit(() -&gt; <span class="string">&quot;Successfully!--&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">//if(service.take().get().startsWith(&quot;Successfully!&quot;))&#123;</span></span><br><span class="line">        <span class="comment">//    updateDBStatus();</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateDBStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//更新DB执行状态。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">45000</span>;i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;========&quot;</span> + i);</span><br><span class="line">                test();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">10000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ExecutorCompletionService和ExecutorService的区别</p>
<ul>
<li><p>ExecutorCompletionService： 当我们需要获取每一个线程执行的返回值的时候，使用ExecutorCompletionService<br>ExecutorService + Future也可以实现这种效果，但是这样如果有10个返回值; 一个返回值对应一个线程执行；如果有9个返回值1s返回，剩下的一个100s，那么在执行以下代码的时候<br>&#x2F;&#x2F; List.add(future);<br>&#x2F;&#x2F; for(List) {<br>&#x2F;&#x2F;   future.get() 在进行结果获取的时候阻塞第10个返回值直到 100 s<br>&#x2F;&#x2F;  }<br>&#x2F;&#x2F; 所以ExecutorService + Future这个组合一般适用于所有线程全部执行完毕才向下执行的场景</p>
<p>&#x2F;&#x2F; ExecutorCompletionService 这个东西是，有10个异步线程，他不管谁快谁慢，都会将这个10个返回值存储到队列里。调用端想取出来随时就能取出来。future的get是自身的，ExecutorCompletionService返回值放队列里边了。</p>
</li>
</ul>
</li>
<li><p>目前代码没有任何问题，但是现在需求改为了我们这个不需要返回值了，DB这边也不需要更新了。因为我们直接在我们的异步线程run方法里进行我们的异常的catch以及log记录。updateDBStatus();性能问题。所以我们采取了这种方式，如果有异常，就重试。</p>
<ul>
<li><p>然后根据这个这个需求直接将下面三行进行注释就可以了</p>
<ul>
<li><pre><code class="java">    //if(service.take().get().startsWith(&quot;Successfully!&quot;))&#123;
    //    updateDBStatus();
    //&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 上线五天出现OOM</span><br><span class="line"></span><br><span class="line">  - 内存泄露的点在于：我们的返回值实际上已经不再使用了，但是仍然被 static service 中的 LinkedBq所引用。所以就会一直无法被垃圾收集器回收</span><br><span class="line"></span><br><span class="line">  - &#123;% asset_img image-20231217143425746.png image-20231217143425746 %&#125;</span><br><span class="line"></span><br><span class="line">    &#123;% asset_img image-20231217143832934.png image-20231217143832934 %&#125;</span><br><span class="line"></span><br><span class="line">  - 问题的根源就在120行</span><br><span class="line"></span><br><span class="line">#### 2.OOM问题排查</span><br><span class="line"></span><br><span class="line">* 排查步骤：</span><br><span class="line"></span><br><span class="line">1. 可以通过参数dump堆内存快照</span><br><span class="line"></span><br><span class="line">    -XX:+HeapDumpOnOutOfMemoryError 发生OOM时，理解dump堆内存 </span><br><span class="line"></span><br><span class="line">   -XX:HeapDumpPath=E:\Temp 堆内存快照保存路径</span><br><span class="line"></span><br><span class="line">2. 也可以通过 JPS 获取虚拟机进程ID， 通过jmap 命令dump堆内存快照 jmap -dump:format=b,file=E:\Temp\dump.hprof 4676。</span><br><span class="line"></span><br><span class="line">3. 将dump下来的堆内存快照进行分析。此处介绍 jvisualvm 可视化分析方式。 </span><br><span class="line"></span><br><span class="line">在jvisualvm 可以看出，char[],String,LinkedBlockingQueue,FutureTask占用内存最多，这四部分其实是存在联系的，FutureTask占用了22.4%的内存，他的返回结果要存在LinkedBlockingQueue，而存储的内容是用String类型表示的，String类型的底层是char[]，所以可以初步把问题定位到FutureTask中</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231217165318702.png image-20231217165318702 %&#125;</span><br><span class="line"></span><br><span class="line">#### 3.内存泄漏和内存溢出</span><br><span class="line"></span><br><span class="line">* 内存泄漏</span><br><span class="line"></span><br><span class="line">  - 对象已经没有实际的使用意义，但是仍然有被**错误引用（非必要的引用）**，而无法被垃圾收集，导致内存泄漏。</span><br><span class="line">  - 内存泄漏的常见原因</span><br><span class="line"></span><br><span class="line">  1. 静态集合类引起内存泄漏(例如static来修饰的list集合，它属于类属性，不会被回收)</span><br><span class="line"></span><br><span class="line">  2. 数据库连接（dataSourse.getConnection ()），网络连接 (socket) 和 io 连接，除非其显式的调用了其 close () 方法将其连接关闭，否则是不会自动被 GC 回收的。</span><br><span class="line"></span><br><span class="line">  3. 内部类持有外部类。如果一个外部类的实例对象的一个方法的返回值是内部类的实例，然后内部类实例被长期引用，这时即使外部类的实例对象已经没有用了，也不会被垃圾收集器回收</span><br><span class="line"></span><br><span class="line">* 内存溢出</span><br><span class="line"></span><br><span class="line">  - 内存溢出实际上是内存不够的表现。内存泄漏最终会导致内存溢出。 如果所有的对象都有实际的使用意义无法被回收导致内存不够使用的话，称之为内存溢出。（创建很多个对象，还在被使用；加载大量的数据文件）</span><br><span class="line"></span><br><span class="line">#### 4.OOM案例二</span><br><span class="line"></span><br><span class="line">直接由内存溢出导致</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//-Xms10m -Xmx10m</span><br><span class="line">public class OomTest2 &#123;</span><br><span class="line">    // 一个数据转储一个服务</span><br><span class="line">    // 接收数据，然后对数据进行转储。</span><br><span class="line">    // 接收数据通过 中间件 进行监听接收（mq)</span><br><span class="line">    </span><br><span class="line">	// 可能出现的场景</span><br><span class="line">    // 读取数据库大量数据</span><br><span class="line">    // 读取大文件</span><br><span class="line">    // 从网络上加载大的数据包</span><br><span class="line"></span><br><span class="line">    //解决方案</span><br><span class="line">    //1 . 可以通过中间件进行数据的缓冲</span><br><span class="line">    //2. 分批进行数据的获取</span><br><span class="line">    //3. 增加我们的内存量（堆内存）-- 考虑： 越大的堆内存面临着时间停顿越长，垃圾量太多。</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        byte[] bytes = getData(); // 接收数据</span><br><span class="line">        processData(bytes); // 进行数据的处理和转储</span><br><span class="line">        // getDataFromMq(一次性取多少分batch还是一条条的)</span><br><span class="line">        //processData</span><br><span class="line">    &#125;</span><br><span class="line">    public static byte[] getData()&#123;</span><br><span class="line">        return new byte[10*1024*1024];</span><br><span class="line">    &#125;</span><br><span class="line">    private static void processData(byte[] bytes) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>直接读取一个大文件，然后对文件进行处理转储等后续操作，此时文件会作为局部变量存到内存当中，所以很容易出现内存溢出</p>
<h4 id="5-JVM调优总结"><a href="#5-JVM调优总结" class="headerlink" title="5.JVM调优总结"></a>5.JVM调优总结</h4><ol>
<li><p>在大访问压力下，MinorGC 频繁，每次在MGC 存活下来的对象，会移动到Survivor1区。只要MGC 延迟不导致停顿时间过长或者引发FGC ，那可以适当的增大Eden 空间大小，降低频繁程度，<strong>同时要保证，空间增大对垃圾回收时间产生的停顿时间增长也是可以接受的</strong>。如果MinorGC 频繁，且容易引发 Full GC。需要从如下几个角度进行分析。</p>
<ul>
<li>每次MGC存活的对象的大小，是否能够全部移动到 S1区，如果S1 区大小 &lt; MGC 存活的对象大小，这批对象会直接进入老年代。注意了，这批对象的年龄才1岁，很有可能再多等1次MGC 就能被回收了，可是却进入了老年代，只能等到Full GC 进行回收。这种情况下，应该在系统压测的情况下，实时监控每次MGC存活的对象大小，并合理调整eden和s区的大小以及比例。</li>
<li>如果S1区的对象，相同年龄的对象所占总空间大小&gt;s1区空间大小的一半，这时S1区的所有年龄大于等于这些相同年龄对象的对象会直接进入老年代，所以为了应对这种情况，对于S区的大小的调整就要考虑：尽量保证峰值状态下，S1区的对象所占空间能够在MGC的过程中，相同对象年龄所占空间不大于S1区空间的一半，因此对于S1空间大小的调整，也是十分重要的。</li>
</ul>
</li>
<li><p>由于大对象创建频繁，导致Full GC 频繁。对于大对象，JVM专门有参数进行控制，-XX：PretenureSizeThreshold。超过这个参数值的对象，会直接进入老年代，只能等到full GC 进行回收，所以在系统压测过程中，要重点监测大对象的产生。</p>
<ul>
<li>如果能够优化对象大小，则进行代码层面的优化，优化如：该大对象是否可以进行拆分使用，或者如果大对象确定使用完成后，将该对象赋值为null，方便垃圾回收。</li>
<li>如果代码层面无法优化，则需要考虑：a:调高-XX：PretenureSizeThreshold参数的大小，使对象有机会在eden区创建，有机会经历MGC以被回收。但是这个参数的调整要结合MGC过程中Eden区的大小是否能够承载，包括S1区的大小承载问题。b：如果必须要进入老年代，也要尽量保证，该对象确实是长时间使用的对象，放入老年代的总对象创建量不会造成老年代的内存空间迅速长满发生Full GC，在这种情况下，可以通过定时脚本，在业务系统不繁忙情况下，主动触发full gc。</li>
</ul>
</li>
<li><p>MGC 与 FGC 停顿时间长导致影响用户体验。其实对于停顿时间长的问题无非就两种情况：</p>
<ul>
<li>gc 真实回收过程时间长，即real time时间长。这种时间长大部分是因为内存过大导致，导致从标记到清理的过程中需要对很大的空间进行操作，导致停顿时间长。</li>
<li>b：gc真实回收时间 real time 并不长，但是user time(用户态执行时间) 和 sys time（核心态执行时间）时间长，导致从客户角度来看，停顿时间过长。<ul>
<li>user time：进程执行用户态代码所耗费的处理器时间。（执行我们书写的代码）</li>
<li>sys time：进程执行核心态代码所耗费的处理器时间。（用户态转为内核态后，内核态执行时间）</li>
<li>real time：执行垃圾收集动作从开始到结束耗费的时钟时间。（真正的时间消耗）</li>
</ul>
</li>
<li>对于a情况，要考虑减少堆内存大小，包括新生代和老年代，比如之前使用16G的堆内存，可以考虑将16G 内存拆分为4个4G的内存区域，可以单台机器部署JVM逻辑集群，也可以为了降低GC回收时间进行4节点的分布式部署，这里的分布式部署是为了降低GC垃圾回收时间。</li>
<li>对于b情况，要考虑线程是否及时达到了安全点，安全点一般放置在方法调用、循环跳转、异常跳转这些位置，<strong>但是HotSpot虚拟机为了避免安全点过多带来过重的负担，对循环还有一项优化措施，认为循环次数较少的话，执行时间应该也不会太长，所以使用int类型或范围更小的数据类型作为索引值的循环默认是不会被放置安全点的。相对应地，使用long或者范围更大的数据类型作为索引值的循环将会被放置安全点。</strong>通常情况下这个优化措施是可行的，<strong>但循环执行的时间不单单是由其次数决定，如果循环体单次执行就特别慢，那即使是可数循环也可能会耗费很多的时间。</strong>主要考虑以下两种改进方式<ul>
<li>修改我们的代码。加快代码执行速度</li>
<li>将发生问题的这部分循环代码以 long型进行循环索引数据类型。</li>
</ul>
</li>
</ul>
</li>
<li><p>内存泄漏导致的MGC和FGC频繁，最终引发oom。</p>
</li>
<li><p>纯代码级别导致的MGC和FGC频繁。如果是这种情况，那就只能对代码进行大范围的调整，这种情况就非常多了，而且会很糟糕。如大循环体中的new 对象，未使用合理容器进行对象托管导致对象创建频繁，不合理的数据结构使用等等。</p>
</li>
</ol>
<p>总之，JVM的调优无非就一个目的，在系统可接受的情况下达到一个<strong>合理的MGC和FGC的频率以及可接受的回收时间。</strong></p>
<ul>
<li><p>如何直到垃圾回收的时候，每个区的使用率和垃圾回收所用的时间</p>
<ul>
<li>jstat -gcutil + 虚拟机进程号 这个命令</li>
<li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231217180240548.png" class title="image-20231217180240548"></li>
</ul>
</li>
<li><p>直接内存溢出</p>
<ul>
<li><p>虚拟机虽然会对直接内存进行回收，但是直接内存却不能像新生代、老年代那样，发现空间不足了就主动通知收集器进行垃圾回收，<strong>它只能等待老年代满后Full GC出现后，“顺便”帮它清理掉内存的废弃对象</strong>。否则就不得不一直等到抛出内存溢出异常。</p>
<p>直接内存溢出，加入-XX：+HeapDumpOnOutOfMemoryError参数，也没有任何反应，抛出内存溢出异常时什么文件都没有产生。</p>
<p>·直接内存：可通过**-XX：MaxDirectMemorySize**调整大小，内存不足时抛出OutOf-MemoryError或者OutOfMemoryError：Direct buffer memory。</p>
</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://monkey918857.github.io">Inequalities</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://monkey918857.github.io/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">https://monkey918857.github.io/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://monkey918857.github.io" target="_blank">Inequalitiesの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="https://img-baofun.zhhainiao.com/pcwallpaper_ugc/static/53f31f4f8ca1bb064ea18a398db64db9.jpg?x-oss-process=image%2fresize%2cm_lfit%2cw_3840%2ch_2160" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="《Redis设计与实现》阅读笔记"><img class="cover" src="https://www.toopic.cn/public/uploads/image/20200411/20200411133433_43554.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《Redis设计与实现》阅读笔记</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="《Java并发编程的艺术》阅读笔记"><img class="cover" src="https://www.toopic.cn/public/uploads/small/1695101465702169510146570.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《Java并发编程的艺术》阅读笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Inequalities</div><div class="author-info__description">欢迎访问Inequalitiesの博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/monkey918857"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/monkey918857" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/472353013?spm_id_from=444.41.0.0" target="_blank" title="小破绽"><i class="fab fa-algolia"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">非科班转码小猴的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%AD%A6%E4%B9%A0%E9%93%BE%E8%B7%AF"><span class="toc-text">JVM学习链路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">Class 文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%AD%94%E6%95%B0%E4%B8%8E%E6%AC%A1%E4%B8%BB%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-text">1.魔数与次主版本号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-text">2.常量池计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">3.常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%E3%80%81%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88"><span class="toc-text">4.访问标志、类索引、父类索引与接口索引集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%AD%97%E6%AE%B5%E8%A1%A8%E9%9B%86%E5%90%88%E3%80%81%E6%96%B9%E6%B3%95%E8%A1%A8%E9%9B%86%E5%90%88"><span class="toc-text">5.字段表集合、方法表集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%B1%9E%E6%80%A7%E8%A1%A8%E9%9B%86%E5%90%88"><span class="toc-text">6.属性表集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4"><span class="toc-text">7.JVM 字节码指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-text">类加载子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-text">1.类加载流程概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E5%8A%A0%E8%BD%BD"><span class="toc-text">2.类加载过程 - 加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E8%BF%9E%E6%8E%A5-%E9%AA%8C%E8%AF%81"><span class="toc-text">3.类加载过程 - 连接 - 验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E8%BF%9E%E6%8E%A5-%E5%87%86%E5%A4%87"><span class="toc-text">4.类加载过程 - 连接 - 准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E8%BF%9E%E6%8E%A5-%E8%A7%A3%E6%9E%90"><span class="toc-text">5.类加载过程 - 连接 - 解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">6.类加载过程 - 初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-text">运行时数据区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-text">1.运行时数据区概述及程序计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A0%86"><span class="toc-text">2.堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-text">3.Java对象的创建过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-text">4.Java对象的内存布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-text">5.Java对象的访问定位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-text">6.方法区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">7.运行时常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E4%B8%8E%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-text">8.Java虚拟机栈与本地方法栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-text">垃圾收集器与内存分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB"><span class="toc-text">1.判断对象是否存活</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E6%9E%9C%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%8F%AF%E8%BE%BE%EF%BC%8C%E4%B8%80%E5%AE%9A%E4%BC%9A%E8%A2%AB%E5%9B%9E%E6%94%B6%E5%90%97%EF%BC%9F"><span class="toc-text">2.如果对象不可达，一定会被回收吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%86%8D%E8%B0%88%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9B%9E%E6%94%B6"><span class="toc-text">3.再谈方法区回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA"><span class="toc-text">4.垃圾收集算法 - 分代收集理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%87%A0%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95-%E6%8C%89%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4"><span class="toc-text">5.几种垃圾收集算法(按出现时间)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86-%E6%A0%B9%E8%8A%82%E7%82%B9%E6%9E%9A%E4%B8%BE"><span class="toc-text">6.垃圾收集 - 根节点枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86-%E5%AE%89%E5%85%A8%E7%82%B9"><span class="toc-text">7.垃圾收集 - 安全点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="toc-text">8.垃圾收集 - 安全区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86-%E8%AE%B0%E5%BF%86%E9%9B%86%E4%B8%8E%E5%8D%A1%E8%A1%A8"><span class="toc-text">9.垃圾收集 - 记忆集与卡表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0"><span class="toc-text">10.并发的可达性分析 - 三色标记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-text">11.垃圾收集器概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E4%B8%89%E6%AC%BE%E6%96%B0%E7%94%9F%E4%BB%A3%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">12.三款新生代收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E4%B8%89%E6%AC%BE%E8%80%81%E5%B9%B4%E4%BB%A3%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">13.三款老年代处理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-Garbage-First%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">14.Garbage First收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-text">15.内存分配策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-text">虚拟机字节码执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84"><span class="toc-text">1.运行时栈帧结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-text">2.局部变量表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="toc-text">3.操作数栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="toc-text">4.动态连接和方法返回地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8-%E8%A7%A3%E6%9E%90%E8%B0%83%E7%94%A8"><span class="toc-text">5.方法调用 - 解析调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8-%E5%88%86%E6%B4%BE%E8%B0%83%E7%94%A8"><span class="toc-text">6.方法调用 - 分派调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OOM%E5%BC%82%E5%B8%B8%E4%B8%8EJvm%E8%B0%83%E4%BC%98"><span class="toc-text">OOM异常与Jvm调优</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Oom%E6%A1%88%E4%BE%8B%E4%B8%80"><span class="toc-text">1.Oom案例一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-JVM%E8%B0%83%E4%BC%98%E6%80%BB%E7%BB%93"><span class="toc-text">5.JVM调优总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="《MySQL技术内幕 InnoDB存储引擎》阅读笔记"><img src="https://www.toopic.cn/public/uploads/small/1692244437821169224443772.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《MySQL技术内幕 InnoDB存储引擎》阅读笔记"/></a><div class="content"><a class="title" href="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="《MySQL技术内幕 InnoDB存储引擎》阅读笔记">《MySQL技术内幕 InnoDB存储引擎》阅读笔记</a><time datetime="2023-12-26T09:05:57.000Z" title="发表于 2023-12-26 17:05:57">2023-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="《Redis设计与实现》阅读笔记"><img src="https://www.toopic.cn/public/uploads/image/20200411/20200411133433_43554.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Redis设计与实现》阅读笔记"/></a><div class="content"><a class="title" href="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="《Redis设计与实现》阅读笔记">《Redis设计与实现》阅读笔记</a><time datetime="2023-12-18T05:19:19.000Z" title="发表于 2023-12-18 13:19:19">2023-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="《深入理解Java虚拟机》阅读笔记"><img src="https://img-baofun.zhhainiao.com/pcwallpaper_ugc/static/53f31f4f8ca1bb064ea18a398db64db9.jpg?x-oss-process=image%2fresize%2cm_lfit%2cw_3840%2ch_2160" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《深入理解Java虚拟机》阅读笔记"/></a><div class="content"><a class="title" href="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="《深入理解Java虚拟机》阅读笔记">《深入理解Java虚拟机》阅读笔记</a><time datetime="2023-10-24T13:40:17.000Z" title="发表于 2023-10-24 21:40:17">2023-10-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="《Java并发编程的艺术》阅读笔记"><img src="https://www.toopic.cn/public/uploads/small/1695101465702169510146570.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Java并发编程的艺术》阅读笔记"/></a><div class="content"><a class="title" href="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="《Java并发编程的艺术》阅读笔记">《Java并发编程的艺术》阅读笔记</a><time datetime="2023-09-20T13:40:17.000Z" title="发表于 2023-09-20 21:40:17">2023-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="数据结构算法笔记"><img src="https://www.toopic.cn/public/uploads/small/1695101465702169510146570.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构算法笔记"/></a><div class="content"><a class="title" href="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="数据结构算法笔记">数据结构算法笔记</a><time datetime="2023-08-29T01:16:55.000Z" title="发表于 2023-08-29 09:16:55">2023-08-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By Inequalities</div><div class="footer_custom_text">如果你真的想蜕变，那就从今天开始！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="鸡,你,太,美,你干嘛~,哎呦~" data-fontsize="15px" data-random="false" async="async"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>