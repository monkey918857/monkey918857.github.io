<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《Java并发编程的艺术》阅读笔记 | Inequalitiesの博客</title><meta name="author" content="Inequalities"><meta name="copyright" content="Inequalities"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="并发编程初探1.Java天生的多线程进程是资源分配的最小单位，线程是CPU调度的最小单位 在Java中仅仅运行一个main函数，在相当于启动了一个JVM进程，而且这个进程有六条线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。  main函数启动后开启的六条线程： [6] Monitor Ctrl-Br">
<meta property="og:type" content="article">
<meta property="og:title" content="《Java并发编程的艺术》阅读笔记">
<meta property="og:url" content="https://monkey918857.github.io/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Inequalitiesの博客">
<meta property="og:description" content="并发编程初探1.Java天生的多线程进程是资源分配的最小单位，线程是CPU调度的最小单位 在Java中仅仅运行一个main函数，在相当于启动了一个JVM进程，而且这个进程有六条线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。  main函数启动后开启的六条线程： [6] Monitor Ctrl-Br">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.toopic.cn/public/uploads/small/1658044853457165804485391.png">
<meta property="article:published_time" content="2023-09-20T13:40:17.000Z">
<meta property="article:modified_time" content="2023-12-10T14:04:51.878Z">
<meta property="article:author" content="Inequalities">
<meta property="article:tag" content="并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.toopic.cn/public/uploads/small/1658044853457165804485391.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://monkey918857.github.io/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《Java并发编程的艺术》阅读笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-10 22:04:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.toopic.cn/public/uploads/small/1658044853457165804485391.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Inequalitiesの博客"><span class="site-name">Inequalitiesの博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《Java并发编程的艺术》阅读笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-20T13:40:17.000Z" title="发表于 2023-09-20 21:40:17">2023-09-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-10T14:04:51.878Z" title="更新于 2023-12-10 22:04:51">2023-12-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">35.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>110分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《Java并发编程的艺术》阅读笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="并发编程初探"><a href="#并发编程初探" class="headerlink" title="并发编程初探"></a>并发编程初探</h3><h4 id="1-Java天生的多线程"><a href="#1-Java天生的多线程" class="headerlink" title="1.Java天生的多线程"></a>1.Java天生的多线程</h4><p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位</strong></p>
<p>在Java中仅仅运行一个main函数，在相当于启动了一个JVM进程，而且这个进程有六条线程，这些线程都拥有各自的<strong>计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量</strong>。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。</p>
<hr>
<p>main函数启动后开启的六条线程：</p>
<p>[6] Monitor Ctrl-Break （跟JVM 关系不大，他是 IDEA 通过反射的方式，开启一个随着我们运行的jvm进程开启与关闭的一个监听线程。）</p>
<p>[5] Attach Listener （附加监听器。 简单来说，他是jdk里边一个工具类提供的<strong>jvm</strong> <strong>进程之间通信</strong>的工具。 cmd – java -version; jvm – jstack、jmap、dump） 进程间的通信。</p>
<p>开启我们这个线程的两个方式： 1. 通过jvm参数开启。-XX: StartAttachListener</p>
<ol start="2">
<li>延迟开启： cmd – java -version –&gt; JVM 适时开启A L 线程</li>
</ol>
<p>[4] Signal Dispatcher （信号分发器。 我们通过cmd 发送jstack，传到了jvm进程，这时候信号分发器就要发挥作用了。）</p>
<p>[3] Finalizer （JVM 垃圾回收相关的内容。此处只做简单的介绍。 1. 只有当开始一轮垃圾收集的时候，才会开始调用finalize方法。 2. daemon prio&#x3D;10 高优先级的守护线程。  3. jvm在垃圾收集的时候，会将失去引用的对象封装到我们的 Fianlizer 对象（Reference）， 放入我们的 F-queue 队列中。由 Finalizer 线程执行inalize方法）</p>
<p>[2] Reference Handler （引用处理的线程。强，软，弱，虚。 -GC 有不同表现 - JVM深入分析）</p>
<p>[1] main 主线程</p>
<hr>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231119213444916.png" class title="image-20231119213444916">

<h4 id="2-线程的优先级和守护线程"><a href="#2-线程的优先级和守护线程" class="headerlink" title="2.线程的优先级和守护线程"></a>2.线程的优先级和守护线程</h4><ul>
<li><p>优先级</p>
<ul>
<li>通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，setPriority(int)这个方法是 jvm 提供的一个方法，并且能够调用 本地方法 setPriority0. 但是设置以后发现没有作用，为什么？ <ul>
<li>1.我们现在的计算机都是多核的，t1，t2 会让哪个cpu处理不好说。由不同的cpu同时提供资源执行。 2.优先级不代表先后顺序。哪怕你的优先级低，也是有可能先拿到我们的cpu时间片的，只不过这个时间片比高优先级的线程的时间片短。 <strong>优先级针对的是 cpu时间片的长短问题。</strong>这个 setPriority方法很少使用，很难控制。实际的运行环境太复杂。</li>
</ul>
</li>
</ul>
</li>
<li><p>守护线程</p>
<ul>
<li><p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这 意味着，<strong>当一个Java虚拟机中不存在非Daemon线程的时候，守护线程也会立即终止(这也是finally块中代码不一定执行的一个原因)，</strong>Java虚拟机将会退出。</p>
</li>
<li><p>可以通过调 用Thread.setDaemon(true)将线程设置为Daemon线程。但是注意设置守护线程的时候一定要在调用thread.start()之前设置，如果线程已经启动了在进行设置会抛出异常</p>
</li>
</ul>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231119220444532.png" class title="image-20231119220444532"></li>
</ul>
<h4 id="3-线程状态转换"><a href="#3-线程状态转换" class="headerlink" title="3.线程状态转换"></a>3.线程状态转换</h4><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231119223427696.png" class title="image-20231119223427696">

<ul>
<li>注意：①上面图中有一个错误，就是红框里面的join方法是Thread的。②BLOCKED状态只针对sync锁。③通过调用join方法导致状态转为WAITING时，也是需要调用notify方法转为RUNNABLE状态，因为join方法底层就是调用了wait方法</li>
</ul>
<h4 id="4-init方法和start方法"><a href="#4-init方法和start方法" class="headerlink" title="4.init方法和start方法"></a>4.init方法和start方法</h4><ul>
<li>init方法<ul>
<li>当使用new关键词进行线程创建的时候，底层调用的是init方法，一个新构造的线程对象是由其parent线程来进行空间分配的，而child线程继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的ThreadLocal，同时还会分配一个唯一的（sync）ID来标识这个child线程(之所以能保证唯一是因为nextThreadID这个方法是被synchronized修饰的)。此时这个线程会被添加到Unstarted线程组，也就是NEW状态，因为还有调用start方法;至此，一个能够运行的线程对象就初始化好了，在堆内存中等待着运行。</li>
</ul>
</li>
<li>start方法<ul>
<li>start方法也是一个被synchronized修饰的方法，这样可以避免多线程同时启动一个线程，start方法底层调用的是用native修饰的start0方法，在start0方法完全执行完成之前，线程处于READY状态，在start0方法完全执行结束以后，线程就处于RUNNING状态，线程start()方法的含义是：当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程。</li>
</ul>
</li>
</ul>
<h4 id="5-sleep方法和wait方法"><a href="#5-sleep方法和wait方法" class="headerlink" title="5.sleep方法和wait方法"></a>5.sleep方法和wait方法</h4><ul>
<li>sleep方法<ul>
<li>是否释放锁？<ul>
<li>不释放</li>
<li>通过源码发现sleep方法是一个native方法，但是可以根据注释**The thread does not lose ownership of any monitors.**，说明他不会释放锁</li>
</ul>
</li>
<li>是否响应中断？<ul>
<li>响应，他会先清除中断标志然后抛出异常，所以调用Thread.isInterrupted()方法的时候会返回false</li>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231121191452253.png" class title="image-20231121191452253"></li>
</ul>
</li>
<li>是否释放CPU<ul>
<li>释放，通过jstack命令可以查看到它没有占用任何CPU</li>
</ul>
</li>
</ul>
</li>
<li>wait方法<ul>
<li>是否释放锁？<ul>
<li>释放</li>
<li>wait方法也是一个native方法，使用上面的方法可以查看到，线程会释放锁</li>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231121192241133.png" class title="image-20231121192241133"></li>
</ul>
</li>
<li>是否响应中断？<ul>
<li>响应</li>
</ul>
</li>
<li>是否释放CPU？<ul>
<li>释放，他会让出CPU时间片，然后进入到等待队列中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-join方法"><a href="#6-join方法" class="headerlink" title="6.join方法"></a>6.join方法</h4><ul>
<li>是否释放锁？<ul>
<li>释放，但是它释放的是当前调用 join方法的那个对象的锁。</li>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231121192631058.png" class title="image-20231121192631058"></li>
</ul>
</li>
<li>是否响应中断？<ul>
<li>响应</li>
</ul>
</li>
<li>是否释放CPU？<ul>
<li>释放，其底层调用的是wait方法</li>
</ul>
</li>
</ul>
<h4 id="7-线程间的通信方式"><a href="#7-线程间的通信方式" class="headerlink" title="7.线程间的通信方式"></a>7.线程间的通信方式</h4><ul>
<li>volitate 、synchronize、lock。（都保证可见性）</li>
<li>wait、notify、await() 、 signal</li>
<li>管道输入&#x2F;输出流和普通的文件输入&#x2F;输出流或者网络输入&#x2F;输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</li>
<li>Thread.join() ： 隐式唤醒。等待其他线程执行完成，其他线程会发送唤醒信号。</li>
<li>ThreadLocal() </li>
<li>线程中断</li>
</ul>
<h4 id="8-ThreadLocal"><a href="#8-ThreadLocal" class="headerlink" title="8.ThreadLocal"></a>8.ThreadLocal</h4><p>ThreadLocal之所以能够实现线程的隔离，主要是依靠线程自身有一个名叫threadLocals的ThreadLocalMap类型的变量，threadLocal底层是使用一个table数组进行数据的存放，存放的时候使用斐波那契散列法把对应不同的threadlocal进行散列，存放的数据是使用threadlocal和要set的值封装成的Entry对象，每次从map中获取信息的时候是通过thradLocal的get方法，当前线程拿到这个map，通过threadLocal散列得到存放的位置，最终得到数据，如果线程一直不终止，那么这个数据会一直存放在threadLocals，<strong>ThreadLocalMap中ThreadLocal是弱引用，</strong></p>
<p>如果在ThreadLocalMap中使用强引用来存储ThreadLocal对象，那么ThreadLocal对象会一直存在于内存中，即使在实际的应用中已经不再需要该ThreadLocal对象。这是因为ThreadLocalMap是与线程相关联的，保存在ThreadLocalMap的table数组中，ThreadLocalMap中的键值对不会被自动清理，而是会一直保留，从而造成内存泄漏。也就是说ThreadLocal永远不会被清理，除非手动清理，ThreadLocalMap调用set(),get()，remove()方法的时候会被清除value值。</p>
<p>为了解决这个问题，ThreadLocal存放的Entry对象被设计为弱引用。<strong>弱引用的特点是，当一个对象只被弱引用所引用时，在垃圾回收时会被自动回收。当ThreadLocal对象被垃圾回收时，对应的键值对也会被自动从ThreadLocalMap中移除。但是我们set的value是强引用的，当一个线程长时间运行，有可能不会及时清理导致内存泄漏，为了避免泄漏问题应做手动清理的动作</strong></p>
<h3 id="synchronized-全解读"><a href="#synchronized-全解读" class="headerlink" title="synchronized 全解读"></a>synchronized 全解读</h3><h4 id="1-Synchronized的使用方法"><a href="#1-Synchronized的使用方法" class="headerlink" title="1.Synchronized的使用方法"></a>1.Synchronized的使用方法</h4><ul>
<li><p>synchonized关键字的三种使用方式</p>
<ul>
<li>用在同步代码块上，此时锁是括号里面配置的对象</li>
<li>用在普通方法上，此时锁是当前调用该方法的实例对象</li>
<li>用在静态方法上，此时锁是当前类的Class对象</li>
</ul>
<p>当一个线程试图访问同步代码块的时候，必须要先获取到锁，在退出或者出现异常的时候必须释放锁</p>
</li>
<li><p>synchonized在JVM的实现原理</p>
<ul>
<li>JVM是基于进入和退出Monitor对象来实现同步方法和同步代码块，二者的实现细节略有不同<ul>
<li>对于同步代码块来说，在编译后会在进入同步代码块之前会加一个monitorenter指令，在同步代码块结束退出或者发生异常的地方monitorexit指令，任何一个对象都有一个monitor与之关联，当monitor被持有后将处于锁定状态，线程执行到monitorenter的时候会尝试获取对应monitor的所有权，即尝试获取对象的锁</li>
<li>对于同步方法和静态方法来说，通过反编译得到字节码后可以发现，在方法的flags中多了一个ACC_SYNCHONIZED标志，这会告诉JVM这是一个同步方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-Synchronized的特性"><a href="#2-Synchronized的特性" class="headerlink" title="2.Synchronized的特性"></a>2.Synchronized的特性</h4><ol>
<li>有序性 （读读、读写、写读、写写 互斥）</li>
<li>可见性 （可见性是指多个线程访问⼀个资源时，该资源的状态、值信息等对于其他线程都是可见的。 synchronized和volatile都具有可见性，其中synchronized对⼀个类或对象加锁时，⼀个线程如果要访问该类或对象必须先获得它的锁，⽽这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到共享内存当中，保证资源变量的可见性。）</li>
<li>原子性 (本质上是线程互斥保证的原子性)</li>
<li>可重入性 （一个线程获取到某个锁以后，再次请求该对象的锁的时候，还可以获取到执行权）</li>
</ol>
<h4 id="3-Synchronized锁–偏向锁"><a href="#3-Synchronized锁–偏向锁" class="headerlink" title="3.Synchronized锁–偏向锁"></a>3.Synchronized锁–偏向锁</h4><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231122222424235.png" class title="image-20231122222424235">

<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231122222444063.png" class title="image-20231122222444063">

<ul>
<li>偏向锁使用的前提<ul>
<li>在jdk1.6版本以后，并且开启了使用偏向锁这一配置，但是它默认情况下是延迟开启的，可以通过-     XX:BiasedLockingStartupDelay&#x3D;0这个配置关闭延迟，如果我们关闭了延迟开启这一配置，那么<strong>锁对象在创建出来的时候markword的状态就是偏向锁对应的状态</strong>，只不过现在没有任何的线程竞争，此时就是一个没有偏向任何线程的偏向锁</li>
<li>锁对象在被获取之前没有显式&#x2F;隐式的调用hashCode方法(隐式调用比如说以这个锁对象作为hashmap的key进行保存)，如果调用了hashcode方法，由于我们偏向锁的markword中没有地方存储这个hashcode，所以此时就会升级为轻量级锁</li>
</ul>
</li>
</ul>
<p>为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在<strong>锁的对象头中存储线程id并在线程的栈帧中的锁记录里(线程有自己的栈帧，LOCK RECORD) 存储当前线程id</strong>,存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里存储的id和线程栈帧里面锁记录的id是否匹配，如果匹配，表示线程已经获得了锁。如果不匹配，则需要再测试一下锁对象的Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程： 其实是cas竞争替换 线程id。</p>
<h4 id="4-偏向锁撤销"><a href="#4-偏向锁撤销" class="headerlink" title="4.偏向锁撤销"></a>4.偏向锁撤销</h4><p><em><strong>面试过程中，如果聊到偏向锁的撤销可以先通过一句简短的话来描述一下，然后通过面试官后续的发问逐步展开，即偏向锁使用了一种当出现线程竞争才撤销偏向锁的机制，一旦出现竞争偏向锁就会升级为轻量级锁</strong></em></p>
<ul>
<li>在竞争偏向锁的时候会出现以下可能性<ol>
<li>A线程获取偏向锁，并且A线程死亡退出。B线程争抢偏向锁，会直接升级当前对象的锁为轻量级锁。<strong>这只是针对我们争抢了一次。</strong></li>
<li>A线程获取偏向锁，并且A线程没有释放偏向锁，还在sync的代码块里边。B线程此时过来争抢偏向锁，会直接升级为重量级锁。</li>
<li>A线程获取偏向锁，并且A线程释放了锁，但是A线程并没有死亡还在活跃状态。此时锁处于无锁状态，B线程过来争抢，会直接升级为轻量级锁。</li>
<li>A线程获取偏向锁，并且A线程没有释放偏向锁，还在sync的代码块里边。B线程多次争抢锁，会在加锁过程中采用重量级锁；但是，一旦锁被释放，当前对象还是会以轻量级锁的初始状态执行。但是这里不能称之为锁降级，因为锁升级是在线程运行过程中和争抢过程中的一种升级。而现在是线程已经释放了锁，然后又重新获取锁的情况，不属于线程运行中。</li>
<li>A线程获取偏向锁，并且A线程释放了锁，但是A线程并没有死亡还在活跃状态。B线程过来争抢。部分争抢会升级为轻量级锁；部分争抢会依旧保持偏向锁。</li>
</ol>
</li>
</ul>
<p>所以，偏向锁的撤销过程很复杂，即使是锁升级的官方文档中对这一部分也没有特别细致的说明，所以面试过程中不要较真</p>
<p>以下面试过程中推荐说的：</p>
<p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态(<strong>如上述情况1</strong>)；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向的线程对象的栈帧中的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程(<strong>如上述情况5</strong>)，要么恢复到无锁(<strong>如上述情况3</strong>)或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。 </p>
<ul>
<li>偏向锁的批量重偏向和批量撤销<ul>
<li>批量重偏向，一个已经偏向A线程Object类型的对象，在经过另外B线程争抢超过二十次的情况下，该类所创建出来的其他对象会直接重新偏向于B线程，此时jvm认为这个对象更适合偏向于B线程(20这个数字不是一定的，<strong>不同机器环境参数配置不一样</strong>)</li>
<li>批量撤销，如果基于批量重偏向的基础上，还在继续进行争抢达到40次，并且有第三条线程C也来争抢这个对象锁，这个时候会触发批量撤销。JVM会标记该对象不能使用偏向锁，以后新创建的对象，直接以轻量级锁开始。 这个时候，才是真正的完成了锁升级。</li>
</ul>
</li>
</ul>
<p><strong>注意，真正的锁升级，是依赖于 class 的，而并不是依赖于 某一个 new出来的对象（这句话适用于偏向锁升级为轻量级锁），这里更加可以说明锁可以升级，而不能降级，也就是说上面出现的线程争抢锁过程中升级的锁，在使用new关键字对该类进行重新创建的时候还是偏向锁这一现象不能称之为锁降级</strong></p>
<h4 id="5-轻量级锁的加锁和解锁"><a href="#5-轻量级锁的加锁和解锁" class="headerlink" title="5.轻量级锁的加锁和解锁"></a>5.轻量级锁的加锁和解锁</h4><ul>
<li>轻量级锁加锁</li>
</ul>
<p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间（Lock Record记录），并将对象头中的Mark Word（前30位 （25位的hashcode，4位的分代年龄，1位是否为偏向锁））复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针（指向线程栈帧里边的Lock Record的指针）。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用<strong>自旋</strong>来获取锁。</p>
<ul>
<li>轻量级锁解锁</li>
</ul>
<p>轻量级锁解锁时，会使用原子的CAS操作将Displaced Mark Word（Lock Record记录）替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p>
<p><strong>注意，这里真正的锁升级依赖的是对象，对象升级为重量级锁，而对象对应的类再new一个的新对象锁，这时还是从轻量级锁开始(这句话适用于轻量级锁升级为重量级锁)</strong></p>
<h4 id="6-轻量级锁膨胀流程"><a href="#6-轻量级锁膨胀流程" class="headerlink" title="6.轻量级锁膨胀流程"></a>6.轻量级锁膨胀流程</h4><p>线程A在获取到锁以后，线程B也想要获得这个锁，通过CAS进行markword和指针的替换，如果替换失败，会自旋尝试十次，如果线程A一直没有释放锁那么十次自旋也失败，进入膨胀流程，此时线程B会用一个临时的指针指向重量级锁，当线程A执行完代码进行解锁的时候，发现有竞争要升级锁，线程A即会做以下五步：</p>
<ol>
<li><p>线程A 初始化monitor 对象；</p>
</li>
<li><p>将状态设置为膨胀中（inflating）；</p>
</li>
<li><p>将monitor里边的header属性，set称为对象的markword；（即将自己lock record里边的存放的mark word的hashcode，分代年龄，是否为偏向锁 set 到 objectmonitor对象的header属性里）</p>
</li>
<li><p>设置对象头为重量级锁状态（标记为改为00）；然后将前30位指向第1步他初始化的monitor 对象；（<strong>真正的锁升级是由线程A操控的</strong>）</p>
</li>
<li><p>唤醒线程B；</p>
</li>
</ol>
<p>线程B开始争抢重量级锁。（线程B就干了一件事儿，就是弄了一个临时的重量级锁指针吧？还不是最后的重量级锁指针。因为最后的重量级锁指针是线程A初始化的并且是线程A修改的。 而且，线程B被唤醒之后，还不一定能够抢到这个重量级锁。Sync是非公平锁。 线程B费力不讨好，但是线程B做了一件伟大的事情：他是锁升级的奠基者。）</p>
<h4 id="7-锁升级过程中markword的转移流程"><a href="#7-锁升级过程中markword的转移流程" class="headerlink" title="7.锁升级过程中markword的转移流程"></a>7.锁升级过程中markword的转移流程</h4><p>创建一个对象，此时对象里边没有hashcode，所以该对象可以使用我们的偏向锁，偏向锁不会考虑hashcode，</p>
<p>他会直接将自己的线程id放到我们的markword里边，不需要考虑后续的替换问题。 所以呢，一旦我们的对象主动调用了Object的hashcode方法，我们的偏向锁就自动不可用了。</p>
<p>如果我们的对象有了hashcode和分代年龄和是否为偏向锁（30位）。在轻量级锁的状态下，这30位会被复制到我们的轻量级锁线程持有者的栈帧里的lock record里边记录。与此同时，我们的对象的markword里边存放的是我们的指向轻量级锁线程持有者的栈帧的lock recod里的指针。如果一直存在轻量级锁竞争，在未发生锁膨胀的前提下，一直会保持轻量级锁，A线程释放的时候，会将markword替换回对象的markword里边，B线程下次再从新走一遍displace mark word；</p>
<p>一旦发生了轻量级膨胀为重量级锁。前提，A线程持有锁；B线程争抢。</p>
<p>B线程将marikword里边A线程的指针替换成一个临时的（过度的）重量级锁指针，为了让A线程在cas往回替换markword的时候失败。</p>
<p>A线程替换回markword失败后，会发起：1.初始化monitor对象；2. 将状态设置为膨胀中；3 将替换失败的 markword放到objectmonitro的head属性里； 4。改变markword的锁标志为10；将markword里的 30 位设置为指向自己第一步初始化的那个monitor对象；5唤醒B线程； 6以后这个对象只能作为重量级锁；</p>
<p>Markword从未丢失。</p>
<h4 id="8-死锁的避免方式"><a href="#8-死锁的避免方式" class="headerlink" title="8.死锁的避免方式"></a>8.死锁的避免方式</h4><p>概念：死锁是指两个或两个以上的线程在执行过程中，由于竞争资源而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p>
<p>避免死锁的几个常见方法：</p>
<ol>
<li><p>避免一个线程同时获取多个锁。</p>
</li>
<li><p>尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。</p>
</li>
<li><p>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</p>
</li>
</ol>
<h4 id="9-ObjectMonitor的属性"><a href="#9-ObjectMonitor的属性" class="headerlink" title="9.ObjectMonitor的属性"></a>9.<strong>ObjectMonitor</strong>的属性</h4><ol>
<li><p>header ： 重量级锁保存markword的地方；对象的markword里边也保存了指向monitor的指针；</p>
</li>
<li><p>own: 指向我们持有锁的线程；</p>
</li>
<li><p>_cxq 队列： 竞争队列。 A线程持有锁没有释放； B和C线程同时过来争抢锁，都被block了，此时会将B和C线程加入到 该队列。</p>
</li>
<li><p>EntryList队列：同步队列。A线程释放锁，B和C线程中会选定一个继承者（可以去争抢锁的这个线程），另外一个线程会被放入我们的EntryList队列里边。 </p>
</li>
<li><p>waitset：等待队列。Object wait的线程。</p>
</li>
</ol>
<ul>
<li>这个地方为什么要使用cxq和EntryList两个数据结构来存储被阻塞的线程<ul>
<li>这里主要是为了避免ABA问题，对于ABA问题的其中一个解决方式就是通过保证对一个数据结构只能执行相同的操作，在竞争失败后会进入cxq队列(<strong>这个队列只能新增线程，不能删除</strong>)，<strong>持锁线程</strong>释放锁时会唤醒阻塞在cxq队列里面的线程，并将其移动到EntryList队列，notify线程被唤醒的时候，<strong>持锁线程</strong>会把waitset的头节点放到cxq或EntryList的栈顶，从这个地方可以看出加锁失败的线程会往cxq中进行添加，所以会存在竞争，所以我们<strong>限制了cxq只能使用新增操作来避免ABA问题</strong>，而EntryList只能由持锁线程进行操作，所以不存在竞争不会出现ABA问题</li>
</ul>
</li>
</ul>
<p>A线程持有锁，BC线程过来竞争失败，进入cxq – 下轮竞争会把 cxq里的线程移动到EntrylIst中。假设B线程竞争到了锁，然后B线程调用了 Object.Wait方法，这时候B线程进入waitset，并释放锁。C线程拿到了锁，然后唤醒B线程。B线程会从waitset里边出来，直接竞争锁。如果竞争失败进入cxq，继续轮回，如果竞争成功，ok了。</p>
<h4 id="10-CPU的用户态与内核态"><a href="#10-CPU的用户态与内核态" class="headerlink" title="10.CPU的用户态与内核态"></a>10.CPU的用户态与内核态</h4><ul>
<li>内核态：</li>
</ul>
<ol>
<li><p>系统中既有操作系统的程序，也有普通用户程序。为了安全性和稳定性，操作系统的程序不能随便访问，这就是内核态。即需要执行操作系统的程序就必须转换到内核态才能执行！</p>
</li>
<li><p>内核态可以使用计算机所有的硬件资源！</p>
</li>
</ol>
<ul>
<li><p>用户态：不能直接使用系统资源，也不能改变 CPU 的工作状态，并且只能访问这个用户程序自己的存储空间！</p>
</li>
<li><p>用户态与内核态转换的条件</p>
<ul>
<li>用户态进程要使用操作系统资源主动申请状态转换</li>
<li>CPU出现没有预知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常。</li>
</ul>
</li>
</ul>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><h4 id="1-Java内存模型基础"><a href="#1-Java内存模型基础" class="headerlink" title="1. Java内存模型基础"></a>1. Java内存模型基础</h4><p>Java线程之间的通信由Java内存模型控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在<strong>主存</strong>中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读&#x2F;写共享变量的副本。</p>
<h4 id="2-指令重排序"><a href="#2-指令重排序" class="headerlink" title="2.指令重排序"></a>2.指令重排序</h4><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。</p>
<ol>
<li><p><strong>编译器优化的重排序</strong>。编译器在不改变<strong>单线程程序语义</strong>的前提下，可以重新安排语句的执行顺序。</p>
</li>
<li><p><strong>指令级并行的重排序</strong>。现代处理器采用了指令级并行技术来将多条指令<strong>重叠</strong>执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p>
</li>
<li><p><strong>内存系统的重排序</strong>。由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p>
</li>
</ol>
<p>举个例子解释上面三种重排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br></pre></td></tr></table></figure>

<p>例如上面三行代码，其中第一行和第二行在单线程的情况下，即使发生指令顺序的改变，但是也不会改变其语意，所以在编译阶段，编译器就可以对其进行重排序，这就是编译器优化的重排序；同时第一行和第二行不存在数据依赖性，所以在并行执行的时候，可以改变执行顺序，甚至两条指令重叠执行，这也可以提高程序执行效率，这就是指令集并行重排序；由于处理器是使用内存的，所以需要对数据进行加载(i load)和存储(i store)，在保证程序执行结果正确的前提下，这两个操作的顺序也可以被改变，这就是内存系统重排序</p>
<p>JMM的处理器重排序规则会要求 <strong>Java编译器在生成指令序列时，插入特定类型的内存屏障指令</strong>，通过内存屏障指令来禁止特定类型的处理器重排序。</p>
<h4 id="3-内存屏障"><a href="#3-内存屏障" class="headerlink" title="3.内存屏障"></a>3.内存屏障</h4><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231126212750679.png" class title="image-20231126212750679">

<h4 id="4-as-if-serial语义和Happen-Before原则"><a href="#4-as-if-serial语义和Happen-Before原则" class="headerlink" title="4.as-if-serial语义和Happen-Before原则"></a>4.<strong>as-if-serial语义</strong>和<strong>Happen-Before</strong>原则</h4><p>as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（<strong>单线程</strong>）程序的执行结果不能被改变。</p>
<p><strong>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。</strong>但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p>
<p><strong>happens-before关系本质上和as-if-serial语义是一回事。</strong></p>
<p><strong>as-if-serial语义保证单线程</strong>内程序的执行结果不被改变，<strong>happens-before关系保证正确同步的多线程</strong>程序的执行结果不被改变。</p>
<p>as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。</p>
<p><strong>as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度</strong>。</p>
<h4 id="5-锁的内存语义"><a href="#5-锁的内存语义" class="headerlink" title="5.锁的内存语义"></a>5.锁的内存语义</h4><p>线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（<strong>线程A对共享变量进行修改</strong>）消息。</p>
<p>线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（<strong>在释放这个锁之前对共享变量所做修改的</strong>）消息。</p>
<p>线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过<strong>主存</strong>向线程B发送消息。（<strong>隐式通信</strong>）</p>
<h3 id="volatile全解读"><a href="#volatile全解读" class="headerlink" title="volatile全解读"></a>volatile全解读</h3><h4 id="1-volatile定义"><a href="#1-volatile定义" class="headerlink" title="1.volatile定义"></a>1.volatile定义</h4><p>Java语言规范第3版中对volatile的定义如下：Java编程语言允许线程访问共享变量，<strong>为了确保共享变量能被准确和一致地更新</strong>，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁要更加方便（读多写少）。<strong>如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。</strong></p>
<p>volatile主要做的三件事：1. 保证可见性 2. 禁止指令重排序 3. 双重检查锁</p>
<h4 id="2-volatile可见性"><a href="#2-volatile可见性" class="headerlink" title="2.volatile可见性"></a>2.volatile可见性</h4><p>在修改volatile修饰的变量时，Java转变成的<strong>汇编代码会多加一个lock前缀指令</strong>(这一步叫做声言lock信号)，lock前缀指令在多核处理器的条件下会引发两件事，1. 将当前处理器缓存行的数据过总线写回主存。2. 使在其他CPU里缓存了该内存地址的数据无效。</p>
<p>声言lock信号的期间，系统内存只有当前处理器可以访问也就是说锁总线，但是锁总线的开销太大了，所以最近的处理器如果发现要访问的数据缓存到了处理器内部，这时不会声言lock信号，而是锁定这块内存区域的缓存并回写到内存，并使用缓存一致性协议机制确保修改的原子性。(缓存一致性协议会阻止由多个处理器同时缓存的数据同时被修改)。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。如果通过嗅探一个处理器来检测其他处理器打算修改的内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行(缓存行是缓存可以分配的最小单位，所以缓存行中不一定只有这一条被修改的数据)无效，在下次访问相同内存地址时，强制执行缓存行填充(即从系统内存中重新读取最新数据)。</p>
<h4 id="3-volatile的使用优化"><a href="#3-volatile的使用优化" class="headerlink" title="3. volatile的使用优化"></a>3. volatile的使用优化</h4><p>先说问题：问题在于一个使用volatile修饰的队列，如果该队列的头尾节点都不足64位，那么他们就会被缓存到同一个缓存行，这时如果是多核处理器都对该数据进行了缓存，那么在缓存一致性的机制下，当一个处理器对头&#x2F;尾节点的修改会导致其他处理器不能访问这个队列的尾&#x2F;头节点，由于队列的入队和出队操作会频繁的修改头尾节点，这样会严重影响性能。</p>
<p>优化方法是基于缓存行是64位的处理器，处理器的高速缓存行一旦对数据进行缓存，那么就不支持进行部分填充，LinkedTransferQueue这个队列集合则使用追加字节的方式优化入队和出队的性能，它使用一个内部类类型来定义队列的头节点（head）和尾节点（tail），而这个内部类PaddedAtomicReference就是将共享变量追加到64字节。一个对象的引用占4个字节，它追加了15个变量（共占60个字节），再加上父类的value变量，一共64个字节。这样就能保证队列的首尾节点不在同一个缓存行中，</p>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231130220926320.png" class title="image-20231130220926320">

<h4 id="4-volatile禁止指令重排序"><a href="#4-volatile禁止指令重排序" class="headerlink" title="4. volatile禁止指令重排序"></a>4. volatile禁止指令重排序</h4><p>Ø·在每个volatile<strong>写操作的前面</strong>插入一个<strong>StoreStore</strong>屏障，防止前面的写操作与当前的volatile写操作发生指令重排序。</p>
<p>Ø·在每个volatile<strong>写操作的后面</strong>插入一个<strong>StoreLoad</strong>屏障，防止当前的volatile写操作和后面的读操作发生指令重排序。</p>
<p>Ø·在每个<strong>volatile读操作的</strong>后面插入一个<strong>LoadLoad</strong>屏障。</p>
<p>Ø·在每个<strong>volatile读操作的</strong>后面插入一个<strong>LoadStore</strong>屏障。</p>
<ul>
<li>为什么volatile读前面没有屏障？<ul>
<li>JMM原本是在每个volatile写的后面，或者在每个volatile读的前面都插入一个StoreLoad屏障。从整体执行效率的角度考虑，JMM最终选择了只在每个volatile写的后面插入一个StoreLoad屏障。因为volatile写-读内存语义的常见使用模式是：一个写线程写volatile变量，多个读线程读同一个volatile变量。<strong>当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。</strong>因此可以看出JMM是<strong>先保证正确性然后才考虑的性能。</strong></li>
</ul>
</li>
</ul>
<p>由于JMM是<strong>先保证正确性然后才考虑的性能。</strong>所以在真正代码执行屏障插入的时候，编译器可以根据实际情况省略某些屏障！！</p>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231130223957979.png" class title="image-20231130223957979">

<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231130224007219.png" class title="image-20231130224007219">

<ul>
<li>为什么volatile写和普通写不能重排序？<ul>
<li>因为可能会引发以下问题<ul>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231130225009541.png" class title="image-20231130225009541"></li>
<li>当1和2之间没有数据依赖关系时，1和2之间就可能被重排序（3和4类似）。其结果就是：读线程B执行4时，不一定能看到写线程A在执行1时对共享变量的修改。</li>
</ul>
</li>
<li>所以在新的内存模型中进行了volatile的语意增强<ul>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231130225208019.png" class title="image-20231130225208019"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-双重检查锁存在的问题"><a href="#5-双重检查锁存在的问题" class="headerlink" title="5.  双重检查锁存在的问题"></a>5.  双重检查锁存在的问题</h4><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231201164120235.png" class title="image-20231201164120235">

<p>问题出现在第七行，因为创建对象的过程分为三个步骤，分别是1. 为创建的对象开辟一片内存空间 2. 对象的初始化 3. 把初始化好的对象指向开辟好的内存空间，这三步如果发生指令的重排序，比如第二行和第三行进行重排序，就会出现以下问题：</p>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231201164510079.png" class title="image-20231201164510079">

<p>指令交换后，当其他线程发现instance不为空了，但是return回去对象可能还没有初始化</p>
<h4 id="6-基于volatile的解决方案"><a href="#6-基于volatile的解决方案" class="headerlink" title="6.基于volatile的解决方案"></a>6.基于volatile的解决方案</h4><p>在instance对象上加一个volatile修饰即可解决。</p>
<p>原理(大众式理解)：volatile禁止了 new 对象里边三行代码的重排序，所以初始化对象的操作一定在指向内存地址这一操作之前，所以不会发生问题。</p>
<p>个人理解：这个地方new instance对应的JVM指令也是new，所以这个地方可以看成一个volatile写，所以会在new这个操作前加一个storestore屏障，操作之后加一个storeload屏障，这时其他线程想要读取这个变量必须在storeload屏障以后进行读取，也就是说只有当new操作全部执行完时候才能读取，从而解决以上问题，但是new对象过程中的三个步骤还是有可能发生重排序</p>
<h4 id="7-基于类初始化的解决方案"><a href="#7-基于类初始化的解决方案" class="headerlink" title="7.基于类初始化的解决方案"></a>7.基于类初始化的解决方案</h4><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231201170222111.png" class title="image-20231201170222111">

<p>JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。<strong>在执行类的初始化期间，JVM会去获取一个锁。</strong>这个锁可以防止多个线程对同一个类的初始化。锁可以保证原子性可见性，所以在一个线程完成类的初始化之前，其他线程看不见这个类</p>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231201170333032.png" class title="image-20231201170333032">

<h3 id="Lock全解读"><a href="#Lock全解读" class="headerlink" title="Lock全解读"></a>Lock全解读</h3><h4 id="1-Lock锁的由来及API"><a href="#1-Lock锁的由来及API" class="headerlink" title="1. Lock锁的由来及API"></a>1. Lock锁的由来及API</h4><p>Lock锁放弃了隐式获取和释放锁的便捷性，但是却拥有了<strong>锁获取与释放的可操作性、可中断的获取锁以及超时获取锁</strong>等多种synchronized关键字所不具备的同步特性</p>
<ul>
<li>特性</li>
</ul>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231204214927802.png" class title="image-20231204214927802">

<ul>
<li>API</li>
</ul>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231204215022959.png" class title="image-20231204215022959">

<h4 id="2-队列同步器AQS"><a href="#2-队列同步器AQS" class="headerlink" title="2.队列同步器AQS"></a>2.队列同步器AQS</h4><p>队列同步器AQS是用来构建锁和其他同步组件的基础框架，他提供了一个int类型变量来获取锁的状态，通过维护一个先进先出的双端队列管理来竞争的线程，同步器重写以下方法，然后调用同步器提供的模板方法，模板方法中会调用自己重写的方法，最终是实现自定义锁</p>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231204221226033.png" class title="image-20231204221226033">

<p>当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。在线程获取锁失败，加入同步队列尾端的时候需要保证线程安全，使用CAS提供当前线程认为的头节点和尾节点进行判断，看看现在是否能加入尾节点***(设置尾节点需要使用CAS的原因)***。</p>
<p><strong>设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，</strong>因此设置头节点的方法并不需要使用CAS来保证，它只需要将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可***(设置头节点不需要CAS的原因)***。</p>
<h4 id="3-ReentrantLock-非公平-的lock方法"><a href="#3-ReentrantLock-非公平-的lock方法" class="headerlink" title="3.ReentrantLock(非公平)的lock方法"></a>3.ReentrantLock(非公平)的lock方法</h4><p>调用lock方法后，会先后执行AQS中的以下方法</p>
<ul>
<li>compareAndSetState</li>
<li>acquire</li>
<li>addWaiter</li>
<li>enq</li>
<li>acquireQueued</li>
<li>shouldParkAfterFailedAcquire</li>
<li>parkAndCheckInterrupt</li>
<li>cancelAcquire</li>
</ul>
<p>acquire 方法是 aqs提供的模板方法，是为了进行锁的获取；tryAcquire 方法是aqs提供的可以复写的方法，主要是完成了加锁状态变化的逻辑（state）；addWaiter将我们的获取失败的线程放到我们的同步队列里；enq 如果addwaiter第一次没有成功，就进行死循环添加；acquireQueued：这部分其实是通过<strong>循环的自我检查</strong>，如果当前节点的pred节点是头节点，那么就尝试获取锁；如果不是头节点，就调用 shouldParkAfterFailedAcquire 方法，判断pred节点是否为 SIGNAL 状态，如果是signal状态，自己就好好的等着；如果是 cancel状态，就移除cancel的节点。其他状态的节点，会通过cas操作替换为 SIGNAL状态。parkAndCheckInterrupt方法是为了清除中断标志把当前线程挂起。在循环自我检查的过程中发现任何异常，这时会调用finally块中的cancelAcquire方法，把出现异常的线程状态设置为Cancelled </p>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231205160117700.png" class title="image-20231205160117700">

<p>两个比较重要的状态：</p>
<ol>
<li>SIGNAL：等待被通知状态，如果pre节点是这个状态，那么当前节点就会进行park操作</li>
<li>Cancelled ： 一个取消的线程状态。这个状态的线程会被移除</li>
</ol>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231205162740351.png" class title="image-20231205162740351">

<h4 id="4-ReentrantLock的tryLock方法"><a href="#4-ReentrantLock的tryLock方法" class="headerlink" title="4.ReentrantLock的tryLock方法"></a>4.ReentrantLock的tryLock方法</h4><ul>
<li>不含参数<ul>
<li>表示一次性获取锁，获取成功了就成功了，获取失败了就失败了，不会进行重试</li>
</ul>
</li>
<li>含参数<ul>
<li>含有一个时间参数，表示可以在获取锁失败以后，在规定的时间内进行重试，循环获取锁，循环获取锁的逻辑和lock方法一样，都是先把线程封装成一个Node节点，然后判断自己前节点是不是头节点，如果是头节点则开始尝试获取锁</li>
<li>含参数的这个方法是支持中断的</li>
</ul>
</li>
</ul>
<h4 id="5-ReentrantLock的lockInterruptibly方法"><a href="#5-ReentrantLock的lockInterruptibly方法" class="headerlink" title="5.ReentrantLock的lockInterruptibly方法"></a>5.ReentrantLock的lockInterruptibly方法</h4><ul>
<li>lockInterruptibly方法，是一个支持中断的加锁方式。他与 lock.tryLock(1,null) 这个有什么区别？<br>相同点：都支持中断<br>不同点： lockInterruptibly方法仅仅支持中断；不支持超时。lock.tryLock(1,null)即支持超时，也支持超时内的时间中断</li>
</ul>
<h4 id="6-ReentrantLock的isHeldByCurrentThread方法"><a href="#6-ReentrantLock的isHeldByCurrentThread方法" class="headerlink" title="6.ReentrantLock的isHeldByCurrentThread方法"></a>6.ReentrantLock的isHeldByCurrentThread方法</h4><p>直接判断getExclusiveOwnerThread() &#x3D;&#x3D; Thread.currentThread()直接返回锁的持有线程是不是当前线程</p>
<h4 id="7-ReentrantLock的unlock方法"><a href="#7-ReentrantLock的unlock方法" class="headerlink" title="7.ReentrantLock的unlock方法"></a>7.ReentrantLock的unlock方法</h4><p>调用了unlock方法以后，会直接调用AQS的release方法，这也是一个模板方法，会直接调用到ReentrantLock复写的tryRelease方法，还是对state的值进行修改，只有当state的值被修改为0的时候，才会把当前锁的线程置为null，只有线程释放了锁，才会通知后继节点对锁进行争抢，通知的方式是先把线程自己的状态置为0，然后判断当前节点的后继节点状态是不是1，如果是1或者线程为空说明线程等待超时，或者被中断，这时会从后向前遍历整个同步队列，找到队列中第一个可以对锁进行争抢的节点，使用unpark方法对锁进行唤醒</p>
<h4 id="8-ReentrantLock-公平"><a href="#8-ReentrantLock-公平" class="headerlink" title="8.ReentrantLock(公平)"></a>8.ReentrantLock(公平)</h4><ol>
<li><p>synchronized 他是一个非公平锁。</p>
</li>
<li><p>Lock分为非公平锁（默认） 还有公平锁。</p>
<ul>
<li>非公平锁： 当我们的线程在同步队列里排队完成之后，获取锁的时候，这个时间点上如果有其他新的线程来竞争锁，那么我当前的排队的锁可能会被插队（当前线程可能竞争不过新来的线程，导致自己竞争锁失败。）这是不公平的，我（当前线程） 已经在同步队列里排了好长时间了，你这新来的线程直接抢走了。</li>
<li>公平锁：获取锁的时候，这个时间点上如果有其他新的线程来竞争锁，那么新的线程会直接加入到同步队列里（使用CAS放入队列的尾端）。</li>
</ul>
</li>
<li><p>性能比较：肯定是非公平锁性能更高。（所有新来的线程都要同步队列里，都要进行我们源码中的一系列的操作，公平锁会有更多的上下文切换）</p>
</li>
<li><p>非公平锁容易造成线程饥饿。（<strong>会被插队，极限情况考虑，如果一直被插队，同步队列里的其他线程就一直等着</strong>）</p>
</li>
<li><p>很多情况我们在进行实战开发的时候，如果要限定我们的线程的访问先后顺序，就要使用公平锁了。</p>
</li>
</ol>
<ul>
<li>公平锁的实现主要执行tryAcquire方法的时候，在线程使用CAS对state变量进行修改的时候，多了一个hasQueuedPredecessors方法的判断条件，就是判断当前这个要获取锁的线程是不是在队列中，如果不在队列中直接进入队列的tail等待</li>
</ul>
<h4 id="9-ReentrantReadWriteLock原理"><a href="#9-ReentrantReadWriteLock原理" class="headerlink" title="9.ReentrantReadWriteLock原理"></a>9.<strong>ReentrantReadWriteLock</strong>原理</h4><p>读线程获取读锁，写线程获取写锁，所以支持多个线程同时读，但是对于读写和写写依然是排他的，一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。</p>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231205224745413.png" class title="image-20231205224745413">

<p><strong>注意：上面的锁降级的意思是，读锁和写锁相互可以相互转换，而不是synchronized中的那个锁降级</strong></p>
<ul>
<li><p>ReentrantReadWriteLock也是维护了一个FIFO队列实现线程同步，也是维护了一个int类型的state变量，表示获取锁的次数，那么一个int变量是如何对读写两种锁进行统计的呢？</p>
<ul>
<li>在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写</li>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231205225236301.png" class title="image-20231205225236301"></li>
</ul>
</li>
<li><p>写锁的获取</p>
<ul>
<li>通过lock.writeLock().lock()的方式进行锁的获取，然后依然是调用AQS提供的模板方法acquire，acquire调用ReentrantReadWriteLock复写的tryAcquire方法，进入加锁逻辑，先获取到读写锁当前的状态，然后把这个状态和1 &lt;&lt; 16 - 1进行&amp;操作，得到的就是写锁的状态，然后进行判断<ul>
<li>如果读写锁的状态不为0，但是写锁的状态为0，说明此时有线程正在读，所以return false</li>
<li>如果读写锁的状态不为0，写锁的状态也不为0，这时要判断写锁的线程主人是否是当前线程，如果不是当前线程，仍然return false</li>
<li>如果读写锁的状态不为0，同时写锁的状态也不同于以上两种情况，说明此时是写锁的重入，这时在可重入范围(0 — 1 &lt;&lt; 16 - 1)以内都可以进行加锁</li>
<li>如果读写锁的状态为0，那就好办了，说明此时还没有任何线程获取到锁，只需要看当前这个线程是否是公平的，如果是非公平的直接加锁，如果是公平的那么只有在队列中的线程才可以加锁</li>
</ul>
</li>
</ul>
</li>
<li><p>读锁的获取</p>
<ul>
<li>通过lock.readLock().lock()的方式进行锁的获取，然后调用的是AQS中提供的acquireShared这个模板方法，然后模板方法调用ReentrantReadWriteLock复写的tryAcquireShared方法，进入获取锁的逻辑，先判断写锁有没有被获取，如果写锁被获取，且获取写锁的线程还不是自己，那么就直接获取读锁失败，如果写锁没有被获取，或者获取写锁的线程就是当前线程，那么就获取读锁，并且读状态加一(加的是 1 &lt;&lt; 16)</li>
<li>读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在ThreadLocal中（A 和 B 线程获取读锁，A线程重入了3次, B线程只有1次，那么对于我们读锁的读状态&#x3D; 3+1 &#x3D; 4；<strong>A线程的ThreadLoca保存了 3，B线程的ThreadLocal保存了1</strong>）<strong>，</strong>由线程自身维护，所以在释放锁的时候要对应减去自己ThreadLocal中保存的获取锁的状态。</li>
</ul>
</li>
</ul>
<h4 id="10-ReentrantReadWriteLock的锁降级"><a href="#10-ReentrantReadWriteLock的锁降级" class="headerlink" title="10.ReentrantReadWriteLock的锁降级"></a>10.ReentrantReadWriteLock的锁降级</h4><p><strong>锁降级指的是写锁降级成为读锁</strong>。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指<strong>把持住（当前拥有的）写锁</strong>，<strong>再获取到读锁</strong>，<strong>随后释放（先前拥有的）写锁的过程</strong>。</p>
<ul>
<li>锁降级中读锁的获取是否必要呢？<ul>
<li>必要。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻<strong>另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。</strong>如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会一直被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。</li>
</ul>
</li>
</ul>
<h4 id="11-LockSupport工具"><a href="#11-LockSupport工具" class="headerlink" title="11.LockSupport工具"></a>11.<strong>LockSupport</strong>工具</h4><p>LockSupport定义了一组的公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能</p>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231206200046659.png" class title="image-20231206200046659">

<p>上面的park和unpark方法都是直接调用的native方法，所以是直接和操作系统进行了交互，在Java 6中，LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos)和parkUntil(Object blocker,long deadline)3个方法，也就是在原方法的基础上加了一个参数，其中参数<strong>blocker是用来标识当前线程在等待的对象</strong>，调用这个方法会导致线程dump的日志中多出等待对象的信息(下图黄色部分)，从而方便问题排查和系统监控。</p>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231206200726045.png" class title="image-20231206200726045">

<h4 id="12-Condition解读"><a href="#12-Condition解读" class="headerlink" title="12.Condition解读"></a>12.<strong>Condition</strong>解读</h4><ul>
<li><p>Condition介绍</p>
<ul>
<li>Condition接口提供了类似Object的监视器(wait&#x2F;notify)方法，与Lock配合可以实现等待&#x2F;通知模式，但是这两者在使用方式以及功能特性上还是有差别的。</li>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231206215911098.png" class title="image-20231206215911098"></li>
</ul>
</li>
<li><p>Condition使用</p>
<ul>
<li>通过lock.newCondition()的形式进行队列的创建，Condition调用await方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的singal方法，通知当前线程，当前线程才从await方法返回，并且在返回前已经获取了锁。多用于生产者和消费者的形式中，例如当生产者的队列满了以后，调用await方法等待，然后唤醒消费者线程。当没东西可以消费的时候，消费者线程会调用await方法进入等待状态，然后通知生产者线程继续生产</li>
</ul>
</li>
<li><p>Condition的原理</p>
<ul>
<li>通过newCondition得到的队列也是一个FIFO队列，称为等待队列，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。事实上，节点的定义复用了同步器中节点的定义，也就是AbstractQueuedSynchronizer.Node，一个Condition包含一个等待队列，Condition拥有首节点（firstWaiter）和尾节点（lastWaiter）。上述节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。</li>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207125211837.png" class title="image-20231207125211837"></li>
<li>并发包中的Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列，其对应关系如图所示。一个线程持有锁，调用了await方法之后加入了<strong>等待队列</strong>进行排队，当我们的这个线程被唤醒（需要执行await后边的代码），需要重新竞争锁（因为await方法将锁释放掉了）。如果竞争成功执行后续代码，如果竞争失败，就会加入到<strong>同步队列</strong>里进行排队。如果排到了同步队列的头部且争抢锁成功，就继续执行await方法后边的代码。如果在执行过程中又调用了await方法，就再次回到等待队列。依次循环下去。</li>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207125453697.png" class title="image-20231207125453697"></li>
</ul>
</li>
<li><p>await和signal重点源码</p>
<ul>
<li><p>await</p>
<ul>
<li><pre><code class="java">if (Thread.interrupted())//先查看线程的中断标记，如果被中断则直接抛出异常
    throw new InterruptedException();
Node node = addConditionWaiter();//加入到等待队列的尾端
int savedState = fullyRelease(node);//释放锁
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- signal</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    if (first != null)</span><br><span class="line">        doSignal(first);//唤醒等待队列的首节点</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h3><h4 id="1-什么是原子操作类"><a href="#1-什么是原子操作类" class="headerlink" title="1.什么是原子操作类"></a>1.什么是原子操作类</h4><p><strong>原子操作类：提供了可以保证我们线程安全的类。可以直接使用。</strong>Java从JDK 1.5开始提供了java.util.concurrent.atomic包，这个包中的原子操作类提供了一种用法简单、性能高效（使用CAS不会阻塞线程）、线程安全地更新一个变量的方式。</p>
<p>因为变量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是<strong>原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。</strong>Atomic包里的类基本都是使用Unsafe实现的包装类。</p>
<h4 id="2-原子更新基本类型类"><a href="#2-原子更新基本类型类" class="headerlink" title="2.原子更新基本类型类"></a>2.<strong>原子更新基本类型类</strong></h4><p>使用原子的方式更新基本类型，Atomic包提供了以下3个类。</p>
<p>·AtomicBoolean：原子更新布尔类型。</p>
<p>·AtomicInteger：原子更新整型。</p>
<p>·AtomicLong：原子更新长整型。</p>
<p>以原子更新整型为例，可以调用其incrementAndGet方法，先对初始化的值进行加一，然后返回相加后的值</p>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207220113917.png" class title="image-20231207220113917">

<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207220241440.png" class title="image-20231207220241440">

<p>底层直接调用了native方法，使用CAS保证了原子性</p>
<h4 id="3-原子更新数组型类"><a href="#3-原子更新数组型类" class="headerlink" title="3.原子更新数组型类"></a>3.原子更新数组型类</h4><p>通过原子的方式更新数组里的某个元素，Atomic包提供了以下3个类。</p>
<p>·AtomicIntegerArray：原子更新整型数组里的元素。</p>
<p>·AtomicLongArray：原子更新长整型数组里的元素。</p>
<p>·AtomicReferenceArray：原子更新引用类型数组里的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayAtomicTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        array[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">        array[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">        <span class="type">AtomicIntegerArray</span> <span class="variable">aia</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(array);</span><br><span class="line">        aia.compareAndSet(<span class="number">0</span>, <span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line">        System.out.println(aia.get(<span class="number">0</span>)); <span class="comment">// 11</span></span><br><span class="line">        System.out.println(array[<span class="number">0</span>]);<span class="comment">// 10</span></span><br><span class="line">        <span class="comment">//我们的数组的原子操作类，只是复制了我们之前的array的对象，并不会</span></span><br><span class="line">        <span class="comment">//在操作中改变原有array的值。</span></span><br><span class="line">        <span class="comment">//原始的array只作为一个入参。真正保障我们的原子性的还是我们的AtomicIntegerArray</span></span><br><span class="line">        <span class="comment">//备份的这个一份儿数据。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>AtomicIntegerArray的备份操作，克隆了一份原数组，而不是对原数组直接进行修改<ul>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207221600191.png" class title="image-20231207221600191"></li>
</ul>
</li>
</ul>
<p>里面的方法基本都见名知意，而底层基本也都是使用Unsafe类的CAS方法来保证原子性</p>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207221058981.png" class title="image-20231207221058981">

<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207221116257.png" class title="image-20231207221116257">

<h4 id="4-原子更新引用类"><a href="#4-原子更新引用类" class="headerlink" title="4.原子更新引用类"></a>4.<strong>原子更新引用类</strong></h4><p>原子更新引用类型提供的类中常用的两个类：</p>
<p>·AtomicReference：原子更新引用类型。</p>
<p>·AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</p>
<p>底层依然是CAS</p>
<ul>
<li><p>对于原子更新数组和引用的总结：</p>
<ul>
<li><p><strong>对于原子更新数组类和原子更新对象引用类，他们实质上就是将我们的数组和对象的外层进行了一次 Atomic</strong> <strong>的封装。所以，在进行替换的时候，其实是外层的这个封装保证了原子性。</strong></p>
<p><strong>想想我们的原子更新基本类型如：Integer，也是在他的外层进行了一次封装。</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="5-原子更新字段类"><a href="#5-原子更新字段类" class="headerlink" title="5.原子更新字段类"></a>5.<strong>原子更新字段类</strong></h4><p>如果需要原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新。</p>
<p>·AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</p>
<p>·AtomicLongFieldUpdater：原子更新长整型字段的更新器。</p>
<p>·AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的ABA问题。</p>
<p>要想原子地更新字段类需要两步。<strong>第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新类的字段（属性）必须使用public volatile修饰符。</strong></p>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207223857004.png" class title="image-20231207223857004">

<p>底层依然是CAS</p>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207224000538.png" class title="image-20231207224000538">

<h3 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h3><h4 id="1-CountDownLatch介绍"><a href="#1-CountDownLatch介绍" class="headerlink" title="1. CountDownLatch介绍"></a>1. <strong>CountDownLatch</strong>介绍</h4><p>CountDownLatch 中 count down 是倒数的意思，latch 则是门闩的含义。整体含义可以理解为<strong>倒数完成后，门栓打开。倒数没有完成，门栓紧闭。</strong>CountDownLatch 类似于join方法，等待其他线程执行完成后，才会统一继续执行下边的代码。但是它比join的功能更多。</p>
<p>常用方法说明：</p>
<p>Ø<strong>CountDownLatch(int count)</strong>; &#x2F;&#x2F;构造方法，创建一个值为count 的计数器。</p>
<p>Ø<strong>await()</strong>;&#x2F;&#x2F;阻塞当前线程，将当前线程加入阻塞队列。</p>
<p>Ø<strong>await(long timeout, TimeUnit unit)</strong>;&#x2F;&#x2F;在timeout的时间之内阻塞当前线程,时间一过则当前线程可以执行，</p>
<p>Ø<strong>countDown()</strong>;&#x2F;&#x2F;对计数器进行递减1操作，当计数器递减至0时，当前线程会去唤醒阻塞队列里的所有线程。</p>
<ul>
<li><p>使用示例：每条线程执行完之后，倒数的计数器都会减一，直到减为0，才能执行await后面的代码</p>
<ul>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208173827228.png" class title="image-20231208173827228"></li>
</ul>
</li>
<li><p>CountDownLatch 的源码也是一个实现类AQS的Sync，调用await方法相当于是获取锁，调用countDown方法相当于是对锁的状态不断减一，直到减到零，才能释放锁</p>
</li>
</ul>
<h4 id="2-CyclicBarrier介绍"><a href="#2-CyclicBarrier介绍" class="headerlink" title="2.CyclicBarrier介绍"></a>2.<strong>CyclicBarrier</strong>介绍</h4><p>CyclicBarrier的字面意思是<strong>可循环使用（Cyclic）的屏障（Barrier</strong>）。它要做的事情是，让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p>
<p>CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p>
<p><strong>CountDownLatch的计数器只能使用一次</strong>，<strong>而CyclicBarrier的计数器可以使用reset()方法重置</strong>。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。CyclicBarrier在初始化时候的传参，除了设置屏障个数以外，能够支持传入一个 Runnable的 action去做后续的数据的操作。能够适用于更加复杂的场景。</p>
<p>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。</p>
<ul>
<li><p>CyclicBarrier和CountDownLatch 的使用区别(需求：A线程完成3+5，B线程完成10+2，然后主线程对结果进行相加)</p>
<ul>
<li>使用CountDownLatch完成<ul>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208182601180.png" class title="image-20231208182601180"></li>
</ul>
</li>
<li>使用CyclicBarrier完成<ul>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208182813315.png" class title="image-20231208182813315"></li>
</ul>
</li>
<li>总结：CountdownLatch里边的参数直接写的是2，就是进行2次倒计时，我们的main函数调用的await。就是告诉我们main线程在等待其他两个线程执行完毕。 然而，对于 CyclicBarrier 这种实现形式，main函数和其他两个线程都被阻塞到了一个地方。此处main函数到达了屏障之后挂起自己，等待其他两个线程达到屏障之后才开始执行。<strong>CountdownLatch 针对业务完成之后放行；CyclicBarrier 针对的是所有的线程在统一的屏障集合之后开始执行后续代码</strong></li>
</ul>
<ul>
<li>使用CyclicBarrier传入的Runnable的 action完成<ul>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208183829168.png" class title="image-20231208183829168"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-Semaphore介绍"><a href="#3-Semaphore介绍" class="headerlink" title="3.Semaphore介绍"></a>3.<strong>Semaphore</strong>介绍</h4><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p>
<p>Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制。</p>
<ul>
<li>示例代码<ul>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208185046260.png" class title="image-20231208185046260"></li>
<li>这样就可以保证同一时间数据库最多只有十条线程对其进行连接</li>
</ul>
</li>
</ul>
<h4 id="4-Exchanger介绍"><a href="#4-Exchanger介绍" class="headerlink" title="4.Exchanger介绍"></a>4.<strong>Exchanger</strong>介绍</h4><p>Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果<strong>第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</strong></p>
<p>下面来看一下Exchanger的应用场景。Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作，比如我们需要将<strong>纸制银行流水通过人工的方式录入成电子银行流水</strong>，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致。</p>
<h3 id="Java阻塞与非阻塞队列"><a href="#Java阻塞与非阻塞队列" class="headerlink" title="Java阻塞与非阻塞队列"></a>Java阻塞与非阻塞队列</h3><h4 id="1-ConcurrentLinkedQueue非阻塞队列"><a href="#1-ConcurrentLinkedQueue非阻塞队列" class="headerlink" title="1.ConcurrentLinkedQueue非阻塞队列"></a>1.<strong>ConcurrentLinkedQueue</strong>非阻塞队列</h4><p>在多线程并发环境下，如果想要实现一个线程安全的队列，无非两种方式</p>
<ol>
<li>加锁</li>
<li>使用CAS</li>
</ol>
<p>ConcurrentLinkedQueue是一个基于<strong>链接节点的无界线程安全队列</strong>，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元素时，它会返回队列头部的元素，底层使用CAS保证线程安全。</p>
<p>ConcurrentLinkedQueue在节点入队的时候，先会检查tail的next节点是不是为空，如果tail的next节点为空，那么新来的节点直接放到tail的next的位置，如果tail的next节点不为空，那么新来的节点直接放到tail的next节点的next节点，同时把tail指向新来的节点，所以tail指向的不一定是尾节点</p>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208220706859.png" class title="image-20231208220706859">

<p>ConcurrentLinkedQueue在节点出队的时候，当head节点里有元素时，直接弹出head节点里的元素，而不会更新head节点。只有当head节点里没有元素时，出队操作才会更新head节点(head指向弹出节点的next节点)。所以，并不是每次出队时都更新head节点，也就是说head并不一定一直指向头节点</p>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208220848350.png" class title="image-20231208220848350">

<h4 id="2-阻塞队列介绍"><a href="#2-阻塞队列介绍" class="headerlink" title="2.阻塞队列介绍"></a>2.阻塞队列介绍</h4><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列：</p>
<p>1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。</p>
<p>2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。</p>
<p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。</p>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208221559308.png" class title="image-20231208221559308">

<p><em>注：返回特殊值例如true或者false</em></p>
<ul>
<li>JDK7提供的阻塞队列：<ul>
<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li>
</ul>
</li>
</ul>
<h4 id="3-有界阻塞队列"><a href="#3-有界阻塞队列" class="headerlink" title="3.有界阻塞队列"></a>3.有界阻塞队列</h4><p>ArrayBlockingQueue是一个用<strong>数组</strong>实现的<strong>有界阻塞队列</strong>。此队列按照<strong>先进先出（FIFO）</strong>的原则对元素进行排序。</p>
<p>LinkedBlockingQueue是一个用<strong>链表</strong>实现的<strong>有界阻塞队列</strong>。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照<strong>先进先出</strong>的原则对元素进行。</p>
<ul>
<li><p>相同点：</p>
<ul>
<li>都是阻塞队列，且有界；</li>
<li>都是先进先出</li>
</ul>
</li>
<li><p>不同点：</p>
<ul>
<li>锁使用的不同，ArrayBlockingQueue元素入队和出队使用的是一把ReentrantLock，所以进出会相互影响，LinkedBlockingQueue使用的是两把ReentrantLock，一个take锁，一个put锁，入队出队只需要获取对应的锁即可，所以进出互不影响。所以从这一方面来看LinkedBlockingQueue更适合高并发场景，具有更高的吞吐量(单位时间处理更多请求)</li>
<li>ArrayBlockingQueue使用的是object的数组存储的元素，而LinkedBlockingQueue使用的是Node节点进行的元素存储，而且有next节点。如果数据量非常大的情况下，随着数据量的增长，我们需要构建的Node节点的数量就越多，Node节点数量代表的是对象的数量，一旦有这么多对象的产生，就会有产生对象的jvm的消耗;使用完成需要进行垃圾回收; 而且还存在next指针问题。反观我们的 array，就是一个数组,内存空间连续,不需要额外构造node节点了。直接object定义的我们的底层数组，可以存放任何类型的对象，不需要构造 node。</li>
<li>队列长度问题。如果我们要创建ArrayBlockingQueue,需要严格指定queue的大小，也就是说，我们在使用这个queue之前就开辟好了内存空间。而LinkedBlockingQueue不强制指定大小。因为每次插入一个新的节点，都会new 一个Node对象，都会开辟一块新的内存空间。如果我们能够确定定长的队列，建议使用arrayqueue。</li>
</ul>
</li>
</ul>
<p>总结：至于谁的效率更好，真的没有办法界定。因为你永远无法知道，创建节点开辟内存空间的消耗，创建Node对象的消耗，回收Node对象的消耗，和ArrayBlockingQueue 的单锁的消耗谁大谁小。所以有条件一定进行压测然后再选取</p>
<h4 id="4-优先级队列和延时队列"><a href="#4-优先级队列和延时队列" class="headerlink" title="4.优先级队列和延时队列"></a>4.优先级队列和延时队列</h4><ul>
<li>PriorityBlockingQueue优先级队列的介绍：</li>
</ul>
<p>PriorityBlockingQueue是一个支持优先级的无界阻塞队列。底层是使用数组来进行元素的保存,如果达到数组的大小会进行扩容，默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PriorityBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityBlockingQueue</span>&lt;&gt;(<span class="number">10</span>,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                    <span class="comment">// 降序排列，如果o1小于o2，返回-1，如果o1等于o2，返回0，如果o1大于o2，返回1</span></span><br><span class="line">                    <span class="keyword">return</span> o2 - o1;</span><br><span class="line">                &#125;</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>DelayQueue延时队列介绍</li>
</ul>
<p>DelayQueue是一个<strong>支持延时</strong>获取元素的<strong>无界阻塞队列</strong>。队列使用<strong>PriorityQueue</strong>来实现。队列中的元素必须实现<strong>Delayed接口</strong>，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。</p>
<p><strong>DelayQueue非常有用，可以将DelayQueue运用在以下应用场景。</strong></p>
<p><strong>缓存系统的设计</strong>(很少有公司自己设计大型缓存：Redis，ehcache)：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</p>
<p><strong>定时任务调度</strong>：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。</p>
<p>由于它底层的队列是由PriorityQueue实现的，所以它可以实现优先级排序，可以根据加入任务的时间进行升序排列，剩余时间越小的越靠前，当从队列中取数据的时候，会先调用peek方法，看看第一个任务是不是空，看看第一个任务是不是到期可以执行了，然后才会取出任务，其中poll方法在取任务的时候发现任务不能取出，会直接返回null，而take方法在取数据的时候如果第一个任务不能取出，那么这时会死循环返回获取</p>
<ul>
<li>signal和await在这个地方的配合<ul>
<li>如果取任务的线程发现队列中第一个任务不可取，或者第一个去取得线程(leader)不为空，那么说明这个取线程一定取不到任务，这时会调用await进入等待队列，当放任务的线程把一个任务放到空队列的时候，会调用signal方法唤醒正在等待队列中等待的取线程</li>
</ul>
</li>
</ul>
<h4 id="5-SynchronousQueue介绍"><a href="#5-SynchronousQueue介绍" class="headerlink" title="5.SynchronousQueue介绍"></a>5.<strong>SynchronousQueue</strong>介绍</h4><p>SynchronousQueue<strong>是一个不存储元素的阻塞队列</strong>。每一个put操作必须等待一个take操作，否则不能继续添加元素。</p>
<p>它支持公平访问队列。<strong>默认情况下线程采用非公平性策略访问队列</strong>。如果设置为true，则等待的线程会采用先进先出的顺序访问队列。</p>
<ul>
<li><p>使用场景</p>
<ul>
<li><p>不存储数据的队列，阻塞队列。适合短期的小并发场景，且数据处理相当快速。</p>
<p>硬说点好处：首先他没有缓冲容量，那么他可以避免在服务器宕机的情况下，从queue的角度来说，没有数据丢失这么一说。 他类似于一个<strong>传球手</strong>，中间没有任何介质阻碍。如果单纯的进行数据的传递且生产的线程与消费的线程生产时间和消费时间比较同步的话，他的性能能够很高。</p>
</li>
<li><p>CachedThreadPool 里边使用的就是SynchronousQueue。CachedThreadPool 的使用场景就是处理<strong>快速的短期的小并发场景。</strong>CachedThreadPool 是没有核心线程数，完全依赖max线程数，直接依赖操作系统创建线程，如果是短期的小并发，在线程达到 keep live 时间以后，可以自行销毁。</p>
</li>
</ul>
</li>
</ul>
<h4 id="6-LinkedTransferQueue介绍（无界、传球手、阻塞）"><a href="#6-LinkedTransferQueue介绍（无界、传球手、阻塞）" class="headerlink" title="6.LinkedTransferQueue介绍（无界、传球手、阻塞）"></a>6.<strong>LinkedTransferQueue</strong>介绍（无界、传球手、阻塞）</h4><p>LinkedTransferQueue是一个由<strong>链表结构</strong>组成的<strong>无界阻塞TransferQueue队列</strong>。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。</p>
<p>LinkedTransferQueue是一个高效阻塞无界链表队列(被称为综合性的阻塞队列) 。和 SynchronousQueue.TransferQueue (<strong>公平模式</strong>) 相比，它是可以统计长度(使用getWaitingConsumerCount方法查询有多少个正在等待获取的线程，没有获取到的线程会被封装成Node节点)；和 LinkedBlockingQueue 相比，它拥有更高的性能（使用 CAS 自旋，LinkedBlockingQueue使用的是lock锁）；和 ConcurrentLinkedQueue 相比，它拥有阻塞功能（因为它实现了TransferQueue，TransferQueue继承了BlockingQueue）。</p>
<p><strong>（1）transfer方法</strong></p>
<p>如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者（与SynchronousQueue相似<strong>）。如果没有消费者在等待接收元素，transfer方法会将元素</strong>存放在队列的tail节点，并等到该元素被消费者消费了才返回。</p>
<p><strong>（2）tryTransfer方法</strong> </p>
<p>tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。</p>
<p>对于带有时间限制的tryTransfer（E e，long timeout，TimeUnit unit）方法，试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</p>
<h4 id="7-LinkedBlockingDeque介绍"><a href="#7-LinkedBlockingDeque介绍" class="headerlink" title="7.LinkedBlockingDeque介绍"></a>7.<strong>LinkedBlockingDeque</strong>介绍</h4><p>LinkedBlockingDeque是一个由<strong>链表结构</strong>组成的<strong>双向阻塞队列</strong>。所谓双向队列指的是可以从队列的两端插入和移出元素（LinkedBlockingDeque产生的原因是什么？1.首先它是对LinkedBlockingQueue的一个补充，能支持双向存取； 2.对阻塞队列的补充支持双向存取）。</p>
<p>双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法</p>
<p>在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“**工作窃取(Fork&#x2F;Join框架中细说)**”模式中。</p>
<ul>
<li>既然有双向队列，还那么方便，为什么不直接把单向队列移除? <ul>
<li>功能越多，向 越多，Node节点越复杂，添加，移除越复杂，维护起来更加麻烦；虽然是减小了竞争压力，但是对于一些不是很大竞争压力下的场景，我们的单向的队列还是非常好用的</li>
</ul>
</li>
</ul>
<h4 id="8-Fork-x2F-Join框架"><a href="#8-Fork-x2F-Join框架" class="headerlink" title="8.Fork&#x2F;Join框架"></a>8.<strong>Fork&#x2F;Join框架</strong></h4><ul>
<li><p>Fork&#x2F;Join框架介绍</p>
<ul>
<li>Fork&#x2F;Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务(调用compute方法)，最终汇总每个小任务结果后得到大任务结果的框架。再通过Fork和Join这两个单词来理解一下Fork&#x2F;Join框架。Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。</li>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231209221211915.png" class title="image-20231209221211915"></li>
</ul>
</li>
<li><p>工作窃取算法</p>
<ul>
<li>介绍<ul>
<li>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。那么，为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，<strong>把这些子任务分别放到不同的队列里</strong>，并为每个队列<strong>创建一个单独的线程来执行队列里的任务</strong>，线程和队列一一对应。比如A线程负责处理A队列里的任务。但是，有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。</li>
</ul>
</li>
<li>与双端队列的配合<ul>
<li>窃取其他队列中的任务时，它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。工作窃取算法的缺点：如果队列中只剩一个任务，还是会出现竞争，<strong>并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>Fork&#x2F;Join框架使用</p>
<ul>
<li><p>Fork&#x2F;Join使用两个类来完成以上两件事情。</p>
<p>①<strong>ForkJoinTask</strong>：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中<strong>执行fork()<strong>和</strong>join()<strong>操作的机制。通常情况下，我们</strong>不需要直接继承ForkJoinTask类</strong>，只需<strong>要继承它的子类</strong>，Fork&#x2F;Join框架提供了以下两个子类。</p>
<p>·<strong>RecursiveAction</strong>：用于没有返回结果的任务。</p>
<p>·<strong>RecursiveTask</strong>：用于有返回结果的任务。</p>
<p>②<strong>ForkJoinPool</strong>：ForkJoinTask需要通过ForkJoinPool来执行。</p>
</li>
<li><pre><code class="java">//使用fork/join计算从一加到一百
public class ForkJoinTest extends RecursiveTask&lt;Integer&gt; &#123; //需要返回结果
    private static final int THRESHOLD = 2; // 最多几个数字做子任务
    private int start; //从那块相加
    private int end;// 加到几

    public ForkJoinTest(int start, int end) &#123;
        this.start = start;
        this.end = end;
    &#125;

    @Override
    protected Integer compute() &#123; //拆分任务，获取结果
        int sum = 0;
        // 如果任务足够小就计算任务
        boolean canCompute = (end - start) &lt; THRESHOLD;
        if (canCompute) &#123;
            for (int i = start; i &lt;= end; i++) &#123;
                sum += i;
            &#125;
        &#125; else &#123;
            // 如果任务大于阈值，就分裂成两个子任务计算
            int middle = (start + end) / 2;
            ForkJoinTest leftTask = new ForkJoinTest(start, middle);
            ForkJoinTest rightTask = new ForkJoinTest(middle + 1, end);
            // 执行子任务
            leftTask.fork();
            rightTask.fork();
            // 等待子任务执行完，并得到其结果
            int leftResult = leftTask.join();
            int rightResult = rightTask.join();
            // 合并子任务
            sum = leftResult + rightResult;
        &#125;
        return sum;
    &#125;

    public static void main(String[] args) &#123;
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        // 生成一个计算任务，负责计算1+2+3+4
        ForkJoinTest task = new ForkJoinTest(1, 100);
        // 执行一个任务
        Future&lt;Integer&gt; result = forkJoinPool.submit(task);
        try &#123;
            System.out.println(result.get());
        &#125; catch (InterruptedException e) &#123;
        &#125; catch (ExecutionException e) &#123;
        &#125;
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 线程池与Executor框架</span><br><span class="line"></span><br><span class="line">#### 1.**线程池的原理**</span><br><span class="line"></span><br><span class="line">* 线程池运行步骤：</span><br><span class="line"></span><br><span class="line">1）使用者提交任务以后，如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</span><br><span class="line"></span><br><span class="line">2）如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue队列。</span><br><span class="line"></span><br><span class="line">3）如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。</span><br><span class="line"></span><br><span class="line">4）如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231209225302725.png image-20231209225302725 %&#125;</span><br><span class="line"></span><br><span class="line">* ThreadPoolExecutor为什么采取上述步骤的总体设计思路？(或者问：线程池为什么要有一个核心线程数和最大线程数的区分呢？)</span><br><span class="line"></span><br><span class="line">**是为了在执行execute()方法时，尽可能地避免获取全局锁**</span><br><span class="line"></span><br><span class="line">1. 核心线程数和最大线程数中间还有一个queue，向queue里添加任务不需要获取全局锁。如果核心线程数够用，不一定先要去创建其他的线程，因为需要看queue是否还能够继续容纳新的请求； 如果没有所谓的最大的线程数，只有一个核心线程数，那么当我们线程池的核心线程数配置小了的话，那么很多任务都会添加到queue里。如果queue满了，我们就没有其他的办法创建新的额外的线程了。</span><br><span class="line"></span><br><span class="line">2. 如果仅仅依靠核心线程数，比如说我们将核心线程数的值设置的非常大，每次有新任务过来，都有可能在核心线程数里边创建新的线程，可能会造成全局锁的获取，导致性能一个瓶颈。</span><br><span class="line"></span><br><span class="line">* 全局锁？在那块儿有这个逻辑？</span><br><span class="line"></span><br><span class="line">当我们的ThreadPoolExecutor进行execute方法执行的时候，如果当前的工作线程小于 Coresize，就会进行一个新的工作线程的添加，调用 addWorker 方法，这个方法里，当我们进行最终的worker.add的时候，是在一个ReentrantLock里执行的。也就是说，此处不允许并发添加新的worker。如果同时有多个线程进来，且都小于coresize，只能排队添加。</span><br><span class="line"></span><br><span class="line">#### 2.线程池参数</span><br><span class="line"></span><br><span class="line">1）**corePoolSize**（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</span><br><span class="line"></span><br><span class="line">2）**runnableTaskQueue**（任务队列）**建议选用有界队列**。1. 如果是无界队列，那么queue永远不会满，永远不会触发到maximumPoolSize，意味着maximumPoolSize这个参数就没有他的作用了； 2. 最重要的是无界队列无法控制队列最终包含的数据量，导致内存资源的极大的消耗甚至耗尽。3. 最好是选用有界队列并合理的配置maximumPoolSize。4 饱和策略的使用根据需求选择。一旦我们触发了饱和策略，就说明：要么是我们的线程池配置有问题，要么真的是并发量太高，任务太多，导致的问题。警醒我们进行深入的参数调查及合理分配。</span><br><span class="line"></span><br><span class="line">3）**maximumPoolSize**（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。</span><br><span class="line"></span><br><span class="line">4）ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线程设置有意义的名字</span><br><span class="line"></span><br><span class="line">5）**RejectedExecutionHandler**（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略。</span><br><span class="line"></span><br><span class="line">·**AbortPolicy**：直接抛出异常。相对多一些，因为我们会在异常处理的过程中进行各种手段：如果记录日志，存入数据库等待重试</span><br><span class="line"></span><br><span class="line">·**CallerRunsPolicy**：只用调用者所在线程来运行任务。用的也相对少一些。调用者线程也是系统资源，说明线程数量已经很多了，调用者线程的加入其实是变相增加了 maxsize</span><br><span class="line"></span><br><span class="line">·**DiscardOldestPolicy**：丢弃队列里最近的一个任务，并执行当前任务。几乎没有人使用。</span><br><span class="line"></span><br><span class="line">·**DiscardPolicy**：不处理，丢弃掉。 这种使用的也少</span><br><span class="line"></span><br><span class="line">当然，也可以根据应用场景需要来实现**RejectedExecutionHandler**接口**自定义策略**。（最推荐）</span><br><span class="line"></span><br><span class="line">6）keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率,如果是一个多线程一同执行的一个大任务，例如一个定时任务，一天执行一次，这时可以把keepAliveTime的时间调小一些。</span><br><span class="line"></span><br><span class="line">7）TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</span><br><span class="line"></span><br><span class="line">#### 3.如何合理的配置线程池</span><br><span class="line"></span><br><span class="line">1. 我们的线程池是生存在一个复杂的系统环境里，我们还有其他的接口需要使用我们的服务器资源，所以在进行线程池coresize的配置以及maxsize的配置的时候，我们需要明确我们当前的接口的重要性，如果当前接口占据了未来业务访问的50%，那么就可以分配50%的系统资源给当前接口。（我们一个服务，总有一些重要接口和非重要接口，在我们进行项目开发初期，需求就定好了。）</span><br><span class="line">2. 线程池参数的配置一定要基于压测。来评估线程池的参数是否合理。</span><br><span class="line">   - 初次压测的参数配置：</span><br><span class="line">     - 情况一：当前的服务器只为当前的线程池服务。这时可以站在前辈的肩膀，根据前辈的经验，看当前任务是CPU密集型任务还是IO密集型任务，如果是CPU密集型的，那么可以选与当前CPU核数差不多的线程数，或者稍微大一点点的，如果是IO密集型的，那么可以选择CPU核数的两倍或者稍微大一点点的</span><br><span class="line">     - 情况二：当前的服务器不是只为这一个线程池服务。举个场景，一个服务共有五个接口，其中两个重要接口，三个不重要接口(访问量大的时候可以做降级处理，保障另外两个接口可以尽可能多的使用服务器资源)，这两个重要接口都创建了线程池来提高单接口的并发处理速度，这时首先要做的是拿到线上高并发访问压力下该服务每个接口的访问比例，比如这五个接口的访问比例是4：3：1：1：1，那么对于第二个接口而言，它就有资格占用3/10的服务器资源，那么他的线程池的最大线程数可以粗略的设置为当前CPU核数的3/10，首次压测，把核心线程数也设置为和最大线程数相同的大小，然后开始压测，看当前线程池能否撑得住现在的并发访问量，如果撑得住慢慢调小核心线程数，如果撑不住这时queue就要登场了，至于队列大小的计算，需要根据接口访问峰值和持续时间，比如，双11，618等等活动，都会有一个高峰的访问持续时间，假如高峰情况下访问一个小时，打到该接口的请求一共有1000个，而当前接口正常情况下一个小时能处理的请求数量是800个，这时可以得到1000-800=200这个值，然后把200这个值稍微调高50%(为了避免访问不均匀的问题，当然如果访问量曲线比较平稳可以适当降低这个值，比如就调高10%-20%)，也就是300作为这个有界队列的初始大小，然后再次压测，这时如果可以达到要求，那么为了避免资源的浪费，再次降低核心线程数的数量 ，但是如果还没有达到预期要求，可以从以下几点进行解决，1.再次提高队列的长度(不要首先想提高线程数，而是先动队列的长度上限，因为这样一定不会影响到其他接口，属于空间换时间)2.如果由于调高了队列的长度，没有提高线程数导致接口性能下降，这时考虑对代码进行优化(比如可不可以把目前的接口做成异步的，对于消息的处理可不可进行服务的拆分，把他放到RabbitMQ里，由下游的服务从RabbitMQ里边，进行多线程的处理，提高当前接口的并发量)3.如果对代码优化之后还是不能达到预期，这时才可以考虑调高一下线程数，因为如此大的并发情况下，另外三个接口可能做出了服务的降级处理让出了一定服务器资源，但是并不建议这么做，因为虽然其他接口做了降级处理，还是有可能因为提高线程数而引起其他节点的一些问题4.增加节点数量。</span><br><span class="line">3. 我们要给线程池开后门，可以动态的调整线程池的参数。（我们现在很多大型项目都有自己的配置中心，appolo是一个非常好的配置组件，你可以将coresize和maxsize配置到配置中心，一旦发生不可控的高并发场景，可以随时修改配置中心的参数，我们的项目就会按照新的标准进行调整。）</span><br><span class="line"></span><br><span class="line">#### 4.**线程池的监控及关闭**</span><br><span class="line"></span><br><span class="line">* 线程池的监控</span><br><span class="line"></span><br><span class="line">  * 如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根据线程池的使用状况快速定位问题。可以通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性。</span><br><span class="line"></span><br><span class="line">    ·taskCount：线程池需要执行的任务数量。</span><br><span class="line"></span><br><span class="line">    ·completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。</span><br><span class="line"></span><br><span class="line">    ·largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。</span><br><span class="line"></span><br><span class="line">    ·getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。</span><br><span class="line"></span><br><span class="line">    ·getActiveCount：获取活动的线程数。</span><br><span class="line"></span><br><span class="line">    通过扩展线程池进行监控。可以**通过继承线程池来自定义线程池**，重写线程池的beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。</span><br><span class="line"></span><br><span class="line">* 关闭线程池：</span><br><span class="line">  </span><br><span class="line">  - 可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的**原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。**但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后**尝试停止所有的正在执行或暂停任务的线程**，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后**中断所有没有正在执行任务的线程。**</span><br><span class="line"></span><br><span class="line">#### 5.**Executor框架**</span><br><span class="line"></span><br><span class="line">Executor框架就是一个上层的用户级的调度器。</span><br><span class="line"></span><br><span class="line">在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231210145801348.png image-20231210145801348 %&#125;</span><br><span class="line"></span><br><span class="line">应用程序通过Executor框架控制上层的调度；而下层的调度由操作系统内核控制，下层的调度不受应用程序的控制。</span><br><span class="line"></span><br><span class="line">* Executor框架的组成</span><br><span class="line"></span><br><span class="line">  **·任务**。包括被执行任务需要实现的接口：Runnable接口(没有返回值)或Callable接口(有返回值)。</span><br><span class="line"></span><br><span class="line">  **·任务的执行**。包括任务执行机制的核心接口Executor，以及继承自Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口（ThreadPoolExecutor(用来执行被提交的任务)和ScheduledThreadPoolExecutor(在给定的延迟后运行命令，或者定期执行命令。)）。</span><br><span class="line"></span><br><span class="line">  **·异步计算的结果**。包括接口Future和实现Future接口的FutureTask类。</span><br><span class="line"></span><br><span class="line">  - &#123;% asset_img image-20231210150303335.png image-20231210150303335 %&#125;</span><br><span class="line"></span><br><span class="line">#### 6.**Executor框架**的使用</span><br><span class="line"></span><br><span class="line">主线程首先要创建实现Runnable或者Callable接口的任务对象。然后可以把Runnable对象直接交给ExecutorService调用execute或者submit来执行，如果执行ExecutorService.submit，ExecutorService将返回一个实现Future接口的对象（到目前为止的JDK中，返回的是FutureTask对象）。最后，主线程可以执行FutureTask.get()方法来等待任务执行完成。主线程也可以执行FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。</span><br><span class="line"></span><br><span class="line">* 示例代码</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public class ThreadPoolSimpleTest &#123;</span><br><span class="line">        public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">            ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10,</span><br><span class="line">                    200, TimeUnit.MILLISECONDS,</span><br><span class="line">                    new ArrayBlockingQueue&lt;Runnable&gt;(5));</span><br><span class="line">    </span><br><span class="line">            for(int i=0;i&lt;15;i++)&#123;</span><br><span class="line">                //创建任务对象</span><br><span class="line">                MyTask myTask = new MyTask(i);</span><br><span class="line">                //任务的执行</span><br><span class="line">    //            executor.execute(myTask);</span><br><span class="line">                //异步计算的结果</span><br><span class="line">                Future&lt;?&gt; submit = executor.submit(myTask);</span><br><span class="line">                System.out.println(&quot;线程池中线程数目：&quot;+executor.getPoolSize()+&quot;，队列中等待执行的任务数目：&quot;+</span><br><span class="line">                        executor.getQueue().size()+&quot;，已执行完的任务数目：&quot;+executor.getCompletedTaskCount());</span><br><span class="line">            &#125;</span><br><span class="line">            executor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    class MyTask implements Runnable &#123;</span><br><span class="line">        private int taskNum;</span><br><span class="line">    </span><br><span class="line">        public MyTask(int num) &#123;</span><br><span class="line">            this.taskNum = num;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;正在执行task &quot; + taskNum);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.currentThread().sleep(4000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;task &quot; + taskNum + &quot;执行完毕&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="7-FixedThreadPool详解"><a href="#7-FixedThreadPool详解" class="headerlink" title="7.FixedThreadPool详解"></a>7.<strong>FixedThreadPool详解</strong></h4><p>Executor框架最核心的类是ThreadPoolExecutor，通过Executor框架的工具类Executors，可以创建4种类型的ThreadPoolExecutor。</p>
<ol>
<li><p>最大的类型是自定义创建的类型(所有的参数自己输入)</p>
</li>
<li><p>FixedThreadPool。</p>
</li>
<li><p>SingleThreadExecutor。</p>
</li>
<li><p>CachedThreadPool。</p>
</li>
</ol>
<ul>
<li><p>为什么命名不同呢？ </p>
<ul>
<li><p>（不同的pool都是return new ThreadPoolExecutor）ThreadPoolExecutor参数不同导致的。</p>
</li>
<li><p>例如通过使用Executors的newFixedThreadPool创建的FixedThreadPool</p>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231210153132819.png" class title="image-20231210153132819"></li>
</ul>
</li>
<li><p>FixedThreadPool介绍</p>
<ul>
<li><p>FixedThreadPool被称为<strong>可重用固定线程数的线程池</strong>。FixedThreadPool的corePoolSize和maximumPoolSize都被设置为创建FixedThreadPool时指定的参数nThreads。<strong>当线程池中的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的最长时间</strong>，超过这个时间后多余的线程将被终止。这里把keepAliveTime设置为0L，意味着多余的空闲线程会被立即终止。</p>
</li>
<li><p>执行步骤</p>
<ul>
<li><p>1）如果当前运行的线程数少于corePoolSize，则创建新线程来执行任务。</p>
<p>2）在线程池完成预热之后（当前运行的线程数等于corePoolSize），将任务加入LinkedBlockingQueue。</p>
<p>3）线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue获取任务来执行。</p>
</li>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231210154714279.png" class title="image-20231210154714279"></li>
</ul>
</li>
<li><p>FixedThreadPool使用无界队列LinkedBlockingQueue(<strong>这个地方的无界指的是有没有在创建队列的时候手动的限制队列大小，而不是说队列元素有上限就是无界队列</strong>)作为线程池的工作队列<strong>（</strong>队列的容量为Integer.MAX_VALUE）。使用无界队列作为工作队列会对线程池带来如下影响。</p>
<p>1）当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize。</p>
<p>2）由于1，使用无界队列时<strong>maximumPoolSize将是一个无效参数</strong>。</p>
<p>3）由于1和2，使用无界队列时keepAliveTime将是一个无效参数。</p>
<p>4）由于使用无界队列，运行中的FixedThreadPool（未执行方法shutdown()或shutdownNow()）不会拒绝任务</p>
</li>
</ul>
</li>
</ul>
<h4 id="8-SingleThreadExecutor详解"><a href="#8-SingleThreadExecutor详解" class="headerlink" title="8.SingleThreadExecutor详解"></a>8.<strong>SingleThreadExecutor详解</strong></h4><p>SingleThreadExecutor是使用单个worker线程的Executor。属于FixedThreadPool的一种特殊情况</p>
<p>SingleThreadExecutor的corePoolSize和maximumPoolSize被设置为1。其他参数与FixedThreadPool相同。SingleThreadExecutor使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）。</p>
<img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231210155443356.png" class title="image-20231210155443356">

<h4 id="9-CachedThreadPool详解"><a href="#9-CachedThreadPool详解" class="headerlink" title="9.CachedThreadPool详解"></a>9.<strong>CachedThreadPool详解</strong></h4><p>CachedThreadPool是一个会根据需要创建新线程的线程池。</p>
<p>CachedThreadPool的corePoolSize被设置为0，maximumPoolSize被设置为Integer.MAX_VALUE，即maximumPool是<strong>无界的</strong>。这里把keepAliveTime设置为60秒，CachedThreadPool使用没有容量的SynchronousQueue作为线程池的工作队列，但CachedThreadPool的maximumPool是无界的。这意味着，如果主线程提交任务的速度高于maximumPool中线程处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下，CachedThreadPool会因为创建过多线程而耗尽CPU和内存资源。</p>
<ul>
<li><p>总结：</p>
<ul>
<li><p>对于fixed，single和 cache，我们在实际的工作中最多使用到的是 single（相对于fixed和cache）。一般情况下，对于并发量不高的场景，并且需要单条异步线程进行处理的时候，会使用一下 single。 真正的业务处理中，如果使用线程池，99%的情况下，需要自定义线程池（自己传入参数）。只有1%的情况会使用fixed，single和 cache。在这1%里，single稍微多一些。</p>
<p>Fixed和 single 容易造成我们的queue的消息无限积压，还会导致无法触发拒绝策略。所以一般没人用</p>
<p>Cache可能高并发下无法控制最高的线程创建数量，造成cpu和内存资源的消耗甚至耗尽。所以没人用</p>
<p>这三个，仅仅是为了让我们创建线程池的时候方便一些，不代表他们很实用。</p>
</li>
</ul>
</li>
</ul>
<h4 id="10-ScheduledThreadPoolExecutor详解"><a href="#10-ScheduledThreadPoolExecutor详解" class="headerlink" title="10.ScheduledThreadPoolExecutor详解"></a>10.<strong>ScheduledThreadPoolExecutor详解</strong></h4><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的<strong>延迟</strong>之后运行任务，或者<strong>定期</strong>执行任务。ScheduledThreadPoolExecutor的功能与Timer类似，但ScheduledThreadPoolExecutor功能更强大、更灵活。Timer对应的是单个后台线程，而ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数（创建线程池）。</p>
<ul>
<li><p>ScheduledThreadPoolExecutor的创建</p>
<ul>
<li><p>ScheduledThreadPoolExecutor的创建一般有以下三种方法</p>
</li>
<li><pre><code class="java">ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(5);
ScheduledExecutorService service = Executors.newScheduledThreadPool(5);
ScheduledThreadPoolExecutor pool
    = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(5);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 一般使用第三种方法，一方面使用Executors工具类便于new的创建，不许使用new这个关键词，另一方面，源码中就是直接new的ScheduledThreadPoolExecutor只不过返回值是ScheduledExecutorService，所以只需要对其强转，获取其子类就可以同时使用父类和子类的方法</span><br><span class="line"></span><br><span class="line">  - &#123;% asset_img image-20231210163550997.png image-20231210163550997 %&#125;</span><br><span class="line"></span><br><span class="line">* ScheduledThreadPoolExecutor常见方法</span><br><span class="line"></span><br><span class="line">  - schedule方法</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      pool.schedule(new STask(1), 5, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

- 第一次参数是要执行的任务，第二个参数是要延迟多少时间执行，第三个参数是时间的单位
</code></pre>
</li>
<li><p>scheduleAtFixedRate方法</p>
<ul>
<li><pre><code class="java">pool.scheduleAtFixedRate(new STask(1), 5, 5, TimeUnit.SECONDS);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 第一次参数是要执行的任务，第二个参数是要延迟多少时间执行，第三个参数是执行的周期时间，第四个参数是时间的单位</span><br><span class="line"></span><br><span class="line">- scheduleWithFixedDelay方法</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    pool.scheduleWithFixedDelay(new STask(1), 5, 5, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>参数含义和第二个方法完全一致</p>
</li>
</ul>
</li>
<li><p>scheduleAtFixedRate方法和scheduleWithFixedDelay方法的区别</p>
<ul>
<li>scheduleWithFixedDelay的周期执行是等待上一次任务执行完成后才开始计算下一次要执行任务的时间，例如第一次执行任务在0秒开始，然后耗时4秒，第二次执行就会在第9秒开始执行，而scheduleWithFixedDelay的周期执行不会管上一次任务是否执行完毕，严格按照在周期在第5秒，第10秒的时间进行执行(注意：如果第一次执行任务的耗时超过了周期时间，比如第一次耗时6秒，周期是5秒，那么第二次任务的开始时间就是第6秒，因为task是周期执行的，下一次执行的时间是在上一个任务执行完成后进行计算，并且 add 到我们的delayQueue里。现在如果是一个 while循环，那么永远不能执行结束我们的ScheduledThreadPoolExecutor就没有办法再次的重新计算时间，并且从新添加到我们的delayQueue中。)</li>
</ul>
</li>
<li><p>延时执行的实现方式就是把传入的任务，延迟时间，周期时间封装成一个ScheduledFutureTask，然后放入到延时队列中，获取任务并执行的逻辑和延迟队列相同(看队列中第一个任务是不是空，或者第一个任务是否到期可执行，如果可以则赶紧执行，否则继续等待)</p>
<ul>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231210165113464.png" class title="image-20231210165113464"></li>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231210165709980.png" class title="image-20231210165709980"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="11-FutureTask详解"><a href="#11-FutureTask详解" class="headerlink" title="11.FutureTask详解"></a>11.FutureTask详解</h4><p><strong>Future接口</strong>和<strong>实现Future接口的FutureTask类</strong>，代表异步计算的结果。</p>
<p>FutureTask除了实现Future接口外，还实现了Runnable接口。因此，FutureTask可以交给Executor执行，也可以由调用线程直接执行（FutureTask.run()）。根据FutureTask.run()方法被执行的时机，FutureTask可以处于下面3种状态。</p>
<p>1）未启动。FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态。当创建一个FutureTask，且没有执行FutureTask.run()方法之前，这个FutureTask处于未启动状态。</p>
<p>2）已启动。FutureTask.run()方法被执行的过程中，FutureTask处于已启动状态。</p>
<p>3）已完成。FutureTask.run()方法执行完后正常结束，或被取消（FutureTask.cancel（…）），或执行FutureTask.run()方法时抛出异常而异常结束，FutureTask处于已完成状态。</p>
<ul>
<li><p>使用FutureTask.get()方法的几种结果</p>
<ul>
<li>当FutureTask处于未启动或已启动状态时，执行FutureTask.get()方法将导致调用线程阻塞</li>
<li>当FutureTask处于已完成状态时，执行FutureTask.get()方法将导致调用线程立即返回结果或抛出异常。</li>
</ul>
</li>
<li><p>使用FutureTask.cancel()方法的几种结果</p>
<ul>
<li>当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将导致此任务永远不会被执行；</li>
<li>当FutureTask处于已启动状态时，执行FutureTask.cancel（true）方法将以中断执行此任务线程的方式来试图停止任务；</li>
<li>当FutureTask处于已启动状态时，执行FutureTask.cancel（false）方法将不会对正在执行此任务的线程产生影响（让正在执行的任务的线程正常运行完成）；</li>
<li>当FutureTask处于已完成状态时，执行FutureTask.cancel（…）方法将返回false。</li>
</ul>
</li>
<li><p>FutureTask的使用示例</p>
<ul>
<li><pre><code class="java">public class FutureTaskTest &#123;
    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;
        TaskTest task = new TaskTest();
        //方式一：放到线程池中执行
        Future submit = Executors.newSingleThreadExecutor().submit(task);
        System.out.println(submit.get());
        //方式二：调用线程直接执行
        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(task);
        futureTask.run();
        System.out.println(futureTask.get());
    &#125;

    private static class TaskTest implements Callable &#123;
        @Override
        public String call() throws Exception &#123;
            Thread.sleep(5000);
            return &quot;Hello world!&quot;;
        &#125;
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 两个关键字</span><br><span class="line"></span><br><span class="line">* volatile </span><br><span class="line">  * 保证可见性</span><br><span class="line">    * 可见性是让其他线程可见，现在的处理器都是多核的处理器，多核处理器就有多核CPU，每个CPU理论上可以提供一条线程，多个线程共同修改一个volatile 修饰的共享变量的时候，一旦一个线程拿到修改权限并且修改完之后，会立即把修改后的值过**总线**推送到主存中，此时其他的CPU会一直嗅探总线的数据流通，在**缓存一致性协议**的保障下，他能够嗅探到这条数据的修改，如果自己的缓存行中有这条数据，就会把这条数据置为不可用，当该线程再次用到这条数据的时候，需要在主存中重新读取，并保存到自己缓存行中</span><br><span class="line">    * 关于CPU在嗅探总线的数据流通的时候，它这么知道这个数据就是volatile 修饰的呢？</span><br><span class="line">      * 当一个数据被volatile修饰后，被一个线程修改，并通过总线保存到主存时，它的汇编指令的码会在里面加一个lock关键词，lock指令有两层含义，第一，是将信息的修改推送到主存；第二，lock指令过总线的时候其他CPU会嗅探含有lock的指令，然后置其他缓存行为不可用</span><br><span class="line">  * 禁止指令重排序</span><br><span class="line">    * volatile写之前加入storestore屏障，表示上面的普通写和volatile写不能重排序</span><br><span class="line">    * volatile写之后加入storeload屏障，表示下面的volatile读写和volatile写不能重排序</span><br><span class="line">    * volatile读之后加入loadload屏障，表示下面的普通读和volatile读不能重排序</span><br><span class="line">    * volatile读之后加入loadstore屏障，表示下面的普通写和volatile读不能重排序</span><br><span class="line">  * 在特殊情况下还能保证原子性</span><br><span class="line">    * 比如volatile修饰的变量i，进行i++操作的时候，就不能保证原子性，因为i++有三条JVM指令字节码。第一条，i load读取i这个变量；第二条，i add进行加一的操作；第三条，i store然后把相加后结果写回。所以被volatile修饰的变量是单条JVM指令字节码的时候就可以保证原子性，而volatile修饰的变量是多条JVM指令字节码的时候就不能保证原子性</span><br><span class="line">* synchronized</span><br><span class="line">  * 三种使用方式</span><br><span class="line">    * 作用到代码块上(锁可以是Object类型的成员变量，也可以使用this作为锁)</span><br><span class="line">    * 多用在静态方法上(锁是当前的Class，因为静态方法在调用的时候是 类.方法 的形式进行调用，不需要创建对象，所以只能使用当前类的Class作为锁)</span><br><span class="line">    * 作用到普通方法上(锁是当前的类的对象)</span><br><span class="line">  * 有一个Student类，其中有一个int类型的成员变量，同时提供set和get方法。给int变量加上volatile修饰可以保证原子性，因为set和get都是对应单条JVM字节码指令；不给int变量加上volatile进行修饰，而是给get和set方法加上synchronized也可以保证原子性</span><br><span class="line">    * 如果此时get操作多，set操作少，即读多写少的场景，volatile的方法更快，因为如果不对volatile修饰的变量进行修改，那么每个线程可以直接从线程的缓存行里面直接拿到</span><br><span class="line">    * 如果此时get操作少，set操作多，即读少写多的场景，这个时候volatile就慢了，此时volatile修饰的变量一直修改，一直过总线写到主存中，其他的CPU一直在嗅探总线，一直把自己缓存行的数据置为不可用，每次都要透过总线从主存中拉取最新数据，严重损耗计算机的总线资源，synchronized这是就比较快了，因为写比较多，一个线程写的时候其他线程处于BLOCK状态，对于set方法来说处理器执行的是非常快的，也就是其他线程BLOCK的时间会非常短，*重量级锁可以提高程序的吞吐量*</span><br><span class="line"></span><br><span class="line">#### Lock</span><br><span class="line"></span><br><span class="line">*lock相关的问题比较繁杂，所以要找到一个好的切入点进行总结，先从lock和synchronized的区别切入*</span><br><span class="line"></span><br><span class="line">##### 区别</span><br><span class="line"></span><br><span class="line">* synchronized是一个关键字，lock是一个接口，使用lock的话需要new出其子类来</span><br><span class="line">  - lock接口中的方法</span><br><span class="line">    - lock()方法：加锁</span><br><span class="line">    - unlock()方法：锁释放</span><br><span class="line">    - tryLock()方法：可以非阻塞的进行加锁</span><br><span class="line">    - tryLock(long time , TimeUnit unit)方法：可以超时性的非阻塞式加锁</span><br><span class="line">    - lockInterruptibly()方法：可中断式加锁</span><br><span class="line">    - newCondition()方法：配合实现等待通知机制</span><br><span class="line">  - 常用的实现子类是ReentrantLock和ReentrantReadWriteLock</span><br><span class="line">* synchronized是隐式加锁，lock是显式加锁</span><br><span class="line">  - synchronized肉眼看不到加锁和解锁的过程，lock一定要在finally代码块中释放锁</span><br><span class="line">* synchronized可以作用到方法和代码块上，lock只能作用到代码块上</span><br><span class="line">  - synchronized三种加锁方式</span><br><span class="line">    - 加到静态方法上使用的当前类的Class</span><br><span class="line">    - 加到普通方法上使用的当前类的对象</span><br><span class="line">    - 加到代码块上可以用this关键字，也可以new一个Object对象</span><br><span class="line">    - lock加锁就不用多说了，只能加在代码块上，同时别忘了进行锁的释放</span><br><span class="line">  - synchronized作用到代码块上和作用到方法上，使用javap命令反编译成字节码指令有什么区别</span><br><span class="line">    - synchronized作用到代码块上反编译之后，在代码块进入的点有一个monitorenter指令，在代码块出的点有一个monitorexit指令，而且monitorexit这个指令最少要有两个，一个是正常出代码块释放锁，一个是发生异常释放锁</span><br><span class="line">    - synchronized作用到方法上会在方法的flag上加一个acc_synchronized，**后续学完JVM进行详细补充**</span><br><span class="line">* lock支持非阻塞式加锁</span><br><span class="line">  - lock接口中有两个关于非阻塞式加锁的方法，tryLock()方法和tryLock(long time , TimeUnit unit)方法，如果尝试获加锁失败直接返回，不会阻塞线程，那么线程就不会从用户态转为内核态，少一次线程上下文切换</span><br><span class="line">* lock支持可超时性加锁</span><br><span class="line">  - tryLock(long time , TimeUnit unit)方法可以超时性加锁，一定时间内尝试加锁失败了，直接返回，是一个避免发生死锁的好办法</span><br><span class="line">* lock支持可中断式加锁</span><br><span class="line">  - 可中断的意思是一个线程在运行的时候，另一个线程想要对这个线程进行中断，lock中的lockInterruptibly()方法可以接受这种中断，synchronized做不到这一点</span><br><span class="line">* synchronized采用对象监视器，lock采用AQS</span><br><span class="line">  - 两个线程竞争一个synchronized锁，一条线程竞争成功，另一条线程竞争失败进入到ObjectMonitor中的EntryList(同步队列)，等到当前执行线程释放锁，被唤醒以后才重新进入到锁的竞争，但是当前执行线程调用了wait方法释放锁以后，会进入到ObjectMonitor中的WaitSet(等待队列)中</span><br><span class="line">  - AQS根据一个int类型的state变量，来确定这个锁有没有被获取，如果被获取则会加入到AQS双端队列的尾部，这里注意此时有可能是大量的线程同时竞争锁失败，然后同时放到双端队列的尾部，此时就会有线程安全的问题，这里采用的CAS的方式来保证进入双端队列尾部的线程安全，当获取锁的线程执行完成释放锁的时候，会通知自己的后继节点进行锁的竞争</span><br><span class="line">* 在加锁和解锁时，synchronized有一个同步队列和一个等待队列，lock有一个同步队列和多个等待队列</span><br><span class="line">  - lock可以new出多个Condition，一个Condition就有一个等待队列</span><br><span class="line">* 锁竞争方面，synchronized只支持非公平锁，lock支持非公平锁和公平锁</span><br><span class="line">  - 到底什么叫公平，什么叫非公平(场景举例)</span><br><span class="line">    - 假设此时有A,B,C三条线程对lock锁进行竞争，A线程获取到锁了，B,C线程要依次进入到双端队列中进行等待，当A线程执行完成释放锁，唤醒B线程进行锁的竞争时，此时又来了另外十条线程竞争这个lock，如果B和这十条线程进行锁的竞争那么就是不公平，因为B线程已经在队列中排队等待了很久了，如果B不用和新来的线程竞争(新来的十条线程在CAS的保证下直接加入到双端队列的尾端)那么就是公平的</span><br><span class="line">  - 新来的十条线程怎么知道这是一个公平锁，并且加入到队列的？</span><br><span class="line">    - 新来的线程对于公平锁的竞争之前，会进行一个判断，就是判断自己是否有前置节点，如果没有就进入到队列排队，但是对于非公平锁的竞争就不会有这个判断</span><br><span class="line">  - 非公平锁的线程饥饿问题？</span><br><span class="line">    - 一条线程在竞争失败后进入到等待队列进行等待，下一次再次失败再次等待，如此反复线程一直处于等待状态，这就叫做线程饥饿</span><br><span class="line">* 对于等待唤醒机制，synchronized与Object进行配合，lock与Condition接口进行配合</span><br><span class="line">  * synchronized与Object的wait/notify进行配合</span><br><span class="line">  * lock与Condition接口await和signal进行配合</span><br><span class="line">    - 拿到lock锁的线程，调用await方法时，就会进入到Condition的等待队列的尾节点中，**不需要使用CAS直接加就行**，因为线程在调用await方法之前先回把自己加入到等待队列的尾部，正因为此时还没有调用await方法，线程还持有着锁，所以进入到尾节点的时候不用CAS</span><br><span class="line">  * 调用await方法之后，这个线程经历了什么？</span><br><span class="line">    - 拿到lock锁的线程，调用await方法时，就会进入到Condition的等待队列的尾节点中，当他达到队列的头部时会被唤醒，此时这条线程会重新竞争lock锁，一旦竞争失败会使用CAS加入到同步队列的尾端，排队到同步队列的头部，直到他的前置节点线程释放锁以后，根据是否是公平锁重新竞争，竞争失败继续等待，竞争成功继续执行完await后面的逻辑</span><br><span class="line">* lock锁可以根据需要进行个性化开发 </span><br><span class="line">* ReentrantReadWriteLock支持并发读</span><br><span class="line">  * 读-读可以并发执行，读-写，写-读，写-写 都不可以并发执行</span><br><span class="line">  * 通过一个int类型的state变量来控制读写权限，他把一个32位的int变量分成高16位和低16位，高16位负责控制读，低16位负责控制写。当一个读线程来的时候会检查低16，如果低16位为0说明没有写线程，直接对高16位加一，然后进行读取，如果有写线程那么就会被阻塞。当一个写线程来的时候会检查高16位和低16位，此时不管是有写还是有读直接被阻塞，这是ReadWriteLock的加锁细节。如果是ReentrantReadWriteLock(表示可重入读写锁)的话，加读锁的时候，如果低16位不为0，会先判断持有写锁的线程是不是当前线程，如果是也会在高16位加一，加写锁的时候，如果低16位和高16位都不为0，此时会先判断持有这些锁的线程是不是当前线程，如果是则会在低16位加一</span><br><span class="line"></span><br><span class="line">#### 锁升级</span><br><span class="line"></span><br><span class="line">*背景：32位JVM虚拟机*</span><br><span class="line"></span><br><span class="line">* 无锁状态</span><br><span class="line"></span><br><span class="line">  - 当我们新创建一个对象的时候，它的对象头MarkWord里有25位的HashCode，4位的对象分代年龄，1位的偏向锁标记位，2位的锁标记位</span><br><span class="line">  - **当我们仅仅只是用new关键字创建一个对象的时候，此时如果没有显式/隐式的调用Object里面的hashCode方法，那么hashCode的值不会存储在对象头中**，此时的占位是0</span><br><span class="line">    - 显示调用hashCode：比如在类的构造器中直接调用super.hashCode()方法，这样我们对象头的MarkWord中是有hashCode的</span><br><span class="line">    - 隐式调用hashCode：比如在构造函数中，对象创建完毕的一瞬间直接把该对象放入到了HashMap，HashSet这样的类Hash集合中，因为put方法的第一个参数就是哈希值，这个哈希值就是靠调用Object类的hashCode方法得到的</span><br><span class="line">    - 如果该类重写了hashCode方法，然后在对象的创建过程中调用了重写以后的hashCode方法，那么同样不会把hashCode的值存放到对象头的MarkWord中，**必须调用父类的hashCode方法才会把值存到对象头的MarkWord中**</span><br><span class="line">  - 对于分代年龄，此时由于对象刚刚创建，没有分代年龄，所以还是以0表示</span><br><span class="line">  - 对于锁标记位，无锁状态和偏向锁状态的锁标记位都是01，他们的区别在于偏向锁标记位，无锁的偏向锁标记位是0，偏向锁状态的偏向锁标记位是1</span><br><span class="line"></span><br><span class="line">* 无锁状态升级为偏向锁</span><br><span class="line"></span><br><span class="line">  - 无锁状态想要升级位偏向锁状态，此时**对象头的MarkWord中必须不能有hashCode值**，理论上hashCode这个位置要保存上23位的线程ID和2位的Epoch，但是如果这个位置有hashCode的值就会对这个值进行覆盖，因为hashCode值没有替换这个逻辑也无法对这个值进行保存，所以这个行为是不允许的，所以此时就不能成为偏向锁</span><br><span class="line">  - 如果想要成为偏向锁的对象的对象头的MarkWord没有存放hashCode值，此时就可以把线程ID放到前23位，Epoch的值放到后2位，偏向锁标记位从0变成1，锁标记位还是01不变</span><br><span class="line">  - 偏向锁的好处在于，当一个线程想要再次获取锁，可以直接检查一下MarkWord里面保存的线程ID是不是当前线程的ID，如果是那么直接加锁成功，性能会有所提升</span><br><span class="line"></span><br><span class="line">* 偏向锁升级为轻量级锁</span><br><span class="line"></span><br><span class="line">  - 发生线程竞争的时候偏向锁一定会升级为轻量级锁吗？</span><br><span class="line">  - 偏向锁升级为轻量级锁发生了线程的竞争这句话是对的，但是反过来说就不一定对了，例如下面加粗斜体的例子，虽然有线程的竞争但是锁的偏向发生了改变但是没有升级为轻量级锁</span><br><span class="line">  - 偏向锁升级为轻量级锁的过程：***加入A线程获取到了偏向锁把自己的线程ID存放到MarkWord中，此时又来了一个B线程也想要获取偏向锁，他会先检查锁标记状态是不是01，偏向锁标记位是不是1，如果锁标记位是01，且偏向锁标记位是1，那么线程B就知道此时这个锁已经有线程偏向了，这时线程B会检查线程A的线程存活状态，如果此时A线程没有在执行同步代码，那么B线程会直接把这个偏向锁置为无锁状态，然后去竞争这个偏向锁，如果竞争成功则把自己的线程ID放入到MarkWord当中，此时偏向锁就偏向B线程了***，但是如果线程B争抢失败了，线程C争抢成功了，把线程C的ID存放到了MarkWord中并执行线程C对应的代码，这是时候线程B就很烦，他会执行一个更加高级的操作，叫做**偏向锁的撤销**，线程B会等待线程C执行到JVM安全点，对线程C的栈进行遍历，遍历的是锁记录，遍历完成可能会有三种情况</span><br><span class="line">  - 可能会直接把锁的状态变为无锁状态，然后把锁标记位置为00，即轻量级锁</span><br><span class="line">      - 这个地方可以理解为锁从偏向锁直接升级为轻量级锁，所谓把锁的状态变为无锁状态就是把锁标记位置为00，并且把偏向线程ID和Epoch置为空，偏向锁标记位是0。之所以上面说把锁的状态变为无锁状态，是因为真正的轻量级锁的对象头应该除了2位的锁标记位之外，其余的30位都应该指向栈帧中锁记录的指针，但是此时的状态比较**游离**，暂且理解为无锁状态</span><br><span class="line">  - ***可能会把偏向锁重新偏向到线程B***</span><br><span class="line">      - JVM除了有开启偏向锁的配置之外，还有批量重偏向和批量撤销的操作。场景举例：比如有一个Student类，然后这个Student类创建了40个对象，线程A把这四十个对象进行偏向锁的加锁操作，然后线程A一直对这四十个对象保持代码的执行，此时来了个线程B，**线程B要对这四十个对象进行锁撤销的操作**，此时这1-19个对象直接升级为轻量级锁也就是上面所说的游离状态，当执行到第20个对象时，JVM就会反思自己是不是最开始的时候偏向错了，然后就把后面的20-39个对象批量重偏向到线程B，因为JVM里有配置批量偏向锁的阈值是20，但是当线程B撤销到第40个对象的时候，此时已经有20个对象偏向给线程B了，线程B还在继续要求偏向，JVM又不高兴了，既然这个对象的竞争这么激烈那么你就不适合作为偏向锁，然后直接把这个对象置为不可使用偏向锁</span><br><span class="line">    - 可能会把该锁直接置为不可使用偏向锁</span><br><span class="line">      - 书接上文，至于置为不可使用偏向锁体现在new出第41个student对象的时候，此时该对象的对象头的MarkWord的锁标记位直接就是00，其实JVM这个地方还有一个默认参数，也就是两万五千毫秒，如果25秒以内批量撤销没有达到40这个阈值，那么从20-39的这个重偏向可以重新计数，**也就是说25秒内批量撤销没有达到阈值，那么此时就不会发生置为不可使用偏向锁这一状态**</span><br><span class="line">  </span><br><span class="line">* 轻量级锁record</span><br><span class="line"></span><br><span class="line">  - 竞争过程：假设此时多条线程竞争时，如果A线程竞争成功了，A线程会直接把锁对象头里的MarkWord里面的25位hashCode，4位的分代年龄和1位的偏向锁标记，这30位的内容复制到A线程的栈帧中的一个叫做lockRecord即锁记录中，然后把对象头的MarkWord中对应的30位的位置放上一个指向当前线程栈帧中lockRecord这块区域的一个指针，当B线程来竞争轻量级锁的时候，他会使用CAS的方式把锁对象头对应位置的内容放到自己栈帧的lockRecord中，此时肯定是失败的，因为锁对象头本来该存放的hashCode，分代年龄等内容已经被替换成了指针了，此时B线程会进行一个CAS的自旋，再次尝试替换，默认循环十次，如果这十次还没有成功，那么轻量级锁将会升级为重量级锁</span><br><span class="line">  - 轻量级锁升级为重量级锁： 自旋十次没有成功的B线程，会把原本指向A线程中栈帧的lockRecord的指针替换为指向重量级锁的指针即ObjectMonitor，此时线程A执行完对应代码要使用CAS进行锁的释放时，会发现此时锁对象头内的指针已经不是轻量级锁的指针了，已经变成了重量级锁的指针了，所以这个时候他就知道要进行重量级锁解锁的过程了</span><br><span class="line">  - 重量级锁解锁的过程：线程A会先把栈帧中lockRecord记录的hashcode，分代年龄等内容保存到ObjectMonitor的header属性中保证这些内容不丢失，然后把ObjectMonitor的owner属性保存成自己</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 双重检查锁</span><br><span class="line"></span><br><span class="line">*双重检查锁是基于单例模式的两次改造，第一次改造实是在synchronized同步代码块的外边，加一个判空处理，减少一些线程对于锁的竞争而变为阻塞状态，导致从用户态转化为内核态对于资源的消耗，这样会导致一些问题，因为在new对象的时候有三个步骤，第一，开辟一块内存空间，第二，初始化对象，第三，把instance指向这片内存空间，此时如果不用volatile修饰的话，可能会导致第二步和第三步发生指令重排序，在多线程的情况下其他线程访问到判空处理那一步时，他只会关心这个instance是否有指向，所以此时他会认为instance已经初始化好了，导致得到一个错误的结果*</span><br><span class="line"></span><br><span class="line">***加上volatile修饰的话会导致第二步和第三步不会发生重排序***，这句话是错误的！！！！！！！！！！！</span><br><span class="line"></span><br><span class="line">因为当我们new一个对象的时候，new是写在我们Java代码里面的，new这个关键词对应的JVM字节码指令也是new，volatile作为Java中的一个关键词，他做的添加屏障只能做到JVM字节码指令这个级别，它无法涉及到new这个关键词带来的更加底层的操作，也就是创建对象的那三步操作，这就像lock锁锁住了三行代码，在这三行代码执行结束前其他的线程进不来，而volatile就像是包住了new的这个过程保证了创建对象结束前其他线程进不来，从而保证线程安全</span><br><span class="line"></span><br><span class="line">#### 线程状态转化</span><br><span class="line"></span><br><span class="line">*new 一个线程出来进入new状态，然后调用start方法进入runnable状态，在runnable状态下调用join，wait，park方法会进入waiting状态，调用sleep，wait(long)等方法会进入到timed_waiting状态，加锁失败的话会进入到blocked状态，最后是线程的TERMINATED终止状态，在Java的Thread类中的state内部枚举类中只有这六种状态*</span><br><span class="line"></span><br><span class="line">**网上说的七种状态区别在于把runnable状态分成了running状态和ready状态，在running状态的线程调用了yield方法会进入到ready状态，此时放弃了CPU的执行权**</span><br><span class="line"></span><br><span class="line">* NEW状态</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">/**</span><br><span class="line"> * Thread state for a thread which has not yet started.</span><br><span class="line"> */</span><br><span class="line">NEW</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>线程还没有开始的状态，也就是说还没有调用start方法</p>
<ul>
<li>RUNNABLE状态</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment"> * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment"> * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment"> * such as processor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RUNNABLE</span><br></pre></td></tr></table></figure>

<p>在JVM中线程已经开始了，但会因为其他的一些调用进入到waiting状态</p>
<ul>
<li>WAITING状态</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment"> * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment"> * following methods:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment"> * perform a particular action.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WAITING</span><br></pre></td></tr></table></figure>

<p>在调用wait，join，park方法后会进入到waiting状态，调用notify，unpark等方法会使线程从waiting状态切换到runnable状态</p>
<ul>
<li>TIMED_WAITING状态</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment"> * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment"> * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TIMED_WAITING</span><br></pre></td></tr></table></figure>

<p>在调用sleep，wait(long)，join，parkNanos，parkUntil这些方法后会进入到TIMED_WAITING状态</p>
<ul>
<li>BLOCKED状态</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment"> * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment"> * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment"> * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BLOCKED</span><br></pre></td></tr></table></figure>

<p>只有在synchronized代码块或者synchronized修饰的方法的范围内才有可能进入到BLOCKED状态</p>
<ul>
<li>TERMINATED状态</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment"> * The thread has completed execution.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TERMINATED</span><br></pre></td></tr></table></figure>

<p>线程运行完毕，执行结束</p>
<ul>
<li>锁释放(使用join来说明)</li>
</ul>
<p>join方法底层也调用了wait方法，但是很多博客文章上说调用join方法不会释放锁，他会释放锁，但是他释放的是调用join方法的线程对应的对象的锁，举个例子，在synchronized(Object obj)代码块里面创建一个thread1线程，然后thread1线程调用join方法，此时释放的不是obj这个对象锁，而是thread1线程自身对象的Object Monitor锁</p>
<ul>
<li>waiting和timed_waiting的区别</li>
</ul>
<p>time_waiting状态不用唤醒，等时间到了以后自动执行后续代码，waiting状态需要显式或者隐式的唤醒，显式唤醒就是通过调用wait或者park方法进入waiting状态，通过调用notify或者unpark方法进行唤醒，隐式唤醒就是通过调用join方法，等到其他线程执行结束后会在线程内部接收到一条消息，然后执行后面的代码</p>
<ul>
<li>有了waiting和timed_waiting这两种状态为什么还要一个blocked状态</li>
</ul>
<p>线程在竞争锁失败后会进到EntryList同步队列，线程状态变为blocked状态，线程在调用wait方法进入到WaitSet等待队列，线程进入到waiting状态，当waiting状态被唤醒时会重新进行锁的竞争，此时如果竞争失败，那么会进入到EntryList同步队列，状态变位block，所以此时状态和队列进行了一个对应，为了把不同的线程状态进行一个更加细致的划分</p>
<h3 id="并发编程重点问题"><a href="#并发编程重点问题" class="headerlink" title="并发编程重点问题"></a>并发编程重点问题</h3><ul>
<li><p>进程和线程的区别</p>
<ul>
<li>进程是系统进行资源分配和调度的基本单位，线程是进程的一个执行路径，一个进程最少有一个线程，进程中的每个线程共享进程中的资源</li>
<li>操作系统分配资源的时候是分配给进程的，而CPU分配资源是分配给线程的，真正占用CPU的是线程，所以说线程是CPU分配的基本单位</li>
<li>一个进程中的多个线程共享进程的堆和方法区的资源，每个线程有自己的程序计数器和栈区域</li>
</ul>
</li>
<li><p>为什么将程序计数器设为线程私有的区域</p>
<ul>
<li>程序计数器记录线程当前要执行的指令地址，因为线程在用时间片轮转的方式的占用CPU，当前时间片用完后下次再次继续执行的时候，需要从线程私有的程序计数器这个内存区域拿到指定地址继续执行，如果要执行的是native方法那么程序计数器记录的undefined地址，只有要执行的是Java代码程序计数器记录的才是下一条指令的地址</li>
</ul>
</li>
<li><p>局部变量，对象实例，JVM加载的类，常量及静态常量都存在主存的哪个部分，是线程私有的吗？</p>
<ul>
<li>每个线程有自己的栈资源，该栈用于存储线程的局部变量，局部变量是线程私有的，除了局部变量，栈还可以用来存放线程的调用栈帧</li>
<li>new操作创建的实例对象存放在堆中，堆是进程在创建的时候分配的，是进程中最大的一块内存，所有线程可以共享</li>
<li>JVM加载的类，常量和静态常量放在方法区，也是线程共享的</li>
</ul>
</li>
<li><p>继承Thread类实现多线程的优劣</p>
<ul>
<li>好处：在run()方法中，想要获取当前线程的时候直接this就可以，不用Thread.currentThread()方法</li>
<li>坏处：Java不支持多继承，如果继承了Thread类就无法在继承其他的类了。</li>
</ul>
</li>
<li><p>IllegalMonitorStateException出现的原因</p>
<ul>
<li>调用wait()方法之前没有获得该对象的监视器锁</li>
</ul>
</li>
<li><p>什么是虚假唤醒，如何避免</p>
<ul>
<li><p>虚假唤醒指的是，一条线程在没有被其他线程调用notify(),notifyAll()方法进行通知，也没有被中断，也没有等待超时，这时如果还被唤醒那么就是虚假唤醒</p>
</li>
<li><p>可以在while循环中调用wait方法来防止虚假唤醒，只有满足while中条件才可以退出循环详见以下伪代码</p>
<ul>
<li><pre><code class="java">synchronized(obj)&#123;
    while(条件不成立)&#123;
        obj.wait();
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 调用共享对象的notify()方法后，会唤醒一个在该共享变量上调用wait的线程，这两个线程对于锁获取和释放的过程</span><br><span class="line"></span><br><span class="line">  - 首先一个线程一定是在拿到共享变量锁之后才能调用wait方法，调用wait方法后该线程会先释放锁，进入到WaitSet队列中进行等待，然后另外一条线程拿到该共享对象的锁，调用了notify方法唤醒了在队列中等待的线程，等到该线程释放了锁以后，被唤醒的线程会重新进行该共享对象的锁的竞争，只有竞争到锁后才能继续执行后序代码</span><br><span class="line"></span><br><span class="line">* join()方法和yeild()方法</span><br><span class="line"></span><br><span class="line">  - join方法的使用场景在需要多个线程同时完成某个事情的时候才继续向下执行，比如多个线程同时加载同一个资源，使用join方法可以等到所有线程完成后进行汇总处理，join方法底层就是使用了while循环和wait方法实习无限等待和带时间参数的等待</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      //join方法源码</span><br><span class="line">      public final synchronized void join(long millis)</span><br><span class="line">          throws InterruptedException &#123;</span><br><span class="line">              long base = System.currentTimeMillis();</span><br><span class="line">              long now = 0;</span><br><span class="line">      </span><br><span class="line">              if (millis &lt; 0) &#123;</span><br><span class="line">                  throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">      </span><br><span class="line">              if (millis == 0) &#123;</span><br><span class="line">                  while (isAlive()) &#123;</span><br><span class="line">                      wait(0);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  while (isAlive()) &#123;</span><br><span class="line">                      long delay = millis - now;</span><br><span class="line">                      if (delay &lt;= 0) &#123;</span><br><span class="line">                          break;</span><br><span class="line">                      &#125;</span><br><span class="line">                      wait(delay);</span><br><span class="line">                      now = System.currentTimeMillis() - base;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>线程的执行需要操作系统分配时间片来轮询占用CPU，正常情况下当时间片用完后，线程调度器会进行下一轮线程调度，而调用了yeild方法，表示线程告诉线程调度器虽然现在分配的时间片还没用完，但是此时可以进行下一轮的线程调度了，此时该线程让出CPU的使用权，线程计数器可以从就绪队列中找出一个优先级最高的线程执行</p>
</li>
</ul>
</li>
<li><p>sleep()方法和yeild()方法的区别</p>
<ul>
<li>调用了sleep方法的线程处于阻塞状态，且线程调度器在指定时间内不会调度该线程</li>
<li>调用了yeild方法的线程处于就绪状态，如果该线程的优先级较高线程调度器可能下一次调度仍然调度到当前线程执行</li>
</ul>
</li>
<li><p>interrupt(),isInterrupted()和interrupted()的特点和区别</p>
<ul>
<li>interrupt方法表示中断线程，例如线程A正在执行，线程B调用线程A的interrupt方法，会使线程A的线程中断标记为true，但是此时的线程不会真正中断，还需继续向下执行后面的代码，如果线程A调用了wait，sleep，join方法挂起阻塞，此时线程B还调用线程A的interrupt方法，就会在调用方法的地方抛出InterruptedExpection</li>
<li>isInterrupted方法用于判断某个线程是否被中断，如果被中断返回true，没有被中断返回false</li>
<li>interrupted方法也是用于判断某个线程是否被中断，如果被中断返回true，没有被中断返回false，与isInterrupted不同的是调用interrupted方法后发现线程已被中断，那么此时会清除中断标记，并且interrupted是static方法；interrupted调用的是currentThread()的native方法isInterrupted，而isInterrupted调用的是实例对象的native方法，其中native方法的传参如果是true表示清除中断标志，是false表示不清除中断标志</li>
</ul>
</li>
<li><p>什么是死锁</p>
<ul>
<li>死锁是两个或两个以上的线程在执行过程中，为了获取某一资源而相互等待的现象，在无外力帮助的情况下会一直等待下去无法继续运行，例如线程A持有资源1，想要资源2，线程B持有资源2，想要资源1，两个线程都在等待其他线程已经持有的资源就会一直等待下去处于死锁状态</li>
</ul>
</li>
<li><p>线程发生死锁的条件</p>
<ul>
<li><p>资源具有排他性，即资源在同一时刻只能由一条线程持有，另外的线程想要持有必须等待到当前线程释放该资源</p>
</li>
<li><p>持有某个资源的线程，想要获取其他被持有的资源的时候，进行等待，但此时该线程在阻塞期间不会释放原有的资源</p>
</li>
<li><p>持有的资源只能由自己使用完后释放，释放前其他线程不能抢占</p>
</li>
<li><p>发生死锁时，一定会有一条 线程 &#x3D;&gt; 资源的环形链，例如 T0线程 &#x3D;》T1线程占用的资源 &#x3D;》T2线程占有的资源。。。。&#x3D;》 Tn线程占有的资源 &#x3D;》 T0线程占有的资源</p>
<ul>
<li><p>类似伪代码</p>
</li>
<li><pre><code class="java">//线程A重写的run方法
synchronized(A)&#123;
    sleep(1000);
    synchronized(B)&#123;
        //do something
    &#125;
&#125;
//线程B重写的run方法
synchronized(B)&#123;
    sleep(1000);
    synchronized(A)&#123;
        //do something
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 如何避免死锁</span><br><span class="line"></span><br><span class="line">  - 要想避免死锁，只需破环形成死锁的四个条件中的至少一个条件，我们人为能进行破坏的只有第二条和第四条，破环的方法都是调整资源的访问顺序，保证资源获取的有序性。*所谓有序性，就是假如线程A，B都需要1，2，3....n这些资源，那么获取到资源n条件是已经获取了n-1这个资源*</span><br><span class="line"></span><br><span class="line">    - 以上代码进行如下优化，就会谦让有序不会发生死锁</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      //线程A重写的run方法</span><br><span class="line">      synchronized(A)&#123;</span><br><span class="line">          sleep(1000);</span><br><span class="line">          synchronized(B)&#123;</span><br><span class="line">              //do something</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //线程B重写的run方法</span><br><span class="line">      synchronized(A)&#123;</span><br><span class="line">          sleep(1000);</span><br><span class="line">          synchronized(B)&#123;</span><br><span class="line">              //do something</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对ThreadLocal的了解</p>
<ul>
<li>ThreadLocal是JDK包提供的，它提供的是每个线程的本地变量，也就是创建一个ThreadLocal变量以后，当有线程访问这个变量的时候都会有这个变量的本地副本，当多个线程对同一个变量进行操作的时候其实操作的是自己本地内存中的变量，可以避免线程安全问题。即创建ThreadLocal变量后，每个线程都会复制一个变量到自己的本地内存中</li>
</ul>
</li>
<li><p>ThreadLocal的原理</p>
<ul>
<li>Thread类中维护了两个ThreadLocalMap类型的变量，一个叫做threadLocals，一个叫做inheritableThreadLocals(下图1)，默认情况下这两个的值都为null，只有当该线程第一次调用ThreadLocal的set或get方法的时候才会创建他们，其实每个线程的本地变量不是存在ThreadLocal中的，而是存在threadLocals这个变量中的，ThreadLocal其实就是一个工具壳，它通过set方法把值存放到调用方法线程的threadLocals变量中，调用get方法再从当前线程的threadLocals变量中拿出来使用(如图2)，如果调用线程一直不终止那么这个本地变量就只存在当前线程的threadLocals中，之所以threadLocals的类型是ThreadLocalMap类型，是因为一个线程可以关联多个ThreadLocal变量(如图3)<ul>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231010225027854.png" class title="image-20231010225027854"></li>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231010225102302.png" class title="image-20231010225102302"></li>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231010225251621.png" class title="image-20231010225251621"></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>关于ThreadLocal的set方法</p>
<ul>
<li>set方法先是获取到当前线程，通过当前线程得到threadLocals这个成员变量，如果这个threadLocals不为null，那么就以this作为key，this代表当前对象，要set的值作为value，放到threadLocals这个map中，如果threadLocals为空，那么就调用cteateMap方法以当前线程为key，要set的值为value新建一个threadLocals对象<ul>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231012224747251.png" class title="image-20231012224747251"></li>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231012224757298.png" class title="image-20231012224757298"></li>
</ul>
</li>
</ul>
</li>
<li><p>ThreadLocal支持继承吗</p>
<ul>
<li>对于同一个ThreadLocal变量，父线程set的值，子线程是get不到的，因为父线程在set时候村的key是父线程，而子线程在get的时候是以当前线程作为key来获取的threadLocals，所以自然获取不到</li>
</ul>
</li>
<li><p>如何让子线程访问到父线程的ThreadLocal中的值</p>
<ul>
<li>可以使用InheritableThreadLocal，InheritableThreadLocal继承自ThreadLocal，同时重写了getMap，createMap，childValue方法，这个类的作用就是为了让父线程设置的本地变量子线程可以访问到，主要就是在Thread类的init方法，父线程在构造子线程的时候，先判断出父类的inheritableThreadLocals这个成员变量是否为空，如果不为空就把父线程中的inheritableThreadLocals这个变量复制一份保存到子线程的inheritableThreadLocals这个成员变量中</li>
</ul>
</li>
<li><p>InheritableThreadLocal的使用场景</p>
<ul>
<li>例如子线程需要访问父线程存放到ThreadLocal中的用户登录信息，其实子线程想要获取到父线程的信息还有其他的方式，例如在创建子线程的时候传入父线程的变量复制到子线程中，或者在父线程中构造一个map作为参数传递给子线程，但是这些方法违背了我们使用的习惯，这时InheritableThreadLocal类就显得很关键</li>
</ul>
</li>
<li><p>程序CPU100%，内存和IO利用率都正常，是什么原因，如何排查</p>
<ul>
<li>有可能发生死锁，通过java程序的进程ID，使用jstack命令dump出线程文件，查看所有线程处于什么状态，看看是否存在处于BLOCKED状态的线程</li>
</ul>
</li>
<li><p>volatile如何保证可见性</p>
<ul>
<li>被volatile修饰的变量在进行写操作的时候，会多出一个lock汇编代码，有了lock前缀在多核处理器会发生两件事，第一件事是将当前处理器缓存行的数据写回到系统内存，第二件事是其他CPU缓存该内存地址的数据置为无效，在多核处理器下，为了保证每个处理器的缓存是一致的，会实现缓存一致性协议，每个处理器在嗅探总线上的传输的数据检查自己缓存的数据是不是过期了，当发现缓存行对应的内存地址发生的修改，那么就会置该缓存行的数据为无效，当处理器再次对该数据进行修改操作的时候会重新从系统内存中重新读取数据保存到处理器缓存行中</li>
</ul>
</li>
<li><p>synchonized关键字的三种使用方式</p>
<ul>
<li>用在同步代码块上，此时锁是括号里面配置的对象</li>
<li>用在普通方法上，此时锁是当前实例对象</li>
<li>用在静态方法上，此时锁是当前类的Class对象</li>
</ul>
<p>当一个线程试图访问同步代码块的时候，必须要先获取到锁，在退出或者出现异常的时候必须释放锁</p>
</li>
<li><p>synchonized在JVM的实现原理</p>
<ul>
<li>JVM是基于进入和退出Monitor对象来实现同步方法和同步代码块，二者的实现细节略有不同<ul>
<li>对于同步代码块来说，在编译后会在进入同步代码块之前会加一个monitorenter指令，在同步代码块结束退出或者发生异常的地方monitorexit指令，任何一个对象都有一个monitor与之关联，当monitor被持有后将处于锁定状态，线程执行到monitorenter的时候会尝试获取对应monitor的所有权，即尝试获取对象的锁</li>
<li>对于同步方法来说，通过反编译得到字节码后可以发现，在方法的flags中多了一个ACC_SYNCHONIZED标志，这会告诉JVM这是一个同步方法</li>
</ul>
</li>
</ul>
</li>
<li><p>synchonized锁信息在对象的存储位置</p>
<ul>
<li><p>无锁状态</p>
<ul>
<li><table>
<thead>
<tr>
<th>锁状态</th>
<th>25bit</th>
<th>4bit</th>
<th>1bit是否是偏向锁</th>
<th>2bit锁标志位</th>
</tr>
</thead>
<tbody><tr>
<td>无锁状态</td>
<td>对象的hashCode</td>
<td>对象分代年龄</td>
<td>0</td>
<td>01</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>不同的加锁状态</p>
<ul>
<li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231027113647593.png" class title="image-20231027113647593"></li>
</ul>
</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://monkey918857.github.io">Inequalities</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://monkey918857.github.io/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">https://monkey918857.github.io/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://monkey918857.github.io" target="_blank">Inequalitiesの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></div><div class="post_share"><div class="social-share" data-image="https://www.toopic.cn/public/uploads/small/1658044853457165804485391.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="数据结构算法笔记"><img class="cover" src="https://www.toopic.cn/public/uploads/small/1695101465702169510146570.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构算法笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Inequalities</div><div class="author-info__description">欢迎访问Inequalitiesの博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/monkey918857"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/monkey918857" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/472353013?spm_id_from=444.41.0.0" target="_blank" title="小破绽"><i class="fab fa-algolia"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">非科班转码小猴的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%88%9D%E6%8E%A2"><span class="toc-text">并发编程初探</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Java%E5%A4%A9%E7%94%9F%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.Java天生的多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-text">2.线程的优先级和守护线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-text">3.线程状态转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-init%E6%96%B9%E6%B3%95%E5%92%8Cstart%E6%96%B9%E6%B3%95"><span class="toc-text">4.init方法和start方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-sleep%E6%96%B9%E6%B3%95%E5%92%8Cwait%E6%96%B9%E6%B3%95"><span class="toc-text">5.sleep方法和wait方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-join%E6%96%B9%E6%B3%95"><span class="toc-text">6.join方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">7.线程间的通信方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-ThreadLocal"><span class="toc-text">8.ThreadLocal</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E5%85%A8%E8%A7%A3%E8%AF%BB"><span class="toc-text">synchronized 全解读</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Synchronized%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">1.Synchronized的使用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Synchronized%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">2.Synchronized的特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Synchronized%E9%94%81%E2%80%93%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-text">3.Synchronized锁–偏向锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%81%8F%E5%90%91%E9%94%81%E6%92%A4%E9%94%80"><span class="toc-text">4.偏向锁撤销</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E5%8A%A0%E9%94%81%E5%92%8C%E8%A7%A3%E9%94%81"><span class="toc-text">5.轻量级锁的加锁和解锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E8%86%A8%E8%83%80%E6%B5%81%E7%A8%8B"><span class="toc-text">6.轻量级锁膨胀流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B%E4%B8%ADmarkword%E7%9A%84%E8%BD%AC%E7%A7%BB%E6%B5%81%E7%A8%8B"><span class="toc-text">7.锁升级过程中markword的转移流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E6%AD%BB%E9%94%81%E7%9A%84%E9%81%BF%E5%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">8.死锁的避免方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-ObjectMonitor%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">9.ObjectMonitor的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-CPU%E7%9A%84%E7%94%A8%E6%88%B7%E6%80%81%E4%B8%8E%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-text">10.CPU的用户态与内核态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">Java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80"><span class="toc-text">1. Java内存模型基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-text">2.指令重排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-text">3.内存屏障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-as-if-serial%E8%AF%AD%E4%B9%89%E5%92%8CHappen-Before%E5%8E%9F%E5%88%99"><span class="toc-text">4.as-if-serial语义和Happen-Before原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%94%81%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89"><span class="toc-text">5.锁的内存语义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E5%85%A8%E8%A7%A3%E8%AF%BB"><span class="toc-text">volatile全解读</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-volatile%E5%AE%9A%E4%B9%89"><span class="toc-text">1.volatile定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-volatile%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">2.volatile可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96"><span class="toc-text">3. volatile的使用优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-volatile%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-text">4. volatile禁止指令重排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">5.  双重检查锁存在的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%9F%BA%E4%BA%8Evolatile%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">6.基于volatile的解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">7.基于类初始化的解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock%E5%85%A8%E8%A7%A3%E8%AF%BB"><span class="toc-text">Lock全解读</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Lock%E9%94%81%E7%9A%84%E7%94%B1%E6%9D%A5%E5%8F%8AAPI"><span class="toc-text">1. Lock锁的由来及API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8AQS"><span class="toc-text">2.队列同步器AQS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-ReentrantLock-%E9%9D%9E%E5%85%AC%E5%B9%B3-%E7%9A%84lock%E6%96%B9%E6%B3%95"><span class="toc-text">3.ReentrantLock(非公平)的lock方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-ReentrantLock%E7%9A%84tryLock%E6%96%B9%E6%B3%95"><span class="toc-text">4.ReentrantLock的tryLock方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-ReentrantLock%E7%9A%84lockInterruptibly%E6%96%B9%E6%B3%95"><span class="toc-text">5.ReentrantLock的lockInterruptibly方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-ReentrantLock%E7%9A%84isHeldByCurrentThread%E6%96%B9%E6%B3%95"><span class="toc-text">6.ReentrantLock的isHeldByCurrentThread方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-ReentrantLock%E7%9A%84unlock%E6%96%B9%E6%B3%95"><span class="toc-text">7.ReentrantLock的unlock方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-ReentrantLock-%E5%85%AC%E5%B9%B3"><span class="toc-text">8.ReentrantLock(公平)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-ReentrantReadWriteLock%E5%8E%9F%E7%90%86"><span class="toc-text">9.ReentrantReadWriteLock原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-ReentrantReadWriteLock%E7%9A%84%E9%94%81%E9%99%8D%E7%BA%A7"><span class="toc-text">10.ReentrantReadWriteLock的锁降级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-LockSupport%E5%B7%A5%E5%85%B7"><span class="toc-text">11.LockSupport工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-Condition%E8%A7%A3%E8%AF%BB"><span class="toc-text">12.Condition解读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB"><span class="toc-text">原子操作类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB"><span class="toc-text">1.什么是原子操作类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%B1%BB"><span class="toc-text">2.原子更新基本类型类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E6%95%B0%E7%BB%84%E5%9E%8B%E7%B1%BB"><span class="toc-text">3.原子更新数组型类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%BC%95%E7%94%A8%E7%B1%BB"><span class="toc-text">4.原子更新引用类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%AD%97%E6%AE%B5%E7%B1%BB"><span class="toc-text">5.原子更新字段类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">并发工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-CountDownLatch%E4%BB%8B%E7%BB%8D"><span class="toc-text">1. CountDownLatch介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-CyclicBarrier%E4%BB%8B%E7%BB%8D"><span class="toc-text">2.CyclicBarrier介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Semaphore%E4%BB%8B%E7%BB%8D"><span class="toc-text">3.Semaphore介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Exchanger%E4%BB%8B%E7%BB%8D"><span class="toc-text">4.Exchanger介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-text">Java阻塞与非阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ConcurrentLinkedQueue%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-text">1.ConcurrentLinkedQueue非阻塞队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%BB%8B%E7%BB%8D"><span class="toc-text">2.阻塞队列介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9C%89%E7%95%8C%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-text">3.有界阻塞队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%92%8C%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97"><span class="toc-text">4.优先级队列和延时队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-SynchronousQueue%E4%BB%8B%E7%BB%8D"><span class="toc-text">5.SynchronousQueue介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-LinkedTransferQueue%E4%BB%8B%E7%BB%8D%EF%BC%88%E6%97%A0%E7%95%8C%E3%80%81%E4%BC%A0%E7%90%83%E6%89%8B%E3%80%81%E9%98%BB%E5%A1%9E%EF%BC%89"><span class="toc-text">6.LinkedTransferQueue介绍（无界、传球手、阻塞）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-LinkedBlockingDeque%E4%BB%8B%E7%BB%8D"><span class="toc-text">7.LinkedBlockingDeque介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Fork-x2F-Join%E6%A1%86%E6%9E%B6"><span class="toc-text">8.Fork&#x2F;Join框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-FixedThreadPool%E8%AF%A6%E8%A7%A3"><span class="toc-text">7.FixedThreadPool详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-SingleThreadExecutor%E8%AF%A6%E8%A7%A3"><span class="toc-text">8.SingleThreadExecutor详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-CachedThreadPool%E8%AF%A6%E8%A7%A3"><span class="toc-text">9.CachedThreadPool详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-ScheduledThreadPoolExecutor%E8%AF%A6%E8%A7%A3"><span class="toc-text">10.ScheduledThreadPoolExecutor详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-FutureTask%E8%AF%A6%E8%A7%A3"><span class="toc-text">11.FutureTask详解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%87%8D%E7%82%B9%E9%97%AE%E9%A2%98"><span class="toc-text">并发编程重点问题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="《Java并发编程的艺术》阅读笔记"><img src="https://www.toopic.cn/public/uploads/small/1658044853457165804485391.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Java并发编程的艺术》阅读笔记"/></a><div class="content"><a class="title" href="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="《Java并发编程的艺术》阅读笔记">《Java并发编程的艺术》阅读笔记</a><time datetime="2023-09-20T13:40:17.000Z" title="发表于 2023-09-20 21:40:17">2023-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="数据结构算法笔记"><img src="https://www.toopic.cn/public/uploads/small/1695101465702169510146570.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构算法笔记"/></a><div class="content"><a class="title" href="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="数据结构算法笔记">数据结构算法笔记</a><time datetime="2023-08-29T01:16:55.000Z" title="发表于 2023-08-29 09:16:55">2023-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/23/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" title="并发编程笔记"><img src="https://www.toopic.cn/public/uploads/image/20200411/20200411133433_43554.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="并发编程笔记"/></a><div class="content"><a class="title" href="/2023/07/23/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" title="并发编程笔记">并发编程笔记</a><time datetime="2023-07-23T08:16:18.000Z" title="发表于 2023-07-23 16:16:18">2023-07-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/03/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="《深入理解Java虚拟机》阅读笔记"><img src="https://www.toopic.cn/public/uploads/small/1658045182318165804518239.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《深入理解Java虚拟机》阅读笔记"/></a><div class="content"><a class="title" href="/2023/07/03/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="《深入理解Java虚拟机》阅读笔记">《深入理解Java虚拟机》阅读笔记</a><time datetime="2023-07-03T13:28:33.000Z" title="发表于 2023-07-03 21:28:33">2023-07-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/03/%E6%A0%A1%E9%95%BF%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/" title="校长书籍推荐"><img src="https://img-baofun.zhhainiao.com/pcwallpaper_ugc/static/53f31f4f8ca1bb064ea18a398db64db9.jpg?x-oss-process=image%2fresize%2cm_lfit%2cw_3840%2ch_2160" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="校长书籍推荐"/></a><div class="content"><a class="title" href="/2023/07/03/%E6%A0%A1%E9%95%BF%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/" title="校长书籍推荐">校长书籍推荐</a><time datetime="2023-07-03T09:22:04.000Z" title="发表于 2023-07-03 17:22:04">2023-07-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Inequalities</div><div class="footer_custom_text">如果你真的想蜕变，那就从今天开始！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="鸡,你,太,美,你干嘛~,哎呦~" data-fontsize="15px" data-random="false" async="async"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>