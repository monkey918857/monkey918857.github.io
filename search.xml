<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《Java并发编程的艺术》阅读笔记</title>
      <link href="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="并发编程初探"><a href="#并发编程初探" class="headerlink" title="并发编程初探"></a>并发编程初探</h3><h4 id="1-Java天生的多线程"><a href="#1-Java天生的多线程" class="headerlink" title="1.Java天生的多线程"></a>1.Java天生的多线程</h4><p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位</strong></p><p>在Java中仅仅运行一个main函数，在相当于启动了一个JVM进程，而且这个进程有六条线程，这些线程都拥有各自的<strong>计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量</strong>。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。</p><hr><p>main函数启动后开启的六条线程：</p><p>[6] Monitor Ctrl-Break （跟JVM 关系不大，他是 IDEA 通过反射的方式，开启一个随着我们运行的jvm进程开启与关闭的一个监听线程。）</p><p>[5] Attach Listener （附加监听器。 简单来说，他是jdk里边一个工具类提供的<strong>jvm</strong> <strong>进程之间通信</strong>的工具。 cmd – java -version; jvm – jstack、jmap、dump） 进程间的通信。</p><p>开启我们这个线程的两个方式： 1. 通过jvm参数开启。-XX: StartAttachListener</p><ol start="2"><li>延迟开启： cmd – java -version –&gt; JVM 适时开启A L 线程</li></ol><p>[4] Signal Dispatcher （信号分发器。 我们通过cmd 发送jstack，传到了jvm进程，这时候信号分发器就要发挥作用了。）</p><p>[3] Finalizer （JVM 垃圾回收相关的内容。此处只做简单的介绍。 1. 只有当开始一轮垃圾收集的时候，才会开始调用finalize方法。 2. daemon prio&#x3D;10 高优先级的守护线程。  3. jvm在垃圾收集的时候，会将失去引用的对象封装到我们的 Fianlizer 对象（Reference）， 放入我们的 F-queue 队列中。由 Finalizer 线程执行inalize方法）</p><p>[2] Reference Handler （引用处理的线程。强，软，弱，虚。 -GC 有不同表现 - JVM深入分析）</p><p>[1] main 主线程</p><hr><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231119213444916.png" class title="image-20231119213444916"><h4 id="2-线程的优先级和守护线程"><a href="#2-线程的优先级和守护线程" class="headerlink" title="2.线程的优先级和守护线程"></a>2.线程的优先级和守护线程</h4><ul><li><p>优先级</p><ul><li>通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，setPriority(int)这个方法是 jvm 提供的一个方法，并且能够调用 本地方法 setPriority0. 但是设置以后发现没有作用，为什么？ <ul><li>1.我们现在的计算机都是多核的，t1，t2 会让哪个cpu处理不好说。由不同的cpu同时提供资源执行。 2.优先级不代表先后顺序。哪怕你的优先级低，也是有可能先拿到我们的cpu时间片的，只不过这个时间片比高优先级的线程的时间片短。 <strong>优先级针对的是 cpu时间片的长短问题。</strong>这个 setPriority方法很少使用，很难控制。实际的运行环境太复杂。</li></ul></li></ul></li><li><p>守护线程</p><ul><li><p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这 意味着，<strong>当一个Java虚拟机中不存在非Daemon线程的时候，守护线程也会立即终止(这也是finally块中代码不一定执行的一个原因)，</strong>Java虚拟机将会退出。</p></li><li><p>可以通过调 用Thread.setDaemon(true)将线程设置为Daemon线程。但是注意设置守护线程的时候一定要在调用thread.start()之前设置，如果线程已经启动了在进行设置会抛出异常</p></li></ul><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231119220444532.png" class title="image-20231119220444532"></li></ul><h4 id="3-线程状态转换"><a href="#3-线程状态转换" class="headerlink" title="3.线程状态转换"></a>3.线程状态转换</h4><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231119223427696.png" class title="image-20231119223427696"><ul><li>注意：①上面图中有一个错误，就是红框里面的join方法是Thread的。②BLOCKED状态只针对sync锁。③通过调用join方法导致状态转为WAITING时，也是需要调用notify方法转为RUNNABLE状态，因为join方法底层就是调用了wait方法</li></ul><h4 id="4-init方法和start方法"><a href="#4-init方法和start方法" class="headerlink" title="4.init方法和start方法"></a>4.init方法和start方法</h4><ul><li>init方法<ul><li>当使用new关键词进行线程创建的时候，底层调用的是init方法，一个新构造的线程对象是由其parent线程来进行空间分配的，而child线程继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的ThreadLocal，同时还会分配一个唯一的（sync）ID来标识这个child线程(之所以能保证唯一是因为nextThreadID这个方法是被synchronized修饰的)。此时这个线程会被添加到Unstarted线程组，也就是NEW状态，因为还有调用start方法;至此，一个能够运行的线程对象就初始化好了，在堆内存中等待着运行。</li></ul></li><li>start方法<ul><li>start方法也是一个被synchronized修饰的方法，这样可以避免多线程同时启动一个线程，start方法底层调用的是用native修饰的start0方法，在start0方法完全执行完成之前，线程处于READY状态，在start0方法完全执行结束以后，线程就处于RUNNING状态，线程start()方法的含义是：当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程。</li></ul></li></ul><h4 id="5-sleep方法和wait方法"><a href="#5-sleep方法和wait方法" class="headerlink" title="5.sleep方法和wait方法"></a>5.sleep方法和wait方法</h4><ul><li>sleep方法<ul><li>是否释放锁？<ul><li>不释放</li><li>通过源码发现sleep方法是一个native方法，但是可以根据注释**The thread does not lose ownership of any monitors.**，说明他不会释放锁</li></ul></li><li>是否响应中断？<ul><li>响应，他会先清除中断标志然后抛出异常，所以调用Thread.isInterrupted()方法的时候会返回false</li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231121191452253.png" class title="image-20231121191452253"></li></ul></li><li>是否释放CPU<ul><li>释放，通过jstack命令可以查看到它没有占用任何CPU</li></ul></li></ul></li><li>wait方法<ul><li>是否释放锁？<ul><li>释放</li><li>wait方法也是一个native方法，使用上面的方法可以查看到，线程会释放锁</li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231121192241133.png" class title="image-20231121192241133"></li></ul></li><li>是否响应中断？<ul><li>响应</li></ul></li><li>是否释放CPU？<ul><li>释放，他会让出CPU时间片，然后进入到等待队列中</li></ul></li></ul></li></ul><h4 id="6-join方法"><a href="#6-join方法" class="headerlink" title="6.join方法"></a>6.join方法</h4><ul><li>是否释放锁？<ul><li>释放，但是它释放的是当前调用 join方法的那个对象的锁。</li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231121192631058.png" class title="image-20231121192631058"></li></ul></li><li>是否响应中断？<ul><li>响应</li></ul></li><li>是否释放CPU？<ul><li>释放，其底层调用的是wait方法</li></ul></li></ul><h4 id="7-线程间的通信方式"><a href="#7-线程间的通信方式" class="headerlink" title="7.线程间的通信方式"></a>7.线程间的通信方式</h4><ul><li>volitate 、synchronize、lock。（都保证可见性）</li><li>wait、notify、await() 、 signal</li><li>管道输入&#x2F;输出流和普通的文件输入&#x2F;输出流或者网络输入&#x2F;输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</li><li>Thread.join() ： 隐式唤醒。等待其他线程执行完成，其他线程会发送唤醒信号。</li><li>ThreadLocal() </li><li>线程中断</li></ul><h4 id="8-ThreadLocal"><a href="#8-ThreadLocal" class="headerlink" title="8.ThreadLocal"></a>8.ThreadLocal</h4><p>ThreadLocal之所以能够实现线程的隔离，主要是依靠线程自身有一个名叫threadLocals的ThreadLocalMap类型的变量，threadLocal底层是使用一个table数组进行数据的存放，存放的时候使用斐波那契散列法把对应不同的threadlocal进行散列，存放的数据是使用threadlocal和要set的值封装成的Entry对象，每次从map中获取信息的时候是通过thradLocal的get方法，当前线程拿到这个map，通过threadLocal散列得到存放的位置，最终得到数据，如果线程一直不终止，那么这个数据会一直存放在threadLocals，<strong>ThreadLocalMap中ThreadLocal是弱引用，</strong></p><p>如果在ThreadLocalMap中使用强引用来存储ThreadLocal对象，那么ThreadLocal对象会一直存在于内存中，即使在实际的应用中已经不再需要该ThreadLocal对象。这是因为ThreadLocalMap是与线程相关联的，保存在ThreadLocalMap的table数组中，ThreadLocalMap中的键值对不会被自动清理，而是会一直保留，从而造成内存泄漏。也就是说ThreadLocal永远不会被清理，除非手动清理，ThreadLocalMap调用set(),get()，remove()方法的时候会被清除value值。</p><p>为了解决这个问题，ThreadLocal存放的Entry对象被设计为弱引用。<strong>弱引用的特点是，当一个对象只被弱引用所引用时，在垃圾回收时会被自动回收。当ThreadLocal对象被垃圾回收时，对应的键值对也会被自动从ThreadLocalMap中移除。但是我们set的value是强引用的，当一个线程长时间运行，有可能不会及时清理导致内存泄漏，为了避免泄漏问题应做手动清理的动作</strong></p><h3 id="synchronized-全解读"><a href="#synchronized-全解读" class="headerlink" title="synchronized 全解读"></a>synchronized 全解读</h3><h4 id="1-Synchronized的使用方法"><a href="#1-Synchronized的使用方法" class="headerlink" title="1.Synchronized的使用方法"></a>1.Synchronized的使用方法</h4><ul><li><p>synchonized关键字的三种使用方式</p><ul><li>用在同步代码块上，此时锁是括号里面配置的对象</li><li>用在普通方法上，此时锁是当前调用该方法的实例对象</li><li>用在静态方法上，此时锁是当前类的Class对象</li></ul><p>当一个线程试图访问同步代码块的时候，必须要先获取到锁，在退出或者出现异常的时候必须释放锁</p></li><li><p>synchonized在JVM的实现原理</p><ul><li>JVM是基于进入和退出Monitor对象来实现同步方法和同步代码块，二者的实现细节略有不同<ul><li>对于同步代码块来说，在编译后会在进入同步代码块之前会加一个monitorenter指令，在同步代码块结束退出或者发生异常的地方monitorexit指令，任何一个对象都有一个monitor与之关联，当monitor被持有后将处于锁定状态，线程执行到monitorenter的时候会尝试获取对应monitor的所有权，即尝试获取对象的锁</li><li>对于同步方法和静态方法来说，通过反编译得到字节码后可以发现，在方法的flags中多了一个ACC_SYNCHONIZED标志，这会告诉JVM这是一个同步方法</li></ul></li></ul></li></ul><h4 id="2-Synchronized的特性"><a href="#2-Synchronized的特性" class="headerlink" title="2.Synchronized的特性"></a>2.Synchronized的特性</h4><ol><li>有序性 （读读、读写、写读、写写 互斥）</li><li>可见性 （可见性是指多个线程访问⼀个资源时，该资源的状态、值信息等对于其他线程都是可见的。 synchronized和volatile都具有可见性，其中synchronized对⼀个类或对象加锁时，⼀个线程如果要访问该类或对象必须先获得它的锁，⽽这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到共享内存当中，保证资源变量的可见性。）</li><li>原子性 (本质上是线程互斥保证的原子性)</li><li>可重入性 （一个线程获取到某个锁以后，再次请求该对象的锁的时候，还可以获取到执行权）</li></ol><h4 id="3-Synchronized锁–偏向锁"><a href="#3-Synchronized锁–偏向锁" class="headerlink" title="3.Synchronized锁–偏向锁"></a>3.Synchronized锁–偏向锁</h4><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231122222424235.png" class title="image-20231122222424235"><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231122222444063.png" class title="image-20231122222444063"><ul><li>偏向锁使用的前提<ul><li>在jdk1.6版本以后，并且开启了使用偏向锁这一配置，但是它默认情况下是延迟开启的，可以通过-     XX:BiasedLockingStartupDelay&#x3D;0这个配置关闭延迟，如果我们关闭了延迟开启这一配置，那么<strong>锁对象在创建出来的时候markword的状态就是偏向锁对应的状态</strong>，只不过现在没有任何的线程竞争，此时就是一个没有偏向任何线程的偏向锁</li><li>锁对象在被获取之前没有显式&#x2F;隐式的调用hashCode方法(隐式调用比如说以这个锁对象作为hashmap的key进行保存)，如果调用了hashcode方法，由于我们偏向锁的markword中没有地方存储这个hashcode，所以此时就会升级为轻量级锁</li></ul></li></ul><p>为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在<strong>锁的对象头中存储线程id并在线程的栈帧中的锁记录里(线程有自己的栈帧，LOCK RECORD) 存储当前线程id</strong>,存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里存储的id和线程栈帧里面锁记录的id是否匹配，如果匹配，表示线程已经获得了锁。如果不匹配，则需要再测试一下锁对象的Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程： 其实是cas竞争替换 线程id。</p><h4 id="4-偏向锁撤销"><a href="#4-偏向锁撤销" class="headerlink" title="4.偏向锁撤销"></a>4.偏向锁撤销</h4><p><em><strong>面试过程中，如果聊到偏向锁的撤销可以先通过一句简短的话来描述一下，然后通过面试官后续的发问逐步展开，即偏向锁使用了一种当出现线程竞争才撤销偏向锁的机制，一旦出现竞争偏向锁就会升级为轻量级锁</strong></em></p><ul><li>在竞争偏向锁的时候会出现以下可能性<ol><li>A线程获取偏向锁，并且A线程死亡退出。B线程争抢偏向锁，会直接升级当前对象的锁为轻量级锁。<strong>这只是针对我们争抢了一次。</strong></li><li>A线程获取偏向锁，并且A线程没有释放偏向锁，还在sync的代码块里边。B线程此时过来争抢偏向锁，会直接升级为重量级锁。</li><li>A线程获取偏向锁，并且A线程释放了锁，但是A线程并没有死亡还在活跃状态。此时锁处于无锁状态，B线程过来争抢，会直接升级为轻量级锁。</li><li>A线程获取偏向锁，并且A线程没有释放偏向锁，还在sync的代码块里边。B线程多次争抢锁，会在加锁过程中采用重量级锁；但是，一旦锁被释放，当前对象还是会以轻量级锁的初始状态执行。但是这里不能称之为锁降级，因为锁升级是在线程运行过程中和争抢过程中的一种升级。而现在是线程已经释放了锁，然后又重新获取锁的情况，不属于线程运行中。</li><li>A线程获取偏向锁，并且A线程释放了锁，但是A线程并没有死亡还在活跃状态。B线程过来争抢。部分争抢会升级为轻量级锁；部分争抢会依旧保持偏向锁。</li></ol></li></ul><p>所以，偏向锁的撤销过程很复杂，即使是锁升级的官方文档中对这一部分也没有特别细致的说明，所以面试过程中不要较真</p><p>以下面试过程中推荐说的：</p><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态(<strong>如上述情况1</strong>)；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向的线程对象的栈帧中的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程(<strong>如上述情况5</strong>)，要么恢复到无锁(<strong>如上述情况3</strong>)或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。 </p><ul><li>偏向锁的批量重偏向和批量撤销<ul><li>批量重偏向，一个已经偏向A线程Object类型的对象，在经过另外B线程争抢超过二十次的情况下，该类所创建出来的其他对象会直接重新偏向于B线程，此时jvm认为这个对象更适合偏向于B线程(20这个数字不是一定的，<strong>不同机器环境参数配置不一样</strong>)</li><li>批量撤销，如果基于批量重偏向的基础上，还在继续进行争抢达到40次，并且有第三条线程C也来争抢这个对象锁，这个时候会触发批量撤销。JVM会标记该对象不能使用偏向锁，以后新创建的对象，直接以轻量级锁开始。 这个时候，才是真正的完成了锁升级。</li></ul></li></ul><p><strong>注意，真正的锁升级，是依赖于 class 的，而并不是依赖于 某一个 new出来的对象（偏向锁升级为轻量级锁），这里更加可以说明锁可以升级，而不能降级，也就是说上面出现的线程争抢锁过程中升级的锁，在使用new关键字对该类进行重新创建的时候还是偏向锁这一现象不能称之为锁降级</strong></p><h4 id="两个关键字"><a href="#两个关键字" class="headerlink" title="两个关键字"></a>两个关键字</h4><ul><li>volatile <ul><li>保证可见性<ul><li>可见性是让其他线程可见，现在的处理器都是多核的处理器，多核处理器就有多核CPU，每个CPU理论上可以提供一条线程，多个线程共同修改一个volatile 修饰的共享变量的时候，一旦一个线程拿到修改权限并且修改完之后，会立即把修改后的值过<strong>总线</strong>推送到主存中，此时其他的CPU会一直嗅探总线的数据流通，在<strong>缓存一致性协议</strong>的保障下，他能够嗅探到这条数据的修改，如果自己的缓存行中有这条数据，就会把这条数据置为不可用，当该线程再次用到这条数据的时候，需要在主存中重新读取，并保存到自己缓存行中</li><li>关于CPU在嗅探总线的数据流通的时候，它这么知道这个数据就是volatile 修饰的呢？<ul><li>当一个数据被volatile修饰后，被一个线程修改，并通过总线保存到主存时，它的汇编指令的码会在里面加一个lock关键词，lock指令有两层含义，第一，是将信息的修改推送到主存；第二，lock指令过总线的时候其他CPU会嗅探含有lock的指令，然后置其他缓存行为不可用</li></ul></li></ul></li><li>禁止指令重排序<ul><li>volatile写之前加入storestore屏障，表示上面的普通写和volatile写不能重排序</li><li>volatile写之后加入storeload屏障，表示下面的volatile读写和volatile写不能重排序</li><li>volatile读之后加入loadload屏障，表示下面的普通读和volatile读不能重排序</li><li>volatile读之后加入loadstore屏障，表示下面的普通写和volatile读不能重排序</li></ul></li><li>在特殊情况下还能保证原子性<ul><li>比如volatile修饰的变量i，进行i++操作的时候，就不能保证原子性，因为i++有三条JVM指令字节码。第一条，i load读取i这个变量；第二条，i add进行加一的操作；第三条，i store然后把相加后结果写回。所以被volatile修饰的变量是单条JVM指令字节码的时候就可以保证原子性，而volatile修饰的变量是多条JVM指令字节码的时候就不能保证原子性</li></ul></li></ul></li><li>synchronized<ul><li>三种使用方式<ul><li>作用到代码块上(锁可以是Object类型的成员变量，也可以使用this作为锁)</li><li>多用在静态方法上(锁是当前的Class，因为静态方法在调用的时候是 类.方法 的形式进行调用，不需要创建对象，所以只能使用当前类的Class作为锁)</li><li>作用到普通方法上(锁是当前的类的对象)</li></ul></li><li>有一个Student类，其中有一个int类型的成员变量，同时提供set和get方法。给int变量加上volatile修饰可以保证原子性，因为set和get都是对应单条JVM字节码指令；不给int变量加上volatile进行修饰，而是给get和set方法加上synchronized也可以保证原子性<ul><li>如果此时get操作多，set操作少，即读多写少的场景，volatile的方法更快，因为如果不对volatile修饰的变量进行修改，那么每个线程可以直接从线程的缓存行里面直接拿到</li><li>如果此时get操作少，set操作多，即读少写多的场景，这个时候volatile就慢了，此时volatile修饰的变量一直修改，一直过总线写到主存中，其他的CPU一直在嗅探总线，一直把自己缓存行的数据置为不可用，每次都要透过总线从主存中拉取最新数据，严重损耗计算机的总线资源，synchronized这是就比较快了，因为写比较多，一个线程写的时候其他线程处于BLOCK状态，对于set方法来说处理器执行的是非常快的，也就是其他线程BLOCK的时间会非常短，<em>重量级锁可以提高程序的吞吐量</em></li></ul></li></ul></li></ul><h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p><em>lock相关的问题比较繁杂，所以要找到一个好的切入点进行总结，先从lock和synchronized的区别切入</em></p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ul><li>synchronized是一个关键字，lock是一个接口，使用lock的话需要new出其子类来<ul><li>lock接口中的方法<ul><li>lock()方法：加锁</li><li>unlock()方法：锁释放</li><li>tryLock()方法：可以非阻塞的进行加锁</li><li>tryLock(long time , TimeUnit unit)方法：可以超时性的非阻塞式加锁</li><li>lockInterruptibly()方法：可中断式加锁</li><li>newCondition()方法：配合实现等待通知机制</li></ul></li><li>常用的实现子类是ReentrantLock和ReentrantReadWriteLock</li></ul></li><li>synchronized是隐式加锁，lock是显式加锁<ul><li>synchronized肉眼看不到加锁和解锁的过程，lock一定要在finally代码块中释放锁</li></ul></li><li>synchronized可以作用到方法和代码块上，lock只能作用到代码块上<ul><li>synchronized三种加锁方式<ul><li>加到静态方法上使用的当前类的Class</li><li>加到普通方法上使用的当前类的对象</li><li>加到代码块上可以用this关键字，也可以new一个Object对象</li><li>lock加锁就不用多说了，只能加在代码块上，同时别忘了进行锁的释放</li></ul></li><li>synchronized作用到代码块上和作用到方法上，使用javap命令反编译成字节码指令有什么区别<ul><li>synchronized作用到代码块上反编译之后，在代码块进入的点有一个monitorenter指令，在代码块出的点有一个monitorexit指令，而且monitorexit这个指令最少要有两个，一个是正常出代码块释放锁，一个是发生异常释放锁</li><li>synchronized作用到方法上会在方法的flag上加一个acc_synchronized，<strong>后续学完JVM进行详细补充</strong></li></ul></li></ul></li><li>lock支持非阻塞式加锁<ul><li>lock接口中有两个关于非阻塞式加锁的方法，tryLock()方法和tryLock(long time , TimeUnit unit)方法，如果尝试获加锁失败直接返回，不会阻塞线程，那么线程就不会从用户态转为内核态，少一次线程上下文切换</li></ul></li><li>lock支持可超时性加锁<ul><li>tryLock(long time , TimeUnit unit)方法可以超时性加锁，一定时间内尝试加锁失败了，直接返回，是一个避免发生死锁的好办法</li></ul></li><li>lock支持可中断式加锁<ul><li>可中断的意思是一个线程在运行的时候，另一个线程想要对这个线程进行中断，lock中的lockInterruptibly()方法可以接受这种中断，synchronized做不到这一点</li></ul></li><li>synchronized采用对象监视器，lock采用AQS<ul><li>两个线程竞争一个synchronized锁，一条线程竞争成功，另一条线程竞争失败进入到ObjectMonitor中的EntryList(同步队列)，等到当前执行线程释放锁，被唤醒以后才重新进入到锁的竞争，但是当前执行线程调用了wait方法释放锁以后，会进入到ObjectMonitor中的WaitSet(等待队列)中</li><li>AQS根据一个int类型的state变量，来确定这个锁有没有被获取，如果被获取则会加入到AQS双端队列的尾部，这里注意此时有可能是大量的线程同时竞争锁失败，然后同时放到双端队列的尾部，此时就会有线程安全的问题，这里采用的CAS的方式来保证进入双端队列尾部的线程安全，当获取锁的线程执行完成释放锁的时候，会通知自己的后继节点进行锁的竞争</li></ul></li><li>在加锁和解锁时，synchronized有一个同步队列和一个等待队列，lock有一个同步队列和多个等待队列<ul><li>lock可以new出多个Condition，一个Condition就有一个等待队列</li></ul></li><li>锁竞争方面，synchronized只支持非公平锁，lock支持非公平锁和公平锁<ul><li>到底什么叫公平，什么叫非公平(场景举例)<ul><li>假设此时有A,B,C三条线程对lock锁进行竞争，A线程获取到锁了，B,C线程要依次进入到双端队列中进行等待，当A线程执行完成释放锁，唤醒B线程进行锁的竞争时，此时又来了另外十条线程竞争这个lock，如果B和这十条线程进行锁的竞争那么就是不公平，因为B线程已经在队列中排队等待了很久了，如果B不用和新来的线程竞争(新来的十条线程在CAS的保证下直接加入到双端队列的尾端)那么就是公平的</li></ul></li><li>新来的十条线程怎么知道这是一个公平锁，并且加入到队列的？<ul><li>新来的线程对于公平锁的竞争之前，会进行一个判断，就是判断自己是否有前置节点，如果没有就进入到队列排队，但是对于非公平锁的竞争就不会有这个判断</li></ul></li><li>非公平锁的线程饥饿问题？<ul><li>一条线程在竞争失败后进入到等待队列进行等待，下一次再次失败再次等待，如此反复线程一直处于等待状态，这就叫做线程饥饿</li></ul></li></ul></li><li>对于等待唤醒机制，synchronized与Object进行配合，lock与Condition接口进行配合<ul><li>synchronized与Object的wait&#x2F;notify进行配合</li><li>lock与Condition接口await和signal进行配合<ul><li>拿到lock锁的线程，调用await方法时，就会进入到Condition的等待队列的尾节点中，<strong>不需要使用CAS直接加就行</strong>，因为线程在调用await方法之前先回把自己加入到等待队列的尾部，正因为此时还没有调用await方法，线程还持有着锁，所以进入到尾节点的时候不用CAS</li></ul></li><li>调用await方法之后，这个线程经历了什么？<ul><li>拿到lock锁的线程，调用await方法时，就会进入到Condition的等待队列的尾节点中，当他达到队列的头部时会被唤醒，此时这条线程会重新竞争lock锁，一旦竞争失败会使用CAS加入到同步队列的尾端，排队到同步队列的头部，直到他的前置节点线程释放锁以后，根据是否是公平锁重新竞争，竞争失败继续等待，竞争成功继续执行完await后面的逻辑</li></ul></li></ul></li><li>lock锁可以根据需要进行个性化开发 </li><li>ReentrantReadWriteLock支持并发读<ul><li>读-读可以并发执行，读-写，写-读，写-写 都不可以并发执行</li><li>通过一个int类型的state变量来控制读写权限，他把一个32位的int变量分成高16位和低16位，高16位负责控制读，低16位负责控制写。当一个读线程来的时候会检查低16，如果低16位为0说明没有写线程，直接对高16位加一，然后进行读取，如果有写线程那么就会被阻塞。当一个写线程来的时候会检查高16位和低16位，此时不管是有写还是有读直接被阻塞，这是ReadWriteLock的加锁细节。如果是ReentrantReadWriteLock(表示可重入读写锁)的话，加读锁的时候，如果低16位不为0，会先判断持有写锁的线程是不是当前线程，如果是也会在高16位加一，加写锁的时候，如果低16位和高16位都不为0，此时会先判断持有这些锁的线程是不是当前线程，如果是则会在低16位加一</li></ul></li></ul><h4 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h4><p><em>背景：32位JVM虚拟机</em></p><ul><li><p>无锁状态</p><ul><li>当我们新创建一个对象的时候，它的对象头MarkWord里有25位的HashCode，4位的对象分代年龄，1位的偏向锁标记位，2位的锁标记位</li><li><strong>当我们仅仅只是用new关键字创建一个对象的时候，此时如果没有显式&#x2F;隐式的调用Object里面的hashCode方法，那么hashCode的值不会存储在对象头中</strong>，此时的占位是0<ul><li>显示调用hashCode：比如在类的构造器中直接调用super.hashCode()方法，这样我们对象头的MarkWord中是有hashCode的</li><li>隐式调用hashCode：比如在构造函数中，对象创建完毕的一瞬间直接把该对象放入到了HashMap，HashSet这样的类Hash集合中，因为put方法的第一个参数就是哈希值，这个哈希值就是靠调用Object类的hashCode方法得到的</li><li>如果该类重写了hashCode方法，然后在对象的创建过程中调用了重写以后的hashCode方法，那么同样不会把hashCode的值存放到对象头的MarkWord中，<strong>必须调用父类的hashCode方法才会把值存到对象头的MarkWord中</strong></li></ul></li><li>对于分代年龄，此时由于对象刚刚创建，没有分代年龄，所以还是以0表示</li><li>对于锁标记位，无锁状态和偏向锁状态的锁标记位都是01，他们的区别在于偏向锁标记位，无锁的偏向锁标记位是0，偏向锁状态的偏向锁标记位是1</li></ul></li><li><p>无锁状态升级为偏向锁</p><ul><li>无锁状态想要升级位偏向锁状态，此时<strong>对象头的MarkWord中必须不能有hashCode值</strong>，理论上hashCode这个位置要保存上23位的线程ID和2位的Epoch，但是如果这个位置有hashCode的值就会对这个值进行覆盖，因为hashCode值没有替换这个逻辑也无法对这个值进行保存，所以这个行为是不允许的，所以此时就不能成为偏向锁</li><li>如果想要成为偏向锁的对象的对象头的MarkWord没有存放hashCode值，此时就可以把线程ID放到前23位，Epoch的值放到后2位，偏向锁标记位从0变成1，锁标记位还是01不变</li><li>偏向锁的好处在于，当一个线程想要再次获取锁，可以直接检查一下MarkWord里面保存的线程ID是不是当前线程的ID，如果是那么直接加锁成功，性能会有所提升</li></ul></li><li><p>偏向锁升级为轻量级锁</p><ul><li>发生线程竞争的时候偏向锁一定会升级为轻量级锁吗？</li><li>偏向锁升级为轻量级锁发生了线程的竞争这句话是对的，但是反过来说就不一定对了，例如下面加粗斜体的例子，虽然有线程的竞争但是锁的偏向发生了改变但是没有升级为轻量级锁</li><li>偏向锁升级为轻量级锁的过程：<em><strong>加入A线程获取到了偏向锁把自己的线程ID存放到MarkWord中，此时又来了一个B线程也想要获取偏向锁，他会先检查锁标记状态是不是01，偏向锁标记位是不是1，如果锁标记位是01，且偏向锁标记位是1，那么线程B就知道此时这个锁已经有线程偏向了，这时线程B会检查线程A的线程存活状态，如果此时A线程没有在执行同步代码，那么B线程会直接把这个偏向锁置为无锁状态，然后去竞争这个偏向锁，如果竞争成功则把自己的线程ID放入到MarkWord当中，此时偏向锁就偏向B线程了</strong></em>，但是如果线程B争抢失败了，线程C争抢成功了，把线程C的ID存放到了MarkWord中并执行线程C对应的代码，这是时候线程B就很烦，他会执行一个更加高级的操作，叫做<strong>偏向锁的撤销</strong>，线程B会等待线程C执行到JVM安全点，对线程C的栈进行遍历，遍历的是锁记录，遍历完成可能会有三种情况</li><li>可能会直接把锁的状态变为无锁状态，然后把锁标记位置为00，即轻量级锁<ul><li>这个地方可以理解为锁从偏向锁直接升级为轻量级锁，所谓把锁的状态变为无锁状态就是把锁标记位置为00，并且把偏向线程ID和Epoch置为空，偏向锁标记位是0。之所以上面说把锁的状态变为无锁状态，是因为真正的轻量级锁的对象头应该除了2位的锁标记位之外，其余的30位都应该指向栈帧中锁记录的指针，但是此时的状态比较<strong>游离</strong>，暂且理解为无锁状态</li></ul></li><li><em><strong>可能会把偏向锁重新偏向到线程B</strong></em><ul><li>JVM除了有开启偏向锁的配置之外，还有批量重偏向和批量撤销的操作。场景举例：比如有一个Student类，然后这个Student类创建了40个对象，线程A把这四十个对象进行偏向锁的加锁操作，然后线程A一直对这四十个对象保持代码的执行，此时来了个线程B，<strong>线程B要对这四十个对象进行锁撤销的操作</strong>，此时这1-19个对象直接升级为轻量级锁也就是上面所说的游离状态，当执行到第20个对象时，JVM就会反思自己是不是最开始的时候偏向错了，然后就把后面的20-39个对象批量重偏向到线程B，因为JVM里有配置批量偏向锁的阈值是20，但是当线程B撤销到第40个对象的时候，此时已经有20个对象偏向给线程B了，线程B还在继续要求偏向，JVM又不高兴了，既然这个对象的竞争这么激烈那么你就不适合作为偏向锁，然后直接把这个对象置为不可使用偏向锁</li><li>可能会把该锁直接置为不可使用偏向锁<ul><li>书接上文，至于置为不可使用偏向锁体现在new出第41个student对象的时候，此时该对象的对象头的MarkWord的锁标记位直接就是00，其实JVM这个地方还有一个默认参数，也就是两万五千毫秒，如果25秒以内批量撤销没有达到40这个阈值，那么从20-39的这个重偏向可以重新计数，<strong>也就是说25秒内批量撤销没有达到阈值，那么此时就不会发生置为不可使用偏向锁这一状态</strong></li></ul></li></ul></li></ul></li><li><p>轻量级锁record</p><ul><li>竞争过程：假设此时多条线程竞争时，如果A线程竞争成功了，A线程会直接把锁对象头里的MarkWord里面的25位hashCode，4位的分代年龄和1位的偏向锁标记，这30位的内容复制到A线程的栈帧中的一个叫做lockRecord即锁记录中，然后把对象头的MarkWord中对应的30位的位置放上一个指向当前线程栈帧中lockRecord这块区域的一个指针，当B线程来竞争轻量级锁的时候，他会使用CAS的方式把锁对象头对应位置的内容放到自己栈帧的lockRecord中，此时肯定是失败的，因为锁对象头本来该存放的hashCode，分代年龄等内容已经被替换成了指针了，此时B线程会进行一个CAS的自旋，再次尝试替换，默认循环十次，如果这十次还没有成功，那么轻量级锁将会升级为重量级锁</li><li>轻量级锁升级为重量级锁： 自旋十次没有成功的B线程，会把原本指向A线程中栈帧的lockRecord的指针替换为指向重量级锁的指针即ObjectMonitor，此时线程A执行完对应代码要使用CAS进行锁的释放时，会发现此时锁对象头内的指针已经不是轻量级锁的指针了，已经变成了重量级锁的指针了，所以这个时候他就知道要进行重量级锁解锁的过程了</li><li>重量级锁解锁的过程：线程A会先把栈帧中lockRecord记录的hashcode，分代年龄等内容保存到ObjectMonitor的header属性中保证这些内容不丢失，然后把ObjectMonitor的owner属性保存成自己</li></ul></li></ul><h4 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a>双重检查锁</h4><p><em>双重检查锁是基于单例模式的两次改造，第一次改造实是在synchronized同步代码块的外边，加一个判空处理，减少一些线程对于锁的竞争而变为阻塞状态，导致从用户态转化为内核态对于资源的消耗，这样会导致一些问题，因为在new对象的时候有三个步骤，第一，开辟一块内存空间，第二，初始化对象，第三，把instance指向这片内存空间，此时如果不用volatile修饰的话，可能会导致第二步和第三步发生指令重排序，在多线程的情况下其他线程访问到判空处理那一步时，他只会关心这个instance是否有指向，所以此时他会认为instance已经初始化好了，导致得到一个错误的结果</em></p><p><em><strong>加上volatile修饰的话会导致第二步和第三步不会发生重排序</strong></em>，这句话是错误的！！！！！！！！！！！</p><p>因为当我们new一个对象的时候，new是写在我们Java代码里面的，new这个关键词对应的JVM字节码指令也是new，volatile作为Java中的一个关键词，他做的添加屏障只能做到JVM字节码指令这个级别，它无法涉及到new这个关键词带来的更加底层的操作，也就是创建对象的那三步操作，这就像lock锁锁住了三行代码，在这三行代码执行结束前其他的线程进不来，而volatile就像是包住了new的这个过程保证了创建对象结束前其他线程进不来，从而保证线程安全</p><h4 id="线程状态转化"><a href="#线程状态转化" class="headerlink" title="线程状态转化"></a>线程状态转化</h4><p><em>new 一个线程出来进入new状态，然后调用start方法进入runnable状态，在runnable状态下调用join，wait，park方法会进入waiting状态，调用sleep，wait(long)等方法会进入到timed_waiting状态，加锁失败的话会进入到blocked状态，最后是线程的TERMINATED终止状态，在Java的Thread类中的state内部枚举类中只有这六种状态</em></p><p><strong>网上说的七种状态区别在于把runnable状态分成了running状态和ready状态，在running状态的线程调用了yield方法会进入到ready状态，此时放弃了CPU的执行权</strong></p><ul><li>NEW状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NEW</span><br></pre></td></tr></table></figure><p>线程还没有开始的状态，也就是说还没有调用start方法</p><ul><li>RUNNABLE状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment"> * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment"> * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment"> * such as processor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RUNNABLE</span><br></pre></td></tr></table></figure><p>在JVM中线程已经开始了，但会因为其他的一些调用进入到waiting状态</p><ul><li>WAITING状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment"> * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment"> * following methods:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment"> * perform a particular action.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WAITING</span><br></pre></td></tr></table></figure><p>在调用wait，join，park方法后会进入到waiting状态，调用notify，unpark等方法会使线程从waiting状态切换到runnable状态</p><ul><li>TIMED_WAITING状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment"> * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment"> * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TIMED_WAITING</span><br></pre></td></tr></table></figure><p>在调用sleep，wait(long)，join，parkNanos，parkUntil这些方法后会进入到TIMED_WAITING状态</p><ul><li>BLOCKED状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment"> * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment"> * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment"> * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BLOCKED</span><br></pre></td></tr></table></figure><p>只有在synchronized代码块或者synchronized修饰的方法的范围内才有可能进入到BLOCKED状态</p><ul><li>TERMINATED状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment"> * The thread has completed execution.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TERMINATED</span><br></pre></td></tr></table></figure><p>线程运行完毕，执行结束</p><ul><li>锁释放(使用join来说明)</li></ul><p>join方法底层也调用了wait方法，但是很多博客文章上说调用join方法不会释放锁，他会释放锁，但是他释放的是调用join方法的线程对应的对象的锁，举个例子，在synchronized(Object obj)代码块里面创建一个thread1线程，然后thread1线程调用join方法，此时释放的不是obj这个对象锁，而是thread1线程自身对象的Object Monitor锁</p><ul><li>waiting和timed_waiting的区别</li></ul><p>time_waiting状态不用唤醒，等时间到了以后自动执行后续代码，waiting状态需要显式或者隐式的唤醒，显式唤醒就是通过调用wait或者park方法进入waiting状态，通过调用notify或者unpark方法进行唤醒，隐式唤醒就是通过调用join方法，等到其他线程执行结束后会在线程内部接收到一条消息，然后执行后面的代码</p><ul><li>有了waiting和timed_waiting这两种状态为什么还要一个blocked状态</li></ul><p>线程在竞争锁失败后会进到EntryList同步队列，线程状态变为blocked状态，线程在调用wait方法进入到WaitSet等待队列，线程进入到waiting状态，当waiting状态被唤醒时会重新进行锁的竞争，此时如果竞争失败，那么会进入到EntryList同步队列，状态变位block，所以此时状态和队列进行了一个对应，为了把不同的线程状态进行一个更加细致的划分</p><h3 id="并发编程重点问题"><a href="#并发编程重点问题" class="headerlink" title="并发编程重点问题"></a>并发编程重点问题</h3><ul><li><p>进程和线程的区别</p><ul><li>进程是系统进行资源分配和调度的基本单位，线程是进程的一个执行路径，一个进程最少有一个线程，进程中的每个线程共享进程中的资源</li><li>操作系统分配资源的时候是分配给进程的，而CPU分配资源是分配给线程的，真正占用CPU的是线程，所以说线程是CPU分配的基本单位</li><li>一个进程中的多个线程共享进程的堆和方法区的资源，每个线程有自己的程序计数器和栈区域</li></ul></li><li><p>为什么将程序计数器设为线程私有的区域</p><ul><li>程序计数器记录线程当前要执行的指令地址，因为线程在用时间片轮转的方式的占用CPU，当前时间片用完后下次再次继续执行的时候，需要从线程私有的程序计数器这个内存区域拿到指定地址继续执行，如果要执行的是native方法那么程序计数器记录的undefined地址，只有要执行的是Java代码程序计数器记录的才是下一条指令的地址</li></ul></li><li><p>局部变量，对象实例，JVM加载的类，常量及静态常量都存在主存的哪个部分，是线程私有的吗？</p><ul><li>每个线程有自己的栈资源，该栈用于存储线程的局部变量，局部变量是线程私有的，除了局部变量，栈还可以用来存放线程的调用栈帧</li><li>new操作创建的实例对象存放在堆中，堆是进程在创建的时候分配的，是进程中最大的一块内存，所有线程可以共享</li><li>JVM加载的类，常量和静态常量放在方法区，也是线程共享的</li></ul></li><li><p>继承Thread类实现多线程的优劣</p><ul><li>好处：在run()方法中，想要获取当前线程的时候直接this就可以，不用Thread.currentThread()方法</li><li>坏处：Java不支持多继承，如果继承了Thread类就无法在继承其他的类了。</li></ul></li><li><p>IllegalMonitorStateException出现的原因</p><ul><li>调用wait()方法之前没有获得该对象的监视器锁</li></ul></li><li><p>什么是虚假唤醒，如何避免</p><ul><li><p>虚假唤醒指的是，一条线程在没有被其他线程调用notify(),notifyAll()方法进行通知，也没有被中断，也没有等待超时，这时如果还被唤醒那么就是虚假唤醒</p></li><li><p>可以在while循环中调用wait方法来防止虚假唤醒，只有满足while中条件才可以退出循环详见以下伪代码</p><ul><li><pre><code class="java">synchronized(obj)&#123;    while(条件不成立)&#123;        obj.wait();    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 调用共享对象的notify()方法后，会唤醒一个在该共享变量上调用wait的线程，这两个线程对于锁获取和释放的过程</span><br><span class="line"></span><br><span class="line">  - 首先一个线程一定是在拿到共享变量锁之后才能调用wait方法，调用wait方法后该线程会先释放锁，进入到WaitSet队列中进行等待，然后另外一条线程拿到该共享对象的锁，调用了notify方法唤醒了在队列中等待的线程，等到该线程释放了锁以后，被唤醒的线程会重新进行该共享对象的锁的竞争，只有竞争到锁后才能继续执行后序代码</span><br><span class="line"></span><br><span class="line">* join()方法和yeild()方法</span><br><span class="line"></span><br><span class="line">  - join方法的使用场景在需要多个线程同时完成某个事情的时候才继续向下执行，比如多个线程同时加载同一个资源，使用join方法可以等到所有线程完成后进行汇总处理，join方法底层就是使用了while循环和wait方法实习无限等待和带时间参数的等待</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      //join方法源码</span><br><span class="line">      public final synchronized void join(long millis)</span><br><span class="line">          throws InterruptedException &#123;</span><br><span class="line">              long base = System.currentTimeMillis();</span><br><span class="line">              long now = 0;</span><br><span class="line">      </span><br><span class="line">              if (millis &lt; 0) &#123;</span><br><span class="line">                  throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">      </span><br><span class="line">              if (millis == 0) &#123;</span><br><span class="line">                  while (isAlive()) &#123;</span><br><span class="line">                      wait(0);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  while (isAlive()) &#123;</span><br><span class="line">                      long delay = millis - now;</span><br><span class="line">                      if (delay &lt;= 0) &#123;</span><br><span class="line">                          break;</span><br><span class="line">                      &#125;</span><br><span class="line">                      wait(delay);</span><br><span class="line">                      now = System.currentTimeMillis() - base;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>线程的执行需要操作系统分配时间片来轮询占用CPU，正常情况下当时间片用完后，线程调度器会进行下一轮线程调度，而调用了yeild方法，表示线程告诉线程调度器虽然现在分配的时间片还没用完，但是此时可以进行下一轮的线程调度了，此时该线程让出CPU的使用权，线程计数器可以从就绪队列中找出一个优先级最高的线程执行</p></li></ul></li><li><p>sleep()方法和yeild()方法的区别</p><ul><li>调用了sleep方法的线程处于阻塞状态，且线程调度器在指定时间内不会调度该线程</li><li>调用了yeild方法的线程处于就绪状态，如果该线程的优先级较高线程调度器可能下一次调度仍然调度到当前线程执行</li></ul></li><li><p>interrupt(),isInterrupted()和interrupted()的特点和区别</p><ul><li>interrupt方法表示中断线程，例如线程A正在执行，线程B调用线程A的interrupt方法，会使线程A的线程中断标记为true，但是此时的线程不会真正中断，还需继续向下执行后面的代码，如果线程A调用了wait，sleep，join方法挂起阻塞，此时线程B还调用线程A的interrupt方法，就会在调用方法的地方抛出InterruptedExpection</li><li>isInterrupted方法用于判断某个线程是否被中断，如果被中断返回true，没有被中断返回false</li><li>interrupted方法也是用于判断某个线程是否被中断，如果被中断返回true，没有被中断返回false，与isInterrupted不同的是调用interrupted方法后发现线程已被中断，那么此时会清除中断标记，并且interrupted是static方法；interrupted调用的是currentThread()的native方法isInterrupted，而isInterrupted调用的是实例对象的native方法，其中native方法的传参如果是true表示清除中断标志，是false表示不清除中断标志</li></ul></li><li><p>什么是死锁</p><ul><li>死锁是两个或两个以上的线程在执行过程中，为了获取某一资源而相互等待的现象，在无外力帮助的情况下会一直等待下去无法继续运行，例如线程A持有资源1，想要资源2，线程B持有资源2，想要资源1，两个线程都在等待其他线程已经持有的资源就会一直等待下去处于死锁状态</li></ul></li><li><p>线程发生死锁的条件</p><ul><li><p>资源具有排他性，即资源在同一时刻只能由一条线程持有，另外的线程想要持有必须等待到当前线程释放该资源</p></li><li><p>持有某个资源的线程，想要获取其他被持有的资源的时候，进行等待，但此时该线程在阻塞期间不会释放原有的资源</p></li><li><p>持有的资源只能由自己使用完后释放，释放前其他线程不能抢占</p></li><li><p>发生死锁时，一定会有一条 线程 &#x3D;&gt; 资源的环形链，例如 T0线程 &#x3D;》T1线程占用的资源 &#x3D;》T2线程占有的资源。。。。&#x3D;》 Tn线程占有的资源 &#x3D;》 T0线程占有的资源</p><ul><li><p>类似伪代码</p></li><li><pre><code class="java">//线程A重写的run方法synchronized(A)&#123;    sleep(1000);    synchronized(B)&#123;        //do something    &#125;&#125;//线程B重写的run方法synchronized(B)&#123;    sleep(1000);    synchronized(A)&#123;        //do something    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 如何避免死锁</span><br><span class="line"></span><br><span class="line">  - 要想避免死锁，只需破环形成死锁的四个条件中的至少一个条件，我们人为能进行破坏的只有第二条和第四条，破环的方法都是调整资源的访问顺序，保证资源获取的有序性。*所谓有序性，就是假如线程A，B都需要1，2，3....n这些资源，那么获取到资源n条件是已经获取了n-1这个资源*</span><br><span class="line"></span><br><span class="line">    - 以上代码进行如下优化，就会谦让有序不会发生死锁</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      //线程A重写的run方法</span><br><span class="line">      synchronized(A)&#123;</span><br><span class="line">          sleep(1000);</span><br><span class="line">          synchronized(B)&#123;</span><br><span class="line">              //do something</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //线程B重写的run方法</span><br><span class="line">      synchronized(A)&#123;</span><br><span class="line">          sleep(1000);</span><br><span class="line">          synchronized(B)&#123;</span><br><span class="line">              //do something</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li><li><p>对ThreadLocal的了解</p><ul><li>ThreadLocal是JDK包提供的，它提供的是每个线程的本地变量，也就是创建一个ThreadLocal变量以后，当有线程访问这个变量的时候都会有这个变量的本地副本，当多个线程对同一个变量进行操作的时候其实操作的是自己本地内存中的变量，可以避免线程安全问题。即创建ThreadLocal变量后，每个线程都会复制一个变量到自己的本地内存中</li></ul></li><li><p>ThreadLocal的原理</p><ul><li>Thread类中维护了两个ThreadLocalMap类型的变量，一个叫做threadLocals，一个叫做inheritableThreadLocals(下图1)，默认情况下这两个的值都为null，只有当该线程第一次调用ThreadLocal的set或get方法的时候才会创建他们，其实每个线程的本地变量不是存在ThreadLocal中的，而是存在threadLocals这个变量中的，ThreadLocal其实就是一个工具壳，它通过set方法把值存放到调用方法线程的threadLocals变量中，调用get方法再从当前线程的threadLocals变量中拿出来使用(如图2)，如果调用线程一直不终止那么这个本地变量就只存在当前线程的threadLocals中，之所以threadLocals的类型是ThreadLocalMap类型，是因为一个线程可以关联多个ThreadLocal变量(如图3)<ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231010225027854.png" class title="image-20231010225027854"></li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231010225102302.png" class title="image-20231010225102302"></li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231010225251621.png" class title="image-20231010225251621"></li></ul></li></ul></li></ul><ul><li><p>关于ThreadLocal的set方法</p><ul><li>set方法先是获取到当前线程，通过当前线程得到threadLocals这个成员变量，如果这个threadLocals不为null，那么就以this作为key，this代表当前对象，要set的值作为value，放到threadLocals这个map中，如果threadLocals为空，那么就调用cteateMap方法以当前线程为key，要set的值为value新建一个threadLocals对象<ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231012224747251.png" class title="image-20231012224747251"></li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231012224757298.png" class title="image-20231012224757298"></li></ul></li></ul></li><li><p>ThreadLocal支持继承吗</p><ul><li>对于同一个ThreadLocal变量，父线程set的值，子线程是get不到的，因为父线程在set时候村的key是父线程，而子线程在get的时候是以当前线程作为key来获取的threadLocals，所以自然获取不到</li></ul></li><li><p>如何让子线程访问到父线程的ThreadLocal中的值</p><ul><li>可以使用InheritableThreadLocal，InheritableThreadLocal继承自ThreadLocal，同时重写了getMap，createMap，childValue方法，这个类的作用就是为了让父线程设置的本地变量子线程可以访问到，主要就是在Thread类的init方法，父线程在构造子线程的时候，先判断出父类的inheritableThreadLocals这个成员变量是否为空，如果不为空就把父线程中的inheritableThreadLocals这个变量复制一份保存到子线程的inheritableThreadLocals这个成员变量中</li></ul></li><li><p>InheritableThreadLocal的使用场景</p><ul><li>例如子线程需要访问父线程存放到ThreadLocal中的用户登录信息，其实子线程想要获取到父线程的信息还有其他的方式，例如在创建子线程的时候传入父线程的变量复制到子线程中，或者在父线程中构造一个map作为参数传递给子线程，但是这些方法违背了我们使用的习惯，这时InheritableThreadLocal类就显得很关键</li></ul></li><li><p>程序CPU100%，内存和IO利用率都正常，是什么原因，如何排查</p><ul><li>有可能发生死锁，通过java程序的进程ID，使用jstack命令dump出线程文件，查看所有线程处于什么状态，看看是否存在处于BLOCKED状态的线程</li></ul></li><li><p>volatile如何保证可见性</p><ul><li>被volatile修饰的变量在进行写操作的时候，会多出一个lock汇编代码，有了lock前缀在多核处理器会发生两件事，第一件事是将当前处理器缓存行的数据写回到系统内存，第二件事是其他CPU缓存该内存地址的数据置为无效，在多核处理器下，为了保证每个处理器的缓存是一致的，会实现缓存一致性协议，每个处理器在嗅探总线上的传输的数据检查自己缓存的数据是不是过期了，当发现缓存行对应的内存地址发生的修改，那么就会置该缓存行的数据为无效，当处理器再次对该数据进行修改操作的时候会重新从系统内存中重新读取数据保存到处理器缓存行中</li></ul></li><li><p>synchonized关键字的三种使用方式</p><ul><li>用在同步代码块上，此时锁是括号里面配置的对象</li><li>用在普通方法上，此时锁是当前实例对象</li><li>用在静态方法上，此时锁是当前类的Class对象</li></ul><p>当一个线程试图访问同步代码块的时候，必须要先获取到锁，在退出或者出现异常的时候必须释放锁</p></li><li><p>synchonized在JVM的实现原理</p><ul><li>JVM是基于进入和退出Monitor对象来实现同步方法和同步代码块，二者的实现细节略有不同<ul><li>对于同步代码块来说，在编译后会在进入同步代码块之前会加一个monitorenter指令，在同步代码块结束退出或者发生异常的地方monitorexit指令，任何一个对象都有一个monitor与之关联，当monitor被持有后将处于锁定状态，线程执行到monitorenter的时候会尝试获取对应monitor的所有权，即尝试获取对象的锁</li><li>对于同步方法来说，通过反编译得到字节码后可以发现，在方法的flags中多了一个ACC_SYNCHONIZED标志，这会告诉JVM这是一个同步方法</li></ul></li></ul></li><li><p>synchonized锁信息在对象的存储位置</p><ul><li><p>无锁状态</p><ul><li><table><thead><tr><th>锁状态</th><th>25bit</th><th>4bit</th><th>1bit是否是偏向锁</th><th>2bit锁标志位</th></tr></thead><tbody><tr><td>无锁状态</td><td>对象的hashCode</td><td>对象分代年龄</td><td>0</td><td>01</td></tr></tbody></table></li></ul></li><li><p>不同的加锁状态</p><ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231027113647593.png" class title="image-20231027113647593"></li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构算法笔记</title>
      <link href="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><a href="https://leetcode.cn/problems/binary-search/submissions/">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &gt; target)&#123;</span><br><span class="line">                j = m - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[m] &lt; target)&#123;</span><br><span class="line">                i = m + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[m] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>区间开闭分析<ul><li>左闭右闭<ul><li>此时数组中所有的元素都在查找范围内，所以j的大小应该等于数组最后一个元素的索引大小，所以j &#x3D; nums.length - 1，然后判断while循环条件时，根据数组是否合法来判断是否有等于号。左闭右闭的情况下[1,1]这个数组是合法的所以需要等于号。然后进入循环，当nums[m] &gt; target时，此时要更新原数组的右边界，因为已经判断过nums[m] &gt; target了，所以nums[m]一定不是要查找的数，所以 j &#x3D; m - 1。nums[m] &lt; target的情况同理。</li></ul></li><li>左闭右开<ul><li>此时数组中最后一个元素不在查找范围内，所以j的大小应该等于数组最后一个元素的索引大小，所以j &#x3D; nums.length，然后判断while循环条件时，根据数组是否合法来判断是否有等于号。左闭右开的情况下[1,1)这个数组是不合法的所以不能加等于号。然后进入循环，当nums[m] &gt; target时，此时要更新原数组的右边界，由于右边界是开区间 j 还等于m - 1话，此时数组就少了一个元素，所以j应该等于m，如果nums[m] &lt; target的情况同理。</li></ul></li></ul></li></ul><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素 - 力扣（LeetCode）</a></p><ul><li>暴力解法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val == nums[i])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;j &lt; size;j++)&#123;</span><br><span class="line">                    nums[j-<span class="number">1</span>] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">                i --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接两层for循环，第一层for循环主要遍历整个数组，查找要删除的值，找到要删除的值以后，进入第二层for循环，把当前位置后面的所有元素向前移一位，即覆盖要删除的值，此时要把数组的长度减一，<strong>循环i的值减一</strong>,因为此时的数组相当于目标值之后元素都向前移了一位，如果循环的i不减一，那么就会少校验一个元素</p><ul><li>快慢指针法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="type">int</span> <span class="variable">slowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">quickIndex</span> <span class="operator">=</span> <span class="number">0</span>;quickIndex&lt;nums.length;quickIndex++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(val != nums[quickIndex])&#123;</span><br><span class="line">               nums[slowIndex] = nums[quickIndex];</span><br><span class="line">               slowIndex++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure><p><strong>核心思想</strong>：当快指针找到目标值的时候，快指针移向下一位，没有其他任何操作，当快指针指向的不是目标值的时候，把指向的值赋给慢指针所指的位置</p><p>快指针：要去寻找目标值</p><p>慢指针：始终指向的是当快指针找到目标元素后要覆盖的位置</p><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项 - 力扣（LeetCode）</a></p><p>同样使用快慢指针的思想</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">quickIndex</span> <span class="operator">=</span> <span class="number">1</span>;quickIndex&lt;nums.length;quickIndex++)&#123;</span><br><span class="line">            tmp = nums[slowIndex];</span><br><span class="line">            <span class="keyword">if</span>(tmp != nums[quickIndex])&#123;</span><br><span class="line">                nums[++slowIndex] = nums[quickIndex]; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h3><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            nums[i] *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> res.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[begin] &gt;= nums [end])&#123;</span><br><span class="line">                res[k] = nums[begin];</span><br><span class="line">                begin++;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[k] = nums[end];</span><br><span class="line">                end--;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思路：非递减的有序数组就是一个相等或者递增的数组，之所以平方之后会出现不递增的情况，是因为数组中可能含有负数，所以此时可以发现<strong>平方之后的数组的最大值一定出现的数组的两端</strong>，所以定义两个指针分别指向数组的第一个元素和数组的最后一个元素，遍历整个数组，向新的数组中赋值。</p><h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h3><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums.length + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">real</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">fast</span>  <span class="operator">=</span> <span class="number">0</span>;fast &lt; nums.length;fast++)&#123;</span><br><span class="line">            sum += nums[fast];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                real = fast - slow + <span class="number">1</span>;</span><br><span class="line">                res = Math.min(res,real);</span><br><span class="line">                sum -= nums[slow];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == nums.length + <span class="number">1</span> ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是双指针的思想，通过双指针来卡数组的长度，其中for循环中的fast一定指的是截取数组的末尾，类似于快指针，通过结尾和开始来判断中间的数的和是否大于target，当大于target的时候慢指针才开始移动，直到截取的数组之和小于target时，此时快指针继续向前移动。其中<strong>res的值在最开始定义的时候必须是一个比数组长度大的数字</strong>，如果定义数字小于等于数组的长度，此时如果原数组中所有的数字相加正好等于target的时候，就会出现问题。</p><h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h3><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II - 力扣（LeetCode）</a></p><ul><li>方法一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">startx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">starty</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i , j;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num &lt; n/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = starty;j &lt; n - offset;j++)&#123;</span><br><span class="line">                res[startx][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i = startx;i &lt; n - offset;i++)&#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;j &gt;= offset;j--)&#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;i &gt;= offset; i--)&#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            offset++;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            res[startx][starty] = n*n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遵循左闭右开或者左开右闭的原则，通过i和j循环递增和递减的方式，上边右边下边左边依次填充</p><p>这个方法的难点：为什么要转n&#x2F;2圈？因为n是正方形的边长，可以通过startx和starty发现每一圈起点的规律，每一圈的起点一定是从左上角开始向正方形的中心递进</p><ul><li>方法二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        res[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; n*n)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; n - <span class="number">1</span>&amp;&amp;res[i][j+<span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                res[i][++j] = ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n - <span class="number">1</span>&amp;&amp;res[i+<span class="number">1</span>][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                res[++i][j] = ++count;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span>&amp;&amp;res[i][j-<span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                res[i][--j] = ++count;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &gt; <span class="number">0</span>&amp;&amp;res[i - <span class="number">1</span>][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                res[--i][j] = ++count;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接螺旋写数字，关键在于要在写数字的时候知道什么时候要拐弯，这里的判断方法是判断下一个点的数是不是零和判断到没到边界的前一个点（判断是不是边界用于写第一圈，判断是不是零用于写第二圈），如果是零说明可以写数字，因为矩阵中不可能有零，如果到了边界的前一个点说明拐弯了。</p><h3 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h3><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素 - 力扣（LeetCode）</a></p><ul><li>不使用虚拟头节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; head.val == val) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val == val)&#123;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时要分情况讨论</p><ol><li>头节点的值等于要删除的值</li></ol><p>while (head !&#x3D; null &amp;&amp; head.val &#x3D;&#x3D; val)，此时要循环移动head所对应的节点</p><ol start="2"><li>头节点的值不等于要删除的值</li></ol><p>此时要用一个pre变量记录头节点，来完成接下来的一系列操作，因为最后要求返回的是链表的头节点，同时头节点的值不等于要删除的值，所以head的指向不能改变，用cur记录pre的下一个节点，相当于cur和pre两个指针遍历整个链表</p><ul><li>使用虚拟头节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val == val) &#123;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加虚拟头节点的好处是不需要单独判断头节点是否为要删除的val，核心思路就是把<strong>pre指向虚拟头节点！虚拟头节点！虚拟头节点！</strong>，cur指向头节点，然后让这俩个指针遍历整个链表即可</p><h3 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode()&#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//size存储链表元素的个数</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//虚拟头结点</span></span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取第index个节点的数值，注意index是从0开始的，第0个节点就是头结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//如果index非法，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//包含一个虚拟头节点，所以查找第 index+1 个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentNode.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表最前面插入一个节点，等价于在第0个元素前添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表的最后插入一个节点，等价于在(末尾+1)个元素前添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class="line">    <span class="comment">// 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// 如果 index 大于链表的长度，则返回空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">//找到要插入节点的前驱</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pred</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">toAdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        toAdd.next = pred.next;</span><br><span class="line">        pred.next = toAdd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除第index个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pred</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index ; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pred.next = pred.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典题目，基本包含了包含了链表的所有常见操作，主要想好<strong>在get节点的时候，指针要指向该节点，在增删节点的时候，指针指向的是要增删位置节点的前一个节点</strong></p><p>一个小坑：在增加节点的时候先把新增节点的next指向下一个节点，在将cur指向的节点的next指向新增节点，因为如果cur指向的节点先指向了新增节点，那么新增的节点就找不到next要指向谁了</p><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表 - 力扣（LeetCode）</a></p><ul><li>双指针法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个指针指向头节点的前一个即为null，第二个指针指向头节点，注意遍历到cur为null而不是cur的next为null，因为当cur的next为空的时候，此时cur指向的是原链表的最后一个，此时应该进入循环，tmp指针需要保存的是cur的next，因为如果不保存的话，cur的指向已经发生改变了，下一次循环就找不到cur.next了</p><ul><li>递归写法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reverseList(<span class="literal">null</span>,head);      </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode pre,ListNode cur)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        </span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">        <span class="keyword">return</span> reverseList(pre,cur);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路和双指针一摸一样，注意递归终止的条件是cur为空</p><h3 id="两两交换链表中节点"><a href="#两两交换链表中节点" class="headerlink" title="两两交换链表中节点"></a>两两交换链表中节点</h3><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp1</span> <span class="operator">=</span> cur.next.next;</span><br><span class="line">            cur.next = tmp1;</span><br><span class="line">            tmp.next = tmp1.next;</span><br><span class="line">            tmp1.next = tmp;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是使用虚拟头节点的方式，首先要判断什么时候循环结束，当前指向的后两个只要有null就停止循环，交换的顺序一定是要交换的两个节点的前一个节点的前一个节点指向要交换的后一个，要交换的前一个指向下一组的前一个，要交换的后一个节点指向要交换的前一个节点</p><h3 id="删除倒数第几个节点"><a href="#删除倒数第几个节点" class="headerlink" title="删除倒数第几个节点"></a>删除倒数第几个节点</h3><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一提到删除就要想到指针指向的是要删除节点的前一个节点，此时我们就要知道要删的节点的前一个在哪，这时有一个比较巧妙的方法，使用一种<strong>特殊的快慢指针</strong>，开始的时候，快慢指针同时指向虚拟头节点，然后快指针向前移动n个位置，然后快慢指针一起移动，直到快指针到达链表最后一个节点，此时慢指针刚好指向要删除的前一个节点，很巧妙，可以多画图理解</p><h3 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur1</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur2</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            size1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">            size2++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = headA;</span><br><span class="line">        cur2 = headB;</span><br><span class="line">        <span class="keyword">if</span>(size2 &gt; size1)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> size1;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmpList</span> <span class="operator">=</span> cur1;</span><br><span class="line">            size1 = size2;</span><br><span class="line">            size2 = tmp;</span><br><span class="line">            cur1 = cur2;</span><br><span class="line">            cur2 = tmpList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> size1 - size2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; count;i++)&#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1 == cur2)&#123;</span><br><span class="line">                <span class="keyword">return</span> cur1;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解题的关键是要想找到相交的链，这两个链表一定是尾部对齐的，然后短链的指针指向该链的第一个节点，长链的指针从头节点开始向后移动两链表长度之差，这样在链表尾部对齐的情况下，两指针就在同一个位置了，然后依次向后遍历判断是否有相同的节点</p><h3 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h3><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index1</span> <span class="operator">=</span> fast;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index2</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="keyword">while</span>(index1 != index2)&#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题可以分成两个部分，第一是判断是否有环，第二是找出环的入口</p><ol><li>判断是否有环</li></ol><p>使用快慢指针的方法，让快指针每次走两个节点，慢指针走一个节点，如果快慢指针能相遇，那么一定有环</p><ul><li>为什么快慢指针一定能相遇？不会跨过去吗？</li></ul><p>因为快指针的移动速度是2，慢指针的移动速度是1，快指针相对慢指针的速度是1，所以在慢指针看来，快指针是在一个节点一个节点的靠近自己，所以不会跨过去</p><ol start="2"><li>找出环的入口</li></ol><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230909145914203.png" class title="image-20230909145914203"><p>根据公式可以发现，环的入口位置一定等于z加上n倍的圈数，所以可以定两个指针，一个指向头节点位置，一个指向快慢指针相遇位置，两个指针同时以1的速度前进，相遇的位置就是入口位置。</p><h3 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h3><p><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            hash[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; t.length();i++)&#123;</span><br><span class="line">            hash[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; hash.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用一个数组来表示要存放26个字母，a是索引0的数据，z是索引25的数据，然后分别遍历s和t这两个字符串的每一个字母，s和t的每一个字母分别和’a’相减得到每个字母对应的索引，s得到索引后把对应位置的数字加一，t得到索引后把对应位置的数字减一，最后遍历数组的每个数字，如果每个位置的数字都等于0‘，那么每个位置加的次数和减的次数相同，说明是字母异位词</p><h3 id="两个数组元素交集-去重"><a href="#两个数组元素交集-去重" class="headerlink" title="两个数组元素交集(去重)"></a>两个数组元素交集(去重)</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1 == <span class="literal">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="literal">null</span> || nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; resSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历数组1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            set1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历数组2的过程中判断哈希表中是否存在该元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set1.contains(i)) &#123;</span><br><span class="line">                resSet.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[resSet.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : resSet)&#123;</span><br><span class="line">            arr[j++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数组内的元素大小不确定时，可以考虑使用set集合来找交集，思路很简单就是先把第一个数组中所有的元素放到set集合中，然后遍历第二个数组，看set集合中是否包含该元素，如果包含直接放到新的set集合中，因为set集合可以帮我们去重。重点记住相关api，判断是否包含的：set1.contains(i)，往集合中添加元素set1.add(i)，获得集合大小Set.size()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1 == <span class="literal">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="literal">null</span> || nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1001</span>];</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums1.length;i++)&#123;</span><br><span class="line">            hash[nums1[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i &lt; nums2.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[nums2[i]] == <span class="number">1</span>)&#123;</span><br><span class="line">                set.add(nums2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> set.stream().mapToInt(x -&gt; x).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在力扣改版之后，这道题新增了一个条件是元素的大小在0到1000中，此时元素的大小有了范围，所以可以考虑使用数组解决，思路和集合一样，第一个传入的数组直接放到新的，容量为1000的数组中，第二个传入的数组在这个容量为1000的数组中查询</p><h3 id="两个数组元素交集-不去重"><a href="#两个数组元素交集-不去重" class="headerlink" title="两个数组元素交集(不去重)"></a>两个数组元素交集(不去重)</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/submissions/">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[Math.min(nums1.length,nums2.length)];</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; nums1.length &amp;&amp; p2 &lt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[p1] &lt; nums2[p2])&#123;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums2[p2] &lt; nums1[p1])&#123;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                arr[index] = nums1[p1];</span><br><span class="line">                index++;</span><br><span class="line">                p1++;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(arr,<span class="number">0</span>,index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先对两个数组进行从小打到的排序，然后分别定义两个指针分别指向两个数组索引为0的位置，比大小让小的元素对应的指针向前进一个，然后如果相等那么就把该元素记录到新数组重，然后两个指针同时向后前进一位</p><h3 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h3><p><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span>&amp;&amp;!set.contains(n))&#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">            n = getNextNumber(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNumber</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">            res += tmp * tmp;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意获取一个数，每位之和的方法，循环模10的方法取到最后一位，然后除10一直循环到这个数除10为0。然后的关键点在于判断是不是快乐数的终止条件，如果平方和为1了，直接终止循环是快乐数，如果set集合中出现了这个数，说明这个数每位的平方和进入了循环且不等于1，此时一定不是快乐数</p><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和 - 力扣（LeetCode）</a></p><ul><li>暴力</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                    res[<span class="number">0</span>] = i;</span><br><span class="line">                    res[<span class="number">1</span>] = j;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两层循环直接找，时间复杂度O(n²)，不好</p><ul><li>哈希法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(tmp))&#123;</span><br><span class="line">                res[<span class="number">0</span>] = map.get(tmp);</span><br><span class="line">                res[<span class="number">1</span>] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们想到要通过数组的元素来判断是不是我们需要的下标，所以元素和下标我们都需要，所以考虑使用map，注意此时<strong>把元素的值作为map的key，元素的下标作为map的value</strong>，因为要通过元素的值来判断是否符合要求，把他作为key能迅速的查找他是否在map中出现过，一定要在判断的过程中往map里添加，<strong>千万不能把数组全部添加到map中再进行判断，这样可能重复的元素索引值会被覆盖</strong></p><h3 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加"></a>四数相加</h3><p><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums2.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> nums1[i] + nums2[j];</span><br><span class="line">                map.put(s,map.getOrDefault(s,<span class="number">0</span>) + <span class="number">1</span>);                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums3.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums4.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums3[i] + nums4[j];    </span><br><span class="line">                count += map.getOrDefault(-m,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路和两数之和很像，这道题为了降低时间复杂度，可以把四个数组两两分组，然后先遍历其中两个数组，得到他们的和放到map集合中，其中map的key是两元素之和，map的value是这个和出现的次数，然后遍历剩下两个数组，也是先得到两个数的和m，然后在map中找有没有和m相加等于0的key，即-m的key，如果有统计出现-m的次数即可</p><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(right &gt; left)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>])&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三数之和虽然可以考虑和两数之和一样使用哈希法来解决，但是要考虑去重，太麻烦，所以推荐使用双指针法(其实是三个指针，分别指向要想加的三个元素)，核心思路是，先对数组进行从小到大的排序，i先指向数组的第一个元素，left指向i的下一个元素，right指向数组的最后一个元素，然后三个数相加，如果等于大于零说明这三个数相加比目标值大了，让right向前移动，如果小于零则left向后移一位。</p><ul><li>去重细节<ul><li>i的去重，一定是i和i的前一个元素进行比较，即nums[i] &#x3D;&#x3D; nums[i - 1]，因为如果是nums[i] &#x3D;&#x3D; nums[i +1]这样进行比较去重的话，可能会漏掉一些结果，比如{-1，-1，2}，题目只要求数组与数组之间不能重复，没有说数组内的元素不能重复，这样i和i的前一个进行比较如果相等说明这个数已经用过了无需再次遍历直接coontinue</li><li>left和right的去重，一定要保证left&lt;right的情况之下，然后left和后一个进行比较，right和前一个进行计较即可</li></ul></li></ul><h3 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h3><p><a href="https://leetcode.cn/problems/4sum/">18. 四数之和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;k &lt; nums.length;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">0</span>&amp;&amp;nums[k] == nums[k - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; k + <span class="number">1</span>&amp;&amp;nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>)nums[k] + nums[i] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[k],nums[i],nums[left],nums[right]));</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right&amp;&amp;nums[left] == nums[left + <span class="number">1</span>])&#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span>(right &gt; left&amp;&amp;nums[right] == nums[right - <span class="number">1</span>])&#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑和三数之和一样，只是在三数之和的代码逻辑之上加上一层循环，注意去重细节，k指向数组第一个元素，然后去重的时候和前一个元素进行比较，如果相等向前移动，<strong>这里就不要考虑剪枝了，因为数组中可能有负数，有可能两个数越加越小导致直接return漏掉结果</strong></p><h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><p><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典双指针的思路，一个指针指向数组的头节点，另一个指针指向数组的尾节点，然后同时向中间移动</p><h3 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h3><p><a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] strChar = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; strChar.length;i += <span class="number">2</span>*k)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Math.min(strChar.length - <span class="number">1</span>,left + k -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> strChar[left];</span><br><span class="line">                strChar[left] = strChar[right];</span><br><span class="line">                strChar[right] = tmp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(strChar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反转过程和第一个反转字符串一样，但是注意这个遍历的时候需要以2k为单位向前移动for(int i &#x3D; 0;i &lt; strChar.length;i +&#x3D; 2*k)，反转的头节点就是每一次遍历的i，反转尾节点就是数组长度和i+k中较小的一个，这样正好可以满足题目的两个条件</p><h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格 - 力扣（LeetCode）</a></p><ul><li>复制元素直接求解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用StringBuilder追加字符串的方式，遍历原字符串，如果遇到’ ‘就替换成“%20”，思路简单，注意StringBuilde的API使用，另外还需要额外的内存空间</p><ul><li>双指针法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sb.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        s += sb.toString();</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[left] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                ch[right--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                ch[right--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                ch[right] = <span class="string">&#x27;%&#x27;</span>; </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ch[right] = ch[left];</span><br><span class="line">            &#125;</span><br><span class="line">            left--;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路就是遍历原字符串，如果遇到’ ‘的情况就直接在字符串的后面追加两个空位，然后一个指针指向原字符串的最后一个元素，另一个指针指向追加后字符串的最后一个空位，然后向前对新字符串进行填充</p><h3 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h3><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> ch.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch[left] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ch[right] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(index &gt;= left &amp;&amp; ch[index] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index+<span class="number">1</span>;i &lt;= right;i++)&#123;</span><br><span class="line">                sb.append(ch[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(index &gt; left)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(index &gt;= left &amp;&amp; ch[index] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">            right = index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>难点在于多出来的空格如何处理，使用双指针法，先去除字符串两端的空格，一个指针指向字符串的最前面，一个指针指向字符串的最后面，然后向前遍历，直到不是’ ‘，然后使用一个index指针，从后向前遍历每个单词(即等于空的时候停下)，此时有了单词的开始索引(index的指向)和单词结束的索引(right的指向)，这时可以使用StringBuilder拼接这个单词，如果此时index大于left再拼接一个空格表示不是最后一个单词，然后index继续向前走，直到不是空格的时候，让right指向该位置(下一个单词最后一个字母的位置)，此后一直循环即可</p><p>详细图解：<a href="https://leetcode.cn/problems/reverse-words-in-a-string/solutions/1153820/yi-ci-bian-li-shi-xian-fan-zhuan-zi-fu-c-cmos/">https://leetcode.cn/problems/reverse-words-in-a-string/solutions/1153820/yi-ci-bian-li-shi-xian-fan-zhuan-zi-fu-c-cmos/</a></p><h3 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h3><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &gt;= s.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] res = <span class="keyword">new</span> <span class="title class_">char</span>[ch.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n;i &lt; ch.length;i++)&#123;</span><br><span class="line">            res[index] = ch[i];</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            res[index] = ch[i];</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(res);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启一个新的数组，然后先遍历原数组的n到末尾的位置，放到新数组，再遍历原数组的首个元素到n的前一个位置，放到新数组中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &gt;= s.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        reverse(ch,<span class="number">0</span>,n - <span class="number">1</span>);</span><br><span class="line">        reverse(ch,n,ch.length - <span class="number">1</span>);</span><br><span class="line">        reverse(ch,<span class="number">0</span>,ch.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] ch,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> ch[start];</span><br><span class="line">            ch[start] = ch[end];</span><br><span class="line">            ch[end] = tmp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接在原字符串数组中操作，先把数组的首个元素到n的前一个进行反转，然后再把数组的第n个元素到最后一个元素进行反转，最后把数组整个反转，这样可以直接得到返转好的数组</p><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> haystack.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> needle.length();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; h)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>;right &lt; n;right++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &gt; <span class="number">0</span>&amp;&amp;needle.charAt(left) != needle.charAt(right))&#123;</span><br><span class="line">                left = next[left - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(needle.charAt(left) == needle.charAt(right))&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[right] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">0</span>;i &lt; h;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span>&amp;&amp;haystack.charAt(i) != needle.charAt(j))&#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(haystack.charAt(i) == needle.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == n)&#123;</span><br><span class="line">                <span class="keyword">return</span> i - n + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>haystack查询字符串，needle被查询字符串</p><p>暴力解法就是两层for循环遍历两个字符串，如果找不到从查找字符串的第二个字符再次遍历，KMP的核心思路就是找到字符串的最长前后缀长度，可以少遍历几个几个字符串</p><p>前缀：以第一个字符开头的任意长度的字符串</p><p>后缀：以最后一个字符结尾的任意长度字符串</p><p>其中，前缀表示的是被查询的字符串的前几个字符，后缀表示的是查询字符串中的几个字符</p><p>next数组存放的就是每个字符所对应的最长前后缀长度，这样我们遍历到不相符的字符的时候，直接找到该字符前一个字符对应的最长前后缀长度，指针直接指向最长前缀的后一个字符，从那个位置开始遍历，最长的前缀的东西一定在要查询的字符串出现了。。。。。。胡言乱语，刷算法的第一道坎，还是多练吧</p><p>详细分解：<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/1119642/duo-tu-yu-jing-xiang-jie-kmp-suan-fa-by-w3c9c/">https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/1119642/duo-tu-yu-jing-xiang-jie-kmp-suan-fa-by-w3c9c/</a></p><h3 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h3><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串 - 力扣（LeetCode）</a></p><ul><li>拼接法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> s + s;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(ss);</span><br><span class="line">        sb.deleteCharAt(ss.length() - <span class="number">1</span>);</span><br><span class="line">        sb.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">newString</span> <span class="operator">=</span> newStr.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[pre];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>;right &lt; pre;right++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &gt; <span class="number">0</span>&amp;&amp;s.charAt(left) != s.charAt(right))&#123;</span><br><span class="line">                left = next[left - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[right] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">0</span>;i &lt; newString;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span>&amp;&amp;newStr.charAt(i) != s.charAt(j))&#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(newStr.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == pre)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个字符串是ababab这样的由一个子字符串重复出现构成的，那么两个这样的字符串相加，并且掐头去尾后，一定会包含原本的字符串，即相加后abababababab，掐头去尾后bababababa，此时ababab一定在该字符串中，所以就可以使用kmp算法解决</p><ul><li>next数组妙用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[pre];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>;right &lt; pre;right++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &gt; <span class="number">0</span>&amp;&amp;s.charAt(left) != s.charAt(right))&#123;</span><br><span class="line">                left = next[left - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[right] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(next[pre - <span class="number">1</span>] &gt; <span class="number">0</span>&amp;&amp;pre%(pre - next[pre - <span class="number">1</span>]) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果s是一个重复的子字符串，那么他的最大前后缀长度一定是next数组的最后一个位置，此时数组的长度减去最长前后缀长度，得到就是一个子字符串的长度，所以如果原字符串长度%子字符串长度为0，那么它就是重复的子字符串</p><h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Stack stackIn;</span><br><span class="line">    Stack stackOut;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(stackOut.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stackIn.isEmpty())&#123;</span><br><span class="line">                stackOut.push(stackIn.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> (<span class="type">int</span>)stackOut.peek();</span><br><span class="line">        stackOut.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="built_in">this</span>.pop();</span><br><span class="line">        stackOut.push(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stackIn.isEmpty()&amp;&amp;stackOut.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理是使用两个栈来模拟队列，一个栈模拟队列的入口，一个栈模拟队列的出口，队列每次添加数据从入口栈添加，获取数据从出口栈获取，每当出口栈为空的时候，把入口栈的数据全部放到出口栈，因为栈是先进后出的，所以后进入入口栈的数据会先出来放到出口栈的最下面，先进入口栈的数据放到出口栈的最上面形成先进先出的效果</p><h3 id="使用队列实现栈"><a href="#使用队列实现栈" class="headerlink" title="使用队列实现栈"></a>使用队列实现栈</h3><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈 - 力扣（LeetCode）</a></p><ul><li>使用两个队列实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="comment">//q1作为主要的队列，其元素排列顺序和出栈顺序相同</span></span><br><span class="line">    Queue&lt;Integer&gt; q1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//q2仅作为临时放置</span></span><br><span class="line">    Queue&lt;Integer&gt; q2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在加入元素时先将q1中的元素依次出栈压入q2，然后将新加入的元素压入q1，再将q2中的元素依次出栈压入q1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(q1.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            q2.add(q1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        q1.add(x);</span><br><span class="line">        <span class="keyword">while</span>(q2.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            q1.add(q2.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个队列辅助另一个队列实现栈，每次新增元素的时候把第一个队列的所有元素放入第二个队列，然后在第一个队列放入新元素，然后把第二个队列的所有元素放入第一个队列中，实现先进后出</p><ul><li>一个队列实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">     <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        q.add(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        size = q.size();</span><br><span class="line">        <span class="keyword">while</span>(size &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            q.add(q.poll());</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> q.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思路就是在每次弹出元素的时候，根据队列的长度先弹出前n - 1个元素并放到队列尾端，这样再弹出的时候就是最后加入进来的元素，Deque 接口继承了 Queue 接口, 所以 Queue 中的 add、poll、peek等效于 Deque 中的 addLast、pollFirst、peekFirst，peekLast,这样在获取栈顶部元素的时候，直接调用peekLast获取队列的最后一个即可</p><h3 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h3><p><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">Stack</span> <span class="variable">sk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ch.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                sk.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch[i] == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                sk.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch[i] == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                sk.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sk.isEmpty() || !sk.peek().equals(ch[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sk.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无效的括号无非就三种情况，1. 左括号多了 2. 右括号多了 3. 左右括号不匹配，所以可以利用栈先进后出的特点，遍历字符串，如果遇到左括号那么就往栈里面加一个与之对应的右括号，如果遇到右括号看栈里面的peek元素是不是和遍历的右括号相符，如果相符就从栈中把该右括号取出，如果栈空了或者不相符直接返回false，最后整个遍历完根据栈里是否有元素判断是否为有效括号</p><h3 id="删除字符串的相邻重复项"><a href="#删除字符串的相邻重复项" class="headerlink" title="删除字符串的相邻重复项"></a>删除字符串的相邻重复项</h3><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ch.length;i++)&#123;</span><br><span class="line">            ch[slow] = ch[fast];</span><br><span class="line">            <span class="keyword">if</span>(slow &gt; <span class="number">0</span>&amp;&amp;ch[slow] == ch[slow - <span class="number">1</span>])&#123;</span><br><span class="line">                slow--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch,<span class="number">0</span>,slow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用经典的双指针解法就可以搞定，一个快指针遍历整个字符串，慢指针用来判断前后两个字符是不是相等，如果相等慢指针后退，不相等慢指针前进一个，注意最后返回的字符串是从零到慢指针指向的位置</p><h3 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h3><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; sk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; tokens.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;+&quot;</span>.equals(tokens[i])||<span class="string">&quot;-&quot;</span>.equals(tokens[i])||<span class="string">&quot;*&quot;</span>.equals(tokens[i])||<span class="string">&quot;/&quot;</span>.equals(tokens[i]))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> sk.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> sk.pop();</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;+&quot;</span>.equals(tokens[i]))&#123;</span><br><span class="line">                    sk.push(num1 + num2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;-&quot;</span>.equals(tokens[i]))&#123;</span><br><span class="line">                    sk.push(num2 - num1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;*&quot;</span>.equals(tokens[i]))&#123;</span><br><span class="line">                    sk.push(num1 * num2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;/&quot;</span>.equals(tokens[i]))&#123;</span><br><span class="line">                    sk.push(num2/num1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(tokens[i]);</span><br><span class="line">                sk.push(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带有”+-*&#x2F;“这种运算符的都可以考虑用栈来解决，这道题可以把传入的字符串数组看成一个二叉树，按照左右中的顺序进行计算，把整个字符串数组进行遍历放到栈里，然后如果遇到运算符号，从栈顶取出两个元素进行运算，把运算结果放到栈里，当字符换数组遍历完之后栈里剩的数就是最后的结果，很神奇</p><h3 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h3><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> nums.length - k + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[count];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!d.isEmpty()&amp;&amp;nums[d.peekLast()] &lt; nums[i])&#123;</span><br><span class="line">                d.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            d.addLast(i);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!d.isEmpty()&amp;&amp;d.peekFirst() &lt;= i - k)&#123;</span><br><span class="line">                    d.pollFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                res[i - k + <span class="number">1</span>] = nums[d.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法是维护一个单调队列，遍历整个数组，把数组的每一个元素的<strong>索引</strong>放到队列中，但是在每次加入前都要先进行判断，看看当前加入的索引对应的元素是不是比队列尾部索引对应的值大，如果大则队列中尾部索引就删除掉，判断到上一个索引元素大于要加入的或者队列为空为止，然后开始取元素，取元素的条件是遍历的次数要大于等于k-1，然后从头开始看这个队列，如果开头元素索引比i - k还小，说明此时的滑动窗口以及到了开头元素的后面，所以开头的不符合滑动窗口范围的也要进行删除，最后队列的头部就是想要的元素</p><p>以上代码第一个while是从后开始删除不符合的元素索引(<strong>比新加的元素索引对应的值还小</strong>)，第二个while是从前删除不符合的元素索引(不在滑动窗口的范围以内)，i可以代表滑动窗口的最后的位置</p><h3 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h3><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            map.put(nums[i],map.getOrDefault(nums[i],<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((n1, n2) -&gt;n1[<span class="number">1</span>] - n2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> keyValue : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &lt; k)&#123;</span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;keyValue,map.get(keyValue)&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(map.get(keyValue) &gt; pq.peek()[<span class="number">1</span>])&#123;</span><br><span class="line">                pq.remove();</span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;keyValue,map.get(keyValue)&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> [] tmp = pq.remove();</span><br><span class="line">            res[i++] = tmp[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先遍历整个数组，把数组元素作为key，元素出现的频率作为value，保存到map集合中，然后使用PriorityQueue这个优先队列(底层是用栈来实现的)，泛型指定为数组形式，把map中的每一个键值对的两个数作为一个数组放到队列中，<strong>因为我们要保留出现频率高的，所以使用的是小顶堆</strong>，所以规定好排序规则即按照传入数组索引为1的值进行升序排列，然后放入到队列中，保留前K多的数组即可，最后留在队列中的就是前K个最高频率的</p><h3 id="二叉树的前-x2F-中-x2F-后序遍历"><a href="#二叉树的前-x2F-中-x2F-后序遍历" class="headerlink" title="二叉树的前&#x2F;中&#x2F;后序遍历"></a>二叉树的前&#x2F;中&#x2F;后序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历 - 力扣（LeetCode）</a></p><ul><li>递归法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preorderTraversal(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorderTraversal</span><span class="params">(TreeNode cur,List list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(cur.val);</span><br><span class="line">        preorderTraversal(cur.left,list);</span><br><span class="line">        preorderTraversal(cur.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前序遍历：<strong>中</strong>左右，中序遍历：左<strong>中</strong>右，后序遍历：左右<strong>中</strong>。根据”中”这个字位置来记忆这几个遍历的顺序</p><p>使用递归法遍历的核心代码就三行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.add(cur.val);<span class="comment">//中</span></span><br><span class="line">preorderTraversal(cur.left,list);<span class="comment">//左</span></span><br><span class="line">preorderTraversal(cur.right,list);<span class="comment">//右</span></span><br></pre></td></tr></table></figure><p>不管是哪种遍历只需要调整这三行代码顺序即可</p><ul><li>迭代法前序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; sk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        sk.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!sk.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> sk.pop();</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                list.add(cur.val);<span class="comment">//中</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sk.push(cur.right);<span class="comment">//右</span></span><br><span class="line">            sk.push(cur.left);<span class="comment">//左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的是栈这个数据结构，理论上所以的递归操作都可以用栈来模拟，前序遍历的顺序是中左右，然后栈是先进后出的，所以思路就是中节点先入栈，然后处理中间节点，然后中间节点的右节点和左节点先后入栈，这样在弹出元素的时候就可以左节点先弹出处理，右节点后弹出</p><ul><li>迭代法后序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; sk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        sk.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!sk.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> sk.pop();</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                list.add(cur.val);<span class="comment">//中</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sk.push(cur.left);<span class="comment">//左</span></span><br><span class="line">            sk.push(cur.right);<span class="comment">//右</span></span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历的代码直接在前序遍历的基础上改就行，思路就是在我们处理前序遍历<strong>中左右</strong>的时候，处理和放入栈的顺序是<strong>中右左</strong>，此时遍历的顺序是<strong>左右中</strong>，所以只需要在处理和放入栈的时候把在前序遍历的基础上改为<strong>中左右</strong>，这样放入链表的顺序就是<strong>中右左</strong>，最后再使用reverse方法对链表进行反转就变成了<strong>左右中</strong></p><ul><li>迭代法中序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; sk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>||!sk.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                sk.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = sk.pop();</span><br><span class="line">                res.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路就是从根节点开始，一路向左向栈中添加遍历的节点，当遍历到空的时候，从栈中取出栈顶的元素，让当前指针指向该元素，此时这个元素一定是二叉树最左下角的那一个，把他的值加到链表中，然后让指针再指向当前元素的右节点，进入到下一次循环即可，注意进入循环的条件：当前节点的元素和栈有一个不为空即可</p><ul><li>二叉树层序遍历</li></ul><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            d.addLast(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!d.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> d.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> d.pollFirst();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层序遍历的意思是按照二叉树的每一层的元素顺序放到集合中，思路是使用队列，先把根节点放到队列中，然后记录此时队列的大小，然后进入循环，每次循环的次数根据队列中队开始的元素个数决定，把根节点放入到结果集中，然后先后把根节点的左右节点加入到队列中，循环到队列为空</p><h3 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            d.addLast(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!d.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> d.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> d.pollFirst();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层序遍历就是二叉树每一层从左到右遍历一遍，使用的是ArrayDeque这个队列，每从队列中取出一个元素的时候，就看看该元素是否含有子节点，如果有把子节点放入到队列中，注意每次循环此时是最开始遍历时记录的队列的大小，最后方法的调用pollFirst和addLast</p><h3 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h3><p><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        invert(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invert</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span> || (cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.left;</span><br><span class="line">        cur.left = cur.right;</span><br><span class="line">        cur.right = tmp;</span><br><span class="line">        invert(cur.left);</span><br><span class="line">        invert(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归的写法其实很简答，但是写之前一定先想好自己要使用哪种遍历方式，理论上前中后序遍历都可以，但是推荐前序和后序，因为中序写起来比较绕，举个例子：校长说去年是一年级的学生打扫学校，今年轮到二年级的打扫，乍一听没毛病，但仔细一想还是一批人，中序遍历是左中右，把左孩子处理完了，然后处理中间孩子的时候，右孩子变成左孩子了，然后再处理右孩子的时候其实还是左孩子。所以尽量不要使用中序遍历</p><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p><a href="https://leetcode.cn/problems/symmetric-tree/">101. Symmetric Tree - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left,TreeNode right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left.val != right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">out</span> <span class="operator">=</span> compare(left.left,right.right);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">inside</span> <span class="operator">=</span> compare(left.right,right.left);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> out &amp;&amp; inside;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(left.val != right.val)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过了这四个if的筛选此时后面递归处理的情况一定是左右节点都不为空且值相等的情况</p><p>然后进入递归逻辑</p><ul><li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li><li>比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。</li><li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li></ul><h3 id="最大深度"><a href="#最大深度" class="headerlink" title="最大深度"></a>最大深度</h3><ul><li>递归法</li></ul><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getHight(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHight</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHight</span> <span class="operator">=</span> getHight(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHight</span> <span class="operator">=</span> getHight(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span> + Math.max(leftHight,rightHight);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求一个二叉树的最大深度，就是二叉树的最大高度，所以从最下面的叶子节点开始往上数，碰见空节点说明这个空节点的父节点的高度是1，这样父节点的父节点就知道自己的其中一个孩子高度是1，数数的操作体现在int res &#x3D; 1 + Math.max(leftHight,rightHight)这一行，不好理解建议使用层序遍历</p><ul><li>层序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        d.addLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!d.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> d.size();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> d.pollFirst();</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用层序遍历的原因是二叉树的层数正好是二叉树的最大深度，所以每遍历一层计数器加一</p><h3 id="最小深度"><a href="#最小深度" class="headerlink" title="最小深度"></a>最小深度</h3><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        d.addLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!d.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> d.size();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> d.pollFirst();</span><br><span class="line">                <span class="keyword">if</span>(tmp.left == <span class="literal">null</span> &amp;&amp; tmp .right == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接使用层序遍历比较好理解，从根节点开始遍历遇到左右节点都为空的时候，清空直接返回当前的层数就是最小的深度</p><h3 id="完全二叉树节点个数"><a href="#完全二叉树节点个数" class="headerlink" title="完全二叉树节点个数"></a>完全二叉树节点个数</h3><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数 - 力扣（LeetCode）</a></p><ul><li>层序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        d.addLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!d.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> d.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> d.pollFirst();</span><br><span class="line">                list.add(tmp);</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层序遍历一个个数，时间复杂度有点高</p><ul><li>递归</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNums(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNums</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> getNums(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightNum</span> <span class="operator">=</span> getNums(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> leftNum + rightNum + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用递归分别求出根节点左右子树的的个数最后加上根节点的1就是全部节点的数量</p><ul><li>利用完全二叉树的特性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分别看看左右子树是不是满二叉树</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lef</span> <span class="operator">=</span> getNums(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rig</span> <span class="operator">=</span> getNums(root.right);</span><br><span class="line">        <span class="keyword">return</span> lef + rig + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNums</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftCur</span> <span class="operator">=</span> node.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightCur</span> <span class="operator">=</span> node.right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(leftCur != <span class="literal">null</span>)&#123;</span><br><span class="line">            leftCur = leftCur.left;</span><br><span class="line">            leftNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(rightCur != <span class="literal">null</span>)&#123;</span><br><span class="line">            rightCur = rightCur.right;</span><br><span class="line">            rightNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rightNum == leftNum)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; rightNum) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp1</span> <span class="operator">=</span> getNums(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp2</span> <span class="operator">=</span> getNums(node.right);</span><br><span class="line">        <span class="keyword">return</span> tmp1 + tmp2 + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完全二叉树可能出现其根节点的左子树为满二叉树或者完全二叉树本身就是一棵满二叉树，如果是满二叉树可以利用满二叉树的特性，如果不是满二叉树可以按照之前的遍历方式数数，如果是满二叉树的话节点数量为2^depth - 1 ，完全二叉树判断是不是满二叉树的方法是看左节点个数和右节点个数是否相等，利用这个公式还有一个好处是不用遍历完树的所有节点，上面的层序遍历和递归都需要遍历所有节点，而如果是一个满二叉树只需要遍历最左侧和最右侧的节点</p><h3 id="是否是平衡二叉树"><a href="#是否是平衡二叉树" class="headerlink" title="是否是平衡二叉树"></a>是否是平衡二叉树</h3><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> getHigh(root);</span><br><span class="line">        <span class="keyword">if</span>(res &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHigh</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHigh</span> <span class="operator">=</span> getHigh(node.left);</span><br><span class="line">        <span class="keyword">if</span>(leftHigh == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHigh</span> <span class="operator">=</span> getHigh(node.right);</span><br><span class="line">        <span class="keyword">if</span>(rightHigh == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(rightHigh - leftHigh) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + Math.max(rightHigh,leftHigh);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路很简单，就是判断二叉树的每个节点的高度是否超过了一，这个设计很巧妙，先是自底向上查看每个节点的高度，但是如果发现了某个节点已经不是平衡二叉树了就向上返回-1，这样最后只需判断最后返回的结果是不是-1即可</p><h3 id="二叉树所有路径"><a href="#二叉树所有路径" class="headerlink" title="二叉树所有路径"></a>二叉树所有路径</h3><p><a href="https://leetcode.cn/problems/binary-tree-paths/">257. Binary Tree Paths - 力扣（LeetCode）</a></p><ul><li>使用栈</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Object&gt; sk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        sk.push(root);</span><br><span class="line">        sk.push(root.val + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(!sk.isEmpty())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> (String)sk.pop();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> (TreeNode)sk.pop();</span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                res.add(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                sk.push(node.left);</span><br><span class="line">                sk.push(path + <span class="string">&quot;-&gt;&quot;</span> + node.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                sk.push(node.right);</span><br><span class="line">                sk.push(path + <span class="string">&quot;-&gt;&quot;</span> + node.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把已经拼接到路径和遍历到的当前节点放到一个栈中，注意要同时放入和取出，放入栈的路径便于返回，放入栈的节点为判断该节点是否为叶子节点，如果是叶子节点直接把路径放到集合即可，如果不是先给路径拼接好其左右节点的值，然后连同节点放入到栈中，这样做比较简单好理解，但是时间复杂度较高，还可以使用递归+回溯的方法，但是还没有悟道，等想明白了再补充</p><h3 id="左叶子节点之和"><a href="#左叶子节点之和" class="headerlink" title="左叶子节点之和"></a>左叶子节点之和</h3><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftSum(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leftSum</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> leftSum(node.left);</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span> &amp;&amp; node.left.left == <span class="literal">null</span> &amp;&amp; node.left.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            leftNum = node.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightNum</span> <span class="operator">=</span> leftSum(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> rightNum + leftNum;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意左叶子节点的定义，首先他得是一个叶子节点，其次他是父节点的左孩子。而<strong>不是计算所有的左孩子之和</strong>，然后从跟节点开始递归，遇到空节点返回0，**遇到左右孩子都为空的节点也返回0(因为这样的节点一定是叶子节点，但是现在不确定是不是左叶子节点，所以没有必要向下递归了)**，然后在下面进行判断如果当前节点的左孩子的左右孩子都是空那么记录这个数值即可</p><h3 id="树左下角的值"><a href="#树左下角的值" class="headerlink" title="树左下角的值"></a>树左下角的值</h3><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值 - 力扣（LeetCode）</a></p><ul><li>层序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        d.addLast(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!d.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> d.size();</span><br><span class="line">            res = d.peekFirst().val;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> d.pollFirst();</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历每一层之前，把该层的第一个节点的值保存起来，这一定是该层最左边的值</p><ul><li>递归</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> max,res;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        findBottom(root,<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findBottom</span><span class="params">(TreeNode node,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(depth &gt; max)&#123;</span><br><span class="line">            max = depth;</span><br><span class="line">            res = node.val;</span><br><span class="line">        &#125;</span><br><span class="line">        findBottom(node.left,depth + <span class="number">1</span>);</span><br><span class="line">        findBottom(node.right,depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化最大深度为0，然后递归的时候传两个参数，一个是节点一个是当前节点所在的高度，每次向下一层遍历的时候高度要加一，因为不管是前&#x2F;中&#x2F;后序遍历都是左在前，右在后，所以每次修改最大深度max这个参数的都是每层的最左节点，所以此时可以一同修改res的值为该节点的val值</p><h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h3><p><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hasPath(root,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPath</span><span class="params">(TreeNode node,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span>&amp;&amp;node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node.val == target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">leftPath</span> <span class="operator">=</span> hasPath(node.left,target - node.val);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rightPath</span> <span class="operator">=</span> hasPath(node.right,target - node.val);</span><br><span class="line">        <span class="keyword">return</span> leftPath || rightPath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次传入的是根节点和目标值，每次递归传入的是下一个节点和目标值减去当前节点的值，这样在遇到叶子节点时候，可以根据叶子节点值是否等于目标值来判断该路径是否符合要求</p><h3 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h3><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a></p><ul><li>直接构造截开的数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> postorder.length;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">        root.val = postorder[postorder.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="keyword">for</span>(index = <span class="number">0</span>;index &lt; size;index++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[index] == postorder[postorder.length - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] inLeft = <span class="keyword">new</span> <span class="title class_">int</span>[index];</span><br><span class="line">        <span class="type">int</span>[] inRight = <span class="keyword">new</span> <span class="title class_">int</span>[inorder.length - <span class="number">1</span> -index];</span><br><span class="line">        <span class="type">int</span>[] postLeft = <span class="keyword">new</span> <span class="title class_">int</span>[index];</span><br><span class="line">        <span class="type">int</span>[] postRight = <span class="keyword">new</span> <span class="title class_">int</span>[inorder.length - <span class="number">1</span> -index];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; inLeft.length;i++)&#123;</span><br><span class="line">            inLeft[i] = inorder[i];</span><br><span class="line">            postLeft[i] = postorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; inRight.length;i++)&#123;</span><br><span class="line">            inRight[i] = inorder[index + i + <span class="number">1</span>];</span><br><span class="line">            postRight[i] = postorder[inLeft.length + i];</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = buildTree(inLeft,postLeft);</span><br><span class="line">        root.right = buildTree(inRight,postRight);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题思路很简单，但是边界的处理很麻烦，一定注意边界使用的是左闭右开还是左闭右闭，核心思路是通过后序的数组的最后一个元素创建出根节点，然后拿到这个元素在中序遍历的数组中把中序的数组截开，截开后前半部分就是左树的长度，根据这个长度可以在后序的数组中拿到后序的截开后的数组，然后分别剩下的就是中后序遍历的右树的数组</p><ul><li>递归法(思路和上面完全一样)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map;  <span class="comment">// 方便根据数值查找位置</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123; <span class="comment">// 用map保存中序序列的数值对应位置</span></span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> findNode(inorder,  <span class="number">0</span>, inorder.length, postorder,<span class="number">0</span>, postorder.length);  <span class="comment">// 前闭后开</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">findNode</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> inBegin, <span class="type">int</span> inEnd, <span class="type">int</span>[] postorder, <span class="type">int</span> postBegin, <span class="type">int</span> postEnd)</span> &#123;</span><br><span class="line">        <span class="comment">// 参数里的范围都是前闭后开</span></span><br><span class="line">        <span class="keyword">if</span> (inBegin &gt;= inEnd || postBegin &gt;= postEnd) &#123;  <span class="comment">// 不满足左闭右开，说明没有元素，返回空树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> map.get(postorder[postEnd - <span class="number">1</span>]);  <span class="comment">// 找到后序遍历的最后一个元素在中序遍历中的位置</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(inorder[rootIndex]);  <span class="comment">// 构造结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lenOfLeft</span> <span class="operator">=</span> rootIndex - inBegin;  <span class="comment">// 保存中序左子树个数，用来确定后序数列的个数</span></span><br><span class="line">        root.left = findNode(inorder, inBegin, rootIndex,</span><br><span class="line">                            postorder, postBegin, postBegin + lenOfLeft);</span><br><span class="line">        root.right = findNode(inorder, rootIndex + <span class="number">1</span>, inEnd,</span><br><span class="line">                            postorder, postBegin + lenOfLeft, postEnd - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序和中序构造二叉树"><a href="#前序和中序构造二叉树" class="headerlink" title="前序和中序构造二叉树"></a>前序和中序构造二叉树</h3><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; inorder.length;i++)&#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(inorder,<span class="number">0</span>,inorder.length,preorder,<span class="number">0</span>,preorder.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] inorder,<span class="type">int</span> inBegin,<span class="type">int</span> inEnd,<span class="type">int</span>[] preorder,<span class="type">int</span> preBegin,<span class="type">int</span> preEnd)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inBegin &gt;= inEnd || preBegin &gt;= preEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(preorder[preBegin]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index - inBegin;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(inorder[index]);</span><br><span class="line">        root.left = build(inorder,inBegin,index,preorder,preBegin + <span class="number">1</span>,preBegin + <span class="number">1</span> + leftSize);</span><br><span class="line">        root.right = build(inorder,index + <span class="number">1</span>,inEnd,preorder,preBegin + <span class="number">1</span> + leftSize,preEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上一道题思路一模一样，只不过这次从前序数组中的第一个元素在中序数组来截开</p><p>详细分析一下构造二叉树的传参(左闭右开)</p><ul><li>构造左子树的时候：需要前序和中序的左部分<ul><li>中序的左部分<ul><li>开始：其实就是inorder的第一个元素，因为左中右的顺序每次截开后，第一个元素一定是截开后要的左部分的第一个</li><li>结束：直接就是截开位置的索引，因为左中右和左闭右开</li></ul></li><li>前序的左部分<ul><li>开始：每一次都是在上一次开始的基础上加一，因为中左右，每次舍弃掉中也就是第一个即可</li><li>结束：先找到<strong>本次</strong>前序的左部分开始位置的索引，在这个索引的基础上加上左部分的长度</li></ul></li></ul></li><li>构造右子树的时候：需要前序和中序的右部分<ul><li>中序的右部分<ul><li>开始：直接就是截开的索引位置加一</li><li>结束：就是每一次传入的inEnd，这个值其实和中序左部分开始一样是不变的</li></ul></li><li><strong>前序的右部分(这部分最关键，最容易弄错导致数组越界)</strong><ul><li>开始：在<strong>本次</strong>左部分开始位置的索引加上左部分的长度</li><li>就是每一次传入的preEnd</li></ul></li></ul></li></ul><p><strong>防错技巧：记住前序遍历的左部分的结尾就是右部分的开始索引，还是因为左闭右开</strong></p><h3 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h3><p><a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> constructMaximumBinaryTree1(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree1</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> leftIndex, <span class="type">int</span> rightIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rightIndex - leftIndex &lt; <span class="number">1</span>) &#123;<span class="comment">// 没有元素了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightIndex - leftIndex == <span class="number">1</span>) &#123;<span class="comment">// 只有一个元素</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[leftIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> leftIndex;<span class="comment">// 最大值所在位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxVal</span> <span class="operator">=</span> nums[maxIndex];<span class="comment">// 最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> leftIndex + <span class="number">1</span>; i &lt; rightIndex; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; maxVal)&#123;</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxVal);</span><br><span class="line">        <span class="comment">// 根据maxIndex划分左右子树</span></span><br><span class="line">        root.left = constructMaximumBinaryTree1(nums, leftIndex, maxIndex);</span><br><span class="line">        root.right = constructMaximumBinaryTree1(nums, maxIndex + <span class="number">1</span>, rightIndex);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造思路和上两题差不多，都是通过切割数组，注意好传参的边界，提前想好左闭右开还是左闭右闭，不用上两题的map结构，而是递归找最大值和索引的方式可以减少用时</p><h3 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h3><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span> &amp;&amp; root2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1 != <span class="literal">null</span> &amp;&amp; root2 ==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        root1.val += root2.val;</span><br><span class="line">        root1.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">        root1.right = mergeTrees(root1.right,root2.right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时操作两个二叉树，但是不难，如果递归到的两个节点都是null那么向上返回null，两个节点都有值返回相加值很好理解，主要是想明白如果一个为空另一个不为空的时候要直接返回那一个不为null的节点即可</p><h3 id="二叉搜索树搜索"><a href="#二叉搜索树搜索" class="headerlink" title="二叉搜索树搜索"></a>二叉搜索树搜索</h3><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索 - 力扣（LeetCode）</a></p><ul><li>直接递归找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> searchBST(root.left,val);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> searchBST(root.right,val);</span><br><span class="line">        <span class="keyword">if</span>(leftNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用二叉搜索树(左节点小于根节点，右节点大于根节点)的特性找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root.val)&#123;</span><br><span class="line">            res = searchBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root.val)&#123;</span><br><span class="line">            res = searchBST(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用迭代法找，还是根据二叉搜索树的特性，可以根据要得到的val的值的大小，来确定要递归的方向</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val &lt; root.val)&#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &gt; root.val)&#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证是否为二叉搜索树"><a href="#验证是否为二叉搜索树" class="headerlink" title="验证是否为二叉搜索树"></a>验证是否为二叉搜索树</h3><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树 - 力扣（LeetCode）</a></p><ul><li>中序递归遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">leftValid</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; pre.val &gt;= root.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rigthValid</span> <span class="operator">=</span> isValidBST(root.right);</span><br><span class="line">        <span class="keyword">return</span> leftValid &amp;&amp; rigthValid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是死死抓住二叉搜索树的特性进行求解，如果一个二叉树是二叉搜索树那么这个树的中序遍历一定是一个递增的数列，所以这道题直接使用二叉树的中序遍历，比较当前节点的值是否比上一个大即可，注意遍历到空节点的时候直接返回的是true而不是false，这里可以想一个极端的情况，比如这个树的跟节点就是空，那么这个树一定是个二叉搜索树</p><ul><li>中序迭代遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; sk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span> || !sk.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">                sk.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> sk.pop();</span><br><span class="line">            <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; pre.val &gt;= tmp.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = tmp;</span><br><span class="line">            root = tmp.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树最小差值"><a href="#二叉搜索树最小差值" class="headerlink" title="二叉搜索树最小差值"></a>二叉搜索树最小差值</h3><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        getMinimum(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMinimum</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getMinimum(cur.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span>)&#123;</span><br><span class="line">            res = Math.min(res,cur.val - pre.val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        getMinimum(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是利用二叉搜索树的中序遍历的特性，此时最小的插值一定出现在遍历后数组的相邻两个元素中，和上一题的递归法思路很像，仍然使用双指针操作一棵二叉树，每次比较之后把pre指针指向当前节点</p><h3 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h3><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. Find Mode in Binary Search Tree - 力扣（LeetCode）</a></p><ul><li>暴力</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        find(root,map);</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Integer key : map.keySet())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            <span class="keyword">if</span>(tmp == max)&#123;</span><br><span class="line">                list.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(TreeNode root,Map&lt;Integer,Integer&gt; map)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(root.val,map.getOrDefault(root.val,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(map.get(root.val) &gt; max)&#123;</span><br><span class="line">            max = map.get(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        find(root.left,map);</span><br><span class="line">        find(root.right,map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力法，第一遍使用任何一种遍历顺序，把二叉树中的所有元素进行一个统计，以二叉树的值为key，出现的次数作为value放到一个map中，同时不断地更新出现最大次数的值，第二次遍历这个map，如果map的value为最大出现的频率，那么直接放到结果集中</p><ul><li>双指针法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    TreeNode pre ;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        find(root);</span><br><span class="line">        <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        find(cur.left);</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="literal">null</span>)&#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pre.val == cur.val)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="keyword">if</span>(count == max)&#123;</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; max)&#123;</span><br><span class="line">            max = count;</span><br><span class="line">            list.clear();</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">        &#125;</span><br><span class="line">        find(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一些代码技巧可以只遍历一次，此时要维护两个变量，第一个max表示最大出现的频率，第二个count表示当前节点的值出现的频率，同时这种方法必须使用中序遍历，因为只有中序遍历后的顺序才能保证这个二叉树非递减排列，双指针计数的过程是如果pre节点为空，那么说明此时的cur节点指向了叶子节点此时count为1，如果cur和pre相同说明这个值的频率不为1，所以count要加一，如果pre和cur不相等了说明这个数统计完了，此时要统计新的数，把count重新初始为1，放入结果集的时候很有意思，刚放入的时候先不管这个最大频率是不是真正的最大频率，只要出现的频率等于这个最大频率那么就先放入结果集中，然后如果遇到了更大的频率那么把原先的结果集清空，然后修改最大频率，然后将此时的值放到结果集中</p><h3 id="二叉树最近公共祖先"><a href="#二叉树最近公共祖先" class="headerlink" title="二叉树最近公共祖先"></a>二叉树最近公共祖先</h3><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(leftNode != <span class="literal">null</span> &amp;&amp; rightNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(leftNode == <span class="literal">null</span> &amp;&amp; rightNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(leftNode != <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公共祖先一定是要从底向上遍历寻找，所以优先会考虑使用后序遍历，即先看左右孩子的情况再决改向上一层返回什么，核心思路就是碰到了p或q节点直接向上返回，如果一个节点的左右孩子都不是空那么这个节点一定就是想要的公共节点，如果只有一个节点不为空那么直接向上返回不为空的节点，这样处理的话可以考虑到所有情况</p><ol><li>第一种情况：公共节点不是pq本身，再结合题目所说二叉树中一定包含pq节点，这样一定会在</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(leftNode != <span class="literal">null</span> &amp;&amp; rightNode != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个条件中找到想要的公共祖先</p><ol start="2"><li>第二种情况：公共节点是pq本身，那么此时一定会在</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root == p || root == q)&#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个节点找到想要的公共节点，这时哪怕p或q有一个没遍历到也没有关系，因为公共节点已经找到了</p><h3 id="二叉搜索树最近公共祖先"><a href="#二叉搜索树最近公共祖先" class="headerlink" title="二叉搜索树最近公共祖先"></a>二叉搜索树最近公共祖先</h3><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）</a></p><ul><li>递归法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这道题使用上一题的代码完全没有问题，因为二叉搜索树也是二叉树，自底向上递归一定找到最近的公共节点，但是可以狠狠利用二叉搜索树的特性来提升代码的执行效率，再强调一遍什么时二叉搜索树，即根节点的<strong>所有</strong>子节点都比根节点的值要小，跟节点的<strong>所有</strong>右节点都比根节点的值要大，所以当pq的值都比根节点小的时候，此时一定只需要向左递归即可，当pq的值都比根节点的值要大的时候，此时一定只需要向右递归，<strong>当根节点的值处于pq的中间时，此时这个节点就是最大公共节点，因为此时不管是向左遍历还是向右遍历一定会错过pq其中一个节点</strong></p><h3 id="插入二叉搜索树"><a href="#插入二叉搜索树" class="headerlink" title="插入二叉搜索树"></a>插入二叉搜索树</h3><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. Insert into a Binary Search Tree - 力扣（LeetCode）</a></p><ul><li>递归法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题很简单，但是题目的描述很具与迷惑性，他说答案不一定唯一，比如要插入的值可能在叶子节点也可能在根节点，<strong>但是要想明白所有的二叉搜索树再插入一个不同的元素的时候一定可以找到一个叶子节点来插入的</strong>，所以只需要考虑如何找到这个叶子节点即可</p><ul><li>迭代法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">index</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur = root;</span><br><span class="line">            <span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(cur.val &lt; val)&#123;</span><br><span class="line">            cur.right = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.val &gt; val)&#123;</span><br><span class="line">            cur.left = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代法这个地方有个小坑，就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">    root = root.left;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">    root = root.right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方要写成if(){}else if(){}的形式,不能写成两个if，因为第一种形式表示如果第一个条件成立了，那么执行第一个if中的逻辑，同时不会判断第二个else if中的条件更不会执行其中的逻辑，如果是第二种形式会进行第二个if条件的判断，此时如果已经执行完了第一个if中的逻辑可能会发生空指针异常</p><h3 id="有序数组转为二叉搜索树"><a href="#有序数组转为二叉搜索树" class="headerlink" title="有序数组转为二叉搜索树"></a>有序数组转为二叉搜索树</h3><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左闭右开版</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin &gt;= end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(end - begin == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[begin]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (begin + end)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = sortedArrayToBST(nums,begin,mid);</span><br><span class="line">        root.right = sortedArrayToBST(nums,mid + <span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左闭右闭版</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(end == begin)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[begin]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (begin + end)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = sortedArrayToBST(nums,begin,mid - <span class="number">1</span>);</span><br><span class="line">        root.right = sortedArrayToBST(nums,mid + <span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和前面根据中序遍历和后序遍历构造二叉树思路相似，有序数组可以看成二叉搜索树的中序遍历，然后根据题目要求要左右的高度差不超过1，所以可以使用每次传递数组的中间的数值作为根节点，仍然要注意左闭右开和左闭右闭的问题</p><h3 id="二叉搜索树转累加树"><a href="#二叉搜索树转累加树" class="headerlink" title="二叉搜索树转累加树"></a>二叉搜索树转累加树</h3><p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        convert(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        convert(node.right);</span><br><span class="line">        node.val += pre;</span><br><span class="line">        pre = node.val;</span><br><span class="line">        convert(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题最难的是读题，他的意思是要先找到二叉搜索树中最大的节点的值，然后以此节点为基础不断向前累加，因为是一个二叉搜索树，所以遍历的顺序是右中左，使用双指针的思路不断累加即可</p><h3 id="删除二叉搜索树节点"><a href="#删除二叉搜索树节点" class="headerlink" title="删除二叉搜索树节点"></a>删除二叉搜索树节点</h3><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. Delete Node in a BST - 力扣（LeetCode）</a></p><ul><li>暴力删除，先把二叉树中序遍历，得到一个数组，在数组中删除目标节点，然后根据数组构造树二叉搜索树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        getArray(root);</span><br><span class="line">        <span class="keyword">if</span>(list.contains(key))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> list.indexOf(key);</span><br><span class="line">            list.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size();i ++)&#123;</span><br><span class="line">            arr[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> combine(arr,<span class="number">0</span>,arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getArray</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getArray(node.left);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        getArray(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">combine</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin &gt;= end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(end - begin == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(arr[begin]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (begin + end)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(arr[mid]);</span><br><span class="line">        root.left = combine(arr,begin,mid);</span><br><span class="line">        root.right = combine(arr,mid + <span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>递归法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right;</span><br><span class="line">                <span class="keyword">while</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                cur.left = root.left;</span><br><span class="line">                root = root.right;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; key)</span><br><span class="line">            root.left = deleteNode(root.left,key);</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; key)</span><br><span class="line">            root.right = deleteNode(root.right,key);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分五种情况考虑</p><ol><li><p>没有找到要删除的节点</p></li><li><p>要删除的节点左右子树都为空，即根节点不用调整二叉树结构</p></li><li><p>要删除的节点左不为空右为空，直接将该节点的父亲的左子树指向该节点的左子树</p></li><li><p>要删除的节点右不为空左为空，直接将该节点的父亲的右子树指向该节点的右子树</p></li><li><p>要删除的节点左右节点全不为空，可以将该节点的任意左右子节点替换该节点，同时调整二叉树结构，<br>例如：当把右孩子替换该节点的时候可以把左子树放到比要替换的节点大一位的节点的左侧 (即左下角)</p><p>​当把左孩子替换该节点的时候可以把右子树放到比要替换节点为跟的树的最大的位置(即右下角)</p></li></ol><h3 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h3><p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; low)&#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; high)&#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = trimBST(root.left,low,high);</span><br><span class="line">        root.right = trimBST(root.right,low,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>牢记三句话：<ul><li>当前节点的值小于目标范围的时候，只需要处理该节点的右孩子</li><li>当前节点的值大于目标范围的时候，只需要处理该节点的左孩子</li><li>当前节点符合要求范围的时候，直接处理其左右孩子</li></ul></li></ul><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p><a href="https://leetcode.cn/problems/combinations/">77. 组合 - 力扣（LeetCode）</a></p><ul><li>基础版</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        traceBack(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traceBack</span><span class="params">(<span class="type">int</span> length,<span class="type">int</span> size,<span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == size) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= length; i++) &#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            traceBack(length, size, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231023125112589.png" class title="image-20231023125112589"><p>通过递归函数的传参，来确定每一次遍历的次数，每次递归开始的值比上一次大一，因为上一次已经取走一个数了，当path的路径和要求一致的时候，就可以往结果集中放了，然后弹出最后一个元素，这就是回溯的过程，因为如果不弹出的话就会一直往一个集合中放入元素，导致超出要求范围</p><ul><li>剪枝版</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        traceBack(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traceBack</span><span class="params">(<span class="type">int</span> length,<span class="type">int</span> size,<span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == size)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt;= length - (size - path.size()) + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            traceBack(length,size,i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为什么需要剪枝？因为回溯是一个纯暴力的搜索的方式，如果不加以控制那么他会遍历整个树形结构，即便某些情况下条件一定不会成立，但是他还是会进行遍历，例如，当n&#x3D;4，k&#x3D;3的情况，当startIndex&gt;2的时候是没必要遍历的，因为3或者4开头凑不够要求的3个大小</p><p>剪枝操作往往是在每次递归后的for循环条件中做文章</p><p>本题的剪枝是n-(k - path.size())+1,(k - path.size())这部分是为算出还需要往path集合中放入多少元素，n-(k - path.size())+1就可以算出本次循环最多可以从哪个位置开始，+1是因为剪完之后的长度的后一个元素是符合条件的，例如n&#x3D;5，k&#x3D;3，size&#x3D;1，这样k - path.size()的值是2，说明此时path集合还需要两个元素，然后通过n-2+1&#x3D;4，说明4是至多开始的位置</p><h3 id="组合总和Ⅲ"><a href="#组合总和Ⅲ" class="headerlink" title="组合总和Ⅲ"></a>组合总和Ⅲ</h3><p><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        build(k,n,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum == n &amp;&amp; path.size() == k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt;= <span class="number">9</span> - (k - path.size()) + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            build(k,n,i + <span class="number">1</span>,sum);</span><br><span class="line">            sum -= i;</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和组合问题很像，组合问题只需要考虑收集的集合中元素个数，来作为递归终止的条件，但是这道题在组合的基础上加了一个集合内元素之和大小的限制，相当于加了一个递归终止的条件，然后也多了一个剪枝的可能性，即当组合中的和已经大于了目标值即使元素个数还没有达到要求这时也没必要向下递归了</p><h3 id="电话号码字母组合"><a href="#电话号码字母组合" class="headerlink" title="电话号码字母组合"></a>电话号码字母组合</h3><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String[] numString = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        backTracking(digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String digits,<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">            list.add(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> numString[digits.charAt(index) - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            path += String.valueOf(str.charAt(i));</span><br><span class="line">            backTracking(digits, index + <span class="number">1</span>);</span><br><span class="line">            path = path.substring(<span class="number">0</span>,path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是要把字符串的每个数字想象成一个树形结构，字符串的长度是要递归的深度，字符串的每一个数字对应的字符串长度代表每次循环的次数，首先要把每个数字对应的字符串保存到一个一维数组中，其中0和1这两个用空串表示，之所以这次递归使用的是index来表示接下来要遍历的数字而不是startIndex，是因为之前的题目实在同一个集合上进行的组合操作，而这道题是不同集合的组合操作，所以只需要保留要遍历字符串的索引即可，而每当递归到一个新的集合时候一定是从头遍历到尾</p><h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h3><p><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        combination(candidates,target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">combination</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target,<span class="type">int</span> index,<span class="type">int</span> sum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; candidates.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum + candidates[i] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            combination(candidates,target,i,sum);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题比较关键的地方在于数组中的数字可以重复使用，所以每次循环的开始和上一次递归的开始是一样的，这个题比较难想的地方在于如何剪枝，要想到对这个数组进行排序，然后在收集的过程中，如果收集的内容已经超过目标值了，这是就不需要接下来的递归了</p><h3 id="组合总和Ⅱ"><a href="#组合总和Ⅱ" class="headerlink" title="组合总和Ⅱ"></a>组合总和Ⅱ</h3><p><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">  <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">( <span class="type">int</span>[] candidates, <span class="type">int</span> target )</span> &#123;</span><br><span class="line">    <span class="comment">//为了将重复的数字都放到一起，所以先进行排序</span></span><br><span class="line">    Arrays.sort( candidates );</span><br><span class="line">    backTracking( candidates, target, <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">( <span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> start )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( sum == target ) &#123;</span><br><span class="line">      res.add( <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;( path ) );</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++ ) &#123;</span><br><span class="line">      <span class="comment">//正确剔除重复解的办法</span></span><br><span class="line">      <span class="comment">//跳过同一树层使用过的元素</span></span><br><span class="line">      <span class="keyword">if</span> ( i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] ) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      sum += candidates[i];</span><br><span class="line">      path.add( candidates[i] );</span><br><span class="line">      <span class="comment">// i+1 代表当前组内元素只选取一次</span></span><br><span class="line">      backTracking( candidates, target, i + <span class="number">1</span> );</span><br><span class="line">      sum -= candidates[i];</span><br><span class="line">      path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的难点在于给的数组元素含有重复元素，例如[10,1,2,7,6,1,5]，当target&#x3D;8的时候[1,7]这个结果可能会出现两次，所以需要进行去重操作，去重的时候要先对数组进行排序，[1,1,2,5,6,7,10]对于同一条路径不需要去重，因为两个1可以出现在结果中，当不是同一条路径的时候，比如把第一个1放到路径中然后递归完后面的所有元素，当要放第二个1到路径中的时候就需要去重，因为此时以1开头的结果在第一个1的时候已经收集完了，所以也就是candidates[i] &#x3D;&#x3D; candidates[i - 1]的时候，直接进入下一层循环即可</p><h3 id="分割回文子串"><a href="#分割回文子串" class="headerlink" title="分割回文子串"></a>分割回文子串</h3><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        part(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">part</span><span class="params">(String s,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= s.length())&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i  &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(decide(s,index,i))&#123;</span><br><span class="line">                path.add(s.substring(index,i + <span class="number">1</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            part(s,i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">decide</span><span class="params">(String s,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) != s.charAt(right))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的难点在于一定要想清楚这个切割过程的树形结构</p><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231029222404968.png" class title="image-20231029222404968"><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231029222511499.png" class title="image-20231029222511499"><p>例如这种位置，先判断是不是回文串，再放入到path中，判断的方法是固定index不动，改变i的值来确定要切割的长度，如果当前切割出来字符串不符合要求则直接continue，然后注意substring这个方法切割的时候是左闭右开的</p><h3 id="修复IP地址"><a href="#修复IP地址" class="headerlink" title="修复IP地址"></a>修复IP地址</h3><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">        backTracking(sb, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(StringBuilder s, <span class="type">int</span> startIndex, <span class="type">int</span> dotCount)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dotCount == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(s,startIndex,s.length() - <span class="number">1</span>))&#123;</span><br><span class="line">                result.add(s.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(s,startIndex,i))&#123;</span><br><span class="line">                s.insert(i + <span class="number">1</span>,<span class="string">&quot;.&quot;</span>);</span><br><span class="line">                backTracking(s,i + <span class="number">2</span>,dotCount + <span class="number">1</span>);</span><br><span class="line">                s.deleteCharAt(i + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//[start, end]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(StringBuilder s, <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(start) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i &lt;= end;i++)&#123;</span><br><span class="line">            num = num * <span class="number">10</span> + s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; <span class="number">255</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的关键在于，维护一个dotCount变量来记录当前IP地址已经被我们加了多少个”.”,当”.”的个数到了三个的时候，就达到了IP地址的标准，所以此时只需要验证最后一个点后面的部分是否合格即可，还有一个注意点是在进入下一次递归的时候，startIndex是2，因为已经加了一个”.”了</p><p>还有一个注意点就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(num &gt; <span class="number">255</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个判断一定要放在for循环中，因为字符串可能特别长导致超出Integer的最大值</p><h3 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h3><p><a href="https://leetcode.cn/problems/subsets/">78. 子集 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        backtracking(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= nums.length)&#123;<span class="comment">//相当于一个剪枝，可以不写</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; nums.length;i++)&#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtracking(nums,i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们每次递归往结果加入的path集合都是不一样的，而且这些集合一定都是原数组的子集，所以一上来不用判定任何条件直接加入到res集合中即可，</p><h3 id="子集问题Ⅱ"><a href="#子集问题Ⅱ" class="headerlink" title="子集问题Ⅱ"></a>子集问题Ⅱ</h3><p><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtracting(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracting</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= nums.length)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; index &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                backtracting(nums,i + <span class="number">1</span>);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和组合总和Ⅱ的去重思路相同，每次循环的时候，如果不是第一次往里面放元素，那么就要先检查要放入的元素和上一次放入的是不是相同即可，别忘了对数组进行排序</p><h3 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h3><p><a href="https://leetcode.cn/problems/non-decreasing-subsequences/">491. 递增子序列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        find(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!path.isEmpty() &amp;&amp; path.get(path.size() - <span class="number">1</span>) &gt; nums[i] || set.contains(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            find(nums,i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这个题一定不能对数组进行排列，因为排序以后他的子序列就变了</p><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231103212851949.png" class title="image-20231103212851949"><p>同一层的节点不能取相同的值，而同一个数枝上的数可以取相同的，例如[4,7,6,7,8,9]这个数组，同一个树枝指的是每次递归，所以[4，7，7]是可以作为递增子序列的，而同一层节点的时候，如果取了第一个7，那么7后面的所以可能都被第一个7尝试过了，所以同层时候不能取相同数值，即这种地方</p><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231103213600993.png" class title="image-20231103213600993"><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231103213624668.png" class title="image-20231103213624668"><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p><a href="https://leetcode.cn/problems/permutations/">46. 全排列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        find(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(path.contains(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                find(nums);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保证每次递归时候循环都是从零开始遍历的，然后每次向path集合中添加元素的时候，判断是否存在即可，因为原始数组是不重复的</p><h3 id="全排列Ⅱ"><a href="#全排列Ⅱ" class="headerlink" title="全排列Ⅱ"></a>全排列Ⅱ</h3><p><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        Arrays.fill(used,<span class="literal">false</span>);</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrack(nums,used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">boolean</span>[] used)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>&amp;&amp;nums[i] == nums[i - <span class="number">1</span>]&amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="literal">false</span>)&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                backtrack(nums,used);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题首先要明白为什么会出现重复，才能理解应该在什么地方剪枝，例如[1,1,2]，当选完第一个1的时候得到两个结果[1,1,2]和[1,2,1]的时候，回溯以后要选第二个1，此时会出现重复所以要剪枝，也就是说不同深度的元素可以重复，同一层级的元素不可以重复</p><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231105160110922.png" class title="image-20231105160110922"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span>&amp;&amp;nums[i] == nums[i - <span class="number">1</span>]&amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>)&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个判断条件的前两个就是看看要添加的元素和前一个是否相同，第三个判断条件就是看看是不是在同一层，如果是同一层要加入元素的前一个元素对应的使用情况应该是false，因为他刚刚被回溯撤销</p><h3 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h3><p><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[][] checkerboard = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] ch : checkerboard)&#123;</span><br><span class="line">            Arrays.fill(ch,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(<span class="number">0</span>,n,checkerboard);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> n,<span class="type">char</span>[][] checkerboard)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == row)&#123;</span><br><span class="line">            res.add(array2List(checkerboard));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>;col &lt; n;col++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isValid(row,col,n,checkerboard))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            checkerboard[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            backtrack(row + <span class="number">1</span>,n,checkerboard);</span><br><span class="line">            checkerboard[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">array2List</span><span class="params">(<span class="type">char</span>[][] checkerboard)</span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] ch : checkerboard)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">String</span>(ch));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col,<span class="type">int</span> n,<span class="type">char</span>[][] checkerboard)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; row;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(checkerboard[i][col] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span> , j = col - <span class="number">1</span>;i &gt;= <span class="number">0</span>&amp;&amp;j &gt;= <span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(checkerboard[i][j] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>,j = col + <span class="number">1</span>;i &gt;= <span class="number">0</span>&amp;&amp;j &lt;= n - <span class="number">1</span>;i--,j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(checkerboard[i][j] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>维护了一个char类型的二维数组来模拟一个棋盘，初始的时候棋盘里面元素都为’.’，然后进行循环判断，如果当前该位置合法，那么就把当前元素改为’Q’,然后再次递归，每次递归表示要处理的是下一行，所以传参的时候row要加一，for循环表示判断该行的每一个位置是否合法，然后是如何判断是否合法，根据当前遍历到的行和列为基准，进行三次判断分别是 1.该位置的这一列是否包含’Q’,2.该位置45°左上角是否包含’Q’，3.该位置45°右上角是否包含’Q’，如果全不包含那么这就是一个合法的位置</p><h3 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h3><p><a href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        backtrack(board);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; <span class="number">9</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">char</span> <span class="variable">num</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;num &lt;= <span class="string">&#x27;9&#x27;</span>;num++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(isValid(i,j,num,board))&#123;</span><br><span class="line">                            board[i][j] = num;</span><br><span class="line">                            <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> backtrack(board);</span><br><span class="line">                            <span class="keyword">if</span>(res)&#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col,<span class="type">char</span> num,<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] == num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[row][i] == num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startRow</span> <span class="operator">=</span> (row / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startCol</span> <span class="operator">=</span> (col / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startRow;i &lt; startRow + <span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> startCol;j &lt; startCol + <span class="number">3</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == num)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维递归，这道题和N皇后的区别在于，这道题的棋盘上的每一个位置都要填数，所以每一个位置都要遍历到，所以使用双重for循环来定位每一个位置，然后通过该位置是否是’.’来决定要不要处理，如果是’.’那么就需要对该位置进行处理，遍历1-9这九个数然后判断是否符合数独的条件，在判断行和列的时候很简单只需要遍历，看是否重复即可，然后每一个九宫格的话是先进行除3的操作，然后再乘以3可以定位到九宫格开始的位置，比如遍历到的列是第5列，（5&#x2F;3）&#x3D; 1 ，1*3&#x3D;3，3正好是5这一列开始判断合法的列，关于本题的剪枝操作是通过返回一个boolean类型的变量来剪枝的，当1-9这九个数字全部遍历完成后都不能满足要求那么，说明以前的插入就有问题了无需向下遍历，直接进行回溯，当所有的位置都不是’.’的时候说明找到了一个结果，这时直接返回true即可</p><h3 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h3><p><a href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> g.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(index &gt;= <span class="number">0</span>&amp;&amp;s[index] &gt;= g[i])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让更多的孩子吃到饼干，所以让大的饼干尽量给胃口大孩子吃，先对数组排序，饼干和胃口都是从大到小遍历，保证饼干不动胃口向前遍历，直接第一个满足饼干的胃口，这时就找到了这个饼干能满足的最大的胃，然后饼干再向前遍历</p><h3 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h3><p><a href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prediff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curdiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            curdiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="keyword">if</span>((prediff &gt;= <span class="number">0</span>&amp;&amp;curdiff &lt; <span class="number">0</span>)||(prediff &lt;= <span class="number">0</span>&amp;&amp;curdiff &gt; <span class="number">0</span>))&#123;</span><br><span class="line">                count++;</span><br><span class="line">                prediff = curdiff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求摆动序列的最大长度，其实并不需要把不符合的数组元素进行删除，只需要在出现波峰波谷的位置给计数器加一即可。</p><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231111115016474.png" class title="image-20231111115016474"><p>然后会出现三种情况：</p><ol><li>摆动中有平坡</li></ol><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231111115539808.png" class title="image-20231111115539808"><p>这时有两种方法，第一种就是从左向右删除二直到只剩一个二，第二种就是从右向左删除二直到只剩一个二，由于数组是从左向右遍历的，所以这里选择保留最后一个二，体现在代码中就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((prediff &gt;= <span class="number">0</span>&amp;&amp;curdiff &lt; <span class="number">0</span>)||(prediff &lt;= <span class="number">0</span>&amp;&amp;curdiff &gt; <span class="number">0</span>))<span class="comment">//左边是平坡，右边不是的时候，这时需要记录</span></span><br></pre></td></tr></table></figure><ol start="2"><li>波峰&#x2F;波谷出现在数组首尾</li></ol><p>这里的处理方式是默认尾部就是一个峰&#x2F;谷，所以计数器从一开始计数，然后对于第一个元素的判断可以看成第一个元素前面还有一个和第一个元素相同的虚拟值，例如[1,2]是两个，这时想象成[1,1,2]经过代码的判断还是两个</p><ol start="3"><li>单调坡中有平坡</li></ol><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231111120405222.png" class title="image-20231111120405222"><p>这里的处理方式是，不用每次遍历都更新prediff的值，由于平坡的存在导致不知道是摆动还是持续上升，所以只有当出现要记录的时候才更新prediff</p><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h3><p><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; max)&#123;</span><br><span class="line">                max = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思想是，进行求和运算的时候，实时记录最大值的大小，同时当某一个子序列的总和小于零的时候，让下一个元素成为新序列的头节点，因为总和小于零对于后面的元素来说一定是累赘</p><h3 id="买卖股票的最佳时机Ⅱ"><a href="#买卖股票的最佳时机Ⅱ" class="headerlink" title="买卖股票的最佳时机Ⅱ"></a>买卖股票的最佳时机Ⅱ</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++)&#123;</span><br><span class="line">            res += Math.max(prices[i] - prices[i - <span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常思路是在最低点的时候买股票，最高点的时候卖股票，比如prices[2] - prices[0]就是第三天的时候卖，第一天的时候买，这个式子可以拆成prices[2] - prices[1] + prices[1] - prices[0],也就是每一天的利润，我们可以计算出每一天的利润，然后只取赚的时候，最终就是赚的最多的</p><h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h3><p><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= cover;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + i&gt; cover)&#123;</span><br><span class="line">                cover = nums[i] + i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cover &gt;= nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题不需要关系具体是如何跳跃的，只需要记录当前位置可以跳跃到的最大范围，然后依次遍历范围内的所有元素，来寻找更大的范围，如果找到的范围超过了数组的最大索引，说明可以跳跃到，反之则不行</p><h3 id="跳跃游戏Ⅱ"><a href="#跳跃游戏Ⅱ" class="headerlink" title="跳跃游戏Ⅱ"></a>跳跃游戏Ⅱ</h3><p><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            next = Math.max(next,nums[i] + i);</span><br><span class="line">            <span class="comment">//能进到这个if中，说明下一次就可以跳到最后，所以res+1，然后break即可</span></span><br><span class="line">            <span class="keyword">if</span>(next &gt;= nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//到这里说明目前遍历的范围还不能到最后一个，所以还需要继续往前跳，所以当遍历到当前覆盖的最后一个的时候，直接更新下一次覆盖的最大范围，并且向前跳一步</span></span><br><span class="line">            <span class="keyword">if</span>(i == cover)&#123;</span><br><span class="line">                cover = next;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路很简单，就是每次跳到覆盖最远位置的元素，而不是跳到覆盖范围内元素最大的位置，cover表示当前能够覆盖的最大范围，next表示当前覆盖范围内，下一次覆盖的最远位置，res表示要跳的次数</p><h3 id="K-次取反后最大化的数组和"><a href="#K-次取反后最大化的数组和" class="headerlink" title="K 次取反后最大化的数组和"></a>K 次取反后最大化的数组和</h3><p><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> changeIndex(nums);</span><br><span class="line">            nums[index] = -nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">changeIndex</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; min)&#123;</span><br><span class="line">                min = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次符号的改变都找最小的数字，这样的话如果是负数，那么最小的负数变号之后就是最大的，利于求和，如果是正数，最小的正数在变号以后都会变成绝对值小的负数这样也利于求和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span>&amp;&amp;k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums[i] = -nums[i];</span><br><span class="line">                k--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; <span class="number">0</span>&amp;&amp;k % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            nums[<span class="number">0</span>] = -nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种思路是先对数组从小到大进行排序，然后从头开始变号，此时只有当数字小于零的时候，符号改变，如果全是正数那就跳出循环，看k的奇偶性，如果k是偶数那么就不用变号了，如果k是奇数那么就把最小的正数变为负数即可</p><h3 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h3><p><a href="https://leetcode.cn/problems/gas-station/">134. 加油站 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; gas.length; i++) &#123;</span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                index = i + <span class="number">1</span>; </span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于究竟从哪个站开始走，取决于该站对总体的作用是上升还是下降，如果是上升能不能后面的所有站，满足这两个要求就可以保证绕一圈，比如gas&#x3D;[2,5,2,3,5],cos&#x3D;[1,2,8,2,4]的情况下，我们要看对总体的作用就是看油和花费的差值，即[1,3,-6,1,4]这个数组，从头开始累加，如果累加过程中出现了负数，说明跨不过去，这时把累加的数值清零，然后索引记录当前累加到的后一个，然后重新累加，直到累加过程中没有负数</p><h3 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h3><p><a href="https://leetcode.cn/problems/candy/">135. 分发糖果 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] candy = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        Arrays.fill(candy,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; candy.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i - <span class="number">1</span>])&#123;</span><br><span class="line">                candy[i] = candy[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> candy.length - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i + <span class="number">1</span>])&#123;</span><br><span class="line">                candy[i] = Math.max(candy[i + <span class="number">1</span>] + <span class="number">1</span>,candy[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; candy.length;i++)&#123;</span><br><span class="line">            res += candy[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这种需要两边都考虑的题目，解决的策略是先考虑一边，然后再考虑另一边，首先每个孩子最少有一个糖，所以初始化一个值全为1的数组，然后先考虑右边孩子是否比左边孩子评分高，此时数组从左向右遍历，因为右边孩子的糖果是在左边孩子的基础上加的，如果高给对应孩子的糖果加一，然后考虑左边孩子是否比右边孩子评分高，此时需要数组从后向前遍历，因为左边孩子加糖果是在右边孩子糖果的基础上加的，然后加一之后在和这个孩子原本糖果的数量进行比较取最大值，因为最大值一定可以满足既比左边孩子高而且比右边孩子高的条件</p><h3 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h3><p><a href="https://leetcode.cn/problems/lemonade-change/">860. 柠檬水找零 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>[] bills)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">five</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ten</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bills.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bills[i] == <span class="number">5</span>) &#123;</span><br><span class="line">                five++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bills[i] == <span class="number">10</span>) &#123;</span><br><span class="line">                five--;</span><br><span class="line">                ten++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bills[i] == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ten--;</span><br><span class="line">                    five--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    five -= <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (five &lt; <span class="number">0</span> || ten &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题确实简单，记录好每次收到钱的面值即可，5元直接记录，10元只能用5元找零，20元可以用一张10元和一张5元找零或三张五元找零，这样的话在每次遍历以后看剩余的5元，10元是不是负的即可确认是否能找零，这道题贪心贪在20元找零的时候，这时优先使用10元和5元的组合找零，而不是3个五元的，因为5元更万能，既可以找零20，又可以找零10</p><h3 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h3><p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">        Arrays.sort(people,(a,b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> b[<span class="number">0</span>] - a[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] person : people)&#123;</span><br><span class="line">            list.add(person[<span class="number">1</span>],person);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[people.length][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目还是需要两个维度考虑，一个是自身的身高，一个是需要多少个比自己高的人，所以还是要先抓住一个维度，在考虑另外一个维度，比如people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]的时候，先考虑需要多少个比自己高的人的话，排序结果为[[5,0],[7,0],[6,1],[7,1],[5,2],[4,4]] (当需要相同个数高的人站在自己前面的时候身高高的往后站),这时发现再根据身高进行后序调整的时候不好操作了，所以先考虑身高，排序完的people： [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]，身高相同需要前面站的人多的往后站，排序完就会发现“需要多少个比自己高的人”这个条件变成了要插入队列的索引</p><p>插入的过程：</p><ul><li>插入[7,0]：[[7,0]]</li><li>插入[7,1]：[[7,0],[7,1]]</li><li>插入[6,1]：[[7,0],[6,1],[7,1]]</li><li>插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]</li><li>插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]</li><li>插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</li></ul><p>后面的人往中间插是一定不会影响之前的排序结果的，因为身高是降序排列，所以后面的人的位置变动只会影响自己的需要多少个比自己高的人这个元素，然后因为题目要求往队列里面插入的时候一般是中间插入较多，所以使用ArrayList效率要稍高于LinkedList</p><h3 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h3><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        Arrays.sort(points, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; points.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i - <span class="number">1</span>][<span class="number">1</span>] &lt; points[i][<span class="number">0</span>])&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                points[i][<span class="number">1</span>] = Math.min(points[i - <span class="number">1</span>][<span class="number">1</span>],points[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为题目传入的气球位置是乱序的，所以这时需要对气球的左边界进行升序排列，这样有利于对重叠的气球进行统计，<strong>注意这个地方要使用Integer内置的比较函数不会出现数值溢出，</strong>然后就可以判断左边气球的右边界和右边气球的左边界的大小关系，如果左边气球的右边界小于右边气球的左边界这时说明需要再多来一根弓箭，如果左边气球的有边界大于等于右边气球的左边界，说明这时一根弓箭可以直接射穿，此时为了判断下一个气球是不是可以一块射穿，需要更新这两个气球的最小右边界，只有下一个气球的左边界小于等于这俩气球的最小右边界才可以一块射穿</p><h3 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h3><p><a href="https://leetcode.cn/problems/non-overlapping-intervals/description/">435. 无重叠区间 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(intervals,(a,b) -&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt; intervals[i - <span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                count++;</span><br><span class="line"></span><br><span class="line">                intervals[i][<span class="number">1</span>] = Math.min(intervals[i][<span class="number">1</span>],intervals[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上一题很像，上一题是在两个区间不重叠的时候进行计数表示一个箭可以射穿，这道题是在两个区间重叠的时候进行计数，然后同样更新最小右边界方便下一个区间比较</p><h3 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h3><p><a href="https://leetcode.cn/problems/partition-labels/description/">763. 划分字母区间 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] lasIndex = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            lasIndex[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            right = Math.max(right,lasIndex[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span>(i == right)&#123;</span><br><span class="line">                res.add(right - left + <span class="number">1</span>);</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题的意思是同一个字符只能出现在分割之后的同一个字符串，也就说从原字符串的第一个位置开始收集，那么最少要收集到这个字符在字符串中最后一次出现的位置，在遍历的过程中还会收集到的字符，也要遍历到这些字符的最后位置，所以这个最后位置是动态更新的，取这些字符最后位置的最大值，最后放到集合中即可，记录字符最后出现的位置的方法是，遍历整个字符串，然后用每一个字符减去’a’作为字符所在数组的位置，然后不断更新最后一次在字符中出现就是最大值</p><h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><p><a href="https://leetcode.cn/problems/merge-intervals/description/">56. 合并区间 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//按照左边界排序</span></span><br><span class="line">        Arrays.sort(intervals, (x, y) -&gt; Integer.compare(x[<span class="number">0</span>], y[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">//initial start 是最小左边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightmostRightBound</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt; rightmostRightBound)&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start,rightmostRightBound&#125;);</span><br><span class="line">                start = intervals[i][<span class="number">0</span>];</span><br><span class="line">                rightmostRightBound = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                rightmostRightBound = Math.max(rightmostRightBound,intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, rightmostRightBound&#125;);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先按照范围的左边界进行排序，记录第一个元素的左右边界，然后判断下一个元素左边界和当前记录边界的右边界的关系，如果大于直接把当前记录的边界放入到的集合中，并且更新左右边界为当前遍历的元素，反之只需要更新右边界(如果右边界比当前记录的右边界大的话)，最后注意遍历到最后一个边界的时候，不管这个边界和之前记录的边界范围什么关系都需要把这个边界放到集合中，因为intervals[ i ][ 0]  &gt; rightmostRightBound这种情况放入集合的是当前记录边界，而不是最后一个边界</p><h3 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h3><p><a href="https://leetcode.cn/problems/monotone-increasing-digits/description/">738. 单调递增的数字 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(n);</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[i - <span class="number">1</span>] &gt; ch[i])&#123;</span><br><span class="line">                ch[i - <span class="number">1</span>]--;</span><br><span class="line">                flag = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> flag;i &lt; s.length();i++)&#123;</span><br><span class="line">            ch[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(<span class="keyword">new</span> <span class="title class_">String</span>(ch));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题的思路挺牛逼的，当前一位的数字比后一位大的时候，这个时候因为后一位不能变大了，但是为了让后面的大于前面的，所以让前一位减一，然后后一位变成9，例如332，此时个位比十位小，所以让十位减一，让个位等于九，此时是局部最优，然后依次遍历可以达到全局最优，注意要使用一个标记为表示该位后面的所有位都变成9，而不是当出现位数差值的时候才变成9，全部变成9才是全局最优</p><p>至于遍历顺序问题，可以带入模拟一下，如果从前往后遍历332，在遍历结束的时候就会变成329，就不对了，我们是要根据后面的结果来判断前面数字的改变</p><h3 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h3><p><a href="https://leetcode.cn/problems/binary-tree-cameras/description/">968. 监控二叉树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**状态表示：</span></span><br><span class="line"><span class="comment">        0：无覆盖</span></span><br><span class="line"><span class="comment">        1：有摄像头</span></span><br><span class="line"><span class="comment">        2：有覆盖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span>  res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCameraCover</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(getState(root) == <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getState(cur.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getState(cur.right);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">2</span>&amp;&amp;right == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="number">0</span>||right == <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>截至目前最简单的一个hard题，贪心的思路在于要想到叶子节点的个数一定是大于根节点的，为了让摄像头的个数最少，由于叶子节点的特性，不要让叶子节点出现的摄像头，因为他的覆盖范围小，要让叶子节点的父节点放摄像头，所以这里要使用后序遍历，从下往上安放摄像头，通过子节点的状态判断父节点的状态，来判断是否放摄像头</p><ol><li>当左右节点都是有覆盖状态，这时该节点的状态是无覆盖</li><li>当左右节点至少有一个无覆盖，这时该节点必须放一个摄像头，状态为一</li><li>当左右节点至少有一个摄像头，这时该节点的状态是有覆盖</li></ol><p>之所以遇到空节点的时候要返回有覆盖的状态，是为了让叶子节点的父节点来放摄像头，如果返回另外两种状态那么父节点就放不上摄像头了，最后的根节点返回的状态结果记得处理，也就是根节点如果是无覆盖的状态，那么要在跟节点上放一个摄像头</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程笔记</title>
      <link href="/2023/07/23/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/23/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="并发编程笔记"><a href="#并发编程笔记" class="headerlink" title="并发编程笔记"></a>并发编程笔记</h2><h4 id="wait-amp-notify"><a href="#wait-amp-notify" class="headerlink" title="wait&amp;notify"></a>wait&amp;notify</h4><ul><li>原理</li></ul><p>已经获得锁的线程发现后续的运行不满足条件时，会调用wait方法，线程状态变成waiting，此时和等待锁的线程一样处于阻塞状态，不会占用CPU的时间片，只有当其他线获取到锁并且满足此线程运行的条件后，调用**notify(挑一个线程唤醒)或者notifyAll(唤醒所有线程)**方法唤醒该线程，使得该线程重新进入到队列中重新争抢锁</p><img src="/2023/07/23/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20230723173807210.png" class title="image-20230723173807210"><ul><li>wait&amp;sleep</li></ul><ol><li>区别</li></ol><p>①wait是Object的方法，sleep是Thread的方法</p><p>②调用wait会释放掉锁，而sleep还会占用着锁</p><p>③sleep不需要配合synchronized使用，wait必须要获得到锁才能调用，所以必须配合synchronized使用</p><ol start="2"><li>相同点：</li></ol><p>调用wait和sleep都会使线程进入到TIMED_WAITING状态</p><ul><li>wait&amp;notify的正确使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可能不满足条件的线程部分</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    <span class="keyword">while</span>(!条件不成立)&#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//干活代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改条件使以上线程继续运行的线程部分</span></span><br><span class="line">lock.notifyAll();</span><br></pre></td></tr></table></figure><p><strong>wait一般和notifyAll配合使用，如果使用的是notify，且该锁对象中有多个调用了wait方法的线程，此时因为随机唤醒线程的原因，会导致虚假唤醒的发生</strong></p><h4 id="同步模式-保护性暂停"><a href="#同步模式-保护性暂停" class="headerlink" title="同步模式-保护性暂停"></a>同步模式-保护性暂停</h4><p><em>一个线程需要等待另一个线程的执行结果</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">protectStop</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;等待获取&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> guardedObject.get(<span class="number">2000</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;结果为：&#123;&#125;&quot;</span>,o);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行任务&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                guardedObject.complete(res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">        <span class="comment">//记录开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//记录经历时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">passTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (timeout - passTime &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.wait(timeout - passTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                passTime = System.currentTimeMillis() - begin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.response = obj;</span><br><span class="line">            <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="join原理"><a href="#join原理" class="headerlink" title="join原理"></a>join原理</h4><p><em>与保护性暂停的原理相同，都是根据开始时间和经过时间进行判断</em></p><ul><li>源码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深入理解Java虚拟机》阅读笔记</title>
      <link href="/2023/07/03/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/03/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校长书籍推荐</title>
      <link href="/2023/07/03/%E6%A0%A1%E9%95%BF%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"/>
      <url>/2023/07/03/%E6%A0%A1%E9%95%BF%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<img src="/2023/07/03/%E6%A0%A1%E9%95%BF%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/image-20230703172235266.png" class title="image-20230703172235266"><p>MySQL性能优化指南（提高实操性）</p><p>MySQL技术内幕：innodb存储引擎</p><p>深入理解Java虚拟机：看2，3，7，8，12章</p><p>并发编程的艺术</p><p>netty redis zk</p><p>redis设计与实战：5，9，<strong>10</strong>，11，15，16，17</p><p>设计模式：（等校长的书）</p><p>spring源码：先不看了</p><p>springboot技术内幕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二篇博客</title>
      <link href="/2023/07/02/javaweb/"/>
      <url>/2023/07/02/javaweb/</url>
      
        <content type="html"><![CDATA[<h2 id="IDEA工具开发Servlet程序"><a href="#IDEA工具开发Servlet程序" class="headerlink" title="IDEA工具开发Servlet程序"></a>IDEA工具开发Servlet程序</h2><ol><li>第一步：New Project 创建一个空项目，然后在空工程下新建Module模块（这不是必须的，只是一个习惯），可以直接创建一个非空的Project,起名为javaweb（不是必须的）</li><li>第二步：新建模块(File–&gt;new–&gt;Module..)</li></ol><ul><li>这里新建的是一个普通的JavaSE模块(这里先不要新建Java Enterprise模块)</li><li>这个Module自动会被放在Javaweb的project下面</li><li>Module起名：servlet01</li></ul><ol start="3"><li>第三步：让Module变成JavaEE模块(让Module变成javaweb的模块)</li></ol><ul><li>在Module上右键点击:Add Framework Support(添加框架支持)</li><li>在弹出的窗口，选择Web Application(选择的是webapp的支持)</li><li>选择了这个webapp支持后，idea会自动生成一个符合servlet规范的webapp目录结构</li><li><strong>重点，需要注意：在idea工具中根据Web Application模块生成的目录中有一个web目录，这个目录就代表webapp的根</strong></li></ul><ol start="4"><li>第四步（非必须）：根据Web Application生成的资源中有index.jsp文件，这里可以选择删除这个index.jsp文件</li><li>第五步：编写servlet</li></ol><ul><li>class studentServlet implements Servlet</li><li>这个时候发现Servlet.class文件没有，怎么办？将CATALINA_HOME&#x2F;lib&#x2F;servlet-api.jar添加到class.path当中(File–&gt;Project Structrue–&gt;Modules–&gt;+加号–Add jars…)</li><li>实现jakarta.servlet.Servlet接口中的五个方法</li></ul><ol start="6"><li>第六步：在Servlet当中的servlet方法中编写业务代码并连接数据库。</li><li>第七步：在WEB-INF目录下新增了一个子目录：lib(这个目录名不能随意，必须全部小写),并且将连接数据库驱动的jar包放到lib目录下。</li><li>第八步：在web.xml文件中完成StudentServlet类的注册（请求路径和servlet对应起来）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>studentServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.javaweb.servlet.StudentServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>studentServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet/student<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="9"><li>第九步：写一个html页面写一个超链接，用户点击这个超链接，发送请求。Tomcat执行后台的studentServer</li></ol><ul><li>student.html</li><li>这个文件不能放到WEB-INF目录中,只能放到WEB-INF目录外面</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>student list<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/xmm/servlet/student&quot;</span>&gt;</span>第一个servlet<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="10"><li>第十步：让idea工具去关联Tomcat，关联的过程中将webapp部署到Tocmat服务器中。</li></ol><ul><li>idea工具右上角，绿色锤子旁边有一个：Add Configuration</li><li>点击加号，点击Tomcat Server–&gt;local</li><li>在弹出的界面中设置服务器Server的参数(基本不用动)</li><li>在当前窗口中有一个Deployment(点击这个用来部署webapp),继续点击加号，部署即可</li><li>修改Application context为：html页面中的项目名&#x2F;xmm</li></ul><ol start="11"><li>第十一步：启动Tomcat服务器</li></ol><ul><li>点击右上角的小虫子，可以采用debug的模式启动Tomcat服务器</li><li>我们在开发中建议使用debug的方法启动Tomcat</li></ul><ol start="12"><li>打开浏览器在地址栏输入：http:localhost:8080&#x2F;xmm&#x2F;student.html</li></ol><h2 id="servlet的生命周期"><a href="#servlet的生命周期" class="headerlink" title="servlet的生命周期"></a>servlet的生命周期</h2><ol><li>servlet对象是由谁来维护</li></ol><ul><li>servlet对象的创建，对象的方法调用和对象的销毁，java程序员无权干预</li><li>servlet对象的生命周期是由Tomcat服务器负责的</li><li>Tomcat服务器通常称为WEB容器，WEB容器管理Servlet对象的死活</li></ul><ol start="2"><li><p>自己new的servlet的对象不归WEB容器管理(WEB容器创建的Servlet对象，这些对象会被放到一个集合中管理，自己new的对象不在容器当中)</p></li><li><p>Tomcat服务器在默认情况下Servlet对象不会被实例化，这个设计是合理的，如果提前创建出来所有的Servlet对象，必然是耗费内存的，并且如果创建出来的Servlet如果一直没有用户访问，显然这个Servlet是一个废物，没有必要先创建</p></li><li><p>servlet对象生命周期</p></li></ol><ul><li>用户发送第一次请求的时候，servlet对象实例化，并且执行无参构造方法</li><li>对象创建之后，Tomcat立马调用init方法(init方法执行的时候，servlet对象已经存在，已经被创建出来了)</li><li>init方法执行后，Tomcat立马调用了servlet的service方法</li><li>用户第二、三、四……次请求的时候，servlet对象不会新建，还是使用之前新建的servlet对象，此时直接调用service方法，这说明：<ul><li>第一：servlet对象是单例的（单实例的，需要注意：servlet对象是单实例的，但是servlet类并不符合单例模式，我们称之为假单例。之所以单例是因为servlet对象的创建java程序员不管，对象的创建是由Tomcat说了算的，Tomcat只创建了一个，所以导致了单例，但是属于假单例，真单例模式构造方法是私有化的）</li><li>第二：无参数构造方法，init得到只在第一次用户发送请求的时候执行，也就是说无参数构造方法只执行一次，init方法只调用一次</li><li>第三：用户发一次请求service方法必然会被Tomcat服务器调用一次</li></ul></li></ul><ol start="5"><li>关闭服务器</li></ol><ul><li>servlet的destroy方法会被Tomcat调用一次</li><li>destroy方法是在服务器关闭的时候调用的，因为要销毁对象的内存</li><li>销毁对象内存之前，Tomcat服务器会自动调用destroy方法，destroy方法调用之前，对象还在没有销毁，方法执行结束后，对象内存才被Tomcat释放</li></ul><ol start="6"><li>当我们在Servlet类中编写一个有参构造方法，没有手动编写无参构造方法会出现什么问题？</li></ol><ul><li>报500错误，是一个HTTP协议的错误状态码</li><li>500一般情况下是因为服务器端的Java程序出了问题，没有无参构造方法，会导致出现500错误，无法实例化Servlet对象</li><li>所以一般情况下不建议程序员定于构造方法</li></ul><ol start="7"><li>构造方法和init都是在对象创建的时候执行一次，能不能用无参构造方法代替init方法？</li></ol><ul><li>不能，因为作为Java程序员，编写Serclet类的时候，不建议手动编写构造方法，很容易让无参构造方法消失，这个操作很可能使Servlet无法实例化</li></ul><ol start="8"><li>init，destroy，service方法什么时候使用</li></ol><ul><li>使用最多的是service方法，service一定要实现，service方法是处理用户请求的核心方法</li><li>init方法很少用，通常在init方法中做初始化操作，并且这个初始化操作只执行一次，比如初始化数据库连接池，初始化线程池</li><li>destroy方法也很少用，进行资源的关闭，马上对象被销毁，还有什么没有关闭的抓紧时间关闭，还有什么资源没保存的抓紧保存。</li></ul><h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><ul><li><p>servlet是一个接口，是servlet规范中的一员</p></li><li><p>由Tomcat(WEB服务器)实现servletContext接口</p></li><li><p>ServletContext对象由WEB服务器在启动的时候创建的</p></li><li><p>对于一个webapp只有一个ServletContext对象，对象在服务器关闭的时候销毁</p></li><li><p>ServletContext对应的其实是web.xml文件，Tomcat是一个容器，一个webapp中可以放多个webapp，一个webapp对应一个ServletContext对象</p></li><li><p>ServletContext接口中常用的方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getInitParameter</span><span class="params">(String name)</span>;<span class="comment">//通过初始化参数name获取value</span></span><br><span class="line"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title function_">getInitParameterNames</span><span class="params">()</span>;<span class="comment">//获得所有初始化参数的name</span></span><br><span class="line"><span class="comment">//通过ServletContext对象记录日志</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message , Throwable t)</span></span><br><span class="line"><span class="comment">//这些日志记录到C:\Users\ZDKJ\AppData\Local\JetBrains\IntelliJIdea2020.2\tomcat\Unnamed_servlet02</span></span><br><span class="line"><span class="comment">//Tomcat服务器logs目录下的日志文件</span></span><br><span class="line"><span class="comment">//catalina.2022-11-03.log 服务器端的Java程序运行的控制台信息</span></span><br><span class="line"><span class="comment">//localhost.2022-11-03.log ServletContext对象的log方法记录的日志信息存储到这个文件中    </span></span><br><span class="line"><span class="comment">//   localhost_access_log.2022-11-03.txt 访问日志 </span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--以上两方法是获得以下配置信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>pageSize<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>10<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--以上配置信息属于应用级的配置信息，一般一个项目中共享的信息会放到以上的标签中--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果配置信息只是想给某个servlet作为参考，那么你配置到servlet标签中即可，使用ServletConfig获取即可--&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>ServletContext对象还有另一个名字：应用域（后面还有请求域，会话域等）</p></li><li><p>如果所有的用户共享一份数据，并且这个数据很少被修改，数据量很小，可以将这些数据放到ServletContext这个应用域中</p><ul><li>如果不是共享数据没有意义，因为Servlet对象只有一个，只有共享的数据放进去才有意义</li><li>数据量太大的话，太占用内存，并且这个对象的生命周期比较长，服务器关闭的时候才会被销毁，大量数据会影响服务器性能，占用内存较小的时候可以考虑放进去</li><li>所有用户共享的数据，如果涉及到频繁的修改的操作，必然会存在线程并发所带来的安全问题，为了解决线程安全问题只能使用锁机制,锁一旦使用最终会导致性能降低，所有在ServletContext对象中的数据一般都是只读的</li></ul></li><li><p>数据量小，所有用户共享，又不修改，这样放到ServletContext中，会大大提升效率，因为应用域相当于一个缓存，当道缓存中的数据，下次用的时候，不需要再次从数据库中获取，大大提升执行效率</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAttribute</span><span class="params">(String name,Object value)</span>;<span class="comment">//存</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getAtttibute</span><span class="params">(String name)</span>;<span class="comment">//取</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeAttribute</span><span class="params">(String name)</span>;<span class="comment">//删除</span></span><br></pre></td></tr></table></figure><ul><li><strong>注：以后编写Servlet方法的时候，实际上不会直接继承GenericServlet类的，因为我们是B&#x2F;S结构的系统，这种系统是基于HTTP找文本传输协议的，在Servlet规范中，提供了一个类叫做HttpServlet，它是专门为HTTP协议准备的一个Servlet类，我们编写的Servlet要继承HttpServlet。（HttpServlet是HTTP协议专用的）使用HttpServlet处理HTTP的时候更加便捷</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以上内容的继承结构</span></span><br><span class="line">jakarta.servlet.Servlet(接口)【爷爷】</span><br><span class="line">jakarta.servlet.GenericServlet <span class="keyword">implements</span> <span class="title class_">Servlet</span>(抽象类)【儿子】</span><br><span class="line">jakarta.servlet.HttpServlet <span class="keyword">extends</span> <span class="title class_">GenericServlet</span>(抽象类)【孙子】   </span><br></pre></td></tr></table></figure><ul><li><p>连接池</p><ul><li>这里所说的连接池的连接时Java语言连接数据库的连接对象：java.sql.Connection对象</li><li>JVM是一个进程，mysql是一个进程，进程和进程之间建立连接，打开通道是十分费劲的，很消耗资源，可以提前创建好N个Connection对象，将连接对象放到一个集合中，我们把这个放有Connection对象的集合称为连接池。每一次用户连接的时候不需要在新建连接对象，直接从连接池中获取连接对象，大大提升访问效率</li><li>连接池<ul><li>最小连接数</li><li>最大连接数</li><li>连接池可以提高用户访问效率，当然也可以保证数据库的安全性</li></ul></li></ul></li><li><p>线程池</p><ul><li>Tomcat服务器本身就是支持多线程</li><li>Tomcat服务器不是在用户发送一次请求，就新建一个Thread线程对象，会先创建好N个多线程Thread对象，然后将线程对象放到集合当中，称为线程池，用户发送请求过来后，需要有一个对应的线程来处理这个请求，这个时候线程对象会直接从线程池中拿，效率比较高</li><li>所有的WEB服务器，或者应用服务器，都是支持多线程的，都有线程池机制</li></ul></li></ul><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><ul><li>HTTP的响应协议(S–&gt;B)<ul><li>HTTP的响应协议包括四部分<ul><li>状态行</li><li>响应头</li><li>空白行</li><li>响应体</li></ul></li><li>HTTP的请求报文</li><li>状态行<ul><li>第一部分：版本协议号（HTTP&#x2F;1.11）</li><li>第二部分：状态码（HTTP协议中规定的响应状态号，不同的响应结果对应不同的号码）<ul><li>200表示响应成功，正常结束</li><li>404表示访问的资源不存在，通常是因为要么路径写错了，要么是路径写对了，但是服务器中对应的资源并没有启动成功，总之404错误是前端错误</li><li>405表示前端发送的请求方式与后端请求处理方式不一致时发生：<ul><li>比如：前端是POST请求，后端的处理方式按照get方式进行处理时，发生405</li><li>比如：前端是GET请求，后端的处理方式按照post方式进行处理时，发生405</li></ul></li><li>500表示服务器端的程序出现异常，一般会认为都武器端的错误导致的</li><li>以4开始的，一般是浏览器端错误导致的</li><li>以5开始的，一般是服务器端错误导致的</li></ul></li><li>第三部分：状态的描述信息<ul><li>ok表示正常成功结束</li><li>not found表示资源找不到</li></ul></li></ul></li><li>响应头<ul><li>响应的内容类型</li><li>相应的内容长度</li><li>响应的时间</li><li>….</li></ul></li><li>空白行<ul><li>用来分隔响应头和响应体</li></ul></li><li>响应体<ul><li>响应体是响应的正文，这些内容是一个长的字符串，这个字符串被浏览器渲染，解释并执行，最终展示出效果</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 ok                         状态行</span><br><span class="line">Content-Type:text/html;charset=UTF-8    响应头</span><br><span class="line">Content-Length:160</span><br><span class="line">Date:Mon,08 Nov 2021 13:19:36 GMT</span><br><span class="line">Keep-Alive:timeout=20</span><br><span class="line">Connection:keep-alive</span><br><span class="line">                                        空白行</span><br><span class="line">&lt;!doctype html&gt;                         响应体 </span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">       &lt;title&gt;from get servlet&lt;/title&gt;</span><br><span class="line">   &lt;/head&gt;</span><br><span class="line">   &lt;body&gt;</span><br><span class="line">       &lt;h1&gt;from get servlet&lt;/h1&gt;</span><br><span class="line">   &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;    </span><br></pre></td></tr></table></figure><ul><li>HTTP的请求协(B–&gt;S)<ul><li>请求行<ul><li>第一部分：请求方式（七种）<ul><li>get（常用的）</li><li>post（常用的）</li><li>delete</li><li>put</li><li>head</li><li>options</li><li>trace</li></ul></li><li>第二部分：URI<ul><li>URI是统一资源标识符，代表网络中某个资源的名字，但是通过URI是无法定位资源</li><li>URL是统一资源定位符。代表网络中某个资源，同时，通过URL是可以定位到该资源的</li><li>URL包括URI<ul><li><a href="http://localhost:8080/servlet/index.html%E8%BF%99%E6%98%AFURL">http://localhost:8080/servlet/index.html这是URL</a></li><li>&#x2F;servlet&#x2F;index.html这是URI</li></ul></li></ul></li><li>第三部分：HTTP协议版本号</li></ul></li><li>请求头<ul><li>请求的主机</li><li>主机的端口号</li><li>浏览器信息</li><li>平台信息</li><li>cookie</li><li>….</li></ul></li><li>空白行<ul><li>用来区分请求头和请求体</li></ul></li><li>请求体<ul><li>向服务器发送的具体数据</li></ul></li></ul></li><li>使用Chrome浏览器:F12，然后找到network，通过这个面板可以查看协议的具体内容</li><li>怎么向服务器发送GET请求，怎么向服务器发送的POST请求<ul><li>到目前为止，只有一种情况可以发送POST请求：使用form表单，并且在form标签中的method属性值为method&#x3D;”post”</li><li>其他情况一律是get请求：<ul><li>在浏览器地址栏直接输入的URL，敲回车，属于get请求</li><li>在浏览器上直接点击超链接，属于get请求</li><li>使用form表单提交数据时，form标签中没有method属性，默认是get</li><li>使用form的时候，form标签中的method属性值为method&#x3D;”get”</li><li>….</li></ul></li></ul></li><li>GET和POST请求的区别<ul><li>get请求发送数据的时候，数据会挂在URI的后面，并且在URI后面添加一个”?”，”?”后面是数据，这样会导致发送的数据显示在浏览器的地址栏中（get请求在请求行上发送数据）<ul><li><a href="http://localhost:8080/servlet/getServlet?username=dehua&password=666">http://localhost:8080/servlet/getServlet?username=dehua&amp;password=666</a></li></ul></li><li>post请求发送数据的时候，在请求体当中发送，不会回显到浏览器地址栏上，也就是说post发送的数据，在浏览器地址上看不到</li><li>get请求只能发送普通的字符串，并且发送的字符串长度有限制，不同的浏览器限制不同，没有明确规定</li><li>get请求无法发送大数据量</li><li>post请求可以发送任何类型的数据，包括普通字符串，流媒体等信息：视频、声音、图片</li><li>post请求可以发送大数据量，理论上没有长度限制</li><li>get请求在W3C中是这样说的：get请求比较适合从服务器端获取数据</li><li>post请求在W3C中是这样说的：post请求比较适合从浏览器向服务器端传送数据</li><li>get请求是安全的，get请求时绝对安全的，因为get请求只是为了从服务器上获取数据，不会对服务器造成威胁。（get请求本身是安全的，你不要用错了，用错了还冤枉人家get不安全，这好吗，这不好，那是你自己问题，不是get请求的问题）</li><li>post请求是危险的，因为post请求是向服务器提交数据，如果这些数据通过后门的方式进入到服务器当中，服务器是很危险的，另外post是为了提交数据，所以一般情况下拦截请求的时候，大部分会拦截（监听）post请求</li><li>get支持缓存<ul><li><a href="https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg">https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg</a></li><li>任何一个get请求最终的响应结果都会被浏览器存起来，在浏览器当中：<ul><li>一个get请求的路径a对应一个资源</li><li>一个get请求的路径b对应一个资源</li><li>一个get请求的路径c对应一个资源</li><li>…</li></ul></li><li>实际上只要发送了一个get请求，浏览器第一件事就是先从本地浏览器缓存中找，找不到的时候才会去服务器上获取，这种缓存机制目的是为了提高用户体验</li><li>如果有一个需求：不希望get请求走缓存，而是每次请求都去服务器上找资源，不去本地浏览器的缓存中获取<ul><li><a href="https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=948491511">https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=948491511</a></li><li><a href="https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=5661662">https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=5661662</a></li><li><a href="https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=%E7%B3%BB%E7%BB%9F%E6%AF%AB%E7%A7%92%E6%95%B0">https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=系统毫秒数</a></li><li>解决方案：在每个路径的后面加一个时刻都在变化的时间戳，这样每次的路径都不一样，浏览器就不会走缓存了</li></ul></li></ul></li><li>post不支持缓存<ul><li>post请求之后，服务器的响应结果不会被浏览器缓存起来，因为这个缓存没有意义</li></ul></li></ul></li><li>如何选择get请求和post请求<ul><li>如果请求是想获取服务器的数据，建议使用get请求，如果这个给是为了向服务器提交数据，建议使用post请求</li><li>大部分的form表单是向服务器提交用户手机的大量数据，服务器将这些数据保存，使用post请求</li><li>如果表中敏感信息，建议使用post请求，因为get请求会把敏感信息显示到浏览器地址栏上（例如：密码信息）</li><li>做文件上传一定是post请求，因为这不是普通的文本</li><li>其他情况都可以使用get请求</li></ul></li><li>不管使用get请求还是使用post请求，发送数据的格式是完全相同的，只不过位置不同，格式是统一的：<ul><li>name&#x3D;value&amp;name&#x3D;value&amp;name&#x3D;value</li><li>以form表单为例，name是form表单中input标签的name</li><li>以form表单为例，value是form表单中input标签的value</li></ul></li></ul><h2 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">        <span class="type">long</span> lastModified;</span><br><span class="line">        <span class="keyword">if</span> (method.equals(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">            lastModified = <span class="built_in">this</span>.getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span> (lastModified == -<span class="number">1L</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">long</span> ifModifiedSince;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ifModifiedSince = req.getDateHeader(<span class="string">&quot;If-Modified-Since&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">                    ifModifiedSince = -<span class="number">1L</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ifModifiedSince &lt; lastModified / <span class="number">1000L</span> * <span class="number">1000L</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">                    <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp.setStatus(<span class="number">304</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line">            lastModified = <span class="built_in">this</span>.getLastModified(req);</span><br><span class="line">            <span class="built_in">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">            <span class="built_in">this</span>.doHead(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doPost(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;PUT&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doPut(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;DELETE&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doDelete(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;OPTIONS&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doOptions(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;TRACE&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doTrace(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;method&#125;;</span><br><span class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">            resp.sendError(<span class="number">501</span>, errMsg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过源码的分析，</span></span><br><span class="line"><span class="comment">/*假设前端发送的是get请求，后端程序员重写的是doPost方法，或者前端程序员发送的是post请求，后端程序员重写的是doPost方法，会发生405这样一个错误</span></span><br><span class="line"><span class="comment">405表示的是前端的错误，发送请求方式不对，和服务器不一致，不是服务器需要的请求方式，所以可以看出只要HttpServlet类中的doPost或者doGte方法执行了必然会导致405错误</span></span><br><span class="line"><span class="comment">所以只有后端重写了哪个方法，前端发送对应请求才能避免405错误</span></span><br><span class="line"><span class="comment">但是，不能为了避免405错误把doPost方法和doGet方法都重写，这样虽然能避免405错误，因为405错误还是有用的。该报错的时候就让他报错，而且如果你doGet和doPost方法都重写还不如直接重写servlet方法，这样代码量还少一些*/</span></span><br></pre></td></tr></table></figure><h2 id="web欢迎页"><a href="#web欢迎页" class="headerlink" title="web欢迎页"></a>web欢迎页</h2><ul><li><p>访问方式</p><ul><li>如果访问的是<a href="http://localhost:8080/servlet/index.html%E5%B0%B1%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E6%8C%87%E5%AE%9A%E7%9A%84%E8%B5%84%E6%BA%90">http://localhost:8080/servlet/index.html就直接访问指定的资源</a></li><li>如果访问的是<a href="http://localhost:8080/servlet%E6%B2%A1%E6%9C%89%E6%8C%87%E5%AE%9A%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%EF%BC%8C%E4%BC%9A%E8%AE%BF%E9%97%AE%E8%AE%BE%E7%BD%AE%E7%9A%84%E6%AC%A2%E8%BF%8E%E9%A1%B5">http://localhost:8080/servlet没有指定资源路径，会访问设置的欢迎页</a></li></ul></li><li><p>设置欢迎页步骤</p><ul><li><p>第一步：在idea工具的web目录下新建一个login.html</p></li><li><p>第二步：在web.xml文件中进行以下配置</p><ul><li><pre><code class="xml">    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;welcome/login.html&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - **注：设置欢迎页面的时候路径不需要以&quot;/&quot;开始，并且这个路径默认是从webapp的根下开始查找**</span><br><span class="line"></span><br><span class="line">  - 第三步：开启服务器，浏览器地址栏输入地址</span><br><span class="line"></span><br><span class="line">* 一个webapp可以设置多个欢迎页面</span><br><span class="line"></span><br><span class="line">  - ```xml</span><br><span class="line">        &lt;welcome-file-list&gt;</span><br><span class="line">            &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;</span><br><span class="line">            &lt;welcome-file&gt;welcome/login.html&lt;/welcome-file&gt;</span><br><span class="line">        &lt;/welcome-file-list&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>越靠上的优先级越高</p></li></ul></li><li><p>当文件名设置为index.html的时候，不需要再web.xml文件中进行欢迎页面的设置，因为在Tomcat服务器已经设置好了</p><ul><li><p>实际上设置欢迎页面的地方有两个</p><ul><li><p>一个在webapp内部的web.xml文件中(这个地方属于局部配置)</p></li><li><p>一个在CATALINA_HOME&#x2F;conf&#x2F;web.xml文件中进行配置(这个地方的配置属于全局配置)</p><ul><li><pre><code class="xml">    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      - Tomcat服务器的全局观影页面是：index.html,index.htm,index.jsp，如果一个web站点没有设置局部欢迎页面，Tomcat服务器会以index.html,index.htm,index.jsp作为一个web站点的欢迎页面</span><br><span class="line"></span><br><span class="line">      - 注意原则：局部优先原则（就近原则）</span><br><span class="line"></span><br><span class="line">- 欢迎页面也可以是一个Servlet</span><br><span class="line"></span><br><span class="line">## 关于WEB-INF目录</span><br><span class="line"></span><br><span class="line">* 在WEB-INF目录下新建一个welcome.html</span><br><span class="line">* 打开浏览器访问：http:localhost:8080/WEB-INF/welcome.html出现404错误</span><br><span class="line">* 注意：放在WEB-INF目录下的资源是受保护的，在浏览器上不能够通过路径直接访问，所以像html,css,javascrip,image等静态资源一定要放到WEB-INF之外</span><br><span class="line"></span><br><span class="line">## HttpServletRequest接口详解</span><br><span class="line"></span><br><span class="line">* request和response对象生命周期</span><br><span class="line">  - request对象和response对象，一个是请求对象，一个是响应对象。这两个对象只在当前请求中有效</span><br><span class="line">  - 一次请求对应一个request</span><br><span class="line">  - 两次请求对应两个request</span><br><span class="line"></span><br><span class="line">* HttpServletRequest接口常用方法</span><br><span class="line"></span><br><span class="line">  - ````java</span><br><span class="line">    Map&lt;String,String[]&gt; getParameterMap() //这个是获取整个Map</span><br><span class="line">    Enumeration&lt;String&gt; getParameterNames()//这个是获取Map集合中所以的key</span><br><span class="line">    String[] getParamterValues(String name)//根据key获取Map的value</span><br><span class="line">    String getParamter(String name)//获取value这个一维数组的第一个元素，这个方法最常用    </span><br><span class="line">    ````</span><br><span class="line"></span><br><span class="line">  - 前端提交的数据格式：username=kun&amp;password=999&amp;interest=sing&amp;interest=dance&amp;interest=basketBall&amp;interest=Rap</span><br><span class="line"></span><br><span class="line">**请求域对象**</span><br><span class="line"></span><br><span class="line">* 请求域对象的作用范围比应用域小很多，声明周期短很多，请求域只在一次请求内有效</span><br><span class="line"></span><br><span class="line">* 一个请求对象request对应一个请求域对象，一次请求结束之后请求域就销毁了</span><br><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  //请求域也有ServletContext中的三个方法</span><br><span class="line">  void setAttribute(String name,Object obj);</span><br><span class="line">  Object getAttribute(String name);</span><br><span class="line">  void removeAttribute(String name);</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul></li><li><p>请求域和应用域选择的原则一般是，选择内存占用较小的</p></li><li><p>跳转</p><ul><li><p>转发</p><ul><li><pre><code class="java">req.getRequestDispatcher(&quot;/test.html&quot;).forward(req,resp);//获取请求转发器对象，并调用转发器对象的forward方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 两个Servlet共享数据的方法</span><br><span class="line"></span><br><span class="line">  - 直接将数据放到ServletContext应用域当中，虽然可以，但是作用域的范围太大，占用资源太多，不建议使用</span><br><span class="line">  - 可以将数据放到request域当中，然后AServlet转发到BServlet，保证AServlet和BServlet在一次请求当中，这样可以做到两个servlet共享同一份数据</span><br><span class="line"></span><br><span class="line">* 转发的下一个资源不一定是一个servlet，只要是Tomcat服务器当中合法的资源都可以转发，例如：html....</span><br><span class="line"></span><br><span class="line">* **注：转发的时候路径写法要注意，转发的路径以&quot;/&quot;开始，不要加i项目名**</span><br><span class="line"></span><br><span class="line">* 关于两个容易混淆的方法</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  String username = request.getParameter(&quot;username&quot;);</span><br><span class="line">  //这个获取的是用户在浏览器中提交的数据，数据形式为 uri?username=zhangsan&amp;userpwd=123&amp;sex=1</span><br><span class="line">  Object obj = request.getAttribute(&quot;name&quot;);</span><br><span class="line">  //这个获取的是请求域中绑定的数据，在此之前肯定执行过，request.setAttribute(&quot;name&quot;,new Object());</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li><li><p>HttpServletRequest</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">remoteAddr</span> <span class="operator">=</span> request.getRemoteAddr();</span><br><span class="line"><span class="comment">//获取客户端的ip地址</span></span><br><span class="line">request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//设置请求字体字符集，显然这个方法处理的是Post请求乱码问题，不适用于Get请求</span></span><br><span class="line"><span class="comment">//Tomcat10之后，request请求体当中的字符集默认是UTF-8，不需要设置字符集，不会出现乱码问题</span></span><br><span class="line"><span class="comment">//Tomcat9之前，包括Tomcat9，如果前端请求体提交的是中文，后端获取后会出现乱码，要用这个方法解决</span></span><br><span class="line">request.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//在Tomcat9之前，包括Tomcat9,响应中文即输出在控制台的中文也是有乱码的，使用以上方法解决</span></span><br><span class="line"><span class="comment">//在Tomcat10之后，包括Tomcat10，响应中文的时候就不在出现乱码问题，以上代码不需要设置UTF-8</span></span><br><span class="line"><span class="comment">/*    &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span></span><br><span class="line"><span class="comment">               connectionTimeout=&quot;20000&quot;</span></span><br><span class="line"><span class="comment">               redirectPort=&quot;8443&quot; </span></span><br><span class="line"><span class="comment">               URIEncoding=&quot;UTF-8&quot;/&gt;          */</span></span><br><span class="line"><span class="comment">//修改CATALINA_HOME/conf/server.sml配置文件，为以上内容，可以解决get请求乱码问题，get请求发送的时候，数据是在请求行上提交的，不是在请求体上提交的</span></span><br><span class="line"><span class="comment">//从Tomcat8之后，URIEncoding的默认值就是UTF-8，所以get请求也不会有乱码了</span></span><br><span class="line"><span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> request.getContextPath();</span><br><span class="line"><span class="comment">//获取应用的根路径 输出/servlet05即项目名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line"><span class="comment">//获取请求方式 输出get/post....</span></span><br><span class="line"><span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI(); </span><br><span class="line"><span class="comment">//获取请求的URI 输出/servlet05/B这样的URI</span></span><br><span class="line"><span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> request.getServletPath();</span><br><span class="line"><span class="comment">//获取servlet path 输出/B这样的Servlet路径</span></span><br></pre></td></tr></table></figure><h2 id="纯Servlet增删改查项目的一个bug的解决"><a href="#纯Servlet增删改查项目的一个bug的解决" class="headerlink" title="纯Servlet增删改查项目的一个bug的解决"></a>纯Servlet增删改查项目的一个bug的解决</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type = <span class="string">&#x27;text/javascript&#x27;</span>&gt;</span><br><span class="line">         <span class="keyword">function</span> <span class="title function_">del</span> (deptno)&#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&#x27;删除后不可恢复，请慎重选择&#x27;</span>))&#123;</span><br><span class="line">             <span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;&quot;+contextPath+&quot;/dept/delete?deptno=&#x27;</span>+deptno</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;javascript:void(0)&#x27;</span> <span class="attr">onclick</span> = <span class="string">&#x27;del(&quot;+deptno+&quot;)&#x27;</span> &gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>这样写，当鼠标单击删除的时候，会报del方法未定义的错误</li><li>正确写法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type = <span class="string">&#x27;text/javascript&#x27;</span>&gt;</span><br><span class="line">         del = <span class="keyword">function</span> (<span class="params">deptno</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&#x27;删除后不可恢复，请慎重选择&#x27;</span>))&#123;</span><br><span class="line">             <span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;&quot;+contextPath+&quot;/dept/delete?deptno=&#x27;</span>+deptno</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>如果函数写在$(functiong{ })或者$().ready(function () {});内部，那么 οnclick&#x3D;”del(“+deptno+”)”; 时 ,不能写成  function del(){}，也不能写成var del&#x3D; function(){}，只能写成del &#x3D; function(){}。</strong></p><h2 id="在一个web应用中如何完成资源跳转"><a href="#在一个web应用中如何完成资源跳转" class="headerlink" title="在一个web应用中如何完成资源跳转"></a>在一个web应用中如何完成资源跳转</h2><ul><li><p>两种完成跳转的方式</p><ul><li>转发</li><li>重定向</li></ul></li><li><p>两种方式的区别</p></li><li><p>代码上的区别</p><p>​    转发</p><ul><li><pre><code class="java">RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;/dept/list&quot;);dispatcher.forward(&quot;request,response&quot;);//转发的时候是一次请求，不管转发了多少次，都是一次请求//AServlet转发到BServlet，再转发到CServlet不管转发了多少次都是一次request//这就是为什么调用forward方法的时候会将当前的request和response对象传给下一次Sevlet<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  重定向</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  response.sendRedirect(req.getContextPath()+&quot;/dept/list&quot;);</span><br><span class="line">  //注意：路径上要加上项目名，因为相当于浏览器发送请求</span><br><span class="line">  //以上代码会将请求路径：/oa/dept/list发送给浏览器，浏览器向服务器发一次全新的请求</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>形式上的区别</p><ul><li>转发（一次请求）<ul><li>在浏览器地址栏上的请求是<a href="http://localhost:8080/Servlet/a,%E6%9C%80%E7%BB%88%E8%AF%B7%E6%B1%82%E7%BB%93%E6%9D%9F%E5%90%8E%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BF%98%E6%98%AF%E8%BF%99%E4%B8%AA">http://localhost:8080/Servlet/a,最终请求结束后，浏览器地址栏还是这个</a></li></ul></li><li>重定向（两次请求）<ul><li>在浏览器地址栏上发送的请求是：<a href="http://localhost:8080/Servlet/a,%E6%9C%80%E7%BB%88%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E4%B8%8A%E6%98%BE%E7%A4%BA%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%AF%EF%BC%9Ahttp://localhost:8080/Servlet/b">http://localhost:8080/Servlet/a,最终在浏览器地址栏上显示的地址是：http://localhost:8080/Servlet/b</a></li></ul></li></ul></li><li><p>转发和重定向的本质区别</p><ul><li>转发：是由WEB服务器控制的，A资源跳转到B资源，这个跳转动作是Tomcat服务器内部完成的</li><li>重定向：是浏览器完成的，具体跳转到哪个资源，浏览器说了算</li></ul></li><li><p>转发和重定向如何选择</p><ul><li>如果在上一个Servlet中向request域中绑定了数据，希望在下一个Servlet当中把request域的数据取出来，使用转发机制</li><li>剩下所有的请求均使用重定向</li></ul></li><li><p>跳转的下一个资源没有要求，可以是Servlet，jsp，html…..</p></li></ul><h2 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h2><ul><li><p>在web.xml文件中进行Servlet信息的配置，显然效率开发比较低，而且对于一个大项目来说，最终的web.xml可能会达到几十兆</p></li><li><p>而且web.xml文件中的配置信息是很少修改的，所有在Servlet3.0版本之后推出注解开发，将配置信息写到Java类</p><ul><li>并不是不需要写配置文件了，一般是注释+配置文件的开发模式</li><li>一些不常修改的配置信息建议使用注解，一些可能会修改的信息建议写到配置文件中</li></ul></li><li><p>第一个注解</p><ul><li><pre><code class="java">import jakarta.servlet.annotation.WebServlet;@WebServlet(&quot;/wel&quot;)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 在Servlet类上使用：</span><br><span class="line"></span><br><span class="line">    - name：用来指定Servlet的名字，相当于&lt;servlet-name&gt;</span><br><span class="line">    - urlPatterns：用来指定Servlet的映射路径，可以指定多个字符串，相当于&lt;url-pattern&gt;</span><br><span class="line">    - loadOnStartUp：用来指定在服务器启动阶段是否加载该Servlet,相当于&lt;load-on-startup&gt;</span><br><span class="line">    - value：同样用来映射路径，可以指定多个字符串，注解属性名为value的时候，使用注解的时候，value属性名是可以忽略的</span><br><span class="line">    - 注意：不是必须将所有属性都写上，只需要提供需要的，属性是一个数组的时候，如果数组中只有一个元素，使用该注解的时候，属性值的大括号可以省略</span><br><span class="line"></span><br><span class="line">* 注解对象的使用格式</span><br><span class="line"></span><br><span class="line">  - @注解名称(属性名=属性值，属性名=属性值.....)</span><br><span class="line"></span><br><span class="line">## jsp</span><br><span class="line"></span><br><span class="line">* jsp的基本语法</span><br><span class="line"></span><br><span class="line">  - 在jsp文件中直接编写文字，会被翻译到Servlet类的service方法的out.write(&quot;&quot;)的双引号中，被Java程序当作普通字符串输出到浏览器</span><br><span class="line">- 在jsp文件中编写html，css，js代码，这些代码对于jsp来说也是一个普通字符串，但是把这些普通字符串一旦输出浏览器，浏览器会对这些html，css，js代码进行解释执行，呈现出对应效果</span><br><span class="line">  - 乱码问题的解决</span><br><span class="line"></span><br><span class="line">    - 通过page指令设置相应的内容类型，在内容类型的后面添加：charset=UTF-8</span><br><span class="line">    - &lt;%@page contentType=&quot;text/html;charset=UTF-8&quot;%&gt;,表示响应的内容是text/html采用的字符集是UTF-8</span><br><span class="line">  - 在jsp中编写Java代码</span><br><span class="line">  </span><br><span class="line">  - &lt;% Java语句 %&gt;</span><br><span class="line">      - 在这个符号中编写的被视为Java程序，被编译到Servlet类的service方法内部</span><br><span class="line">    - 时刻记住此时此刻，你正在一个方法体的内部编写代码，想清楚什么能写，什么不能写，例如：不能写静态代码块，不能写方法，不能定义成员变量</span><br><span class="line">      - 在service方法中编写的的代码是有顺序的，方法体当中的代码遵循自上而下顺序进行执行</span><br><span class="line">      - 一个jsp文件中可以出现多个&lt;%%&gt;符号</span><br><span class="line">    - &lt;!%%&gt;</span><br><span class="line">      - 在这个符号中编写的Java程序会自动翻译到service方法之外</span><br><span class="line">      - 这个语法很少用，因为在service方法编写静态变量和实例变量，都会存在线程安全问题，jsp就是servlet，servlet是单例的，多线程并发的环境下，这个静态的变量和实例变量一旦有修改操作，必然会存在线程安全问题</span><br><span class="line">    - jsp输出语句</span><br><span class="line">      - 输出语句是像浏览器输出一个Java变量</span><br><span class="line">      - 语法&lt;% String name = &quot;dehau&quot;; out.write(&quot;name=&quot; + name) %&gt;</span><br><span class="line">      - 注意：以上代码中out是jsp的九大内置对象之一，可以直接拿来调用，必须在service方法内部</span><br><span class="line">  - &lt;%= %&gt;，等号后面写上输出的内容，会被翻译到service方法中，翻译成out.print();（输出的内容含有Java变量，输出的内容是一个动态内容，而输出一个死的字符串就直接在jsp中写就能输出）</span><br><span class="line">  </span><br><span class="line">* JSP指令</span><br><span class="line"></span><br><span class="line">  - 指令的作用：指导JSP的翻译引擎，如何工作(指导当前jsp翻译引擎如何翻译jsp文件)</span><br><span class="line"></span><br><span class="line">  - 指令包括：</span><br><span class="line"></span><br><span class="line">    - include：包含指令，在jsp中完成静态包含，很少用了</span><br><span class="line">    - taglib：引入标签库的指令，先不管</span><br><span class="line">    - page：重点</span><br><span class="line"></span><br><span class="line">  - 指令语法：</span><br><span class="line"></span><br><span class="line">    - &lt;%@指令名 属性名=属性值 属性名=属性值 属性名=属性值....%&gt;</span><br><span class="line"></span><br><span class="line">  - page指令中常用属性</span><br><span class="line"></span><br><span class="line">    - ```jsp</span><br><span class="line">      &lt;%@page session=&quot;true/false&quot;%&gt;</span><br><span class="line">      true表示启用jsp内置对象session，表示一定启动session对象，没有会创建，如果没有设置，默认值是session=&quot;true&quot;</span><br><span class="line">      session=&quot;false&quot;表示不启动内置对象session，当前jsp页面无法使用内置对象</span><br></pre></td></tr></table></figure>- ```jsp  &lt;%@page contentType=&quot;text/json&quot;%&gt;  contentType属性用来设置响应内容的类型  同样可以设置字符集  &lt;%@page contentType=&quot;text/json;charset=&quot;UTF-8&quot;%&gt;  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```jsp</span><br><span class="line">  &lt;%@page pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">  pageEncoding=&quot;UTF-8&quot;表示设置响应时采用的字符集</span><br></pre></td></tr></table></figure>- ```jsp  &lt;%@page import=&quot;java.util.*&quot;%&gt;  import语句，导包  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```jsp</span><br><span class="line">  &lt;%@page errorPage=&quot;/error.jsp&quot;%&gt;</span><br><span class="line">  当页面出现错误的时候，跳转到error.jsp页面</span><br><span class="line">  errorPage属性用来指定出错之后跳转的错误位置</span><br></pre></td></tr></table></figure>- ```jsp  &lt;%@page isErrorPage=&quot;true&quot;%&gt;  表示启用jsp九大内置对象之一：exception  默认值是false  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">  - jsp九大内置对象</span><br><span class="line"></span><br><span class="line">    - jakarta.servlet.jsp.PageContext  pageContext 页面作用域</span><br><span class="line">    - jakarta.servlet.http.HttpServletRequest  request 请求作用域</span><br><span class="line">    - jakarta.servlet.http.HttpSession  session 会话作用域</span><br><span class="line">    - jakarta.servlet.ServletContext  application 应用作用域</span><br><span class="line">      - pagecontext&lt;request&lt;session&lt;application</span><br><span class="line">      - 以上四个作用域都有：setAttribute,getAttribute,removeAttribute方法</span><br><span class="line">      - 以上作用域尽可能使用最小的</span><br><span class="line">    - jakarta.lang.Throwable  expection</span><br><span class="line">    - jakarta.servlet.ServletConfig  config</span><br><span class="line">    - jakarta.lang.Object  page(其实是this，当前的servlet对象)</span><br><span class="line">    - jakarta.servlet.jsp.jspWriter out(输出语句)</span><br><span class="line">    - jakarta.servlet.http.HttpServletResponse  response(负责响应)</span><br><span class="line"></span><br><span class="line">* jsp本质是一个servlet，和servlet到底有什么区别</span><br><span class="line">  - servlet的职责：擅长收集数据(强项是逻辑处理，然后连接数据库，获取/收集数据)</span><br><span class="line">  - jsp的职责：展示数据(强项是做数据的展示)</span><br><span class="line"></span><br><span class="line">## session 会话机制</span><br><span class="line"></span><br><span class="line">* 什么是会话</span><br><span class="line"></span><br><span class="line">  - 打开浏览器，进行一系列操作，然后最终将浏览器关闭，这个整个过程叫做一个会话，会话在服务器端也有一个Java对象，这个Java对象叫做session</span><br><span class="line">  - 在浏览器点击了一下，然后到页面停下来，可以粗略认为是一次请求，请求对应的服务器对象是request</span><br><span class="line">  - 一个会话中包含多次请求</span><br><span class="line"></span><br><span class="line">* session对象最主要的作用是：保存会话状态。（用户登录成功了，这是一种登陆成功的状态，使用session对象可以保留会话状态，把登陆状态一直保存住）</span><br><span class="line"></span><br><span class="line">* 为什么需要session对象保存会话状态</span><br><span class="line"></span><br><span class="line">  - 因为HTTP协议是一种无状态协议(请求的时候，B和S是连接的，但请求结束之后连接就断了，这样服务器压力小)</span><br><span class="line">  - 只要B和S断开了，关闭浏览器的动作，服务器是不知道的</span><br><span class="line"></span><br><span class="line">* 为什么不使用request对象保存会话状态，为什么不用ServletContext对象保存状态</span><br><span class="line"></span><br><span class="line">  - request是一次请求一个对象，作用域太小</span><br><span class="line">  - ServletContext对象是服务器启动的时候创建，服务器关闭的时候销毁，而且这个ServletContext对象只要一个，作用域太大</span><br><span class="line">  - request请求域(HttpServletRequest)&lt;session会话域(HttpSession)&lt;application域(ServletContext)</span><br><span class="line"></span><br><span class="line">* session对象</span><br><span class="line"></span><br><span class="line">  - session对象是存储在服务器中的</span><br><span class="line"></span><br><span class="line">  - 一个session对象对应一个会话，一次会话对应多个请求</span><br><span class="line"></span><br><span class="line">  - 获取方式：</span><br><span class="line"></span><br><span class="line">    - HttpSession session = request.getSession();从服务器中获取当前的session对象，如果没有则新建一个session对象</span><br><span class="line">    - HttpSession session  =  request.getSession(false);从服务器中获取当前session对象，如果没有不新建返回一个null</span><br><span class="line"></span><br><span class="line">  - 实现原理：</span><br><span class="line"></span><br><span class="line">    - 在web服务器中有一个session列表，类似于map集合，这个map集合的key存储的是sessionid，value存储的是session对象</span><br><span class="line">    - 用户第一次发送请求的时候，服务器会创建一个新的session对象，同时给session对象生成一个id，然后web服务器会将session对象的id发送给浏览器，浏览器将session的id保存在浏览器的缓存中</span><br><span class="line">    - 用户第二次发送请求的时候，会自动将浏览器缓存中的session对象的id自动发送给服务器，服务器获取到id，然后根据id查找对应的session对象</span><br><span class="line"></span><br><span class="line">  - session的两种销毁</span><br><span class="line"></span><br><span class="line">    - 超时销毁</span><br><span class="line"></span><br><span class="line">      - ```xml</span><br><span class="line">            &lt;session-config&gt;</span><br><span class="line">                &lt;session-timeout&gt;30&lt;/session-timeout&gt;</span><br><span class="line">            &lt;/session-config&gt;</span><br></pre></td></tr></table></figure>  - 在web.xml文件中的配置信息写上以上内容即可，表示超过三十分钟后session对象销毁- 手动销毁  - 例如，网银的安全退出的操作，就是手动销毁session对象</code></pre></li><li><p><strong>注：关闭浏览器后，浏览器中保存的sessionid消失，下次重新打开浏览器的时候，浏览器的缓存中没有这个sessionid，自然找不到对应的session对象，等同于会话结束</strong></p></li></ul></li><li><p>jsessionid &#x3D; xxxxxxxxx 是以Cookie的形式存在保存在浏览器中的</p></li><li><p>Cookie禁用了，每次请求都会新建一个session对象，此时服务器会正常发送cookie给浏览器，但是浏览器拒收</p><ul><li><p>为了实现session机制，需要使用URL重写机制</p></li><li><p><a href="http://localhost:8080/servlet08/dehua/tuji;JSESSIONID=A532F1125D878307C726D025E547492E">http://localhost:8080/servlet08/dehua/tuji;JSESSIONID=A532F1125D878307C726D025E547492E</a></p></li><li><p>URL重写机制会提高开发成本，开发人员在编写任何请求路径的时候，后面都添加一个sessionid，给开发提高难度，所以，大部分网站的设计是，如果你禁用了cookie就别用了</p></li></ul></li></ul><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul><li><p>session的实现原理中，每一个session对象都会关联一个对应的sessionid，例如：</p><ul><li>JSESSIONID&#x3D;A532F1125D878307C726D025E547492E</li><li>以上这个键值对数据其实就是cookie数据</li><li>对于session关联的cookie来说，这个cookie是被保存在浏览器的运行内存中</li><li>只要浏览器不关闭，用户再次发送请求的时候，会自动将运行内存中的cookie数据发送给服务器</li><li>服务器通过键值对的值A532F1125D878307C726D025E547492E来找到对应的session对象</li></ul></li><li><p>cookie最终是保存在浏览器客户端上的</p><ul><li>可以保存在运行内存中(浏览器只要关闭cookie就消失了)</li><li>也可以保存在硬盘文件中(永久保存)</li></ul></li><li><p>cookie的作用</p><ul><li>cookie和session机制其实都是为了保存会话状态</li><li>cookie是将会话的状态保存在浏览器客户端上(cookie将数据存储在浏览器客户端上)</li><li>session是将会话的状态保存在服务器端(session对象是存储在服务器上)</li></ul></li><li><p>在Java的servlet中，对cookie提供了哪些支持</p><ul><li>提供了一个cookie类专门表示cookie数据：jakarta.servlet.http.Cookie</li><li>java程序把cookie数据发送给浏览器:request.addCookie(cookis)</li></ul></li><li><p>在Http协议中是这样规定的：当浏览器发送请求时，会自动携带path下的cookie数据给服务器(通过URL)</p></li><li><p>关于cookie的有效时间</p><ul><li>用Java设置有效时间：cookie.setMaxAge(60*60)设置cookie在一小时之后失效，所以数字的单位是秒</li><li>没有设置有效时间，，默认保存在浏览器的运行内存中，浏览器关闭则cookie消失</li><li>设置时间大于零，cookie一定会存储在硬盘文件当中</li><li>设置时间等于零，cookie会被删除，同名cookie被删除</li><li>设置时间小于零，保存在浏览器的运行内存中，和没写cookie.setMaxAge(-1)这行代码效果相同</li></ul></li><li><p>关于cookie的path，cookie的相关路径</p><ul><li>假设现在发送的请求是<a href="http://localhost:8080/servlet/cookie/generate%E7%94%9F%E6%88%90%E7%9A%84cookie%EF%BC%8C%E5%A6%82%E6%9E%9Ccookie%E6%B2%A1%E6%9C%89%E8%AE%BE%E7%BD%AEpath%EF%BC%8C%E9%BB%98%E8%AE%A4%E7%9A%84path%E6%98%AF%EF%BC%9Ahttp://localhost:8080/servlet/cookie/%E4%BB%A5%E5%8F%8A%E5%AE%83%E7%9A%84%E5%AD%90%E8%B7%AF%E5%BE%84%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%AA%E8%A6%81%E5%8F%91%E9%80%81%E8%BF%99%E4%B8%AA%E8%B7%AF%E5%BE%84%E5%8F%8A%E5%85%B6%E5%AD%90%E8%B7%AF%E5%BE%84%EF%BC%8Ccookie%E9%83%BD%E4%BC%9A%E8%A2%AB%E5%8F%91%E9%80%81%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8">http://localhost:8080/servlet/cookie/generate生成的cookie，如果cookie没有设置path，默认的path是：http://localhost:8080/servlet/cookie/以及它的子路径，也就是说浏览器只要发送这个路径及其子路径，cookie都会被发送到服务器</a></li><li>手动设置cookie的path：cookie.serPath(“&#x2F;servlet13”),表示只要是servlet13项目的请求路径都会提交这个cookie</li></ul></li><li><p>浏览器发送cookie给服务器，服务器中Java程序接收</p><ul><li><pre><code class="java">Cookie[] cookies = request.getCookie();//如果没有则返回nullif(cookies != null)&#123;        for(Cookie cookie : cookies)&#123;        String name = cookie.getName();        String value = cookie.getValue();    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">## EL表达式</span><br><span class="line"></span><br><span class="line">* EL表达式出现在jsp的作用</span><br><span class="line"></span><br><span class="line">  - 从某个域中取数据，然后将其转换为字符串，然后输出到浏览器，这就是EL浏览器的三大功效</span><br><span class="line"></span><br><span class="line">* 语法  $&#123;key&#125;</span><br><span class="line"></span><br><span class="line">* EL表达式使用：</span><br><span class="line"></span><br><span class="line">  - ```jsp</span><br><span class="line">    &lt;%</span><br><span class="line">      User user = new user();</span><br><span class="line">      user.setName(&quot;jack&quot;);</span><br><span class="line">      user.setAge(66)</span><br><span class="line">      request.setAttribute(&quot;userdetial&quot;,user);</span><br><span class="line">    %&gt;</span><br><span class="line">    $&#123;userdetial&#125;//大括号里面必须写存储到域对象中name，不能写成$&#123;&quot;userdetial&quot;&#125;,这样是直接输出&quot;userdetial&quot;这个字符串</span><br><span class="line">    $&#123;userdetial&#125;的底层是先从域中取数据，即user对象，然后调用user的toString方法，转换成字符串，输出到浏览器</span><br><span class="line">    //直接输出对象的某一个属性</span><br><span class="line">    $&#123;user.name&#125;</span><br><span class="line">    $&#123;user.age&#125;</span><br><span class="line">    //使用这个两个语法的前提是，userd对象有getName()和getAge()这两个方法，这样写底层其实调用了get方法</span><br><span class="line">    //如果在不同的域中，存上相同名字的key，然后使用$&#123;&#125;调用的时候，在没有指定范围的情况下，取出的顺序是先从小的域中取，然后再是大的域</span><br><span class="line">    //指定域的语法,key相同时，优先从哪个域取数据的语法</span><br><span class="line">    $&#123;pageScopr.userdetial&#125;</span><br><span class="line">    $&#123;requestScope.userdetial&#125;</span><br><span class="line">    $&#123;session.userdetial&#125;</span><br><span class="line">    $&#123;applicationScope.userdetial&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>EL表达式对null进行了预处理，如果是null，则输出一个空字符串到浏览器</p></li><li><p>EL表达式取数据的时候有两种形式：</p><ul><li>第一种：${user.userdetial}(大部分是使用这种形式)</li><li>第二种：${user[“userdetial”]}(如果存储到域中的key含有特殊字符，可以使用[]),例如：<ul><li>request.setAttribute(“abc.def”,”fhaishdu”)</li><li>${requestScope.abc.def}这样是无法取值的</li><li>应该写成这样：${requestScope[“abc.def”]}</li><li><strong>注意：中括号里面必须加双引号</strong></li></ul></li></ul></li><li><p>使用EL表达式从Map中取数据</p><ul><li>${map.key}</li></ul></li><li><p>使用EL表达式从List和数组中取数据</p><ul><li>${list[索引]}</li><li>${数组[索引]}</li></ul></li><li><p>page指令忽略EL表达式</p><ul><li><pre><code class="jsp">&lt;%@page contentType=&quot;html/text;charset=UTF-8&quot; isELIgnored=&quot;true&quot;%&gt;isELIgnored=&quot;true&quot;表示忽略EL表达式isELIgnored=&quot;false&quot;表示不忽略EL表示式（这是默认值）//以上指令是忽略所有的EL表达式可以使用反斜杠局部控制：\$&#123;username&#125;，这样也可以忽略EL表达式，只忽略这一行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- EL中的隐式对象</span><br><span class="line"></span><br><span class="line">  - ```jsp</span><br><span class="line">    //pageContext</span><br><span class="line">    //EL表示式中没有request这个隐式对象，EL表达式中有一个隐式对象：pageContext，EL表达式中的pageContext和jsp中的九大内置对象pageContext是同一个对象</span><br><span class="line">    $&#123;pageContext.request.contextPath&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="jsp">//param//如果用户提交的请求是：http://localhost:8080/jsp?aihao=smoke&amp;aihao=drink&amp;aihao=tangtou$&#123;param.aihao&#125;这样可以获取请求参数一维数组当中的第一个元素$&#123;paramValues.aihao[索引]&#125;可以获得数组中指定的元素//在web.xml文件中配置以下数据    &lt;context-param&gt;        &lt;param-name&gt;pageSize&lt;/param-name&gt;        &lt;param-value&gt;20&lt;/param-value&gt;    &lt;/context-param&gt;$&#123;initParam.pageSize&#125;相当于&lt;%application.getInitParameter(&quot;pageSize&quot;)%&gt;获取上下文对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - EL表达式的运算符</span><br><span class="line">    - 算数运算符(+ - * /)只能做数值运算，不能做字符串的运算，如果是“123”这样的字符串，先把字符串转成数字，然后进行数值的运算，其他字符串直接报错</span><br><span class="line">    - 比较运算符(= , !=  , eq)都会调用equal方法</span><br><span class="line">    - empty 判断后面的内容是否为空</span><br><span class="line"></span><br><span class="line">## JSTL标签库</span><br><span class="line"></span><br><span class="line">* 在jsp中引入JSTL标签库(使用taglib指令)</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    &lt;%@taglib prefix=&quot;这里随便起一个名字即可，一般是c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line">    //这个就是核心标签库</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li><li><p>JSTL标签的原理</p><ul><li><pre><code>&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;//以上uri后面的路径实际上指向了一个xxx.tld文件，tld文件其实是一个xml文件，在tld文件中描述了标签和java类的关系//以上核心标签库对应tld文件是：c.tld文件，在jakarta.servlet.jsp.jstl-2.0.0.jar里面META-INF目录下有一个c.tld文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 源码解析</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">      &lt;tag&gt;</span><br><span class="line">        &lt;description&gt;对标签的描述&lt;/description&gt;</span><br><span class="line">        &lt;name&gt;catch&lt;/name&gt;标签的名字</span><br><span class="line">        &lt;tag-class&gt;org.apache.taglibs.standard.tag.common.core.CatchTag&lt;/tag-class&gt;标签对应的Java类</span><br><span class="line">        &lt;body-content&gt;JSP&lt;/body-content&gt;标签体当中可以出现的内容，如果是jsp就表示，就表示标签体中可以出现符合jsp所有语法的代码，例如EL表达式</span><br><span class="line">        &lt;attribute&gt;//属性</span><br><span class="line">            &lt;description&gt;对属性的描述&lt;/description&gt;</span><br><span class="line">            &lt;name&gt;var&lt;/name&gt;属性名</span><br><span class="line">            &lt;required&gt;false&lt;/required&gt;false表示该属性不是必须的，true表示该属性是必须的</span><br><span class="line">            &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt;这个描述说明了该属性是否支持EL表达式，false表示不支持，true表示支持</span><br><span class="line">        &lt;/attribute&gt;</span><br><span class="line">      &lt;/tag&gt;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>jstl中的核心标签库core中的常用标签</p><ul><li><p>c:if</p><ul><li>&lt;c:if test&#x3D;”boolean类型，支持EL表达式”&gt;&lt;&gt;</li></ul></li><li><p>c:forEach</p><ul><li>&lt;c:forEach items&#x3D;”集合，支持EL表达式” var&#x3D;”集合中的元素” varStatus&#x3D;”元素状态对象”&gt;${元素状态对象.count}&lt;&gt;</li><li>count可以实现自增，常用于编号</li><li>&lt;c:forEach var&#x3D;”i” begin &#x3D;”1” end&#x3D;”10” step&#x3D;”1”&gt;${i}&lt;&gt;</li></ul></li><li><p>c:choose c:when c:otherwise</p><ul><li><pre><code>&lt;c:choose&gt;  &lt;c:when test=&quot;$&#123;age&lt;18&#125;&quot;&gt;  未成年  &lt;/c:when&gt;  &lt;c:otherwise&gt;  成年  &lt;/c:otherwise&gt;&lt;/c:choose&gt;  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## Filter过滤器</span><br><span class="line"></span><br><span class="line">* Filter是过滤器，可以在Servlet这个目标程序执行之前添加代码，也可以在目标Servlet程序执行之后添加代码，一般情况下将公共代码编写到过滤器当中</span><br><span class="line"></span><br><span class="line">* 过滤器写法</span><br><span class="line"></span><br><span class="line">  - 第一步：编写一个Java类实现一个接口：jakarta.servlet.Filter并实现这个接口所有方法</span><br><span class="line"></span><br><span class="line">    - init方法：在Filter对象第一次被创建的时候调用，并且只调用一次</span><br><span class="line">    - doFilter方法：只要用户发送一次请求，则执行一次，发送n次请求则执行n次</span><br><span class="line">    - destroy方法：在Filter对象被释放销毁之前被调用，并且只调用一次</span><br><span class="line"></span><br><span class="line">  - 第二步：在类上写注解@WebFilter(&quot;路径&quot;)，或者在web.xml文件中配置和Servlet类似</span><br><span class="line"></span><br><span class="line">    - ```xml</span><br><span class="line">          &lt;filter&gt;</span><br><span class="line">              &lt;filter-name&gt;filter1&lt;/filter-name&gt;</span><br><span class="line">              &lt;filter-class&gt;com.nipowenode.servlet.Filter.Filter1&lt;/filter-class&gt;</span><br><span class="line">          &lt;/filter&gt;</span><br><span class="line">          &lt;filter-mapping&gt;</span><br><span class="line">              &lt;filter-name&gt;filter1&lt;/filter-name&gt;</span><br><span class="line">              &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">          &lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul></li><li><p><strong>注意</strong></p><ul><li>Servlet对象默认情况下，在服务启动的时候不会新建对象</li><li>Filter对象默认情况下，在服务器启动的时候会新建对象</li><li>Servlet是单例的，Filter也是单例的</li></ul></li><li><p>目标Servlet是否执行取决于两个条件</p><ul><li>第一：在过滤器中是否编写了chain.doFilter(request,response);代码(这行代码表示执行下一个过滤器，如果没有下一个过滤器则执行最终的Servlet)</li><li>第二：用户发送的请求是否和Servlet请求路径一致</li></ul></li><li><p>注意：Filter的优先级，天生就比Servlet的优先级高</p><ul><li>&#x2F;a.do对应一个Filter，也对应一个Servlet，那么一定是先执行Filter，然后执行Servlet</li></ul></li><li><p>Filter的配置路径</p><ul><li>&#x2F;a.do,&#x2F;b.do,&#x2F;dept&#x2F;save 这些配置方式都是精确配置</li><li>&#x2F;* 匹配所有路径</li><li>*.do 后缀匹配，不要以&#x2F;开始</li><li>&#x2F;dept&#x2F;* 前缀匹配</li></ul></li><li><p>在web.xml文件中进行配置的时候，Filter的执行顺序是<filter-mapping>标签越靠前的，执行优先级越高</filter-mapping></p></li><li><p>过滤器的调用顺序，遵行栈的数据结构，先进后出</p></li><li><p>使用注,Filter的执行顺序</p><ul><li>比较Filter这个类名</li><li>比如：FilterA和FilterB，先执行FilterA</li><li>比如：Filter1和Filter2，先执行Filter1</li></ul></li><li><p>Filter的生命周期</p><ul><li>和Servlet生命周期相同</li><li>唯一的区别：Filter默认情况下，在服务器启动的情况下就会实例化，Servlet不会</li></ul></li><li><p>责任链设计模式</p><ul><li>过滤器的优点：在程序编译阶段不会确定调用对象，因为Filter的调用顺序是配置到web.xml文件中的，只要修改web.xml配置文件中的filter-mapping的顺序就可以调整Filter的执行顺序，显然Filter的执行顺序是在程序运行阶段动态组合的，这种设计模式被称为责任链设计模式</li><li>责任链模式的最大核心思想：在程序运行阶段，动态的组合程序的调用顺序</li></ul></li></ul><h2 id="Listener-监听器"><a href="#Listener-监听器" class="headerlink" title="Listener 监听器"></a>Listener 监听器</h2><ul><li><p>监听器有什么用</p><ul><li>监听器实际上是Servlet规范留给我们javaweb程序员的特殊时机</li><li>特殊时刻如果想执行这段代码，你需要想到使用对应的监听器</li></ul></li><li><p>Servlet规范中提供的监听器：</p><ul><li>jakarta.servlet包下：<ul><li>ServletContextListener</li><li>ServletContextAttributeListener</li><li>ServletRequestListener</li><li>ServletRequestAttributeListener</li></ul></li><li>jakarta.servlet.http包下：<ul><li>HttpSessionListener</li><li>HttpSessionAttributeListener<ul><li>该监听器需要使用@WebListener注解进行标注</li><li>主要在session中存入数据都会出发该监听器并执行方法</li></ul></li><li>HttpSessionBindingListener<ul><li>该监听器不需要@WebListener注解标注</li><li>只要某个类实现了HttpSessionBindingListener这个监听器，然后这个类对象放入到session的时候触发bind事件，类对象从session中删除的时候，会触发unbind事件</li></ul></li><li>HttpSessionIdListener(不重要)<ul><li>session的id发生改变的时候，监听器中的唯一一个方法就会被调用</li></ul></li><li>HttpSessionActivationListener<ul><li>监听session对象的钝化和活化</li><li>钝化：session对象从内存存到硬盘文件</li><li>活化：session对象从硬盘存到内存</li></ul></li></ul></li></ul></li><li><p>实现一个监听器的步骤：</p><ul><li><p>第一步：编写一个类实现ServletContextListener接口，并实现里面方法</p><ul><li><pre><code class="java">void contextInitialized(ServletContextEvent sce)&#123;&#125;void contextDestroyed(ServletContextEvent sce)</code></pre></li></ul></li><li><p>第二步：在web.xml文件中配置，或者在类上面加上注解@WebListener</p></li></ul></li><li><p>注意：所有监听器中的方法都是不需要javaweb程序员调用的，当某个特殊的事件发生之后，被web服务器自动调用</p></li></ul><h2 id="MVC架构模式"><a href="#MVC架构模式" class="headerlink" title="MVC架构模式"></a>MVC架构模式</h2><p><img src="/2023/07/02/javaweb/Users\ZDKJ\AppData\Roaming\Typora\typora-user-images\image-20221130193806151.png" alt="image-20221130193806151"></p><ul><li>表示层：web包<ul><li>写servlet</li></ul></li><li>业务逻辑层：service包<ul><li>写业务逻辑代码</li></ul></li><li>持久层：dao包<ul><li>做数据库的增删改查</li></ul></li><li>pojo包：封装数据</li><li>utils包：放工具的</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
