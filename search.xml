<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《MySQL技术内幕 InnoDB存储引擎》阅读笔记</title>
      <link href="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="lnnoDB-存储引擎体系架构"><a href="#lnnoDB-存储引擎体系架构" class="headerlink" title="lnnoDB 存储引擎体系架构"></a>lnnoDB 存储引擎体系架构</h3><h4 id="1-Mysql-整体结构"><a href="#1-Mysql-整体结构" class="headerlink" title="1.Mysql 整体结构"></a>1.<strong>Mysql</strong> <strong>整体结构</strong></h4><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231226184646865.png" class title="image-20231226184646865"><p>上图中，从上到下包括了：</p><ul><li>连接池组件</li><li>管理服务和工具组件</li><li>SQL接口组件</li><li>查询分析器组件</li><li>优化器组件</li><li>缓冲组件</li><li>插件式存储引擎</li><li>物理文件</li></ul><p><strong>MySQL数据库区别于其他数据库的最重要的一个特点就是其插件式的表存储引擎。需要特别注意的是，存储引擎是基于表的，而不是数据库。</strong></p><h4 id="2-Innodb后台线程"><a href="#2-Innodb后台线程" class="headerlink" title="2.Innodb后台线程"></a>2.Innodb后台线程</h4><p>InnoDB存储引擎是多线程的模型，因此其后台有多个不同的后台线程，负责处理不同的任务。</p><ol><li><p>Master Thread(后面详细分解)</p><ul><li>Master Thread是一个非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO页的回收等</li></ul></li><li><p>IO Thread</p><ul><li>在InnoDB存储引擎中大量使用了AIO（Async IO 异步IO）来处理写IO请求，这样可以极大提高数据库的性能。InnoDB 1.0版本之前共有4个IO Thread，分别是write、read、insert buffer和log IO thread。在Linux平台下，IO Thread的数量不能进行调整，但是在Windows平台下可以通过参数innodb_file_io_threads来增大IO Thread。从InnoDB 1.0.x版本开始，read thread和write thread分别增大到了4个，可以使用innodb_read_io_threads和innodb_write_io_threads参数进行设置。 </li><li><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231226190807373.png" class title="image-20231226190807373"></li></ul></li><li><p>Purge Thread</p><ul><li><p>事务被提交后，其所使用的undo log可能不再需要，因此需要PurgeThread来回收已经使用并分配的undo页。在InnoDB 1.1版本之前，purge操作仅在InnoDB存储引擎的Master Thread中完成。而从InnoDB 1.1版本开始，purge操作可以独立到单独的线程中进行，以此来减轻Master Thread的工作，从而提高CPU的使用率以及提升存储引擎的性能。</p><p>在InnoDB 1.1版本中，即使将innodb_purge_threads设为大于1，InnoDB存储引擎启动时也会将其设为1，并提示报错信息</p><p>从InnoDB 1.2版本开始，InnoDB支持多个Purge Thread，这样做的目的是为了进一步加快undo页的回收。同时由于Purge Thread需要离散地读取undo页，这样也能更进一步利用磁盘的随机读取性能.</p></li></ul></li><li><p>Page Cleaner Thread</p><ul><li>Page Cleaner Thread在InnoDB 1.2.x版本中引入。其作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。而其目的是为了减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能。</li></ul></li></ol><h4 id="3-Innodb-缓冲池"><a href="#3-Innodb-缓冲池" class="headerlink" title="3.Innodb 缓冲池"></a>3.Innodb 缓冲池</h4><p>InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理(就是MySQL的内存页)。在数据库系统中，由于CPU速度远远高于磁盘速度，所以使用缓冲池技术来提高数据库的整体性能。缓冲池简单来说就是一块内存区域，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响。</p><ul><li><p>对于读取页的操作，首先将从磁盘读到的页存放在缓冲池中。下一次再读相同的页时，首先判断该页是否在缓冲池中。若在缓冲池中，直接读取该页。否则，读取磁盘上的页。</p></li><li><p>对于数据库中页的修改操作，则首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。注意：页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过一种称为<strong>Checkpoint</strong>的机制刷新回磁盘。同样，这也是为了提高数据库的整体性能。</p></li></ul><p>缓冲池的大小直接影响着数据库的整体性能。可以实验参数innodb_buffer_pool_size来设置。默认大小为128MB</p><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231226205746031.png" class title="image-20231226205746031"><p>缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲（insert buffer）、自适应哈希索引（adaptive hash index）、InnoDB存储的锁信息（lock info）、数据字典信息（data dictionary）等。</p><p>从InnoDB 1.0.x版本开始，允许有多个缓冲池实例(通过参数innodb_buffer_pool_instances来进行配置，该值默认为1)。每个页根据哈希值平均分配到不同缓冲池实例中。这样做的好处是减少数据库内部的资源竞争，增加数据库的并发处理能力。</p><p>从MySQL 5.6版本开始，还可以通过information_schema架构下的表INNODB_BUFFER_POOL_STATS来观察缓冲池的信息。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> POOL_ID,POOL_SIZE,FREE_BUFFERS,DATABASE_PAGES <span class="keyword">FROM</span> information_schema.INNODB_BUFFER_POOL_STATS;</span><br></pre></td></tr></table></figure><p>需要注意的是，当整体的pool size小于 1G的时候，参数配置的pool_instances是不生效的</p><h4 id="4-缓冲池的内存管理"><a href="#4-缓冲池的内存管理" class="headerlink" title="4.缓冲池的内存管理"></a>4.缓冲池的内存管理</h4><p>数据库中的缓冲池是通过LRU算法来进行管理的。即最频繁使用的页在LRU列表的前端，而最少使用的页在LRU列表的尾端。当缓冲池不能存放新读取到的页时，将首先释放LRU列表中尾端的页。</p><p>在InnoDB存储引擎中，缓冲池中页的大小默认为<strong>16KB</strong>，同样使用LRU算法对缓冲池进行管理。与传统LRU算法不同的是，在InnoDB的存储引擎中，LRU列表中还加入了midpoint位置。新读取到的页，虽然是最新访问的页，但并不是直接放入到LRU列表的首部，而是放入到LRU列表的midpoint位置。在默认配置下，该位置在LRU列表长度的5&#x2F;8处。</p><ul><li>LRU优化的好处<ul><li>比如某些数据固定一个月查询一次，如果在并发查询较大的情况下，使用传统的LRU算法可能会把真正的热点数据顶没了，而优化后的算法可以把数据先放到midpoint位置，保证热点数据一直存在于缓冲池</li></ul></li></ul><p>midpoint位置可由参数innodb_old_blocks_pct控制。参数innodb_old_blocks_pct默认值为37，表示新读取的页插入到LRU列表尾端的37%的位置（差不多3&#x2F;8的位置）。</p><ul><li>那放到midpoint位置的页如果真是一个热点数据，那么如何进入到列表头部呢？<ul><li>使用innodb_old_blocks_time参数，用于表示页读取到mid位置后需要等待多久才会被加入到LRU列表的热端。</li></ul></li></ul><p>LRU列表用来管理已经读取的页，但当数据库刚启动时，LRU列表是空的，即没有任何的页。这时页都存放在Free列表中。当有数据要存放到缓冲池时，首先从Free列表中查找是否有可用的空闲页，若有则将该页从Free列表中删除，放入到LRU列表中。否则，根据LRU算法，淘汰LRU列表末尾的页，将该内存空间分配给新的页。</p><ul><li><p>压缩页</p><ul><li><p>InnoDB存储引擎从1.0.x版本开始支持压缩页的功能，即将原本16KB的页压缩为1KB、2KB、4KB和8KB。而由于页的大小发生了变化，LRU列表也有了些许的改变。对于非16KB的页，是通过unzip_LRU列表进行管理的。unzip_LRU列表中对不同压缩页大小的页进行分别管理。</p></li><li><p>对于压缩页的表，每个表的压缩比率可能各不相同。可能存在有的表页大小为8KB，有的表页大小为2KB的情况。unzip_LRU是怎样从缓冲池中分配内存的呢？</p><ul><li><p>以需要从缓冲池中申请页为4KB的大小为例，其过程如下：</p><p>1）检查4KB的unzip_LRU列表，检查是否有可用的空闲页；</p><p>2）若有，则直接使用；</p><p>3）否则，检查8KB的unzip_LRU列表；</p><p>4）若能够得到空闲页，将页分成2个4KB页，存放到4KB的unzip_LRU列表；</p><p>5）若不能得到空闲页，从LRU列表中申请一个16KB的页，将页分为1个8KB的页、2个4KB的页，分别存放到对应的unzip_LRU列表中。</p></li></ul></li></ul></li></ul><h4 id="5-重做日志缓冲池"><a href="#5-重做日志缓冲池" class="headerlink" title="5.重做日志缓冲池"></a>5.重做日志缓冲池</h4><p>InnoDB存储引擎的内存区域除了有缓冲池外，还有重做日志缓冲（redo log buffer）。InnoDB存储引擎首先将重做日志信息先放入到这个缓冲区，然后按一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置得很大，因为重做日志刷新到磁盘的频率很高。重做日志缓冲池的大小由配置参数innodb_log_buffer_size控制，默认为8MB</p><ul><li><p>以下三种情况会把重做日志缓冲中的日志刷新到外部磁盘的重做日志文件中：</p><p>❑Master Thread每一秒将重做日志缓冲刷新到重做日志文件；</p><p>❑每个事务提交时会将重做日志缓冲刷新到重做日志文件；</p><p>❑当重做日志缓冲池剩余空间小于1&#x2F;2时，重做日志缓冲刷新到重做日志文件。</p></li></ul><h4 id="6-CheckPoint-技术"><a href="#6-CheckPoint-技术" class="headerlink" title="6.CheckPoint 技术"></a>6.CheckPoint 技术</h4><ul><li>CheckPoint技术的由来<ul><li>当数据库运行了几个月甚至几年时，这时发生宕机，重新应用重做日志的时间会非常久，此时恢复的代价也会非常大。如果有了CheckPoint技术的话，数据库就知道宕机之后数据从什么地方开始恢复，之前都已经恢复了</li></ul></li></ul><p>如果一条DML语句，如Update或Delete改变了页中的记录，那么此时页是脏的，即缓冲池中的页的版本要比磁盘的新。数据库需要将新版本的页从缓冲池刷新到磁盘。如果每次一个页发生变化，就将新页的版本刷新到磁盘，那么这个开销是非常大的。</p><p>同时，如果在从缓冲池将页的新版本刷新到磁盘时发生了宕机，那么数据就不能恢复了。为了避免发生数据丢失的问题，当事务提交时，<strong>先写重做日志，再修改页。</strong>当由于发生宕机而导致数据丢失时，通过重做日志来完成数据的恢复。这也是事务ACID中D（持久性）的要求。</p><ul><li><p>CheckPoint技术解决的问题</p><ul><li>缩短数据库的恢复时间；当数据库发生宕机时，数据库不需要重做所有的日志，因为Checkpoint之前的页都已经刷新回磁盘。故数据库只需对Checkpoint后的重做日志进行恢复。这样就大大缩短了恢复的时间。</li><li>缓冲池不够用时，将脏页刷新到磁盘；当缓冲池不够用时，根据LRU算法会淘汰最近最少使用的页，若此页为脏页，那么需要强制执行Checkpoint，将脏页也就是页的新版本刷回磁盘，如果淘汰的页不是脏页，那么就不需要执行Checkpoint</li><li>重做日志不可用时（重做日志已经到达容量阈值，而且所有的文件内容都需要使用），刷新脏页。重做日志的设计都是<strong>循环使用</strong>的，并不是让其无限增大的。<strong>重做日志可以被重用的部分是指这些重做日志已经不再需要，即当数据库发生宕机时，数据库恢复操作不需要这部分的重做日志，因此这部分就可以被覆盖重用。</strong>(这个地方和JVM局部变量表的变量槽的管理方式很像，JVM变量槽的个数和局部变量的个数是不相等的，如果程序运行过程中，超过了某个局部变量的作用阈，那么这个局部变量对应的变量槽是可以重用的)若此时重做日志还需要使用，那么必须强制产生Checkpoint，将缓冲池中的页<strong>至少刷新</strong>(如果在执行Checkpoint的过程中，重做日志记录了新的内容，Checkpoint会连同新的内容全部刷新到磁盘)到当前重做日志的位置。</li></ul></li><li><p>CheckPoint实现</p><ul><li><p>对于InnoDB存储引擎而言，其是通过LSN来标记版本的。而LSN是8字节的数字，其单位是字节。<strong>每个页有LSN，重做日志中也有LSN，Checkpoint也有LSN</strong>。通过对LSN的对比判断哪些数据已经刷新了。</p></li><li><p>InnoDB存储引擎的两种Checkpoint：</p><p>❑Sharp Checkpoint ：数据库关闭时将所有的脏页都刷新回磁盘，这是默认的工作方式，如果数据库在运行时也使用Sharp Checkpoint，那么数据库的可用性就会受到很大的影响。</p><p>❑Fuzzy Checkpoint：只刷新一部分脏页，而不是刷新所有的脏页回磁盘。</p></li></ul></li></ul><h4 id="7-Master-Thread"><a href="#7-Master-Thread" class="headerlink" title="7.Master Thread"></a>7.<strong>Master Thread</strong></h4><ul><li><p>InnoDB 1.0.x版本之前的Master Thread</p><p>Master Thread具有最高的线程优先级别。其内部由多个循环（loop）组成：主循环（loop）、后台循环（backgroup loop）、刷新循环（flush loop）、暂停循环（suspend loop）。Master Thread会根据数据库运行的状态在loop、background loop、flush loop和suspendloop中进行切换。</p><ul><li><p>主循环：其中有两大部分的操作——每秒钟的操作和每10秒的操作。</p><p><strong>每秒一次的操作包括：</strong></p><p>❑重做日志缓冲刷新到磁盘，即使这个事务还没有提交（总是）；</p><p>❑合并插入缓冲（可能）；InnoDB存储引擎会判断当前一秒内发生的IO次数是否小于5次，如果小于5次，InnoDB认为当前的IO压力很小，可以执行合并插入缓冲的操作。</p><p>❑至多刷新100个InnoDB的缓冲池中的脏页到磁盘（可能）；</p><p>❑如果当前没有用户活动，则切换到background loop（可能）。</p><p><strong>每10秒一次的操作包括：</strong></p><p>❑刷新100个脏页到磁盘（可能）；InnoDB存储引擎会先判断过去10秒之内磁盘的IO操作是否小于200次，如果是，InnoDB存储引擎认为当前有足够的磁盘IO操作能力，因此将100个脏页刷新到磁盘。</p><p>❑合并至多5个插入缓冲（总是）；不同于每秒一次操作时可能发生的合并插入缓冲操作，这次的合并插入缓冲操作总会在这个阶段进行。</p><p>❑将重做日志缓冲刷新到磁盘（总是）；这和每秒一次时发生的操作是一样的。</p><p>❑删除无用的Undo页（总是）；InnoDB存储引擎会进行一步执行full purge操作，即删除无用的Undo页。但是在full purge过程中，InnoDB存储引擎会判断当前事务系统中已被删除的行是否可以删除，比如有时候可能还有查询操作需要读取之前版本的undo信息，如果可以删除，InnoDB会立即将其删除。InnoDB存储引擎在执行full purge操作时，每次最多尝试回收20个undo页。</p><p>❑刷新100个或者10个脏页到磁盘（总是）。如果有超过70%的脏页，则刷新100个脏页到磁盘（这时不会考虑第一条中IO 200 的次数），如果脏页的比例小于70%，则只需刷新10%的脏页到磁盘。</p></li><li><p>后台循环：若当前没有用户活动（数据库空闲时）或者数据库关闭（shutdown），就会切换到这个循环。</p><p><strong>background loop会执行以下操作：</strong></p><p>❑删除无用的Undo页（总是）；</p><p>❑合并20个插入缓冲（总是）；</p><p>❑跳回到主循环（总是）；</p></li><li><p>不断刷新100个页直到符合条件（可能，跳转到flush loop中完成）。</p></li><li><p>若flush loop中也没有什么事情可以做了，InnoDB存储引擎会切换到suspend__loop，将Master Thread挂起，等待事件的发生</p></li></ul></li><li><p>InnoDB1.2.x版本之前的Master Thread</p><ul><li><p>新增了参数innodb_io_capacity，用来表示磁盘IO的吞吐量，默认值为200。对于刷新到磁盘页的数量，会按照innodb_io_capacity的百分比来进行控制。规则如下：</p><p>❑在合并插入缓冲时，合并插入缓冲的数量为innodb_io_capacity值的5%；</p><p>❑在从缓冲区刷新脏页时，刷新脏页的数量为innodb_io_capacity。</p></li><li><p>新增了参数innodb_purge_batch_size，该参数可以控制每次full purge回收的Undo页的数量。该参数的默认值为20，并可以动态地对其进行修改</p></li></ul></li><li><p>InnoDB 1.2.x版本的Master Thread</p><ul><li>对于刷新脏页的操作，从Master Thread线程分离到一个单独的<strong>Page</strong> <strong>Cleaner</strong> <strong>Thread</strong>，从而减轻了Master Thread的工作，同时进一步提高了系统的并发性。</li></ul></li></ul><h4 id="8-InnoDB关键特性-插入缓冲"><a href="#8-InnoDB关键特性-插入缓冲" class="headerlink" title="8.InnoDB关键特性-插入缓冲"></a>8.InnoDB关键特性-插入缓冲</h4><p>插入缓冲(insert buffer)的使用是对于<strong>非聚集索引</strong>的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中，然后再以一定的频率进行Insert Buffer和辅助索引页子节点的merge（合并）操作，这时通常能将多个插入合并到一个操作中（因为在一个索引页中），这就大大提高了对于非聚集索引插入的性能。</p><ul><li><p>使用条件</p><ul><li><p>Insert Buffer的使用需要同时满足以下两个条件：</p><p>❑索引是辅助索引；</p><p>❑索引不是唯一的。</p></li></ul></li><li><p>缺点</p><ul><li>应用程序进行大量的插入操作（1. 辅助索引不在缓冲池；2.10 s以内的大量并发），这些都涉及了不唯一的非聚集索引，也就是使用了Insert Buffer。若此时MySQL数据库发生了宕机，这时势必有大量的Insert Buffer并没有合并到实际的非聚集索引中去。这些操作都保存到了重做日志中，因此这时恢复可能需要很长的时间。</li><li>在写密集的情况下，插入缓冲会占用过多的缓冲池内存，默认最大可以占用到1&#x2F;2的缓冲池内存。</li></ul></li></ul><p><strong>Insert Buffer的数据结构是一棵B+树</strong>，当一个辅助索引要插入到页（space，offset）时，如果这个页不在缓冲池中，那么InnoDB存储引擎会构造一个search key，然后查询Insert Buffer这棵B+树，然后再将这条记录插入到Insert Buffer B+树的叶子节点中。</p><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231227173800029.png" class title="image-20231227173800029"><p>search key一共占用9个字节，其中space表示待插入记录所在表的表空间id，占用4字节。marker占用1字节，它是用来兼容老版本的Insert Buffer。offset表示页所在的偏移量，占用4字节。</p><p><strong>注意：要插入的页不在缓冲池的时候才进插入缓冲</strong></p><p>InnoDB从1.0.x版本开始引入了Change Buffer，可将其视为Insert Buffer的升级。从这个版本开始，InnoDB存储引擎可以对DML操作——INSERT、DELETE、UPDATE都进行缓冲，他们分别是：Insert Buffer、Delete Buffer、Purge buffer。</p><h4 id="9-InnoDB关键特性-两次写"><a href="#9-InnoDB关键特性-两次写" class="headerlink" title="9.InnoDB关键特性-两次写"></a>9.InnoDB关键特性-两次写</h4><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231226230108714.png" class title="image-20231226230108714"><p>使用两次写之前，当发生数据库宕机时，可能InnoDB存储引擎正在写入某个页到表中，而这个页只写了一部分，比如16KB的页，只写了前4KB，之后就发生了宕机，这种情况被称为部分写失效。可以通过重做日志进行恢复。这是一个办法。但是必须清楚地认识到，重做日志中记录的是对页的物理操作(页的变化)，如偏移量800，写’aaaa’记录。如果这个页本身已经发生了损坏，再对其进行重做是没有意义的。所以，在应用重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是doublewrite。</p><p>doublewrite由两部分组成，一部分是内存中的doublewrite buffer，大小为2MB，另一部分是物理磁盘上共享表空间中连续的128个页，即2个区（extent），大小同样为2MB。</p><p>在对<strong>缓冲池的脏页进行刷新</strong>时，并不直接写磁盘，而是先将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后才同步磁盘。如果说Insert Buffer带给InnoDB存储引擎的是性能上的提升，那么doublewrite（两次写）带给InnoDB存储引擎的是数据页的可靠性。</p><h4 id="10-InnoDB关键特性-自适应哈希索引"><a href="#10-InnoDB关键特性-自适应哈希索引" class="headerlink" title="10.InnoDB关键特性 - 自适应哈希索引"></a>10.InnoDB关键特性 - 自适应哈希索引</h4><p>哈希是一种非常快的查找方法，在一般情况下这种查找的时间复杂度为O(1)，即一般仅需要一次查找就能定位数据。而B+树的查找次数，取决于B+树的高度，在生产环境中，B+树的高度一般为3～4层，故需要3～4次的查询。</p><p>InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引。<strong>自适应哈希索引是通过缓冲池的B+树页构造而来</strong>，因此建立的速度很快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。</p><ul><li><p>创建自适应哈希索引有一个要求，即对这个页的连续查询条件必须是一样的</p><p>例如对于（a，b）这样的联合索引页，其访问模式可以是以下情况：</p><p>❑WHERE a&#x3D;xxx</p><p>❑WHERE a&#x3D;xxx and b&#x3D;xxx</p></li><li><p>若交替进行上述两种查询，那么InonDB存储引擎不会对该页构造自适应哈希索引。此外AHI还有如下的要求：</p><p>❑以该查询条件访问了100次</p><p>❑页通过该查询方式访问了N次，其中N&#x3D;页中记录*1&#x2F;16</p></li></ul><h4 id="11-InnoDB关键特性-异步IO与刷新邻接页"><a href="#11-InnoDB关键特性-异步IO与刷新邻接页" class="headerlink" title="11.InnoDB关键特性 -异步IO与刷新邻接页"></a>11.InnoDB关键特性 -异步IO与刷新邻接页</h4><p>为了提高磁盘操作性能，当前的数据库系统都采用异步IO（AIO）的方式来处理磁盘操作。InnoDB存储引擎亦是如此。</p><p>AIO的另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO，这样可以提高性能。例如用户需要访问的页（space，page_no）为：（8，6）、（8，7），（8，8）</p><p>每个页的大小为16KB，那么同步IO需要进行3次IO操作。而AIO会判断到这三个页是连续的（看page_no得知）。因此AIO底层会发送一个IO请求，从（8，6）开始，读取48KB的页。</p><p>InnoDB存储引擎还提供了刷新邻接页的特性。其工作原理为：当刷新一个脏页时，InnoDB存储引擎会检测该页所在区的所有页，如果是脏页，那么一起进行刷新。这样做的好处显而易见，通过AIO可以将多个IO写入操作合并为一个IO操作，故该工作机制在传统机械磁盘下有着显著的优势。固态硬盘本身就具有较高的性能，所以在固态硬盘中该特性效果不明显</p><h4 id="12-InnoDB关闭与启动恢复"><a href="#12-InnoDB关闭与启动恢复" class="headerlink" title="12.InnoDB关闭与启动恢复"></a>12.InnoDB<strong>关闭与启动恢复</strong></h4><p>InnoDB是MySQL数据库的存储引擎之一，因此InnoDB存储引擎的启动和关闭，其实是MySQL实例的启动过程中对InnoDB存储引擎的处理过程。</p><ul><li><p>MySQL在关闭时，参数innodb_fast_shutdown的不同配置InnoDB引擎会有不同的行为，该参数可取值为0、1、2，默认值为1。</p><p>❑0表示在MySQL数据库关闭时，InnoDB需要完成所有的full purge和merge insert buffer，并且将所有的脏页刷新回磁盘。这需要一些时间，有时甚至需要几个小时来完成(关闭慢启动快)。<strong>如果在进行InnoDB升级时，必须将这个参数调为0，然后再关闭数据库。</strong></p><p>❑1是参数innodb_fast_shutdown的默认值，表示不需要完成上述的full purge和merge insert buffer操作，但是在缓冲池中的一些数据脏页还是会刷新回磁盘。(关闭启动都挺快)</p><p>❑2表示不完成full purge和merge insert buffer操作，也不将缓冲池中的数据脏页写回磁盘，而是将日志都写入日志文件。这样不会有任何事务的丢失，但是下次MySQL数据库启动时，会进行恢复操作(关闭快启动慢)。</p></li></ul><p>当正常关闭MySQL数据库时，下次的启动应该会非常“正常”。但是如果没有正常地关闭数据库，如用kill命令关闭数据库，在MySQL数据库运行中重启了服务器，或者在关闭数据库时，将参数innodb_fast_shutdown设为了2时，下次MySQL数据库启动时都会对InnoDB存储引擎的表进行恢复操作。</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><h4 id="1-参数文件"><a href="#1-参数文件" class="headerlink" title="1.参数文件"></a>1.参数文件</h4><p>当MySQL实例启动时，数据库会先去读一个配置参数文件(my.ini)，用来寻找数据库的各种文件所在位置以及指定某些初始化参数</p><p>该文件参数存储形式是键&#x2F;值对。例如对于InnoDB存储引擎很重要的参数innodb_buffer_pool_size&#x3D;1G。这里的“键”是innodb_buffer_pool_size，“值”是1G，这就是键值对。可以通过命令SHOW VARIABLES查看数据库中的所有参数，也可以通过LIKE来过滤参数名。</p><p><strong>若想在数据库实例下一次启动时该参数还是保留为当前修改的值，那么用户必须去修改参数文件。</strong></p><h4 id="2-日志文件"><a href="#2-日志文件" class="headerlink" title="2.日志文件"></a>2.日志文件</h4><ul><li><p>错误日志</p><ul><li>错误日志文件对MySQL的启动、运行、关闭过程进行了记录。该文件不仅记录了所有的错误信息，也记录一些警告信息或正确的信息。通过命令SHOW VARIABLES LIKE’log_error’来定位该文件位置 （辅助定位错误的sql，但是很少去使用这个文件直接看哪个sql报错了，因为对于sql的使用，如果出现错误，我们会从服务层面进行err log的记录。）</li></ul></li><li><p>查询日志</p><ul><li>查询日志记录了MySQL数据库所有的请求信息，无论这些请求是否得到了正确的执行。默认文件名为：主机名.log。（大概率不会开启，因为这个东西极大的增加了数据库的压力）<ul><li>使用general_log&#x3D;ON配置开启查询日志，默认情况不开启</li><li>使用SHOW VARIABLES LIKE’general_log_file’定位查询日志的位置</li></ul></li></ul></li><li><p>慢查询日志</p><ul><li>可以设置long_query_time这个阈值，MySQL数据库会记录运行时间超过该值的所有SQL语句(便于定位有问题的sql，从而进行sql语句层面的优化)，但运行时间正好等于long_query_time的情况并不会被记录下。其次，从MySQL 5.1开始，long_query_time这个参数的配置可以精确到微秒，之前是秒</li><li>另外，通过配置参数log_queries_not_using_indexes&#x3D;ON，可以把没有使用索引的sql记录到慢查询日志中，MySQL 5.6.5版本开始新增了一个参数log_throttle_queries_not_using_indexes，用来表示每分钟最多允许记录到慢查询日志且未使用索引的SQL语句次数。该值默认为0，表示没有限制。</li></ul></li><li><p>二进制日志</p><ul><li><p>二进制日志（bin log）记录了对MySQL数据库所有的修改(不包括SELECT和SHOW这类操作)操作</p><ul><li><p>二进制日志的作用。</p><p>❑恢复：某些数据的恢复需要二进制日志，类似于redo log</p><p>❑复制：从数据库和主数据库的数据同步</p><p>❑审计：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入的攻击。</p><p>二进制日志文件在默认情况下并没有启动，需要手动指定参数来启动（为什么默认关闭？1. 恢复可以用redo；2. 有可能没有主从3. 自己用，公司没审计）。开启这个选项会影响性能，但是性能的损失十分有限。根据MySQL官方手册中的测试表明，开启二进制日志会使性能下降1%。但考虑到可以使用复制和恢复等功能，这些性能损失绝对是可以且应该被接受的。</p><p>开启二进制日志的配置参数：log_bin&#x3D;myBinLog，键是log_bin，值是二进制日志的文件名(不要起OFF即可)，开启后会出现两个文件，一个真正存储日志信息，一个index文件保存所有的二进制文件的文件名</p><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231227211506859.png" class title="image-20231227211506859"></li></ul></li><li><p>二进制日志的重要参数</p><ul><li><p>max_binlog_size参数。max_binlog_size指定了单个二进制日志文件的最大值，如果超过该值，则产生新的二进制日志文件，后缀名+1，并记录到.index文件。从MySQL5.0开始的默认值为1 G（在之前版本默认大小为1.1G）。</p></li><li><p>binlog_cache_size参数。当使用事务时，所有未提交的二进制日志会被记录到一个缓存中去，等该事务提交时直接将缓冲中的二进制日志写入二进制日志文件，而该缓冲的大小由binlog_cache_size决定，<strong>默认大小为32K</strong>。此外，binlog_cache_size是基于会话（session）的，也就是说，当一个线程开始一个事务时，MySQL会自动分配一个大小为binlog_cache_size的缓存，因此该值的设置需要相当小心，不能设置过大。当一个事务的记录大于设定的binlog_cache_size时，MySQL会把缓冲中的日志写入一个临时文件中，因此该值又不能设得太小。具体如何调整这个参数呢？通过SHOW BINLOG EVENTS IN’myBinLog.000001’命令查看binlog_cache_use(缓存使用的次数)、binlog_cache_disk_use(直接写入磁盘的次数)的状态，如果使用缓存次数远多于直接写入磁盘说明配置的还可以，但是直接写入磁盘的次数很多，说明缓存经常爆满，所以可以适当调大该值</p></li><li><p>sync_binlog参数。sync_binlog&#x3D;[N]表示每写缓冲多少次就同步到磁盘。如果将N设为1，表示不使用缓存，直接同步写磁盘的方式来写二进制日志。sync_binlog的默认值为0(表示由操作系统决定说明时候刷新到磁盘)，如果使用InnoDB存储引擎进行复制，并且想得到最大的高可用性，建议将该值设为1。</p><p>但是，即使将sync_binlog设为1，还是会有一种情况导致问题的发生。当使用InnoDB存储引擎时，在一个事务提交之前，由于sync_binlog为1，因此会将二进制日志立即写入磁盘。但是提交还没有发生，并且此时发生了宕机，那么在MySQL数据库下次启动时，由于COMMIT操作并没有发生，这个事务会被回滚掉。但是二进制日志已经记录了该事务信息，不能被回滚。这个问题可以通过将参数innodb_support_xa设为1来防止回滚解决该问题。</p></li><li><p>binlog-do-db参数。binlog-do-db表示需要写入哪些库的日志。默认为空，表示需要同步所有库的日志到二进制日志。</p></li><li><p>binlog-ignore-db参数。binlog-ignore-db表示需要忽略哪些库的日志。默认为空，表示需要同步所有库的日志到二进制日志。</p></li><li><p>log-slave-update参数。从自己的主服务器取得二进制日志，然后将获取的二进制日志文件写入自己的二进制文件中去。</p><p>如果设置为OFF，表示只使用该二进制日志，不存储。设置为ON表示又用又存。</p><p>A数据库 -&gt; B数据库 -&gt; C数据库 这种情况下，对于 B来说，一定要开启这个配置，不然的话，B只用不存，你不存， C就没法用了</p></li><li><p>binlog_format参数。它影响了记录二进制日志的格式。包括以下三个选项：</p><ol><li><p>STATEMENT：二进制日志文件记录的是SQL语句。</p></li><li><p>ROW：记录的是表的行更改情况。从MySQL 5.1版本开始，如果设置了binlog_format为ROW，可以将InnoDB的事务隔离基本设为READ COMMITTED，以获得更好的并发性（主从复制）。</p></li><li><p>MIXED：MySQL默认采用STATEMENT格式进行二进制日志文件的记录，但是在一些情况下会使用ROW格式：</p><p> 1）表的存储引擎为NDB，这时对表的DML操作都会以ROW格式记录。</p><p> 2）使用了UUID()、ROW_COUNT()等不确定函数。</p><p> 3）使用了INSERT DELAY语句。</p><p> 4）使用了用户定义函数（UDF）。</p><p> 5）使用了临时表（temporary table）。</p></li></ol></li></ul></li></ul></li></ul><h4 id="3-Socket文件和Pid文件"><a href="#3-Socket文件和Pid文件" class="headerlink" title="3. Socket文件和Pid文件"></a>3. Socket文件和Pid文件</h4><ul><li>Socket文件<ul><li>在UNIX系统下本地连接MySQL可以采用UNIX域套接字方式，这种方式需要一个套接字（socket）文件。套接字文件可由参数socket控制。一般在&#x2F;tmp目录下，名为mysql.sock。</li></ul></li><li>Pid文件<ul><li>当MySQL实例启动时，会将自己的进程ID写入pid文件中。该文件可由参数pid_file控制，默认位于数据库目录下，文件名为主机名.pid</li></ul></li></ul><h4 id="4-重做日志文件"><a href="#4-重做日志文件" class="headerlink" title="4.重做日志文件"></a>4.重做日志文件</h4><p>在默认情况下，在InnoDB存储引擎的数据目录下会有两个名为ib_logfile0和ib_logfile1的文件，就是重做日志文件</p><p>当数据库重启的时候，InnoDB存储引擎会使用重做日志恢复到重启前的状态，以此来保证数据的完整性。</p><p>每个InnoDB存储引擎至少有1个重做日志文件组（group），每个文件组下至少有2个重做日志文件，如默认的ib_logfile0和ib_logfile1。为了得到更高的可靠性，用户可以设置多个的镜像日志组，将不同的文件组放在不同的磁盘上，以此提高重做日志的高可用性。在日志组中每个重做日志文件的大小一致，并以循环写入的方式运行。例如：InnoDB存储引擎先写重做日志文件1，当达到文件的最后时，会切换至重做日志文件2，再当重做日志文件2也被写满时，会再切换到重做日志文件1中。</p><ul><li><p>关于重做日志文件的参数：</p><p>❑innodb_log_file_size参数。指定每个重做日志文件的大小。在InnoDB1.2.x版本之前，重做日志文件总的大小不得大于等于4GB，而1.2.x版本将该限制扩大为了512GB。</p><p>❑innodb_log_files_in_group参数。指定了日志文件组中重做日志文件的数量，默认为2。</p><p>❑innodb_mirrored_log_groups参数。指定了日志镜像文件组的数量，默认为1，表示只有一个日志文件组，没有镜像。</p><p>❑innodb_log_group_home_dir参数。指定了日志文件组所在路径</p></li></ul><p>重做日志文件的大小设置对于InnoDB存储引擎的性能有着非常大的影响。一方面重做日志文件不能设置得太大，如果设置得很大，在恢复时可能需要很长的时间；另一方面又不能设置得太小了，否则可能导致一个事务的日志需要多次切换重做日志文件。</p><ul><li><p>重做日志文件和二进制日志有什么区别？</p><ol><li>记录的范围不同，二进制日志会记录所有与MySQL数据库有关的日志记录，包括InnoDB、MyISAM等其他存储引擎的日志。而重做日志只记录InnoDB存储引擎本身的事务日志。</li><li>记录的内容不同，二进制日志文件记录的都是关于一个事务的具体操作内容，即具体的sql语句。而InnoDB存储引擎的重做日志文件记录的是关于<strong>每个页（Page）的更改的物理情况</strong>(这个地方也说明了主从复制的时候不能使用重做日志文件，因为它是根据每个页的offset进行修改的，不同的数据库页的offset不同)。</li><li>写入的时间也不同，二进制日志文件仅在事务提交前进行提交，即只写磁盘一次。而在事务进行的过程中，却不断有重做日志被写入到重做日志文件中。</li></ol><p>写入重做日志文件的操作不是直接写，而是先写入一个重做日志缓冲中，然后按照一定的条件顺序地写入日志文件。从重做日志缓冲往磁盘写入时，是按512个字节，也就是一个扇区的大小进行写入。因为扇区是写入的最小单位(原子性)，因此可以保证写入必定是成功的。因此在重做日志的写入过程中不需要有doublewrite。</p></li></ul><h3 id="InnoDB存储引擎的表"><a href="#InnoDB存储引擎的表" class="headerlink" title="InnoDB存储引擎的表"></a>InnoDB存储引擎的表</h3><h4 id="1-InnoDB-逻辑存储结构"><a href="#1-InnoDB-逻辑存储结构" class="headerlink" title="1.InnoDB 逻辑存储结构"></a>1.<strong>InnoDB</strong> <strong>逻辑存储结构</strong></h4><p>在InnoDB存储引擎中，表都是根据主键顺序组织存放的。在InnoDB存储引擎表中，每张表一定都有个主键，如果在创建表时没有显式地定义主键，则InnoDB存储引擎会按如下方式选择或创建主键：</p><ol><li><p>首先判断表中是否有<strong>非空唯一</strong>索引，如果有，则该列即为主键。</p></li><li><p>如果不符合上述条件，InnoDB存储引擎自动创建一个6字节大小的指针（_rowid）作为主键。</p></li></ol><p><strong>当表中有多个非空唯一索引时，InnoDB存储引擎将选择建表时第一个定义的非空唯一索引为主键。这里需要非常注意的是，主键的选择根据的是定义索引的顺序，而不是建表时列的顺序。</strong></p><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231228132724321.png" class title="image-20231228132724321"><p>从InnoDB存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在表空间（tablespace）。表空间又由段（segment）、区（extent）、页（page）组成。页是由行(Row)组成。</p><p>表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。默认情况下InnoDB存储引擎有一个共享表空间ibdata1，即所有数据都存放在这个表空间内。如果用户启用了参数innodb_file_per_table，则每张表内的数据可以单独放到一个表空间内。</p><p>如果启用了innodb_file_per_table的参数，需要注意的是每张表的表空间内存放的只是<strong>数据、索引</strong>和插入缓冲Bitmap页，其他类的数据，如回滚（undo）信息，插入缓冲索引页、系统事务信息，二次写缓冲等还是存放在原来的共享表空间内。所以，即使在启用了参数innodb_file_per_table之后，共享表空间还是会不断地增加其大小。</p><p>InnoDB存储引擎不会在执行rollback时去收缩这个共享表空间中的undo信息。但是，它会自动判断这些undo信息是否还需要，如果不需要，则会将这些空间标记为可用空间，供下次undo使用。</p><h4 id="2-表空间"><a href="#2-表空间" class="headerlink" title="2.表空间"></a>2.表空间</h4><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231228132724321.png" class title="image-20231228132724321"><ul><li><p>段</p><ul><li>表空间是由各个段组成的，常见的段有<strong>数据段、索引段、回滚段</strong>等。数据段即为B+树的叶子节点段（图中Leaf node segment），索引段即为B+树的非叶子节点段（图中Non-leaf node segment），回滚段较为特殊，后序详细分解。在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。</li></ul></li><li><p>区</p><ul><li><p>区是由连续页组成的空间，在<strong>任何情况下每个区的大小都为1MB</strong>。为了保证区中页的连续性，InnoDB存储引擎一次从磁盘申请4～5个区。在默认情况下，InnoDB存储引擎页的大小为16KB，即一个区中一共有64个连续的页(在不使用压缩页的情况下)。</p><p>InnoDB 1.0.x版本开始引入压缩页，即每个页的大小可以通过参数KEY_BLOCK_SIZE设置为2K、4K、8K，因此每个区对应页的数量就应该为512、256、128。</p><p>InnoDB 1.2.x版本新增了参数innodb_page_size，通过该参数可以将默认页的大小设置为4K、8K(只是调整一个页的大小没有进行压缩)。这时区中页的数量同样也为256、128。<strong>总之，不论页的大小怎么变化，区的大小总是为1M。</strong></p><ul><li>注意：在每个段开始时，先用32个页大小的<strong>碎片页</strong>来存放数据，在使用完这些页之后才是64个连续页的申请，也就是申请一个区。这样做的目的是，对于一些小表，或者是undo这类的段，可以在开始时申请较少的空间，节省磁盘容量的开销。</li></ul></li></ul></li><li><p>页</p><ul><li>页是InnoDB磁盘管理的最小单位。在InnoDB存储引擎中，默认每个页的大小为16KB。而从InnoDB 1.2.x版本开始，可以通过参数innodb_page_size将页的大小设置为4K、8K、16K。若设置完成，则所有表中页的大小都为innodb_page_size，不可以对其再次进行修改。</li></ul></li><li><p>行</p><ul><li><p>在InnoDB 1.0.x版本之前，InnoDB存储引擎提供了Compact和Redundant两种格式来存放行记录数据。Redundant格式是为兼容之前版本而保留的，在MySQL 5.1版本中，默认设置为Compact行格式。</p></li><li><p><strong>Compact格式</strong></p><ul><li><p>InnoDB存储引擎是面向行的，也就说数据是按行进行存放的。每个页存放的行也是有硬性定义的，最多允许存放7992行记录，最少存放2行数据。</p><p>Compact行记录的存储方式：</p><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231228154459680.png" class title="image-20231228154459680"><ul><li><p>首部是一个非NULL变长字段长度列表，记录的是类似varcahr这样不确定的数据类型的字段的真实长度，如果不记录该字段的真实长度，那么就无法计算出这一行的准确长度,那么就无法进行行与行的切分。其长度为：</p><p>❑若列的长度小于255字节，用1字节表示；</p><p>❑若大于255个字节，用2字节表示。</p><p>变长字段的长度最大不可以超过2字节，这是因在MySQL数据库中VARCHAR类型的最大长度限制为65535字节。</p></li><li><p>NULL标志位，该位指示了该行数据中是否有NULL值，有则用1表示。占用1字节</p></li><li><p>记录头信息（record header），固定占用5字节（40位），记录了行是否被删除，下一行的相对位置信息等内容</p></li><li><p>最后的部分就是实际存储每个列的数据。<strong>需要特别注意的是，行内的NULL不占该部分任何空间，即NULL除了占有NULL标志位，实际存储不占有任何空间。</strong>另外有一点需要注意的是，每行数据除了用户定义的列外，还有两个隐藏列，事务ID列和回滚指针列，分别为6字节和7字节的大小。若InnoDB表没有定义主键，每行还会增加一个6字节的rowid列。</p></li></ul></li></ul></li><li><p><strong>Redundant格式</strong></p><ul><li><p>Redundant是MySQL 5.0版本之前InnoDB的行记录存储方式，MySQL 5.0支持Redundant是为了兼容之前版本的页格式。</p><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231228161040488.png" class title="image-20231228161040488"></li><li><p>与Compact格式相比，没有了null标志位</p></li></ul></li></ul></li></ul><h4 id="3-行溢出数据"><a href="#3-行溢出数据" class="headerlink" title="3.行溢出数据"></a>3.行溢出数据</h4><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231228162230556.png" class title="image-20231228162230556"><p>InnoDB存储引擎表规定，每个页中至少应该有两条行记录（否则失去了B+Tree的意义，变成链表了）。因此，如果页中只能存放下一条记录，那么InnoDB存储引擎会自动将行数据存放到溢出页(BLOB Page)中。</p><p>MySQL数据库的VARCHAR类型理论上可以存放65535字节数据，通过实际测试发现能存放VARCHAR类型的最大长度为65532（字节），MySQL官方手册中定义的65535长度是指一行中所有VARCHAR列的长度总和，如果列的长度总和超出这个长度，依然无法创建。</p><h4 id="4-Compressed和Dynamic行记录格式"><a href="#4-Compressed和Dynamic行记录格式" class="headerlink" title="4.Compressed和Dynamic行记录格式"></a>4.<strong>Compressed和Dynamic行记录格式</strong></h4><p>InnoDB 1.0.x版本开始引入了新的行记录格式，Compressed和Dynamic</p><p>Compressed行记录格式的另一个功能就是，存储在其中的行数据会以zlib的算法进行压缩，因此对于BLOB、TEXT、VARCHAR这类大长度类型的数据能够进行非常有效的存储。</p><h4 id="5-视图"><a href="#5-视图" class="headerlink" title="5.视图"></a>5.视图</h4><p>视图分为虚拟视图和物化视图</p><ul><li>虚拟视图<ul><li>它由一个SQL查询来定义，可以当做表使用。（例如表user 10条数据。我想给其他人只展3 条数据，我可以在这张表的上层创建一个视图：select * from table limit 3）不会做数据的存储，只是每次查询时会加上视图的限定条件</li></ul></li></ul><ul><li>物化视图<ul><li>物化视图可以用于预先计算并保存多表的链接（JOIN）或聚集（GROUP BY）等耗时较多的SQL操作结果。这样，在执行复杂查询时，就可以避免进行这些耗时的操作，从而快速得到结果。得到的结果可以直接被保存，下次拆线呢直接使用。MySQL数据库本身并不支持物化视图。</li></ul></li></ul><h4 id="6-分区"><a href="#6-分区" class="headerlink" title="6.分区"></a>6.分区</h4><p>分区功能并不是在存储引擎层完成的，因此不是只有InnoDB存储引擎支持分区，常见的存储引擎MyISAM、NDB等都支持。但也并不是所有的存储引擎都支持，如CSV、FEDORATED、MERGE等就不支持。</p><p>MySQL数据库在5.1版本时添加了对分区的支持。分区的过程是将一个表或索引分解为多个更小、更可管理的部分。就访问数据库的应用而言，从逻辑上讲，只有一个表或一个索引，但是在物理上这个表或索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理。</p><p>MySQL数据库支持的分区类型为水平分区[1]，并不支持垂直分区[2]。</p><p>[1]水平分区，指将<strong>同一表</strong>中不同行的记录分配到不同的物理文件中。 </p><p>[2]垂直分区，指将<strong>同一表</strong>中不同列的记录分配到不同的物理文件中。（很少使用，因为不好用。） </p><ul><li><p>分区的类型</p><ul><li>RANGE分区： 是最常用的一种分区类型<ul><li><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231228170649147.png" class title="image-20231228170649147"></li><li>如上图，id小于10的在一个分区，小于20的在另一个分区</li></ul></li><li>LIST分区： LIST分区和RANGE分区非常相似，只是分区列的值是离散的，而非连续的。 （使用较少）<ul><li><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231228170800141.png" class title="image-20231228170800141"></li><li>如上图，奇数放在p0区，偶数放在p1，使用较少的原因是，如果分区多的时候不好管理</li></ul></li><li>HASH分区。HASH分区的目的是将数据均匀地分布到预先定义的各个分区中，保证各分区的数据数量大致都是一样的。在RANGE和LIST分区中，必须明确指定一个给定的列值或列值集合应该保存在哪个分区中；而在HASH分区中，<strong>MySQL自动完成这些工作</strong>，用户所要做的只是<strong>基于将要进行哈希分区的列值指定一个列值</strong>或<strong>表达式</strong>，以及指定被分区的表将要被分割成的分区数量。（使用较少）<ul><li><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231228171039867.png" class title="image-20231228171039867"></li><li>使用较少的原因是，hsah函数必须自己指定，但是散列的效果需要进行大量的测试，而且不能直观的从原数据看出具体分到了哪个区</li></ul></li><li>KEY分区。KEY分区和HASH分区相似，但是不需要使用用户定义的函数进行分区，<strong>KEY分区使用MySQL数据库提供的函数进行分区。</strong>（使用较少）<ul><li><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231228172214887.png" class title="image-20231228172214887"></li></ul></li><li>MySQL5.5版本开始支持COLUMNS分区，可视为RANGE分区和LIST分区的一种进化(之前的分区类型只能对整型类型使用，要想对字符串使用就必须使用函数对字符串转化为整型)。COLUMNS分区可以直接使用非整型的数据进行分区，分区根据类型直接比较而得，不需要转化为整型。 （常见使用）<ul><li><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231228172447446.png" class title="image-20231228172447446"></li></ul></li><li>子分区，就是在分区的基础上再次尽心进行分区，基本没人使用，难以维护，如果数据量真的过大可以使用水平拆分</li></ul></li><li><p>null值分区处理</p><ul><li><p>MYSQL数据库的分区总是视NULL值视小于任何的一个非NULL值，这和MySQL数据库中处理NULL值的ORDER BY操作是一样的。因此对于不同的分区类型，MySQL数据库对于NULL值的处理也是各不相同。</p><ul><li><p>对于RANGE分区，如果向分区列插入了NULL值，则MySQL数据库会将该值放入最左边的分区。</p></li><li><p>在LIST分区下要使用NULL值，则必须显式地指出哪个分区中放入NULL值，否则会报错</p></li><li><p>HASH和KEY分区对于NULL的处理方式和RANGE分区、LIST分区不一样。任何分区函数都会将含有NULL值的记录返回为0。</p></li></ul></li></ul></li><li><p>水平分区和水平拆分的区别</p><ol><li><strong>目的</strong>：水平分区是为了在特定的SQL操作中减少数据读写的总量，而水平拆分是为了扩展表，使其能够处理更多的行。</li><li><strong>实现方式</strong>：水平分区通常根据表的主键定位不同分区来实现，而水平拆分则是通过将表的行分割成多个表来实现。</li></ol></li></ul><h4 id="7-约束"><a href="#7-约束" class="headerlink" title="7.约束"></a>7.约束</h4><p>表建立时的常见约束，如：</p><ol><li><p>对Unique Key（唯一索引）的约束</p></li><li><p>用户还可以通过命令CREATE UNIQUE INDEX来建立。对于主键约束而言，其默认约束名为PRIMARY。</p></li><li><p>而对于Unique Key约束而言，默认约束名和列名一样，当然也可以人为指定Unique Key约束的名字。</p></li><li><p>Foreign Key约束也是如此。</p></li><li><p>NOT NULL 字段的约束。</p></li><li><p>ENUM 和 SET 字段的约束。</p></li><li><p>触发器约束。 创建触发器的命令是CREATE TRIGGER，只有具备Super权限的MySQL数据库用户才可以执行这条命令。</p></li></ol><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="1-B-树概述"><a href="#1-B-树概述" class="headerlink" title="1.B+树概述"></a>1.B+树概述</h4><p>InnoDB存储引擎支持以下几种常见的索引：</p><p>❑B+树索引 B+树索引是目前关系型数据库系统中查找最为常用和最为有效的索引。B+树索引并不能找到一个给定键值的具体行。B+树索引只能找到被查找数据行所在的页。然后数据库通过把页读入到内存，再在内存中进行二分查找，最后得到要查找的数据。</p><p>❑全文索引 支持全文检索。</p><p>❑哈希索引 InnoDB存储引擎支持的哈希索引是自适应的，InnoDB存储引擎会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引。</p><ul><li><p>B+树索引</p><ul><li><p>所有记录都在叶子节点上，并且是顺序存放的，在数据库中，B+树的高度一般都在2～4层，这也就是说查找某一行记录时最多只需要2到4次IO。</p><p>数据库中的B+树索引可以分为聚集索引和辅助索引（但是不管是聚集还是辅助的索引，其内部都是B+树的，即高度平衡的，叶子节点存放着所有的数据。聚集索引与辅助索引不同的是，叶子节点存放的是否是一整行的信息）</p></li></ul></li></ul><h4 id="2-聚集索引"><a href="#2-聚集索引" class="headerlink" title="2.聚集索引"></a>2.<strong>聚集索引</strong></h4><p>聚集索引就是按照每张表的<strong>主键</strong>构造一棵B+树，同时<strong>叶子节点中存放的即为整张表的行记录数据</strong>。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。</p><p>由于实际的数据页只能按照一棵B+树进行排序，<strong>因此每张表只能拥有一个聚集索引</strong>。在多数情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子节点上直接找到数据。此外，由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值的查询。</p><p><strong>聚集索引的存储并不是物理上连续的，所以不需要连续的内存空间。这其中有两点：一是前面说过的页通过双向链表链接，页按照主键的顺序排序；另一点是每个页中的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。</strong></p><p>以bigint类型的主键举例，对于聚集索引，叶子节点存储的整行数据，非叶子节点存储的是主键(8个字节)和指向下一层的指针(6个字节)，所以对于根节点一个16KB的内存页，第二层可以存储(16 * 1024 &#x2F; 14) &#x3D; 1170个节点，所以第三层的节点个数就是1170^2 &#x3D; 个，这时如果数据字段设计不好，出现了一行数据所占大小为16KB的话，那么这个表只能存储1,368,900行数据。所以严格控制单行数据的大小，可以减少IO次数，提升查询效率</p><hr><p>一次IO表示从磁盘读取16KB内存页，然后根据id通过二分查找，定位范围找到指向下一层的指针，所以对于一棵三层高的B+树需要三次IO，总共加载了48KB的内存页</p><ul><li>为什么不用B树(二叉树原因类似)<ul><li>B树和B+树的唯一区别就在于非叶子节点是否存储数据，B树从根节点就开始存储数据了，如果一行数据加上其对应指针的大小为1KB，那么根节点只能存储16行数据，那么二层只有16个节点，三层只有256个节点，共计(256 + 16 + 1) * 16行数据，远不如B+树的数据存储量</li></ul></li><li>为什么不用HashMap<ul><li>HashMap不能支持<strong>模糊查询</strong>，因为数据存储的时候是用完整的数据计算的hashcode值，而模糊查询时查询条件中有%，所以计算的hashcode值不同，找不到原来的数据</li><li>HashMap不支持<strong>范围查询</strong>，例如查询id在1- 100这个范围的所有数据，B+树可以先定位id为1的这一行数据，然后一行行往下找，而且这些数据很可能在同一个内存页中，所以查询效率很高，但是如果把1-100这些id全部计算一边hashcode然后再拿到数据封装返回给用户，效率就很慢了</li><li><strong>hash冲突</strong>问题，不可避免</li></ul></li></ul><h4 id="3-辅助索引"><a href="#3-辅助索引" class="headerlink" title="3.辅助索引"></a>3.辅助索引</h4><p>对于辅助索引，叶子节点并不包含行记录的全部数据。叶子节点除了包含<strong>索引列对应的值</strong>以外，每个叶子节点中的索引行中还包含了每行对应的主键。这样Innodb存储引擎就知道去哪找整行的数据。</p><p>每张表上可以有多个辅助索引，但是必须有一个聚集索引。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。</p><p>举例来说，如果在一棵高度为3的辅助索引树中查找数据，那需要对这棵辅助索引树遍历3次找到指定主键，如果聚集索引树的高度同样为3，那么还需要对聚集索引树进行3次查找，最终找到一个完整的行数据所在的页，因此一共需要6次逻辑IO访问以得到最终的一个数据页。</p><hr><ul><li>索引什么时候会失效(L O L +-*&#x2F; NOT NULL NO METHOD 隐式转换)<ul><li>L：like模糊查询的时候，如果是name like “王%”索引不会失效，但是如果是name like”%王”索引就会失效</li><li>o：or 如果or前后两个字段都是索引那么or不会失效，但是如果有其中一个字段不是索引，那么就会失效</li><li>L：联合索引 在联合索引中，如果where条件后面的首个查询字段是创建索引的首个字段，那么不会失效，否则索引失效</li><li>+-*&#x2F; 运算 例如age字段是一个辅助索引，这时select xx from table where age + 1 &#x3D; 10，这个查询索引就会失效，因为索引字段参与了运算</li><li>NOT：表示取非 还是上面的例子，select xx from table where age !&#x3D; 10，索引会失效</li><li>NULL：表示空值 MySQL在创建索引的时候允许该列中有空值，但是在创建B+树的时候不会把NULL值放到B+树里面，所以当查询where name &#x3D;&#x3D; null的时候可能会发生索引失效，所以在表的设计初期，对一定非空的字段要限制非空，对于不一定非空的字段可以加一个默认值避免索引失效的情况</li><li>NO METHOD：表示如果对索引字段使用MySQL内置的方法，会导致索引失效</li><li>隐式转换：例如表的id字段是varchar，而查询的时候使用了where id &#x3D; 123，的时候MySQL会自动把123转为‘123’导致索引失效</li><li>不一样的版本不一样的我：例如select * from table where age  &gt; 3，其中age字段创建了辅助索引,这条查询语句走不走索引呢？ 如果走索引就是现在辅助索引中三次IO找到age大于3的所有主键id，然后根据id进行回表查询，但是从辅助索引得到的id可能不是连续的，这就导致到聚集索引中查询的时候可能不止三次IO，如果不走辅助索引直接到聚集索引中三次IO来到叶子节点，全表扫描找到所有数据<ul><li>在MySQL5.6版本之前(不包括5.6)，通过对表中的数据量进行阈值设置，不同的数据量走不同的查询方式</li><li>在MySQL5.6版本及以后，MySQL对使用了MRR优化，经过MRR优化后，从辅助索引查询返回的id会在内存中先进行排序，然后才到聚集索引中查询，这样有序的id可能存在同一个内存页中，减少了聚集索引中IO次数</li></ul></li></ul></li></ul><h4 id="4-查看索引"><a href="#4-查看索引" class="headerlink" title="4.查看索引"></a>4.查看索引</h4><p>索引的创建和删除可以通过两种方法，一种是ALTER TABLE，另一种是CREATE&#x2F;DROP INDEX。查看索引信息可以使用SHOW INDEX命令。</p><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231230174323583.png" class title="image-20231230174323583"><p>❑Table：索引所在的表名。</p><p>❑Non_unique：如果该列的值是唯一的，那么Non_unique的值为0。</p><p>❑Key_name：索引的名字，用户可以通过这个名字来执行DROP INDEX。</p><p>❑Seq_in_index：索引中该列的位置，在联合索引中容易看。</p><p>❑Column_name：索引列的名称。</p><p>❑Collation：列以什么方式存储在索引中。可以是A或NULL。B+树索引是A，即排序的。如果使用了Heap存储引擎，并且建立了Hash索引，这里就会显示NULL了。因为Hash根据Hash桶存放索引数据，而不是对数据进行排序。</p><p>❑Cardinality：估计该列不重复的值的数量。该值除以表的总行数，越靠近1说明该列创建索引的效果越好</p><p>❑Sub_part：是否是列的部分被索引。如果一个列只有前100行创建索引，那么该值为100。如果索引整个列，则该字段为NULL。</p><p>❑Packed：关键字如何被压缩。如果没有被压缩，则为NULL。</p><p>❑Null：该列是否含有NULL值。如果允许有空值，那么该值为yes</p><p>❑Index_type：索引的类型。InnoDB存储引擎只支持B+树索引。</p><p>❑Comment：列注释，创建表的时候注释的。</p><h4 id="5-FIC（Fast-Index-Creation）"><a href="#5-FIC（Fast-Index-Creation）" class="headerlink" title="5.FIC（Fast Index Creation）"></a>5.FIC（Fast Index Creation）</h4><p>MySQL 5.5版本之前（不包括5.5）想要在线上进行索引的创建，MySQL数据库的操作过程为：</p><p>❑首先创建一张新的临时表，表结构为ALTER TABLE定义的索引结构。</p><p>❑然后把原表中数据导入到临时表。</p><p>❑接着删除原表。</p><p>❑最后把临时表重名为原来的表名。</p><p>可以发现，对于一张大表进行索引的添加和删除操作会需要很长的时间。更关键的是，若有大量事务需要访问正在被修改的表，这意味着数据库服务不可用。</p><p>InnoDB存储引擎1.0.x版本开始支持一种称为Fast Index Creation的索引创建方式——简称FIC。</p><p>对于辅助索引的创建，InnoDB存储引擎会对创建索引的表加上一个S锁(共享锁)。这样，在创建的过程中，不需要重建表，因此速度较之前提高很多，并且数据库的可用性也得到了提高。</p><p>对于删除辅助索引操作，InnoDB存储引擎只需将辅助索引占用的空间（内存）标记为可用，同时删除MySQL数据库内部视图上对该表的索引定义即可。</p><p>由于FIC在索引的创建的过程中对表加上了S锁，因此在创建的过程中只能对该表进行读操作，若有大量的事务需要对目标表进行写操作，那么数据库的服务同样不可用。此外，FIC方式只限定于辅助索引，对于主键的创建和删除同样需要重建一张表。</p><h4 id="6-OSC（Online-Schema-Change）"><a href="#6-OSC（Online-Schema-Change）" class="headerlink" title="6.OSC（Online Schema Change）"></a>6.OSC（Online Schema Change）</h4><p>Online Schema Change（在线架构改变，简称OSC）是由Facebook实现的一种在线执行DDL的方式。比如创建索引的过程中，可以有<strong>读写事务对表进行操作，</strong>这提高了原有MySQL数据库在DDL操作时的并发性。Facebook采用PHP脚本来现实OSC，而并不是通过修改InnoDB存储引擎源码的方式。实现OSC步骤如下：</p><p>❑init，即初始化阶段，会对创建的表做一些验证工作，如检查表是否有主键，是否存在触发器或者外键等。</p><p>❑createCopyTable，创建和原始表结构一样的新表。</p><p>❑alterCopyTable：对创建的新表进行ALTER TABLE操作，如添加索引或列等。</p><p>❑createDeltasTable，创建deltas表，该表的作用是之后对原表的所有DML操作会被记录到createDeltasTable中。</p><p>❑createTriggers，对原表创建INSERT、UPDATE、DELETE操作的触发器。触发操作产生的记录被写入到deltas表。</p><p>❑startSnpshotXact，开始OSC操作的事务。</p><p>❑selectTableIntoOutfile，将原表中的数据写入到新表。为了减少对原表的锁定时间，这里通过将数据分片写到多个外部文件，然后将外部文件的数据导入到copy表中。</p><p>❑dropNCIndexs，在导入到新表前，删除新表中所有的辅助索引。</p><p>❑loadCopyTable，将导出的分片文件导入到新表。</p><p>❑replayChanges，将OSC过程中原表DML操作的记录应用到新表中，这些记录被保存在deltas表中。</p><p>❑recreateNCIndexes，重新创建辅助索引。</p><p>❑replayChanges，把创建辅助索引过程中执行的DML操作放到表中</p><p>❑swapTables，将原表和新表交换名字，整个操作需要锁定2张表，不允许新的数据产生。由于改名是一个很快的操作，因此阻塞的时间非常短。</p><h4 id="7-Online-DDL"><a href="#7-Online-DDL" class="headerlink" title="7.Online DDL"></a>7.Online DDL</h4><p>虽然FIC可以让InnoDB存储引擎避免创建临时表，从而提高索引创建的效率。但正如前面小节所说的，索引创建时会阻塞表上的DML操作（加了S锁）。OSC虽然解决了上述的部分问题，但是还是有很大的局限性。MySQL 5.6版本开始支持Online DDL（在线数据定义）操作，其允许辅助索引创建的同时，还允许其他诸如INSERT、UPDATE、DELETE这类DML操作，这极大地提高了MySQL数据库在生产环境中的可用性。</p><p>此外，除了辅助索引，还支持以下操作：</p><p>❑辅助索引的创建与删除</p><p>❑改变自增长值</p><p>❑添加或删除外键约束</p><p>❑列的重命名</p><ul><li>在线创建索引语法：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name</span><br><span class="line"><span class="operator">|</span><span class="keyword">ADD</span>&#123;INDEX<span class="operator">|</span>KEY&#125;[index_name]</span><br><span class="line">[index_type] (index_col_name,...)[index_option]...</span><br><span class="line">ALGORITHM[<span class="operator">=</span>]&#123;<span class="keyword">DEFAULT</span><span class="operator">|</span>INPLACE<span class="operator">|</span><span class="keyword">COPY</span>&#125;</span><br><span class="line">LOCK[<span class="operator">=</span>]&#123;<span class="keyword">DEFAULT</span><span class="operator">|</span><span class="keyword">NONE</span><span class="operator">|</span>SHARED<span class="operator">|</span>EXCLUSIVE&#125;</span><br></pre></td></tr></table></figure><p>ALGORITHM指定了创建或删除索引的算法，COPY表示按照MySQL 5.1版本之前的工作模式，即创建临时表的方式(最原始的方法)。INPLACE表示索引创建或删除操作不需要创建临时表。DEFAULT表示根据参数old_alter_table来判断是通过INPLACE还是COPY的算法，该参数的默认值为OFF，表示采用INPLACE的方式</p><p>LOCK部分为索引创建或删除时对表添加锁的情况：</p><p>（1）NONE执行索引创建或者删除操作时，对目标表不添加任何的锁，即事务仍然可以进行读写操作，不会受到阻塞。因此这种模式可以获得最大的并发度。</p><p>（2）SHARE 这和之前的FIC类似，执行索引创建或删除操作时，对目标表加上一个S锁。对于并发地读事务，依然可以执行，但是遇到写事务，就会发生等待操作。如果存储引擎不支持SHARE模式，会返回一个错误信息。</p><p>（3）EXCLUSIVE 在EXCLUSIVE模式下，执行索引创建或删除操作时，对目标表加上一个X锁。读写事务都不能进行，因此会阻塞所有的线程，和最原始的方式很像，但是不需要创建新的表。</p><p>（4）DEFAULT DEFAULT模式首先会判断当前操作是否可以使用NONE模式，若不能，则判断是否可以使用SHARE模式，最后判断是否可以使用EXCLUSIVE模式。也就是说DEFAULT会通过判断事务的最大并发性来判断执行DDL的模式。</p><p><strong>InnoDB存储引擎实现Online DDL的原理是在执行创建或者删除操作的同时，将INSERT、UPDATE、DELETE这类DML操作日志写入到一个缓存中。待完成索引创建后再将重做应用到表上，以此达到数据的一致性。这个缓存的大小由参数innodb_online_alter_log_max_size控制，默认的大小为128MB。如果128MB不够，那么会抛出错误</strong></p><h4 id="8-Cardinality值"><a href="#8-Cardinality值" class="headerlink" title="8.Cardinality值"></a>8.<strong>Cardinality值</strong></h4><p>Cardinality值非常关键，表示索引中不重复记录数量的<strong>预估值</strong>。在实际应用中，Cardinality&#x2F;n_rows_in_table应尽可能地接近1。如果非常小，那么用户需要考虑是否还有必要创建这个索引。数据库对于Cardinality的统计都是通过采样的方法来完成的。</p><p>在InnoDB存储引擎中，Cardinality统计信息的更新发生在两个操作中：INSERT和UPDATE。但是，不可能在每次发生INSERT和UPDATE时就去更新Cardinality信息，这样会增加数据库系统的负荷。</p><ul><li><p>InnoDB存储引擎内部对更新Cardinality信息的策略为(满足以下其中一个即可)：</p><p>❑表中1&#x2F;16的数据已发生过变化(必须是不同行)。</p><p>❑表的修改总次数超过2亿次。</p></li><li><p>InnoDB存储引擎内部对Cardinality信息的采样：</p><p>❑获取B+树索引中全部叶子节点，记为A。</p><p>❑随机取得B+树索引中的8个叶子节点。统计每个页不同记录的个数，即为P1，P2，…，P8。</p><p>❑根据采样信息给出Cardinality的预估值：Cardinality&#x3D;（P1+P2+…+P8）*A&#x2F;8。</p></li></ul><p>通过上述的说明可以发现，在InnoDB存储引擎中，Cardinality值是通过对8个叶子节点预估而得的，不是一个实际精确的值。</p><p>通过参数innodb_stats_sample_pages用来设置统计Cardinality时每次采样页的数量，默认值为8。</p><p>通过参数innodb_stats_method用来判断如何对待索引中出现的NULL值记录。该参数默认值为nulls_equal，表示将NULL值记录视为相等的记录。其有效值还有nulls_unequal，nulls_ignored，分别表示将NULL值记录视为不同的记录和忽略NULL值记录。</p><h4 id="9-联合索引"><a href="#9-联合索引" class="headerlink" title="9.联合索引"></a>9.联合索引</h4><p>联合索引是指对表上的多个列进行索引联合索引的创建方法与单个索引创建的方法一样，不同之处仅在于有多个索引列。例如，创建了一张t表，并且索引idx_a_b是联合索引，联合的列为（a，b）。从本质上来说，联合索引也是一棵B+树，不同的是联合索引的键值的数量不是1，而是大于等于2。</p><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231231142850859.png" class title="image-20231231142850859"><p>对于查询SELECT  *  FROM TABLE WHERE a&#x3D;xxx and b&#x3D;xxx，显然是可以使用（a，b）这个联合索引的。对于单个的a列查询SELECT * FROM TABLE WHERE a&#x3D;xxx，也可以使用这个（a，b）索引。但对于b列的查询SELECT * FROM TABLE WHERE b&#x3D;xxx，则不可以使用这棵B+树索引。因为b列本身没排序，是在a列的基础上进行的排序。</p><h4 id="10-覆盖索引"><a href="#10-覆盖索引" class="headerlink" title="10.覆盖索引"></a>10.覆盖索引</h4><p>InnoDB存储引擎支持覆盖索引，即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录(不需要回表查询)。使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作。</p><h4 id="11-MRR-Multi-Range-Read-优化"><a href="#11-MRR-Multi-Range-Read-优化" class="headerlink" title="11.MRR(Multi-Range Read)优化"></a>11.MRR(<strong>Multi-Range Read</strong>)优化</h4><p>MySQL5.6版本开始支持（MRR）优化。Multi-Range Read优化的目的就是为了减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，这对于IO密集类型的SQL查询语句可带来性能极大的提升。由于从辅助索引的B+树的得到的主键索引是随机的，这些id可能存在聚集索引的不同数据页中。</p><ul><li><p>MRR优化有以下几个好处：</p><p>❑MRR使数据访问变得较为顺序。在查询辅助索引时，首先根据得到的查询结果，按照主键进行排序，并按照主键排序的顺序进行书签查找。</p><p>❑减少缓冲池中页被替换的次数。</p><p>❑批量处理对键值的查询操作。</p></li></ul><h4 id="12-Index-Condition-Pushdown（ICP）优化"><a href="#12-Index-Condition-Pushdown（ICP）优化" class="headerlink" title="12.Index Condition Pushdown（ICP）优化"></a>12.<strong>Index Condition Pushdown（ICP）优化</strong></h4><p>MySQL数据库版本在不支持Index Condition Pushdown的时候，当进行索引查询时，首先根据索引来查找记录，然后在缓存层根据WHERE条件来过滤记录。在支持Index Condition Pushdown后，MySQL数据库会在取出索引的同时，判断是否可以进行WHERE条件的过滤，也就是将WHERE的部分<strong>过滤操作放在了存储引擎层</strong>。这样从存储引擎层到缓存层传输的数据就会减小，从而提高数据库的性能。</p><p>例如，某张表有联合索引(zip_code，last_name，firset_name)，并且查询语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> people</span><br><span class="line"><span class="keyword">WHERE</span> zipcode<span class="operator">=</span><span class="string">&#x27;95054&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> lastname <span class="keyword">LIKE</span><span class="string">&#x27;%etrunia%&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> address <span class="keyword">LIKE</span><span class="string">&#x27;%Main Street%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>对于上述语句，MySQL数据库可以通过索引来定位zipcode等于95 054的记录，但是索引对WHERE条件的lastname LIKE’%etrunia%’AND address LIKE’%Main Street%’没有任何帮助。若不支持Index Condition Pushdown优化，则数据库需要先通过索引取出所有zipcode等于95 054的记录，然后再过滤WHERE之后的两个条件。</p><p>若支持Index Condition Pushdown优化，则在索引取出时，就会进行WHERE条件的过滤，然后再去获取记录。这将极大地提高查询的效率。</p><h4 id="13-InnoDB存储引擎中的哈希算法"><a href="#13-InnoDB存储引擎中的哈希算法" class="headerlink" title="13.InnoDB存储引擎中的哈希算法"></a>13.<strong>InnoDB存储引擎中的哈希算法</strong></h4><p>哈希算法使用场景，当前服务器的内存为128GB时，用户怎么从内存中得到某一个被缓存的页呢？虽然内存中查询速度很快，但是也不可能每次都要遍历所有内存来进行查找，这时使用哈希算法只需O（1）的时间复杂度</p><p>InnoDB存储引擎使用哈希算法来对字典进行查找，其冲突机制采用链表方式，哈希函数采用除法散列方式。对于缓冲池页的哈希表来说，在缓冲池中的每个页都有一个指针，它指向相同哈希函数值的页。而对于除法散列，m的取值为略大于2倍的缓冲池页数量的质数。例如：当前参数innodb_buffer_pool_size的大小为10M，则共有640个16KB的页。对于缓冲池页内存的哈希表来说，需要分配640×2&#x3D;1280个槽，但是由于1280不是质数，需要取比1280略大的一个质数，应该是1399，所以在启动时会分配1399个槽的哈希表，用来哈希查询所在缓冲池中的页。</p><p>InnoDB存储引擎的表空间都有一个space_id，用户所要查询的应该是某个表空间的某个连续16KB的页，即偏移量offset。InnoDB存储引擎将space_id左移20位，然后加上这个space_id和offset，即关键字<strong>K&#x3D;space_id＜＜20+space_id+offset</strong>，然后通过除法散列 k % m(1399) 到各个槽中去。</p><p>注意：自适应哈希索引经哈希函数映射到一个哈希表中，因此对于字典类型的查找非常快速，如SELECT*FROM TABLE WHERE index_col&#x3D;’xxx’。但是对于范围查找就无能为力了。</p><h4 id="14-全文检索"><a href="#14-全文检索" class="headerlink" title="14.全文检索"></a>14.<strong>全文检索</strong></h4><p>全文检索是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。从InnoDB 1.2.x版本开始，InnoDB存储引擎开始支持全文检索。</p><p>全文检索通常使用<strong>倒排索引</strong>来实现。它在辅助表中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。这通常利用关联数组实现，其拥有两种表现形式：</p><p>❑inverted file index，其表现形式为{单词，单词所在文档的ID}</p><p>❑full inverted index，其表现形式为{单词，(单词所在文档的ID，在具体文档中的位置)}</p><p>例如，表t(包括了文件的id和具体内容)存储的内容如表</p><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20240101200900507.png" class title="image-20240101200900507"><ul><li>使用inverted file index存储的辅助表格式(只精确到了文档的id)</li></ul><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20240101200951835.png" class title="image-20240101200951835"><ul><li>使用full inverted index存储的辅助表的格式(精确到在每个文档中的具体位置)</li></ul><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20240101201114780.png" class title="image-20240101201114780"><ul><li>InnoDB中的全文检索</li></ul><p>InnoDB存储引擎使用的是full inverted index形式，但是在其基础上进行了优化。它为了提高全文检索的性能，共有6张辅助表，而且每张表根据word的Latin编码进行分区。进一步缩小了检索范围，提高性能</p><p>另外InnoDB中的全文检索还支持FTS Index Cache（全文检索索引缓存），FTS Index Cache是一个红黑树结构，其根据（word，ilist）进行排序，其用来提高全文检索的性能。</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="1-锁概述"><a href="#1-锁概述" class="headerlink" title="1.锁概述"></a>1.锁概述</h4><p>InnoDB存储引擎在<strong>行级别</strong>上对表数据上锁。同时InnoDB存储引擎也会在数据库内部其他多个地方使用锁，从而允许对多种不同资源提供并发访问。例如，操作缓冲池中的LRU列表，删除、添加、移动LRU列表中的元素或者主键id自增，为了保证一致性，必须有锁的介入（这时锁的是线程）。数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。</p><p>对于MyISAM引擎，其锁是表锁设计（innodb存储也有表锁，就是意象锁，但是与行锁不冲突）。并发情况下的读没有问题，但是并发插入时的性能就要差一些了，若插入是在“底部”，MyISAM存储引擎还是可以有一定的并发写入操作。</p><ul><li><p>lock与latch的区别</p><ul><li><p>latch一般称为闩锁（轻量级的锁），latch又可以分为mutex（互斥量）和rwlock（读写锁）。<strong>其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。</strong></p></li><li><p>lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或rollback后进行释放。此外，lock，正如在大多数数据库中一样，是有死锁机制的。</p></li></ul><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20240101223829074.png" class title="image-20240101223829074"></li></ul><h4 id="2-InnoDB存储引擎中的锁"><a href="#2-InnoDB存储引擎中的锁" class="headerlink" title="2.InnoDB存储引擎中的锁"></a>2.InnoDB存储引擎中的锁</h4><p>InnoDB存储引擎实现了两种标准的行级锁：</p><p>❑共享锁（S Lock）</p><p>❑排他锁（X Lock）</p><p>X锁与任何的锁都不兼容，而S锁仅和S锁兼容。<strong>需要特别注意的是，S和X锁都是行锁，兼容是指对同一记录（row）锁的兼容性情况。</strong></p><p>此外，InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，称之为意向锁。意向锁共有以下两种：</p><p>1）意向共享锁，事务想要查询一张表中某几行的时候</p><p>2）意向排他锁，事务想要修改一张表中某几行的时候</p><p>由于InnoDB存储引擎支持的是行级别的锁，因此<strong>意向锁不会阻塞除全表扫以外的任何请求</strong>(意向锁的作用：当进行全表扫描的时候，如果一条条的查询每一行是否存在锁，那么效率就太慢了，所以这个时候直接看这个表有没有意向锁即可，不需要一条条的遍历查询)。</p><h4 id="3-MVCC"><a href="#3-MVCC" class="headerlink" title="3.MVCC"></a>3.MVCC</h4><ul><li>MVCC的使用场景<ul><li>如果读取的行正在执行DELETE或UPDATE操作，这时该行会加一个X锁，但是为了提高并发性，读取操作不会因此去等待行上锁的释放。相反地，InnoDB存储引擎会去读取行的一个<strong>快照数据</strong>。之所以称其为非锁定读，因为不需要等待访问的行上X锁的释放。<strong>快照数据是指该行的之前版本的数据，该实现是通过undo段来完成。</strong>而undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销。</li></ul></li></ul><p>一个行记录可能有不止一个快照数据，一般称这种技术为行多版本技术。由此带来的并发控制，称之为多版本并发控制（MVCC）</p><ul><li>对于不同的事务隔离级别，读取不同的快照版本<ul><li>在READ COMMITTED事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。所以在该事务隔离级别下，违背了数据库的隔离性</li><li>在REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。</li></ul></li></ul><p>事务的隔离级别为REPEATABLE READ模式下，InnoDB存储引擎的SELECT操作使用一致性非锁定读。</p><p>但是在某些情况下，用户需要显式地对数据库读取操作进行加锁以保证数据逻辑的一致性。而这要求数据库支持加锁语句，即使是对于SELECT的只读操作。InnoDB存储引擎对于SELECT语句支持两种一致性的锁定读操作：</p><p>❑SELECT…FOR UPDATE</p><p>❑SELECT…LOCK IN SHARE MODE</p><p>SELECT…FOR UPDATE对读取的行记录加一个X锁，其他事务不能对已锁定的行加上任何锁。SELECT…LOCK IN SHARE MODE对读取的行记录加一个S锁，其他事务可以向被锁定的行加S锁，但是如果加X锁，则会被阻塞。</p><h4 id="4-自增长与锁"><a href="#4-自增长与锁" class="headerlink" title="4.自增长与锁"></a>4.<strong>自增长与锁</strong></h4><p>自增长在数据库中是非常常见的一种属性(例如主键自增)，插入操作会依据这个自增长的计数器值加1赋予自增长列。这个实现方式称做AUTO-INC Locking。这种锁其实是采用一种<strong>特殊的表锁机制</strong>，为了提高插入的性能，<strong>锁不是在一个事务完成后才释放，而是在完成对自增长值插入的SQL语句后立即释放，即只需保证自增长计数器的线程安全即可。</strong></p><p>虽然AUTO-INC Locking从一定程度上提高了并发插入的效率，但还是存在一些性能上的问题。首先，对于有自增长值的列的并发插入性能较差，事务必须等待前一个插入的完成（虽然不用等待事务的完成）。其次，对于大数据量的插入会影响插入的性能，因为另一个事务中的插入会被阻塞。</p><p>从MySQL 5.1.22版本开始，InnoDB存储引擎中提供了一种<strong>轻量级互斥量</strong>的自增长实现机制。InnoDB存储引擎提供了一个参数innodb_autoinc_lock_mode来控制自增长的模式，该参数的默认值为1。</p><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20240107214402343.png" class title="image-20240107214402343"><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20240107214414393.png" class title="image-20240107214414393"><p><strong>Statement-base Replication (SBR)</strong> ：就是记录sql语句在bin-log中，binlog 记录的是 <strong>SQL的原文。</strong>所以在该方式下，配置参数innodb_autoinc_lock_mode的值为2的话，会导致主从库中数据自增值不一致的情况</p><p>**Row-based Relication(RBR)**：mysql master将SQL语句分解为基于Row更改的语句并记录在bin-log中，也就是只记录哪条数据被修改了，修改成什么样。这样就可以保证主从的强一致性。</p><h4 id="5-锁的算法"><a href="#5-锁的算法" class="headerlink" title="5.锁的算法"></a>5.<strong>锁的算法</strong></h4><p><a href="https://www.bilibili.com/read/cv15138919/?spm_id_from=333.999.0.0">Mysql 锁的三种算法 - 哔哩哔哩 (bilibili.com)</a></p><p>InnoDB存储引擎有3种行锁的算法，其分别是：</p><p>❑Record Lock：单个行记录上的锁</p><p>❑Gap Lock：间隙锁，锁定一个范围，但不包含记录本身</p><p>❑Next-Key Lock∶Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身</p><p><strong>Record Lock总是会去锁住索引记录，如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB存储引擎会使用隐式的主键来进行锁定。</strong></p><p>Next-Key Locking技术，其设计的目的是为了支持一些不需要使用幻读和不可重复读的场景。<strong>当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围。</strong></p><ul><li><p>举例</p><ul><li><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20240107222440581.png" class title="image-20240107222440581"></li><li><p>如果此时执行 select * from z where a &#x3D; 5 for update. 因为a是主键，所以它是唯一的，所以只锁定第三行记录，添加 Record Lock。</p><p>如果此时执行 select * from z where b &#x3D; 3 for update.</p><p>对于辅助索引 b，因为不是唯一索引，Next-Key Locking技术加锁会锁定 辅助索引（1,3） 和 （3,6）。Record Lock 会锁定 主键 a &#x3D; 5的记录。因此效果上感觉锁定的是辅助索引的范围(1，6)</p></li></ul></li></ul><blockquote><p>在RC中，只会对索引增加Record Lock，不会添加Gap Lock和Next-Key Lock。<br>在RR中，为了解决幻读的问题，在支持Record Lock的同时还支持Gap Lock和Next-Key Lock;</p></blockquote><ul><li><p>用户可以通过以下两种方式来显式地关闭Gap Lock：</p><p>❑将事务的隔离级别设置为READ COMMITTED (RR 模式下使用的是 next key locking，RC 模式下使用的是 Gap Lock<em>外键约束和唯一性检查</em>)</p><p>❑将参数innodb_locks_unsafe_for_binlog设置为1</p><p>在上述的配置下，除了外键约束和唯一性检查依然需要的Gap Lock，其余情况仅使用Record Lock进行锁定。</p></li></ul><h4 id="6-脏读"><a href="#6-脏读" class="headerlink" title="6.脏读"></a>6.脏读</h4><p>脏读指当前事务可以读到另外事务未提交的数据，简单来说就是可以读到脏数据。脏读发生的条件是需要<strong>事务的隔离级别为READ</strong> <strong>UNCOMMITTED</strong>，而目前绝大部分的数据库都至少设置成READ COMMITTED。InnoDB存储引擎默认的事务隔离级别为READ REPEATABLE</p><h4 id="7-幻读"><a href="#7-幻读" class="headerlink" title="7.幻读"></a>7.幻读</h4><p>幻读指同一个事物执行两次相同的查询，第一次查询的结果数量与第二次查询的<strong>结果数量不一致</strong>。</p><p><strong>幻读现象只存在于 Read Commited事物隔离级别下。</strong></p><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20240108204915723.png" class title="image-20240108204915723"><p>一般来说，幻读的问题是可以接受的，因为其读到的是已经提交的数据，本身并不会带来很大的问题。</p><p>在InnoDB存储引擎中，通过使用Next-Key Lock算法来避免幻读现象的，如果插入语句要插入的位置被查询语句锁定，那么此时插入事务会被阻塞，直到查询事务结束。</p><h4 id="8-不可重复读"><a href="#8-不可重复读" class="headerlink" title="8.不可重复读"></a>8.不可重复读</h4><p>不可重复读指同一个事物执行两次相同的查询，第一次查询的结果的值与第二次查询的<strong>结果的值不一致</strong>。</p><p><strong>不可重复读问题只存在于 Read Commited事物隔离级别下。</strong></p><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20240108205421939.png" class title="image-20240108205421939"><p>不可重复读的问题是可以接受的，因为其读到的是已经提交的数据，本身并不会带来很大的问题。</p><p>在InnoDB存储引擎中，通过使用Next-Key Lock算法来避免不可重复读的问题。</p><h4 id="9-死锁"><a href="#9-死锁" class="headerlink" title="9.死锁"></a>9.<strong>死锁</strong></h4><p>数据库有些时刻一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源，这就是阻塞。</p><p>阻塞并不是一件坏事，其是为了确保事务可以并发且正常地运行。</p><p>死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。若无外力作用，事务都将无法推进下去。</p><ul><li>数据库避免死锁发生的两个方式</li></ul><ol><li>在InnoDB存储引擎中，参数innodb_lock_wait_timeout用来控制等待的时间（默认是50秒），innodb_rollback_on_timeout用来设定是否在等待超时时对进行中的事务进行回滚操作（默认是OFF，代表不回滚）。</li><li>数据库还都普遍采用<strong>等待图的方式来进行死锁检测</strong>。较之超时的解决方案，这是一种更为主动的死锁检测方式。InnoDB存储引擎也采用的这种方式。等待图要求数据库保存以下两种信息：<ul><li>锁的信息链表：每行上有哪些事务要对改行进行加锁</li><li>事务等待链表：每个事务正在等待哪个事务持有的锁</li><li><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20240108210653715.png" class title="image-20240108210653715"></li></ul></li></ol><p>在每个事务请求锁并发生等待时都会判断是否存在回路，通过右图可以发现，t1和t2存在相互等待的情况，所以可能会出现死锁，这时通常来说InnoDB存储引擎选择回滚undo量最小的事务。</p><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20240108211244558.png" class title="image-20240108211244558"><p>在上面操作中，会话B中的事务抛出了1213这个错误提示，即表示事务发生了死锁。</p><p>发现死锁后，InnoDB存储引擎会马上回滚一个事务，会话A中马上得到了记录为2的这个资源，这其实是因为会话B中的事务发生了回滚，否则会话A中的事务是不可能得到该资源的。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="1-事务概述"><a href="#1-事务概述" class="headerlink" title="1.事务概述"></a>1.事务概述</h4><p>事物的四大特性：ACID。</p><p>❑原子性（atomicity）：事务可由一条非常简单的SQL语句组成，也可以由一组复杂的SQL语句组成。事务是访问并更新数据库中各种数据项的一个单元。在事务中的操作，要么全部成功，要么全部失败，这就是事务的目的。</p><p>❑一致性（consistency）：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏(例如主键约束)。</p><p>❑隔离性（isolation）：每个读写事务之间能够相互隔离，即该事务提交前对其他事务都不可见</p><p>❑持久性（durability）： 事务一旦提交，其结果就是永久性的。Mysql的持久存储是基于磁盘的</p><p>理论上说，事务有着极其严格的定义，它必须同时满足四个特性，即通常所说的事务的ACID特性。值得注意的是，虽然理论上定义了严格的事务要求，但是数据库厂商出于各种目的，并没有严格去满足事务的ACID标准。</p><ul><li>redo log称为重做日志，用来保证事务的原子性和持久性。</li><li>undo log用来保证事务的一致性。</li><li>锁用来保证事物的隔离性。</li></ul><h4 id="2-Redo-Log与Bin-Log"><a href="#2-Redo-Log与Bin-Log" class="headerlink" title="2.Redo Log与Bin Log"></a>2.<strong>Redo Log</strong>与<strong>Bin Log</strong></h4><p>redo log称为重做日志，用来保证事务的原子性和持久性。其由两部分组成：一是内存中的重做日志缓冲，其是易失的；二是重做日志文件，其是持久的。</p><p>当InnoDB是事务的存储引擎，当事务提交时，必须先将该事务的<strong>所有日志写入到重做日志文件</strong>进行持久化。这里的日志是指重做日志，在InnoDB存储引擎中，由两部分组成，即redo log和undo log。redo log用来保证事务的持久性，undo log用来帮助事务回滚及MVCC的功能。</p><p>每次将重做日志缓冲写入重做日志文件，在InnoDB存储引擎都需要调用一次fsync操作。fsync的效率取决于磁盘的性能，因此磁盘的性能决定了事务提交的性能，也就是数据库的性能。</p><ul><li>参数innodb_flush_log_at_trx_commit用来控制重做日志刷新到磁盘的策略。该参数的默认值为1，表示事务提交时必须调用一次fsync操作。还可以设置该参数的值为0和2。<ul><li>0表示事务提交时不进行写入重做日志操作，写入重做日志文件仅在master thread中完成，而在master thread中每1秒会进行一次fsync操作。</li><li>2表示事务提交时将重做日志写入重做日志文件，但仅写入<strong>文件系统(OS 操作系统)的缓存中，不进行fsync操作。</strong>在这个设置下，当MySQL数据库发生宕机而操作系统不发生宕机时，并不会导致事务的丢失。而当操作系统宕机时，重启数据库后会丢失未从文件系统缓存刷新到重做日志文件那部分事务。</li></ul></li></ul><p>对于刷新磁盘策略，大部分企业会选择默认参数。同时为了提高性能，减少 fsync的发生，可以将多个操作放到同一事务中，也就是采用批量提交。</p><hr><ul><li><strong>Redo Log与Bin Log的区别</strong></li></ul><p>首先，<strong>两种日志产生位置不同</strong>，重做日志是在InnoDB存储引擎层产生，而二进制日志是在MySQL数据库的上层产生的，所以MySQL数据库中的任何存储引擎对于数据库的更改都会产生二进制日志。</p><p>其次，<strong>两种日志记录的内容形式不同</strong>。MySQL数据库上层的二进制日志是一种逻辑日志，其记录的是对应的SQL语句。而InnoDB存储引擎层面的重做日志记录的是对于每个页的修改。</p><p>此外，<strong>两种日志记录写入磁盘的时间点不同</strong>。二进制日志只在事务提交完成后进行一次写入。而InnoDB存储引擎的重做日志在事务进行中不断地被写入。</p><h4 id="3-Undo-Log"><a href="#3-Undo-Log" class="headerlink" title="3.Undo Log"></a>3.Undo Log</h4><p>InnoDB存储引擎会产生一定量的undo 信息。这样如果用户执行的事务或语句由于某种原因失败了，又或者用户用一条ROLLBACK语句请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。</p><p>redo存放在重做日志文件中，与redo不同，undo存放在数据库内部的一个特殊段（segment）中，叫做undo段。undo段位于共享表空间内。</p><p>undo是逻辑日志(逻辑日志记录的是sql语句，物理日志记录的是数据页变化)，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同(例如：由于并发插入，页的offset发生变化)。</p><p>除了回滚操作，undo的另一个作用是MVCC。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。</p><p>最后也是最为重要的一点是，undo log所包含的相关增删改操作会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。</p><h4 id="4-purge"><a href="#4-purge" class="headerlink" title="4.purge"></a>4.purge</h4><p>purge用于判断delete和update操作是否能够最终执行。这样设计是因为InnoDB存储引擎支持MVCC，所以delete和update操作不能在事务提交时立即进行处理，因为这时其他事物可能正在引用要操作的数据行。而是否可以删除该条记录通过purge来进行判断。若该行记录已不被任何其他事务引用，那么就可以进行真正的delete操作。</p><p>InnoDB存储引擎有一个history列表，按事务提交的顺序存放每个事务，记录事务中没有执行的delete和update操作，这些操作记录到undo 页中。</p><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20240109205823964.png" class title="image-20240109205823964"><p>InnoDB存储引擎首先从history list中找到第一个需要被执行的记录，这里为trx1，执行之后InnoDB存储引擎会在trx1的undo log所在的页中继续寻找是否存在可以被执行的记录，接着找到trx2所在的页，然后依次再把trx2所在的undo页中要执行的记录进行判断。这样做的好处是避免大量的相同的undo页从磁盘反复读取到内存，从而提高purge的效率。</p><h4 id="5-group-commit"><a href="#5-group-commit" class="headerlink" title="5.group commit"></a>5.group commit</h4><p>为了提高磁盘fsync的效率，当前数据库都提供了group commit的功能，即**一次fsync可以刷新确保多个事务日志被写入文件(区别于程序员的优化方式，程序员为了提高效率减少fsync的发生次数，把多个操作放到同一个事务从而提高性能，而group commit则是把多个事务只进行一次fsync)**。</p><p>对于InnoDB存储引擎来说，事务提交时会进行两个操作：</p><p>1）修改事务对应的数据信息，并且将日志写入重做日志缓冲。</p><p>2）调用fsync将确保日志都从重做日志缓冲写入磁盘。</p><ul><li><p>在InnoDB1.2版本之前，在开启二进制日志后，InnoDB存储引擎的group commit功能会失效，从而导致性能的下降的原因？</p><p>导致这个问题的原因是在开启二进制日志后，为了保证存储引擎层中的事务所产生的日志和二进制日志(mysql数据库上层产生)的一致性，二者之间使用了两阶段事务，其步骤如下：</p><p>1）当事务提交时InnoDB存储引擎进行一些准备操作。</p><p>2）MySQL数据库上层写入二进制日志。</p><p>3）InnoDB存储引擎层将日志写入重做日志文件。</p><p>​ a）修改事务对应数据的信息，并且将日志写入重做日志缓冲。</p><p>​ b）调用fsync将确保日志都从重做日志缓冲写入磁盘。</p><p><strong>一旦步骤2）中的操作完成，就确保了事务的提交</strong>，即使在执行步骤3）时数据库发生了宕机。但是此时的重做日志和二进制日志已经不一致了。为了保证MySQL数据库上层二进制日志的写入顺序和InnoDB层的重做日志一致，MySQL数据库内部使用了prepare_commit_mutex这个锁。但是在启用这个锁之后，步骤3）中的步骤a）和步骤b）不能分开执行，从而导致了group commit失效。</p></li><li><p>mysql5.6以后的解决方案</p><ul><li><p>在MySQL数据库上层进行提交时首先按顺序将事务放入一个队列中</p></li><li><p>将每个事务在mysql上层产生的二进制日志写入内存中。</p></li></ul></li><li><p>将内存中的二进制日志刷新到磁盘，若队列中有多个事务，那么仅一次fsync操作就完成了二进制日志的写入。</p><ul><li>队列中的第一个事务根据顺序调用存储引擎层事务的提交(真正执行数据的操作)，InnoDB存储引擎本就支持group commit，因此修复了原先由于锁prepare_commit_mutex导致group commit失效的问题。</li></ul></li></ul><h4 id="6-事务的隔离级别"><a href="#6-事务的隔离级别" class="headerlink" title="6.事务的隔离级别"></a>6.事务的隔离级别</h4><p>SQL标准定义的四个隔离级别为：</p><p>❑READ UNCOMMITTED</p><p>❑READ COMMITTED</p><p>❑REPEATABLE READ</p><p>❑SERIALIZABLE</p><p>隔离级别越低，事务请求的锁越少。</p><p>❑在SERIALIABLE的事务隔离级别，InnoDB存储引擎会对每个SELECT语句后自动加上LOCK IN SHARE MODE，即为每个读取操作加一个共享锁。因此在这个事务隔离级别下，不支持MVCC。</p><p>❑InnoDB存储引擎默认支持的隔离级别是REPEATABLE READ，InnoDB存储引擎在REPEATABLE READ事务隔离级别下，使用Next-Key Lock锁的算法</p><p>❑在READ COMMITTED的事务隔离级别下，除了唯一性的约束检查及外键约束的检查需要gap lock，InnoDB存储引擎不会使用gap lock的锁算法。MVCC 控制读取最新版本快照</p><h4 id="7-分布式事务"><a href="#7-分布式事务" class="headerlink" title="7.分布式事务"></a>7.分布式事务</h4><p>分布式事务就是要在分布式系统中实现事务。分布式事务指的是允许多个独立的事务资源（数据库）参与到一个全局的事务中。全局事务要求在其中的所有参与的事务<strong>要么都提交，要么都回滚</strong>。</p><p>分布式事务由一个或多个资源管理器、一个事务管理器以及一个应用程序组成。</p><p>❑资源管理器：提供访问事务资源的方法。通常一个数据库就是一个资源管理器。</p><p>❑事务管理器：协调参与全局事务中的各个事务。MySQL数据库事务管理器中就是连接MySQL服务器的客户端。</p><p>❑应用程序：全局事务中的操作。</p><ul><li><p>2PC</p><p>使用两段式提交的方式。在第一阶段，所有参与全局事务的数据库节点都开始准备，告诉事务管理器它们准备好提交了。在第二阶段，事务管理器告诉资源管理器执行ROLLBACK还是COMMIT。如果任何一个节点显示不能提交，则所有的节点都被告知需要回滚。</p></li><li><p>TCC</p><p>TCC 是 Try、Confirm、Cancel 三个词语的缩写，TCC 要求每个分支事务实现三个操作：预处理 Try、确认 Confirm、撤销 Cancel。Try 操作做业务检查及资源预留，Confirm 做业务确认操作，Cancel 实现一个与 Try 相反的操作即回滚操作。</p><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20240109220841664.png" class title="image-20240109220841664"><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20240109220905850.png" class title="image-20240109220905850"></li></ul><h4 id="8-XA内部事务"><a href="#8-XA内部事务" class="headerlink" title="8.XA内部事务"></a>8.XA内部事务</h4><p>最为常见的内部XA事务存在于binlog与InnoDB存储引擎之间。由于复制的需要，因此目前绝大多数的数据库都开启了binlog功能。在事务提交时，先写二进制日志，再写InnoDB存储引擎的重做日志。对上述两个操作的要求也是原子的，即二进制日志和重做日志必须同时写入。若二进制日志先写了，而在写入InnoDB存储引擎时发生了宕机，那么slave可能会接收到master传过去的二进制日志并执行，最终导致了主从不一致的情况。</p><p>为了解决这个问题，MySQL数据库在binlog与InnoDB存储引擎之间采用XA事务。当事务提交时，InnoDB存储引擎会先做一个准备操作，将事务的xid写入，接着进行二进制日志的写入。如果在InnoDB存储引擎提交前，MySQL数据库宕机了，那么MySQL数据库在重启后会先检查准备的UXID事务是否已经提交，若没有，则在存储引擎层再进行一次提交操作。</p><h3 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h3><h4 id="1-备份的分类"><a href="#1-备份的分类" class="headerlink" title="1.备份的分类"></a>1.备份的分类</h4><ul><li><p>根据备份的方法不同可以将备份分为：</p><p>❑Hot Backup（热备）： 指数据库运行中直接备份，对正在运行的数据库操作没有任何的影响</p><p>❑Cold Backup（冷备）：备份操作是在数据库停止的情况下，这种备份最为简单，一般只需要复制相关的数据库物理文件即可</p><p>❑Warm Backup（温备） ：在数据库运行中进行的，但是加了一个全局读锁以保证备份数据的一致性</p></li><li><p>按照备份后文件的内容，备份又可以分为：</p><p>❑逻辑备份 一般是由一条条SQL语句，或者是表内实际数据组成。</p><p>❑裸文件备份 直接复制数据库的物理文件，既可以是在数据库运行中的复制，也可以是在数据库停止运行时直接的数据文件复制。这类备份的恢复时间往往较逻辑备份短很多。</p></li><li><p>若按照备份数据库的内容来分，备份又可以分为：</p><p>❑完全备份</p><p>❑增量备份</p><p>❑日志备份 （bin log）</p></li></ul><h4 id="2-热备"><a href="#2-热备" class="headerlink" title="2.热备"></a>2.热备</h4><ul><li><p>通常使用XtraBackup对数据进行热备份，其工作原理如下：</p><p>1）记录备份开始时，记录InnoDB存储引擎重做日志文件的检查点。</p><p>2）复制共享表空间文件以及独立表空间文件。</p><p>3）复制完表空间文件后，InnoDB存储引擎再次检查重做日志文件的检查点。</p><p>4）复制在备份时产生的重做日志。</p><p>可以发现，在备份期间不会对数据库本身有任何影响，所做的操作只是复制数据库文件，因此任何对数据库的操作都是允许的，不会阻塞任何操作。故XtraBackup的优点如下：</p><p>❑在线备份，不阻塞任何的SQL语句。</p><p>❑备份性能好，备份的实质是复制数据库文件和重做日志文件。</p><p>❑支持压缩备份，通过选项，可以支持不同级别的压缩。</p><p>❑跨平台支持，ibbackup可以运行在Linux、Windows以及主流的UNIX系统平台上。</p></li></ul><ul><li><p>XtraBackup对InnoDB存储引擎表的恢复步骤为：</p><p>❑恢复表空间文件。</p><p>❑应用重做日志文件。</p></li><li><p>XtraBackup增量备份工作原理：</p><p>1）首选完成一个全备，并记录下此时检查点的LSN。</p><p>2）在进行增量备份时，比较表空间中每个页的LSN是否大于上次备份时的LSN，如果是，则备份该页，同时记录当前检查点的LSN。</p></li></ul><h4 id="3-冷备"><a href="#3-冷备" class="headerlink" title="3.冷备"></a>3.冷备</h4><p>对于InnoDB存储引擎的冷备非常简单，只需要备份MySQL数据库的frm文件，共享表空间文件，独立表空间文件（*.ibd），重做日志文件。</p><ul><li><p>冷备的优点是：</p><p>❑备份简单，只要复制相关文件即可。</p><p>❑备份文件易于在不同操作系统，不同MySQL版本上进行恢复。</p><p>❑恢复相当简单，只需要把文件恢复到指定位置即可。</p><p>❑恢复速度快，不需要执行任何SQL语句，也不需要重建索引。</p></li><li><p>冷备的缺点是：</p><p>❑InnoDB存储引擎冷备的文件通常比逻辑文件大很多，因为表空间中存放着很多其他的数据，如undo段，插入缓冲等信息。</p><p>❑冷备也不总是可以轻易地跨平台。操作系统、MySQL的版本、文件大小写敏感和浮点数格式都会成为问题。</p></li></ul><h4 id="4-主从复制的工作原理"><a href="#4-主从复制的工作原理" class="headerlink" title="4.主从复制的工作原理"></a>4.主从复制的工作原理</h4><ul><li><p>主从复制的工作原理分为以下3个步骤：</p><p>1）主服务器（master）把数据更改记录到二进制日志（binlog）中。</p><p>2）从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中。</p><p>3）从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性。</p><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20240109224355672.png" class title="image-20240109224355672"></li></ul><p><strong>从服务器有2个线程，一个是I&#x2F;O线程，负责读取主服务器的二进制日志，并将其保存为中继日志；另一个是SQL线程，执行中继日志。</strong></p><hr><ul><li>为什么MySQL数据库在RC的事务隔离级别下，把binlog的format参数配置为STATEMENT的时候会出现主从不一致的现象，为什么RR的隔离级别又可以解决这个问题？<ul><li><img src="/2023/12/26/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20240117163556638.png" class title="image-20240117163556638"></li><li><strong>因为format参数配置为STATEMENT的时候记录的是sql语句而导致的问题</strong>。如上图所示，在RC模式下，数据库中会保留事务2插入的数据，但是由于事务2先提交，所以这两个操作在binlog是先记录的事务2的操作后记录事务1的操作，这样就会导致binlog传输到从服务器的时候出现主从不一致的现象，但是RR模式下，事务1在执行操作的时候，会锁定b的范围在(-∞，100]，所以事务在插入的时候会被阻塞，直到事务1提交，所以不会出现主从不一致</li><li>但是在MySQL5.0之前，binlog的format参数只能配置为STATEMENT，所以这时把事务隔离级别默认设置为RR是一个无奈之举</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Redis设计与实现》阅读笔记</title>
      <link href="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis底层结构"><a href="#Redis底层结构" class="headerlink" title="Redis底层结构"></a>Redis底层结构</h3><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231219140159312.png" class title="image-20231219140159312"><h4 id="1-简单动态字符串"><a href="#1-简单动态字符串" class="headerlink" title="1.简单动态字符串"></a>1.简单动态字符串</h4><ul><li><p>简介</p><p>Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组），而是自己构建了一种名为简单动态字符串SDS的抽象类型（对象）作为Redis的默认字符串表示。</p><p>当你执行，redis&gt; SET msg “hello world”，(msg 作为key，他有自己的保存位置，字符串字面量；”hello world” 作为value，也要进行保存了。) Redis将在数据库中创建一个新的键值对，其中：</p><ul><li><p>键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串“msg”的SDS。</p></li><li><p>键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串“hello world”的SDS。</p></li></ul><p>又比如，如果执行命令：</p><p>redis&gt; RPUSH fruits “apple” “banana” “cherry”，那么Redis将在数据库中创建一个新的键值对，其中：</p><ul><li><p>键值对的键是一个字符串对象，对象的底层实现是一个保存了字符串“fruits”的SDS。</p></li><li><p>键值对的值是一个列表对象，列表对象包含了三个字符串对象，这三个字符串对象分别由三个SDS实现：第一个SDS保存着字符串“apple”，第二个SDS保存着字符串“banana”，第三个SDS保存着字符串“cherry”。</p></li></ul><p>除了用来保存数据库中的字符串值之外，SDS还被用作缓冲区：AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区，都是由SDS实现的，在AOF持久化和客户端状态模块详解。</p></li><li><p>SDS定义</p><ul><li><pre><code class="c">struct sdshdr &#123;  //SDS所保存字符串的长度  int len;  // 记录buf数组中未使用字节的数量  int free;  // 字节数组，用于保存字符串 char buf[];&#125;;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - set msg “hello world”</span><br><span class="line"></span><br><span class="line">    对于 msg 来说，他的 sdshdr 这个对象的</span><br><span class="line"></span><br><span class="line">    值是： len=3； free=3；buf[]= [‘m’, ‘s’, ‘g’,‘\0’]</span><br><span class="line"></span><br><span class="line">    buf属性是一个char类型的数组，数组的前三个字节分别保存了‘m’, ‘s’, ‘g’三个字符，而最后一个字节则保存了**空字符&#x27;\0&#x27;**。</span><br><span class="line">  </span><br><span class="line">* 使用SDS好处</span><br><span class="line"></span><br><span class="line">  1. C 语言的字符串如果想要得到他的长度，需要进行遍历，意味着时间复杂度为 o(N)。如果使用sds，我们的长度直接从len属性里获取，时间复杂度o(1). </span><br><span class="line">  2. C语言的字符串进行 扩展 或者 缩减的时候： </span><br><span class="line">     - 进行扩展：我们必须要提前分配内存空间，一旦忘了分配，造成缓冲区溢出；</span><br><span class="line">     - 进行缩减：必须要有意识的进行空间的释放，否则造成空间浪费。</span><br><span class="line">     - 无论是进行扩展还是缩减，都需要进行内存的重新分配，会造成额外的耗时。 SDS 来说，他不会造成缓冲区溢出的问题，是封装好的对象，他已经为我们考虑了这部分内存的扩展及缩减问题。</span><br><span class="line">  3. len属性解决了获取长度时的时间复杂度的问题，free则是一个非常有效的空间属性。</span><br><span class="line">     - 当创建sds 对象的时候，如 msg，他的 free 空间也会分配与当前的字符串相同大小的空间； len=3； free=3；buf[]= [‘m’, ‘s’, ‘g’,‘\0’]； 这部分free 之所以分配了 3 个长度的空间，是预防我们进行字符串的扩展，扩展的时候可以直接使用，而无需进行控减分配，我们称之为 **空间预分配；**</span><br><span class="line">     - 如果我存储的字符串，是一个超过 1M 的字符串，比如说 20 M，那么free 就分配1M，只有字符串大小不超过1M才分配与 len相同的值。</span><br><span class="line">     - 当字符串进行缩减，如果msg 缩减为 m。len = 1； free = 5；buf[]= [‘m’,‘\0’]。将这种设计，称之为 **惰性空间释放**</span><br><span class="line">  4. 二进制安全问题。C 语言来说，他的字符串是二进制不安全的，因为**C语言的 空字符 结尾的设计，如果一个字符串中间有空字符串，那么 c语言的字符串的二进制转化会遗弃第一个空字符出现的后边的所有内容**。 举例：m \0 s g \0. 如果是 C语言进行二进制转化，只对 m 进行转化；而SDS是自己封装的对象，我们能支持二进制的安全转化。</span><br><span class="line">  5. C语言的空字符结尾有二进制问题，为什么 SDS 的 buf 里边还是以 空字符结尾呢？ </span><br><span class="line">     - 因为SDS 毕竟是基于C 语言，也需要使用 C语言中字符串的一些方法，所以为了兼容一部分C 语言中字符串的操作，所以以空字符结尾。</span><br><span class="line">#### 2.链表（list、列表结构）</span><br><span class="line">列表的底层实现就是一个链表，链表中的每个节点都保存了一个数值。</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">//列表</span><br><span class="line">typedef struct list &#123;</span><br><span class="line">    // 表头节点</span><br><span class="line">    listNode * head;</span><br><span class="line">    // 表尾节点</span><br><span class="line">    listNode * tail;</span><br><span class="line">    // 链表所包含的节点数量</span><br><span class="line">    unsigned long len;</span><br><span class="line">// 节点值复制函数</span><br><span class="line">    void *(*dup)(void *ptr);</span><br><span class="line">    // 节点值释放函数</span><br><span class="line">    void (*free)(void *ptr);</span><br><span class="line">    // 节点值对比函数</span><br><span class="line">    int (*match)(void *ptr,void *key);</span><br><span class="line">&#125; list;</span><br><span class="line">//链表</span><br><span class="line">typedef struct listNode &#123;</span><br><span class="line">    // 前置节点</span><br><span class="line">    struct listNode * prev;</span><br><span class="line">    // 后置节点</span><br><span class="line">    struct listNode * next;</span><br><span class="line">    // 节点的值</span><br><span class="line">    void * value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>如： <code>lpush list 0 1 2 &quot;hello&quot; &#39;a&#39;</code>,从左边往列表中加入五个元素，元素类型包括数字，字符串和字符。 list 就代表了我们的 typedef struct list  这个结构体，listNode  就是底层实现的 链表节点。</p><ul><li><p>为什么list中的节点值复制函数和节点值释放函数的返回值是 void？</p><ul><li>void 这里代表的是 <strong>多态</strong>。如果你在java里想复制一个值，如果不知道这个值的类型，要么你使用 object 。 对于 redis 来说，<strong>由于 list 里可以存放各种类型的数值，那么，如果你要进行多种类型值的一些统一操作的话，需要使用 void 的返回值类型</strong></li></ul></li><li><p><strong>列表，</strong> <strong>链表，字符串的关系示例</strong></p><ul><li><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231218164237120.png" class title="image-20231218164237120"></li><li><p>list 这个东西，就是列表（源码是 list）；他的底层是现是链表（源码是 listNode： pre、next、val）</p><p>第一个 SDS : 是给我们的 list 准备的， free &#x3D; 4； len &#x3D; 4； buf &#x3D; [‘l’,’i’,’s’,’t’,’\0’] ; 这是我们的列表的名称，列表的 key；</p><p>第二个SDS 是给 a 准备的，bc以此类推，其中abc保存到了listNode里面的<strong>void</strong> * value属性中了，void也是可以存放任何类型元素的意思</p></li></ul></li></ul><h4 id="3-字典"><a href="#3-字典" class="headerlink" title="3.字典"></a>3.字典</h4><p>Redis的字典使用哈希表作为底层实现，一个哈希表（dictht）里面可以有多个哈希表节点（dictEntry ），而每个哈希表节点（dictEntry ）就保存了字典中的一个键（ <code>void *key;</code>）值（<code>union&#123; void *val; uint64_tu64; int64_ts64;&#125; v;</code>）对。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表节点组成的数组</span></span><br><span class="line">    dictEntry **table; <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值 总是等于size-1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量（非null节点）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"><span class="comment">//哈希表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表 （解决hash 冲突，链地址法）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231218170159163.png" class title="image-20231218170159163"><p>字典，是基于哈希表的结构上，再次进行的一层封装。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字典</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表数组，包含两个 dictht</span></span><br><span class="line">    dictht ht[<span class="number">2</span>]; </span><br><span class="line">    <span class="comment">// rehash索引当rehash不在进行时，值为-1</span></span><br><span class="line">    <span class="type">int</span> rehashidx; </span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><ul><li>type属性是一个指向dictType结构的指针，<strong>每个dictType结构保存了用于操作特定类型键值对的函数</strong>，Redis会为用途不同的字典设置不同的类型特定函数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);</span><br></pre></td></tr></table></figure><ul><li>privdata属性则保存了需要传给那些类型特定函数的可选参数。</li></ul><p>简单来说，type和privdata为不同类型的键值对提供不同的方法保存点和不同的方法入参</p><ul><li><p>ht属性是一个包含两个哈希表的数组，数组中的每个项都是一个dictht哈希表，<strong>一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。</strong></p></li><li><p>rehashidx属性，它记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为-1。</p></li></ul><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231218172053859.png" class title="image-20231218172053859"><p>哈希算法</p><ul><li><p>当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值从而得到索引值</p><p>Redis计算哈希值和索引值的方法如下：</p><ol><li><p>还是否记得 dictType 里边的第一个 方法： </p><p> &#x2F;&#x2F; 计算哈希值的函数</p><p> int hashValue &#x3D; unsigned int (*hashFunction)(const void *key);</p></li><li><p>是否记得我们的 sizemask。</p><p>  最终的索引值 &#x3D; hashValue &amp; ht[x].sizemask。</p></li></ol><p>sizemask 出自 dictht（哈希表）。dict(字典)里有两个 dictht，ht[0] 和 ht[1]。你这边的 sizemask 是出自 ht0还是 ht1？如果是一般情况，没有 rehash的时候，取ht0. 如果正在进行rehash，那就取ht1</p></li><li><p>rehash的触发条件</p><ul><li><p>rehash的触发取决于负载因子<strong>load_factor &#x3D; ht[0].used &#x2F; ht[0].size</strong></p></li><li><p>收缩的时候，<strong>当哈希表的负载因子小于0.1时</strong>，程序自动开始对哈希表执行收缩操作。</p></li><li><p>扩展的时候</p><ul><li><p>服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。</p></li><li><p>服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。</p></li><li><p>根据BGSAVE命令或BGREWRITEAOF命令是否正在执行，扩展操作所需的负载因子并不相同，这是因为在执行BGSAVE命令或BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。</p></li></ul></li></ul></li><li><p>rehash的步骤</p><ol><li><p>为字典的dict.ht[1]哈希表分配空间</p><ul><li><p>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2的n次方幂；</p><p>例如：ht0 中 used &#x3D; 10；为ht1分配的大小是 32。因为2的4次方是 16， 2的 5次方是 32， 32 是第一个大于 20的并且是 2 的 n次幂的数字。</p></li><li><p>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2 n。</p><p>例如：ht0 中 used &#x3D; 10，16是第一个大于10的并且未 2的 n次幂的数字，所以此时 ht1的空间分配大小为 16.</p></li></ul></li><li><p>将保存在ht[0]中的所有键值对rehash到ht[1]上面。 </p><ul><li>rehash的计算步骤：dictType里边的第一个函数结果得到的哈希值 &amp; sizemask(sizemask为ht1分配空间以后的大小)</li></ul></li><li><p>当ht[0]包含的所有键值对都迁移到了ht[1]之后，释放ht[0]**，将ht[1]设置为ht[0]**，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。</p></li></ol></li><li><p>渐进式rehash</p><ul><li>如果哈希表是几百万、几千万甚至上亿个键值对，那么要一次性将这些键值对全部rehash到ht[1]的话，庞大的计算量可能会导致服务器在一段时间内停止服务。因此，为了避免rehash对服务器性能造成影响，服务器不是一次性将ht[0]里面的所有键值对全部rehash到ht[1]，而是分多次、渐进式地将ht[0]里面的键值对慢慢地rehash到ht[1]。</li><li>渐进式rehash步骤：<ol><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</li><li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</li><li>**在rehash进行期间，每次对字典执行添加、删除、查找或更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]**，每迁移完成一个索引位置的键值对，就需要在 rehashidx 上自增 </li><li>当ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。同时将ht1设为ht0，再重新创建一个空的 ht1备用。</li></ol></li></ul></li></ul><h4 id="4-跳跃表"><a href="#4-跳跃表" class="headerlink" title="4.跳跃表"></a>4.<strong>跳跃表</strong></h4><p>跳跃表是一种有序数据结构，它通过在每个节点中维持<strong>多个指向其他节点的指针</strong>，从而达到快速访问节点的目的。跳跃表支持平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231218182421446.png" class title="image-20231218182421446"><p>Redis使用跳跃表作为<strong>有序集合键</strong>的底层实现之一，如果一个有序集合<strong>包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时</strong>，Redis就会使用跳跃表来作为有序集合键的底层实现。Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外，跳跃表在Redis里面没有其他用途。</p><p>Redis的跳跃表由zskiplistNode和zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳跃表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 层,表示每个元素存储的最高高度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">    <span class="comment">// 后退指针，同一元素指向前一层(高层指向低层)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 分值，用于排序</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">// 成员对象，该节点存储的内容</span></span><br><span class="line">    robj *obj;</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，每次创建一个新跳跃表节点的时候，随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”；</li><li>每个层都有一个指向表尾方向的前进指针（level[i].forward属性），用于从表头向表尾方向访问节点(对于同一行)。</li><li>节点的后退指针（backward属性）用于从表尾向表头方向访问节点(对于同一列)</li></ul><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231218183534815.png" class title="image-20231218183534815"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳跃表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    structz skiplistNode *header, *tail;</span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><ul><li>保存跳跃表的头尾节点，可以通过这两个指针，可以以O（1）复杂度定位表头节点和表尾节点。通过使用length属性来记录节点的数量，程序可以在O（1）复杂度内返回跳跃表的长度。level属性则用于在O（1）复杂度内获取跳跃表中层高最大的那个节点的层数量(最好的情况是层数最高的节点在链表中间，这样一下就可以排除一般的节点)</li></ul><h4 id="5-压缩列表"><a href="#5-压缩列表" class="headerlink" title="5.压缩列表"></a>5.压缩列表</h4><p>压缩列表是列表和哈希的底层实现之一。当一个列表键<strong>只包含少量列表项或小整数值或比较短的字符串</strong>，那么Redis就会使用压缩列表来做列表键的底层实现。压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存<strong>一个字节数组</strong>或者<strong>一个整数值</strong>。</p><ul><li>压缩列表的整体组成</li></ul><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231219133008667.png" class title="image-20231219133008667"><ul><li>压缩列表中的节点</li></ul><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231219133438001.png" class title="image-20231219133438001"><ul><li>previous_entry_length属性以字节为单位，记录了压缩列表中前一个节点的长度。<strong>压缩列表的从表尾向表头遍历操作就是基于这个属性实现的。</strong>previous_entry_length属性占用空间可能是1字节或者5字节。如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节：前一节点的长度就保存在这一个字节里面。 ·如果前一节点的长度大于等于254字节，那么previous_entry_length属性占用5字节：其中属性的第一字节会被设置为0xFE（十进制值254），而之后的四个字节则用于保存前一节点的长度。现在我需要从列表的表尾向表头进行遍历，先通过zltail定位最后一个entry；拿到最后一个entry的previous_entry_length属性，从而定位到倒数第二个节点，以此类推。</li></ul><ul><li>encoding值的最高位为00、01或者10的是字节数组编码；值的最高位以11开头的是整数编码,后面的值表示具体内容的长度。</li></ul><ul><li>节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。</li></ul><p>连锁更新问题</p><ul><li><p>每个节点的<strong>previous_entry_length属性</strong>都记录了前一个节点的长度：</p><p><strong>如果前一节点的长度小于254字节，那么previous_entry_length属性需要用1字节长的空间来保存这个长度值。</strong></p><p><strong>如果前一节点的长度大于等于254字节，那么previous_entry_length属性需要用5字节长的空间来保存这个长度值。</strong></p><p>那么如果在一个压缩列表中，有多个连续的、长度介于250字节到253字节之间的节点e1至eN，如图：</p><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231219134700012.png" class title="image-20231219134700012"><p>因为e1至eN的所有节点的长度都小于254字节，所以e1至eN的所有节点的previous_entry_length属性都是1字节长的。这时，如果我们将一个长度大于等于254字节的新节点new设置为压缩列表的表头节点，那么所有节点的previous_entry_length属性都会更新</p><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231219134901848.png" class title="image-20231219134901848"><p>这种情况很极端，如果真的碰上了，算你倒霉。在Redis 7中连锁更新已经彻底解决</p></li></ul><h4 id="6-整数集合"><a href="#6-整数集合" class="headerlink" title="6.整数集合"></a>6.<strong>整数集合</strong></h4><p>整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现(如果集合中出现了字符串，那么Redis会使用HashTable进行保存)。整数集合（intset）是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p><strong>虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存任何int8_t类型的值，contents数组的真正类型取决于encoding属性的值：</strong></p><ul><li><p>如果encoding属性的值为INTSET_ENC_INT16，那么contents就是一个int16_t类型的数组，数组里的每个项都是介于-32768到32767的整数值。</p></li><li><p>如果encoding属性的值为INTSET_ENC_INT32，那么contents就是一个int32_t类型的数组，数组里的每个项都是介于-2147483648到2147483647的整数值。</p></li><li><p>如果encoding属性的值为INTSET_ENC_INT64，那么contents就是一个int64_t类型的数组，数组里的每个项都是介于-9223372036854775808到9223372036854775807的整数值。</p></li></ul><p><strong>整数集合</strong> <strong>-</strong> <strong>编码升级</strong></p><p>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后才能将新元素添加到整数集合里面。</p><p>升级整数集合并添加新元素共分为三步：</p><ol><li><p>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</p></li><li><p>将底层数组现有的<strong>所有元素都转换成与新元素相同的类型</strong>，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变。</p></li><li><p>将新元素添加到底层数组里面。</p></li></ol><p><strong>注意： 整数集合 没有降级一说，不会发生任何降级。</strong></p><h4 id="7-对象的类型与编码"><a href="#7-对象的类型与编码" class="headerlink" title="7.对象的类型与编码"></a>7.<strong>对象的类型与编码</strong></h4><p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。</p><p>Redis中的每个对象(数据结构)都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针,这些数据结构由对象的encoding属性决定。</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><ul><li><p>type属性指向不同的数据类型</p><ul><li><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231219142920338.png" class title="image-20231219142920338"></li></ul></li><li><p>encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现，这个属性的值可以是</p><ul><li><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231219143024716.png" class title="image-20231219143024716"></li></ul></li><li><p>每种类型的对象（redis里边的 5种数据结构：string，list，hash，set，zset）都至少使用了两种不同的编码</p><ul><li><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231219143103673.png" class title="image-20231219143103673"></li></ul></li><li><p>根据值的类型的不同选择不同的底层实现</p><ul><li><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231219143423694.png" class title="image-20231219143423694"></li></ul></li></ul><h4 id="8-字符串对象"><a href="#8-字符串对象" class="headerlink" title="8.字符串对象"></a>8.<strong>字符串对象</strong></h4><p>字符串对象的编码可以是int、raw或者embstr。</p><ul><li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。</li><li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值。</li></ul><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231219145135971.png" class title="image-20231219145135971"><p>保存浮点类型的数字的时候： </p><ol><li>会按照字符的形式进行存储，emb或者raw的编码；</li><li>如果进行加减，需要注意精度问题，加减的时候会自动转化为long double类型数字，保存的时候又转化为embstr或者 raw。</li></ol><p>字符串对象的 encoding 转化问题：</p><ol><li><p>int和 raw可以通过append命令进行转化，通过incrby进行回转；</p></li><li><p>int 和 embstr 可以通过 incrbyfloat 进行转化，在一定条件下(incrbyfloat命令调用后的值仍为整数)可以通过incrby进行回转int。</p></li></ol><p><strong>redis之所以这么做，是为了使用者的一个方便性，可以不用来回的去转化对象，redis自己的命令就做了。</strong></p><h4 id="9-列表对象"><a href="#9-列表对象" class="headerlink" title="9.列表对象"></a>9.列表对象</h4><p><strong>列表对象的编码可以是ziplist或者linkedlist。</strong></p><p>当列表对象可以<strong>同时满足</strong>以下两个条件时，列表对象使用ziplist编码：</p><ul><li><p>列表对象保存的所有字符串元素的长度都小于64字节；</p></li><li><p>列表对象保存的元素数量小于512个；</p></li></ul><p>不能满足这两个条件的列表对象需要使用linkedlist编码。</p><p>以上两个条件的上限值是可以修改的，配置文件中关于list-max-ziplist-value选项和list-max-ziplist-entries选项。</p><ul><li>ziplist和 linkedlist的区别</li></ul><ol><li><p>ziplist 他是一个紧凑的顺序型的存储，所占用的空间量相比较于 linkedlist 是很小的，所以ziplist 他是可以节省空间的；</p></li><li><p>linkedlist 是一个 双端的链表，他们是通过指针进行的联系，内存分布式不均匀的。</p></li></ol><ul><li>可以不可以将list-max-ziplist-value参数和list-max-ziplist-entries参数调整的很大？<ul><li>不可以的，虽然ziplist有明显的空间优势，<strong>但是ziplist 存在我们的压缩、解压缩的耗时，而且ziplist存在连锁更新问题。</strong>如果真的为了节约有限的 redis 存储，可以适当调整，但是要进行压测。</li></ul></li></ul><h4 id="10-哈希对象"><a href="#10-哈希对象" class="headerlink" title="10.哈希对象"></a>10.哈希对象</h4><p><strong>哈希对象的编码可以是ziplist或者hashtable。</strong></p><p>使用ziplist编码的时候，每当有新的键值对要加入到哈希对象时，程序会<strong>先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾</strong>，因此：保存了同一键值对的两个节点总是<strong>紧挨在一起</strong>，保存键的节点在前，保存值的节点在后；</p><p>举个例子，如果我们执行以下HSET命令，那么服务器将创建一个名为profile的列表对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET profile name &quot;Tom&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">redis&gt; HSET profile age 25</span><br><span class="line">(integer) 1</span><br><span class="line">redis&gt; HSET profile career &quot;Programmer&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231219151009696.png" class title="image-20231219151009696"><p>如果前面profile创建的不是ziplist编码的哈希对象，而是hashtable编码的哈希对象，那么这个哈希对象应该会是图</p><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231219151157508.png" class title="image-20231219151157508"><p>当哈希对象可以<strong>同时满足</strong>以下两个条件时，哈希对象使用ziplist编码：</p><ul><li><p>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；</p></li><li><p>哈希对象保存的键值对数量小于512个；</p></li></ul><p>不能满足这两个条件的哈希对象需要使用hashtable编码。</p><p>这两个条件的上限值是可以通过hash-max-ziplist-value参数和hash-max-ziplist-entries参数修改的</p><h4 id="11-集合对象"><a href="#11-集合对象" class="headerlink" title="11.集合对象"></a>11.集合对象</h4><p><strong>集合对象的编码可以是intset或者hashtable。</strong></p><p>当集合对象可以同时满足以下两个条件时，对象使用<strong>intset</strong>编码：</p><ul><li><p>集合对象保存的所有元素都是整数值；</p></li><li><p>集合对象保存的元素数量不超过512个。</p></li></ul><p>第二个条件的上限值是可以修改的，配置文件中关于set-max-intset-entries选项</p><ul><li><p>intset编码存储结构</p><p>-<img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231219152139826.png" class title="image-20231219152139826"></p></li><li><p>hashtable编码存储结构</p><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231219152226990.png" class title="image-20231219152226990"></li></ul><h4 id="12-有序集合对象"><a href="#12-有序集合对象" class="headerlink" title="12.有序集合对象"></a>12.<strong>有序集合对象</strong></h4><p><strong>有序集合的编码可以是ziplist或者skiplist。</strong></p><p>当有序集合对象可以<strong>同时满足</strong>以下两个条件时，对象使用<strong>ziplist</strong>编码：</p><ul><li><p>有序集合保存的元素数量小于128个；</p></li><li><p>有序集合保存的所有元素成员的长度都小于64字节；</p></li></ul><p>不能满足以上两个条件的有序集合对象将使用skiplist编码。</p><p>以上两个条件的上限值是可以修改的，配置文件中关于zset-max-ziplist-entries选项和zset-max-ziplist-value选项</p><p><strong>之所以元素数量限制在 128， 是为了让我们的有序集合尽快的使用 skiplist，因为skiplist性能是接近二分查找到。</strong></p><ul><li>skiplist更快，为什么不直接吧 ziplist 从 有序集合里移除呢？ <ul><li>128个以内的这些值，即便是使用跳表，也体现不出什么性能，而且还会占用更为多的空间，逻辑复杂，得不偿失；</li></ul></li></ul><h4 id="13-对象类型检查和多态"><a href="#13-对象类型检查和多态" class="headerlink" title="13.对象类型检查和多态"></a>13.对象类型检查和多态</h4><ul><li>对象类型检查<ul><li>比如使用 Incrby命令的时候 服务器会检查是否为 int 类型，如果不是返回 ERR value is not an integer or out of range</li></ul></li><li>多态<ul><li>比如列表底层可使用 ziplist和 linkedlist两种，那么这两种数据类型的长度获取函数肯定是不一样的。列表进行长度获取操作的时候，redis会先通过多态的性质，进行ziplist和linedlist的类型判断，然后返回长度。</li></ul></li></ul><h4 id="14-对象内存回收"><a href="#14-对象内存回收" class="headerlink" title="14.对象内存回收"></a>14.对象内存回收</h4><p>因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个<strong>引用计数</strong>技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">  <span class="comment">// type,endcoding,ptr</span></span><br><span class="line">  <span class="comment">// 引用计数</span></span><br><span class="line">  <span class="type">int</span> refcount;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><ul><li>实现原理<ul><li>对象的引用计数信息会随着对象的使用状态而不断变化：<ul><li>在创建一个新对象时，引用计数的值会被初始化为1；当对象被一个新程序使用时，它的引用计数值会被增一；</li><li>当对象不再被一个程序使用时，它的引用计数值会被减一；当对象的引用计数值变为0时，对象所占用的内存会被释放。</li></ul></li></ul></li></ul><h4 id="15-对象共享"><a href="#15-对象共享" class="headerlink" title="15.对象共享"></a>15.对象共享</h4><p><strong>除了用于实现引用计数内存回收机制之外，对象的引用计数(refcount)属性还带有对象共享的作用。</strong></p><p>举个例子，假设键A创建了一个包含整数值100的字符串对象作为值对象,如果这时键B也要创建一个同样保存了整数值100的字符串对象作为值对象，那么服务器有以下两种做法：</p><p>1）为键B新创建一个包含整数值100的字符串对象；</p><p>2）让键A和键B共享同一个字符串对象；</p><p>以上两种方法很明显是第二种方法更节约内存。</p><p>在Redis中，多个键共享同一个值对象会有如下现象：</p><p>1）将数据库键的值指针ptr(就是原本指向底层数据结构的指针)指向一个现有的值对象；</p><p>2）将被共享的值对象的引用计数增一。</p><h4 id="16-对象空转时长"><a href="#16-对象空转时长" class="headerlink" title="16.对象空转时长"></a>16.对象空转时长</h4><p>除了前面介绍过的type、encoding、ptr和refcount四个属性之外，redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间，可以使用OBJECT IDLETIME命令可以打印出给定键的空转时长，这一空转时长就是通过<strong>将当前时间减去键的值对象的lru时间计算得出的</strong>(redis之所以可以在内存不足的情况下实现删除最不常用的数据，就是依靠这个属性)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    <span class="comment">// type、encoding、ptr、refcount属性</span></span><br><span class="line">    unsigned lru:<span class="number">22</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p><h3 id="Redis-高级特性"><a href="#Redis-高级特性" class="headerlink" title="Redis 高级特性"></a>Redis 高级特性</h3><h4 id="1-RDB-持久化"><a href="#1-RDB-持久化" class="headerlink" title="1.RDB 持久化"></a>1.<strong>RDB</strong> <strong>持久化</strong></h4><p>Redis是基于内存的数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出或重启，服务器中的数据库状态也会消失不见。</p><p>为了解决这个问题，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。</p><p>RDB持久化既可以手动执行，也可以根据配置在某一个时间点上开始执行，RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态。和使用SAVE命令或者BGSAVE命令创建RDB文件不同，RDB文件的载入工作是在服务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。</p><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231220124701384.png" class title="image-20231220124701384"><p>RDB文件是保存在硬盘里面的，所以即使Redis服务器进程退出，甚至运行Redis服务器的计算机停机，但只要RDB文件仍然存在，Redis服务器就可以用它来还原数据库状态。</p><ul><li><p>RDB文件生成的两个命令</p><ul><li><p>SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求（SAVE命令，大家只有在测试、开发环境手动使用就行了）</p></li><li><p>BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求（redis的主从复制的时候）。</p></li><li><p>BGSAVE命令的保存工作是由<strong>子进程执行的</strong>，在BGSAVE命令执行期间，服务器处理SAVE、BGSAVE、BGREWRITEAOF三个命令的方式会和平时有所不同。</p><ul><li><p>在BGSAVE命令执行期间，客户端发送的SAVE命令和BGSAVE命令会被服务器拒绝，防止产生竞争条件。</p></li><li><p>出于性能方面的考虑，BGREWRITEAOF和BGSAVE两个命令不能同时执行</p><ul><li>如果BGSAVE命令正在执行，那么<strong>客户端发送的BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕之后执行</strong>（BGSVAE 不排斥BGREWRITEAOF，排队效应）。</li><li>如果BGREWRITEAOF命令正在执行，那么<strong>客户端发送的BGSAVE命令会被服务器拒绝</strong>。</li></ul></li></ul></li></ul></li><li><p>BGSAVE命令的触发和实现原理</p><ul><li><p>Redis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。默认配置如下：</p><p>save 900 1        服务器在900秒之内，对数据库进行了至少1次修改。</p><p>save 300 10       服务器在300秒之内，对数据库进行了至少10次修改。</p><p>save 60 10000    服务器在60秒之内，对数据库进行了至少10000次修改。</p><p>服务器程序会根据save选项所设置的秒数和修改次数，把值设置到redisServer结构的saveparams属性：</p></li><li><pre><code class="c">struct redisServer &#123;    // ...    // saveparams属性是一个数组，数组中的每个元素都是一个saveparam结构，每个saveparam结构都保存了一个save选项设置的保存条件    struct saveparam *saveparams;    // 修改计数器    long long dirty;    // 上一次执行保存的时间    time_t lastsave;    // ...&#125;;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - &#123;% asset_img image-20231220190016345.png image-20231220190016345 %&#125;</span><br><span class="line"></span><br><span class="line">  - Redis服务器中有一个周期性操作函数serverCron默认每隔**100毫秒就会执行一次**，它会周期性的检查dirty和lastsave这两个参数，从上一次保存到现在，如果修改次数和时间达到了save所保存的值，就执行BGSAVE命令。</span><br><span class="line"></span><br><span class="line">* RDB文件结构</span><br><span class="line"></span><br><span class="line">  - **基础构造**</span><br><span class="line"></span><br><span class="line">    - &#123;% asset_img image-20231220200107822.png image-20231220200107822 %&#125;</span><br><span class="line"></span><br><span class="line">    - RDB文件的最开头是长度为**5字节，保存着“REDIS”五个字符**。通过这五个字符，程序可以在载入文件时，快速检查所载入的文件是否RDB文件。</span><br><span class="line">    - db_version长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号，比如&quot;0006&quot;就代表RDB文件的版本为第六版。</span><br><span class="line">    - databases保存数据库真实的数据内容。如果服务器的数据库状态为空，那么这个部分也为空，长度为0字节。</span><br><span class="line">    - EOF常量的长度为1字节，这个常量标志着RDB文件正文内容的结束。</span><br><span class="line">    - check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分的内容进行计算得出的。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum所记录的校验和进行对比，**以此来检查RDB文件是否有出错或者损坏的情况出现。**</span><br><span class="line"></span><br><span class="line">  - **database** **部分**</span><br><span class="line"></span><br><span class="line">    - &#123;% asset_img image-20231220200514012.png image-20231220200514012 %&#125;</span><br><span class="line">    - SELECTDB常量的长度为1字节，当读入程序遇到这个值的时候，它知道接下来要读入的将是一个数据库号码。</span><br><span class="line">    - db_number保存着数据库号码，根据号码的大小不同，这个部分的长度不同。当程序读入db_number部分之后，服务器会调用SELECT命令，根据读入的数据库号码进行数据库切换。</span><br><span class="line">    - key_value_pairs部分保存了数据库中的所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。</span><br><span class="line"></span><br><span class="line">  - **key_value_pairs**</span><br><span class="line"></span><br><span class="line">    - 不含过期时间</span><br><span class="line">      - &#123;% asset_img image-20231220200920061.png image-20231220200920061 %&#125;</span><br><span class="line">    - 含有过期时间</span><br><span class="line">      - &#123;% asset_img image-20231220200944951.png image-20231220200944951 %&#125;</span><br><span class="line">    - EXPIRETIME_MS常量的长度为1字节，它告知读入程序，接下来要读入的将是一个以毫秒为单位的过期时间。</span><br><span class="line">    - ms是一个毫秒为单位的时间戳，保存了键值对的过期时间。</span><br><span class="line">    - key总是一个字符串对象，它的编码方式和REDIS_RDB_TYPE_STRING类型的value一样。</span><br><span class="line">    - TYPE记录了value的类型，长度为1字节包括以下几种类型</span><br><span class="line">      - &#123;% asset_img image-20231220201316267.png image-20231220201316267 %&#125;</span><br><span class="line"></span><br><span class="line">#### 2.**AOF** **持久化**</span><br><span class="line"></span><br><span class="line">除了RDB持久化功能之外，Redis还提供了AOF（Append Only File）持久化功能。RDB记录数据库中的键值对，AOF记录Redis服务器执行的写命令。AOF持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231220203611057.png image-20231220203611057 %&#125;</span><br><span class="line"></span><br><span class="line">* **命令追加：**当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会把执行的写命令追加到服务器状态的aof_buf缓冲区的末尾：</span><br><span class="line"></span><br><span class="line">  - ```c</span><br><span class="line">    struct redisServer &#123;</span><br><span class="line">        // ...</span><br><span class="line">        // AOF缓冲区</span><br><span class="line">        sds aof_buf;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>写入与同步：写入AOF文件的时机，是根据配置的appendfsync参数决定的</p><ul><li><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231220204557090.png" class title="image-20231220204557090"></li><li>当appendfsync的值为always时，服务器在每个redis操作后都要将aof_buf缓冲区中的所有内容写入到AOF文件，所以always的效率是最慢的；但always也是最安全的，因为即使出现故障，只会丢失一个事件循环中所产生的命令数据。（并发量不高，并且对数据要求百分百（redis保证99%，剩余的1%由我们的程序保证，每进行一个redis操作，从程序层面也要进行一次记录）不丢失的情况下，用 always）</li><li>当appendfsync的值为everysec时，服务器在每个redis操作后都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行一次同步。everysec模式足够快，并且就算出现故障停机，也只丢失一秒钟的命令数据。</li><li>当appendfsync的值为no时，服务器在每个redis操作后都要将aof_buf缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制。</li></ul></li><li><p>AOF 文件写入整体流程</p><ul><li><ol><li>客户端发起命令操作（查询操作除外）</li><li>服务端接收命令并将我们的命令进行执行，于此同时，将命令写入 redisServer 类中aof 缓冲区；</li><li>通过我们的 appendfsync参数的配置进行我们的缓冲区同步到aof磁盘文件的操作。</li></ol></li></ul></li><li><p>Redis读取AOF文件并还原数据库状态的详细步骤：</p><ul><li><p>1）创建一个不带网络连接的伪客户端：因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令</p><p>2）从AOF文件中分析并读取出一条写命令。</p><p>3）使用伪客户端执行被读出的写命令。</p><p>4）一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。</p></li><li><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231220205603722.png" class title="image-20231220205603722"></li></ul></li><li><p>AOF后台重写</p><ul><li><p>之所以需要进行重写，是因为如果对一个集合中执行了多次加入和弹出操作，那么AOF会把所以的加入弹出操作都记录，这样会导致AOF文件越来越大，数据还原所需的时间越长，所以只需要在AOF中记录集合的最终状态即可</p></li><li><p>Redis决定将AOF重写程序放到子进程里执行，这样做可以同时达到两个目的：</p><ul><li>子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。</li><li>子进程带有服务器进程的数据副本，<strong>使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</strong></li></ul></li><li><p>但是子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致，所以Redis服务器设置了一个<strong>AOF重写缓冲区</strong>，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。例如下图的k2,k3,k4都会放到AOF重写缓冲区，直到子进程执行完AOF重写，父进程会把这部分数据写入AOF**(aof重写过程是子进程先写已经有的，父进程写新加入的，父进程完成最终的aof文件替换)**</p><ul><li><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231220211344225.png" class title="image-20231220211344225"></li></ul></li></ul></li></ul><h4 id="3-Redis文件事件和时间事件"><a href="#3-Redis文件事件和时间事件" class="headerlink" title="3.Redis文件事件和时间事件"></a>3.Redis文件事件和时间事件</h4><p>。。。待学习</p><h4 id="4-Redis-Client"><a href="#4-Redis-Client" class="headerlink" title="4.  Redis Client"></a>4.  <strong>Redis Client</strong></h4><p>Redis服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的命令请求，并向客户端返回命令回复。每一个客户端都以redisClient对象在Redis中进行保存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    robj *name; 在默认情况下，一个连接到服务器的客户端是没有名字的，可以使用client setname 设置</span><br><span class="line">    <span class="type">int</span> fd; 根据客户端类型的不同其值不同，伪客户端的fd属性的值为<span class="number">-1</span>，普通客户端的fd属性的值为大于<span class="number">-1</span>的整数</span><br><span class="line">    <span class="type">int</span> flags; 记录了客户端的角色，举例：REDIS_SLAVE ，客户端是一个从服务器(这个参数用处不大)</span><br><span class="line">   sds querybuf; 客户端状态的输入缓冲区，用于保存客户端发送的命令请求，如<span class="built_in">set</span> msg <span class="string">&quot;hello&quot;</span></span><br><span class="line">   robj **argv; argv属性是一个数组。如 <span class="built_in">set</span> msg “hello” 会被保存为三个数组元素</span><br><span class="line">   <span class="type">int</span> argc; 表示命令长度，如<span class="built_in">set</span> msg “hello”, argc 为<span class="number">3</span></span><br><span class="line">   <span class="type">char</span> buf[REDIS_REPLY_CHUNK_BYTES]; 输出缓冲区,执行命令所得的命令回复会被保存在输出缓冲区里面</span><br><span class="line">    <span class="type">int</span> bufpos; 记录了输出缓冲区目前已使用的字节数量</span><br><span class="line">   <span class="type">int</span> authenticated; 检验客户端是否通过身份认证，<span class="number">0</span>表示未通过，<span class="number">1</span>表示通过</span><br><span class="line">  <span class="type">time_t</span> ctime; 记录了创建客户端的时间</span><br><span class="line"> <span class="type">time_t</span> lastinteraction;记录了客户端与服务器最后一次进行互动的时间</span><br><span class="line"> <span class="type">time_t</span> obuf_soft_limit_reached_time; 记录了输出缓冲区第一次到达软性限制的时间</span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><ul><li>硬性限制：如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端。</li><li>软性限制：如果输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制，那么服务器将使用客户端状态结构的obuf_soft_limit_reached_time属性记录下客户端到达软性限制的起始时间；之后服务器持续关注该客户端，如果输出缓冲区的大小一直超出软性限制，达到服务器设定的时长，那么服务器将关闭客户端；相反地，如果输出缓冲区的大小在指定时间之内，不再超出软性限制，那么客户端就不会被关闭，并且obuf_soft_limit_reached_time属性的值也会被清零。</li><li>一个客户端被关闭的情况<ul><li>客户端进程退出或者被杀死，那么客户端与服务器之间的网络连接将被关闭，从而造成客户端被关闭。</li><li>客户端向服务器发送了带有不符合协议格式的命令请求</li><li>用户为服务器设置了timeout配置选项，那么当客户端的空转时间超过timeout选项设置的值时，客户端将被关闭。</li><li>客户端发送的命令请求的大小超过了输入缓冲区的限制大小（默认为1 GB），那么这个客户端会被服务器关闭。</li><li>要返回给客户端的命令回复的大小超过了输出缓冲区的限制大小(达到硬性限制或者达到软性限制一段时间)，那么这个客户端会被服务器关闭。</li></ul></li></ul><h4 id="5-Redis-Server命令处理过程"><a href="#5-Redis-Server命令处理过程" class="headerlink" title="5.Redis Server命令处理过程"></a>5.<strong>Redis Server</strong>命令处理过程</h4><ol><li><p>读取命令请求</p><p>1）读取命令请求，并将其保存到客户端状态的输入缓冲区里面。(server 需要知道是哪个client发起的请求)</p><p>2）对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面。</p><p>3）调用命令执行器，执行客户端指定的命令。</p></li><li><p>命令执行器，查找命令，即客户端状态的argv[0]参数，将找到的命令保存到客户端状态的cmd属性(执行命令所需的实现函数)里面。</p></li><li><p>调用命令的实现函数</p></li><li><p>执行后续工作</p><ul><li><p>如果服务器开启了慢查询日志功能，那么慢查询日志模块会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志。（Redis 在 4 版本之前，他是单线程的网络连接处理和命令处理模型。一旦有慢查询的命令，会阻塞其他命令。）</p></li><li><p>根据刚刚执行命令所耗费的时长，更新被执行命令的redisCommand结构的milliseconds属性，并将命令的redisCommand结构的calls计数器的值增一。</p></li><li><p>如果服务器开启了AOF持久化功能，那么AOF持久化模块会将刚刚执行的命令请求写入到AOF缓冲区里面。</p></li><li><p>如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器。</p></li></ul></li><li><p>将函数的执行结果返回给客户端</p></li></ol><h4 id="6-serverCron函数"><a href="#6-serverCron函数" class="headerlink" title="6.serverCron函数"></a>6.<strong>serverCron函数</strong></h4><p>serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器的良好运转。</p><ol><li><p>更新服务器时间缓存。Redis服务器中有不少功能需要获取系统的当前时间，获取时间需要进行系统调用，为了减少系统调用的执行次数，会对当前时间进行缓存，但是这个精确度并不高。</p></li><li><p>管理客户端资源，serverCron函数每次执行都会调用clientsCron函数，clientsCron函数会对客户端进行以下两个检查：</p><ul><li><p>如果客户端与服务器之间的连接已经超时，那么程序释放这个客户端。</p></li><li><p>如果客户端在上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存。</p></li></ul></li><li><p>执行被延迟的BGREWRITEAOF （BGSAVE执行的时候，不拒绝BGREWRITEAOF ，让他去排队。 BGREWRITEAOF 不厚道，她自己执行的时候，拒绝BGSAVE）</p></li><li><p>将AOF缓冲区中的内容写入AOF文件</p></li><li><p>关闭那些输出缓冲区大小超出限制的客户端</p></li><li><p>更新服务器内存峰值记录</p></li><li><p>更新服务器每秒执行命令次数(估算，抽样调查)</p></li></ol><h4 id="7-Redis-server初始化"><a href="#7-Redis-server初始化" class="headerlink" title="7.Redis server初始化"></a>7.Redis server初始化</h4><p>一个Redis服务器从启动到能够接受客户端的命令请求，需要经过一系列的初始化和设置过程：</p><ol><li><p>创建一个struct <strong>redisServer</strong>类型的实例变量server作为服务器的状态，并为结构中的各个属性设置默认值。通过initServerConfig函数完成，initServerConfig主要完成设置服务器的默认配置文件路径，设置服务器的默认端口号，设置服务器的默认RDB持久化条件和AOF持久化条件。</p></li><li><p>载入配置选项</p></li><li><p>初始化服务器数据结构，</p><ul><li><p>server.clients链表，这个链表记录了所有与服务器相连的客户端的状态，每个客户端都是一个节点</p></li><li><p>server.db数组，数组中包含了服务器的所有数据库。</p></li><li><p>用于执行Lua脚本的Lua环境server.lua。</p></li><li><p>用于保存慢查询日志的server.slowlog属性。</p></li></ul></li><li><p>还原数据库状态（AOF &#x2F;RDB）</p></li></ol><h4 id="8-主从复制"><a href="#8-主从复制" class="headerlink" title="8.主从复制"></a>8.主从复制</h4><p>在Redis中，用户可以通过执行SLAVEOF命令，让一个服务器去复制另一个服务器，被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）。</p><p>当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器，复制功能分为<strong>同步</strong>和<strong>命令传播</strong>两个操作</p><ul><li><strong>同步</strong><ul><li>第一次进行主从服务器连接的时候，一定会进行同步操作（主服务器发送RDB文件到从服务器）；</li><li>从服务器断线重连主服务器的时候，有可能触发同步操作（如果从服务器断线期间，新的命令都存在主服务器的缓冲区里，那么就直接发送这部分命令<strong>（命令传播）</strong>给从服务器就可以了；如果这些新的命令，不全部存在于主服务器的缓冲区中，则触发同步操作（发送RDB 文件））。</li></ul></li><li>命令传播<ul><li>第一次连接完主服务器后，通过RDB文件同步之后的所有的命令，都是采用命令传播的形式。 同理，断线重连之后的所有主从数据的同步都采用命令传播。</li></ul></li></ul><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231221212355223.png" class title="image-20231221212355223"><h4 id="9-完整重同步与部分"><a href="#9-完整重同步与部分" class="headerlink" title="9.完整重同步与部分"></a>9.完整重同步与部分</h4><p>PSYNC命令具有完整重同步和部分重同步两种模式</p><ul><li>完整重同步</li></ul><p>完整重同步就是RDB文件同步（1. 第一次连接的时候；2 断线重连且缓冲区命令不全的时候）</p><p>完整重同步，需要主服务器生成一个新的 RDB文件，文件生成的开销是有的；RDB文件是整个的redis的数据状态，整个状态的 RDB文件体积不会太小，传输给从服务器需要网络开销及时间；相比于小体积的命令传播，这个RDB 文件开销大得多。</p><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231221213111072.png" class title="image-20231221213111072"><ul><li><p>部分重同步</p><p>部分重同步用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许（缓冲区大小可以容纳断线期间的命令），主服务器可以将主从服务器连接断开期间执行的写命令发送（命令传播）给从服务器，实现数据同步</p><ul><li><p>部分重同步实现</p><ol><li><p>复制偏移量，主从服务器维护各自的偏移量</p><p>·主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N。</p><p>·从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N。</p></li><li><p>当主服务器进行命令传播时，不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面，复制积压缓冲区是由主服务器维护的一个固定长度先进先出（FIFO）队列，默认大小为1MB(可以进行配置修改)。如果1MB的大小不能存储断线期间的命令，那么就执行完整重同步</p></li><li><p>除了复制偏移量和复制积压缓冲区之外，还需要维护服务器运行ID（run ID）：</p><p>·每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID。</p><p>·运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3。</p><p>当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来。</p><p>这样当主从连接的时候，就可以知道从服务器是首次连接主服务器还是断线重连</p></li></ol></li></ul></li><li><p>PSYNC的实现原理</p><ul><li><p>PSYNC命令的调用方法有两种：</p><ul><li><p>如果从服务器以前没有复制过任何主服务器，或者之前执行过SLAVEOF no one命令，那么从服务器在开始一次新的复制时将向主服务器发送<strong>PSYNC ? -1</strong>命令，主动请求主服务器进行完整重同步。</p></li><li><p>如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时将向主服务器发送**PSYNC <runid> <offset>**命令：其中runid是上一次复制的主服务器的运行ID，而offset则是从服务器当前的复制偏移量，通过这两个命令判断执行哪种同步</offset></runid></p></li></ul></li><li><p>接收到PSYNC命令的主服务器的三种返回情况</p><ul><li>如果主服务器返回**+FULLRESYNC <runid> <offset>**回复，那么表示主服务器将与从服务器执行完整重同步操作</offset></runid></li><li>如果主服务器返回**+CONTINUE**回复，那么表示主服务器将与从服务器执行部分重同步操作，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了。</li><li>如果主服务器返回**-ERR**回复，那么表示主服务器的版本低于Redis 2.8（2.8以前只有SYNC命令: SYNC 不支持部分重同步），它识别不了PSYNC命令。</li></ul></li></ul></li></ul><h4 id="10-心跳检测"><a href="#10-心跳检测" class="headerlink" title="10.心跳检测"></a>10.心跳检测</h4><p>在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送REPLCONF ACK <replication_offset>(其中replication_offset是从服务器当前的复制偏移量)命令：</replication_offset></p><ul><li><p>发送REPLCONF ACK命令对于主从服务器有三个作用：</p><ul><li><p>检测主从服务器的网络连接状态。如果主服务器超过一秒钟没有收到从服务器发来的REPLCONF ACK命令，那么主服务器就知道主从服务器之间的连接出现问题了。</p></li><li><p>辅助实现min-slaves选项。Redis的min-slaves-to-write和min-slaves-max-lag两个选项可以防止主服务器在不安全的情况下执行写命令。举个例子，如果我们向主服务器提供以下设置：</p><p>min-slaves-to-write 3</p><p>min-slaves-max-lag 10</p><p>那么在从服务器的数量少于3个，或者三个从服务器的延迟都大于等于10秒时，主服务器将拒绝执行写命令</p></li><li><p>检测命令丢失。如果因为网络故障，主服务器传播给从服务器的写命令在半路丢失，那么当从服务器向主服务器发送REPLCONF ACK命令时，主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器</p></li></ul></li></ul><h4 id="11-哨兵介绍"><a href="#11-哨兵介绍" class="headerlink" title="11.哨兵介绍"></a>11.哨兵介绍</h4><p>哨兵(Sentinel)是Redis的高可用性解决方案：由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p><ol><li><p>如果主服务器进行了断开，替换了从服务器。除了被提升为主服务器的从服务器。所有的从服务器都必须做一次完整重同步（因为新选出来的主服务器不认识这些从服务器的运行ID）。原来的主服务器，上线之后，无论作为谁的从服务器，都必须进行一次完整重同步。 提升为新的主服务的压力在于 BGSAVE,生成一份RDB文件，但是需要进行多份的网络传递； 第二次BGSAVE应该发生在原来的主服务器断线重连到新的服务器。</p></li><li><p>集群，多个主，这个主服务器只是一个集群里的节点。如果这个节点挂了，那我们的集群就会将请求路由到其他的主服务器节点上，上边说的生成RDB和传输的压力，在集群环境下就微乎其服务器微了。</p></li><li><p>如果是从服务器下线了，就是之前所说的断线重连 psync那部分内容。</p></li></ol><h4 id="12-启动并初始化Sentinel过程"><a href="#12-启动并初始化Sentinel过程" class="headerlink" title="12.启动并初始化Sentinel过程"></a>12.<strong>启动并初始化Sentinel</strong>过程</h4><p>1）初始化Sentinel服务器。</p><p>普通服务器在初始化时会通过载入RDB文件或者AOF文件来还原数据库状态，但是因为Sentinel并不使用数据库，所以初始化Sentinel时就不会载入RDB文件或者AOF文件。</p><p>2）将普通Redis服务器使用的代码替换成Sentinel专用代码。例如端口号和命令表</p><p>3）初始化Sentinel状态。</p><p>在应用了Sentinel的专用代码之后，接下来，服务器会初始化一个sentinel.c&#x2F;sentinelState结构，这个结构保存了服务器中所有和Sentinel功能有关的状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sentinelState</span> &#123;</span></span><br><span class="line">    <span class="comment">// 当前纪元，用于实现故障转移</span></span><br><span class="line">    <span class="type">uint64_t</span> current_epoch;</span><br><span class="line">    <span class="comment">// 保存了所有被这个sentinel监视的主服务器</span></span><br><span class="line">    dict *masters;</span><br><span class="line">    <span class="comment">// 是否进入了TILT模式？</span></span><br><span class="line">    <span class="type">int</span> tilt;</span><br><span class="line">    <span class="comment">// 目前正在执行的脚本的数量</span></span><br><span class="line">    <span class="type">int</span> running_scripts;</span><br><span class="line">    <span class="comment">// 进入TILT模式的时间</span></span><br><span class="line">  <span class="type">mstime_t</span> tilt_start_time;</span><br><span class="line">    <span class="comment">// 最后一次执行时间处理器的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> previous_time;</span><br><span class="line">    <span class="comment">// 一个FIFO队列，包含了所有需要执行的用户脚本</span></span><br><span class="line">    <span class="built_in">list</span> *scripts_queue;</span><br><span class="line">&#125; sentinel;</span><br></pre></td></tr></table></figure><p>4）初始化Sentinel状态的masters属性</p><p>Sentinel状态中的masters字典记录了所有被Sentinel监视的主服务器的相关信息，其中：</p><p>·字典的键是被监视主服务器的名字。</p><p>·而字典的值则是被监视主服务器对应的sentinel.c&#x2F;sentinelRedisInstance结构</p><p>5）创建连向主服务器的网络连接</p><p>Sentinel会向监视的主服务器创建两个异步网络连接：</p><p>·一个是命令连接，这个连接专门用于向主服务器发送命令，并接收命令回复。</p><p>·一个是订阅连接，这个连接专门用于订阅主服务器的sentinel:hello频道。</p><h4 id="13-获取主服务器信息"><a href="#13-获取主服务器信息" class="headerlink" title="13.获取主服务器信息"></a>13.获取主服务器信息</h4><p>Sentinel默认会以<strong>每十秒</strong>一次的频率，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来获取主服务器的当前信息。回复类似：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="title class_">Server</span></span><br><span class="line"><span class="attr">run_id</span>:7611c59dc3a29aa6fa0609f841bb6a1019008a9c</span><br><span class="line"></span><br><span class="line">\# <span class="title class_">Replication</span></span><br><span class="line"></span><br><span class="line"><span class="attr">role</span>:master</span><br><span class="line"></span><br><span class="line"><span class="attr">slave0</span>:ip=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>,port=<span class="number">11111</span>,state=online,offset=<span class="number">43</span>,lag=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">slave1</span>:ip=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>,port=<span class="number">22222</span>,state=online,offset=<span class="number">43</span>,lag=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">slave2</span>:ip=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>,port=<span class="number">33333</span>,state=online,offset=<span class="number">43</span>,lag=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">\# <span class="title class_">Other</span> sections</span><br></pre></td></tr></table></figure><p>通过分析主服务器返回的INFO命令回复，Sentinel可以获取以下两方面的信息：</p><ul><li><p>一方面是关于主服务器本身的信息，主服务器运行ID，以及该服务器的角色，主服务器的id端口号</p></li><li><p>另一方面是关于主服务器属下所有从服务器的信息</p></li></ul><ul><li>为什么Sentinel不直接获得从服务器的信息而是从主服务器获取？<ul><li>因为通过master我们可以很容易的拿到 slaves，所以简便起见，第一初始化，只进行 master的一个链接，当确认master连接ok的时候才进行从服务器的信息收集。</li></ul></li></ul><p>当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的从服务器创建相应的实例结构之外，Sentinel还会创建连接到从服务器的命令连接和订阅连接。</p><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231222225402782.png" class title="image-20231222225402782"><h4 id="14-向主从服务器发送信息"><a href="#14-向主从服务器发送信息" class="headerlink" title="14.向主从服务器发送信息"></a>14.向主从服务器发送信息</h4><p>在默认情况下，Sentinel会以每两秒一次的频率，通过命令连接向所有被监视的主服务器和从服务器发送以下格式的命令：</p><p>PUBLISH sentinel:hello “<s_ip>,<s_port>,<s_runid>,<s_epoch>,<m_name>,<m_ip>,<m_port>,<m_epoch>“</m_epoch></m_port></m_ip></m_name></s_epoch></s_runid></s_port></s_ip></p><p>·其中以s_开头的参数记录的是Sentinel本身的信息</p><p>·而m_开头的参数记录的则是主服务器的信息</p><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231224124219146.png" class title="image-20231224124219146"><p>注意：对于监视同一个服务器的多个Sentinel来说，一个Sentinel发送的信息以及服务器返回的信息，都会被Sentinel系统的其他Sentinel实例收到，用于更新其他Sentinel对发送信息Sentinel的认知，也会被用于更新其他Sentinel对被监视服务器的认知。</p><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231224124447323.png" class title="image-20231224124447323"><p>当一个Sentinel从sentinel:hello频道收到一条信息时，Sentinel会对这条信息进行分析，提取出信息中的Sentinel IP地址、Sentinel端口号、Sentinel运行ID等八个参数，并进行以下检查：</p><p>·如果信息中记录的Sentinel运行ID和接收信息的Sentinel的运行ID相同，那么说明这条信息是Sentinel自己发送的，Sentinel将丢弃这条信息，不做进一步处理。</p><p>·如果信息中记录的Sentinel运行ID和接收信息的Sentinel的运行ID不相同，那么说明这条信息是监视同一个服务器的其他Sentinel发来的，接收信息的Sentinel将根据信息中的各个参数，对相应主服务器的实例结构进行更新。</p><h4 id="15-服务器主客观下线"><a href="#15-服务器主客观下线" class="headerlink" title="15.服务器主客观下线"></a>15.服务器主客观下线</h4><p>在默认情况下，Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器、从服务器、其他Sentinel在内）发送PING命令，并通过PING命令返回的内容判断服务是否下线</p><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231224130916145.png" class title="image-20231224130916145"><p>实例对PING命令的回复可以分为以下两种情况：</p><ul><li><p>有效回复：实例返回+PONG(活着)、-LOADING(正在加载)、-MASTERDOWN(我的主服务器下线了)三种回复的其中一种。</p></li><li><p>无效回复：实例返回除+PONG、-LOADING、-MASTERDOWN三种回复之外的其他回复，或者在指定时限内没有返回任何回复。</p></li></ul><p>Sentinel配置文件中的down-after-milliseconds选项<strong>指定了Sentinel判断实例进入主观下线所需的时间长度</strong>：如果一个实例在down-after-milliseconds毫秒内，连续向Sentinel返回无效回复，那么Sentinel会修改这个实例所对应的实例结构，在结构的flags属性中打开SRI_S_DOWN标识，表示主观下线状态。</p><p>当Sentinel将一个<strong>主服务器</strong>判断为主观下线之后，为了确认这个主服务器是否真的下线了，它会向同样监视这一主服务器的其他Sentinel进行询问，看它们是否也认为主服务器已经进入了下线状态。当Sentinel从其他Sentinel那里接收到判断下线的数量达到Sentinel配置中设置的quorum参数的值，Sentinel就会将从服务器判定为客观下线，并对主服务器执行故障转移操作。</p><h4 id="16-选举领头Sentinel及故障转移"><a href="#16-选举领头Sentinel及故障转移" class="headerlink" title="16.选举领头Sentinel及故障转移"></a>16.<strong>选举领头Sentinel</strong>及故障转移</h4><ul><li><p>选领头Sentinel</p><ul><li>当一个<strong>主服务器</strong>被判断为<strong>客观下线</strong>时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移操作。（一旦发现主服务器下线了，一定要选举一个新的主服务器，谁去选择这个新的主服务器呢? 领头的 sentinel 去选择新的主服务器。 谁是领头的 sentinel呢？ 看下边的的选举规则。）<ol><li>所有在线的Sentinel都有被选为领头Sentinel的资格</li><li>每次进行领头Sentinel选举之后，不论选举是否成功，所有Sentinel的配置纪元（configuration epoch，Sentinel的一个属性）的值都会自增一次，所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会，并且局部领头一旦设置，在这个配置纪元里面就不能再更改。</li><li><strong>每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel。</strong></li><li>当一个Sentinel向另一个Sentinel发送SENTINEL is-master-down-by-addr命令，并且命令中的runid参数不是*符号而是自己Sentinel的运行ID时，这表示这个发送的Sentinel要求被发送的Sentinel将自己设置为局部领头Sentinel。<strong>Sentinel设置局部领头Sentinel的规则是先到先得</strong>，所以这个被发送Sentinel的如果已成选了别的Sentinel作为局部领头就不能再选这个了</li><li>被发送的Sentinel在接收到SENTINEL is-master-down-by-addr命令之后，将向发送的Sentinel返回一条命令回复，回复中包括leader_runid等参数，leader_runid表示自己选的作为领头Sentinel的id</li><li>发送的Sentinel在接收命令回复之后，会检查返回的leader_runid参数的值和自己的Sentinel的运行ID是否一致，如果一致说明被发送的Sentinel选了自己</li><li>如果有某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel。</li><li>如果在给定时限内，没有一个Sentinel被选举为领头Sentinel，那么各个Sentinel将在一段时间之后再次进行选举，直到选出领头Sentinel为止。</li></ol></li></ul></li><li><p>故障转移</p><ul><li><p>选出的Sentinel会对下线的主服务器进行故障转移操作：</p><ol><li>在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器。</li><li>让已下线主服务器属下的所有从服务器改为复制新的主服务器。</li><li>监视将已下线主服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。</li></ol></li><li><p>如何挑选新的主服务器</p><p>领头的Sentinel对该下线主服务器所有的从服务器存到一个列表中：</p><ol><li><p>删除列表中所有处于下线或者断线状态的从服务器，这可以保证列表中剩余的从服务器都是正常在线的。</p></li><li><p>删除列表中所有最近五秒内没有回复过领头Sentinel的INFO命令的从服务器，保证列表中剩余的从服务器都是最近成功进行过通信的。</p></li><li><p>删除所有与已下线主服务器连接断开超过down-after-milliseconds * 10毫秒的从服务器：保证列表中的服务器不是主观下线的，都是比较新的</p></li><li><p>之后，领头Sentinel将根据从服务器的优先级，对列表中剩余的从服务器进行排序，并选出其中优先级最高的从服务器(优先级信息可以在INFO命令的回复中进行获取)。如果有多个具有相同最高优先级的从服务器，那么领头Sentinel将按照从服务器的复制偏移量进行排序，选出其中偏移量最大的从服务器（复制偏移量最大的从服务器就是保存着最新数据的从服务器）。最后，如果有多个优先级最高、复制偏移量最大的从服务器，那么领头Sentinel将按照运行ID对这些从服务器进行排序，并选出其中运行ID最小的从服务器。</p></li></ol></li></ul></li></ul><h4 id="17-集群-节点"><a href="#17-集群-节点" class="headerlink" title="17.集群 - 节点"></a>17.<strong>集群</strong> <strong>-</strong> <strong>节点</strong></h4><p>多个节点想要成为一个集群，需要节点之间发送**CLUSTER MEET <ip> <port>**命令</port></ip></p><p>例如：节点B向节点A发送CLUSTER MEET命令，客户端可以让接收命令的节点A将另一个节点B添加到节点A当前所在的集群里面</p><ul><li><p>收到命令的节点A将与节点B进行握手，以此来确认彼此的存在，并为将来的进一步通信打好基础：</p><p>1）节点A会为节点B创建一个<strong>clusterNode</strong>结构，并将该结构添加到自己的<strong>clusterState.nodes</strong>字典里面。</p><p>2）之后，节点A将根据CLUSTER MEET命令给定的IP地址和端口号，向节点B发送一条消息。</p><p>3）如果一切顺利，节点B将接收到节点A发送的MEET消息，节点B也会为节点A创建一个<strong>clusterNode</strong>结构，并将该结构添加到自己的<strong>clusterState.nodes</strong>字典里面。</p><p>4）之后，节点B将向节点A返回一条PONG消息。</p><p>5）如果一切顺利，节点A将接收到节点B返回的PONG消息，A节点就知道B节点已经接受到了自己发的消息</p><p>6）之后，节点A将向节点B返回一条PING消息。</p><p>7）如果一切顺利，节点B将接收到节点A返回的PING消息，B节点就知道A节点已经接收到自己发送的PONG消息，握手完成。</p></li><li><p>clusterNode和clusterState部分结构</p><ul><li><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231224142157670.png" class title="image-20231224142157670"></li><li><strong>clusterState</strong>中nodes属性包含了所有的集群节点； size 属性是集群在线节点的数量；state 代表集群是否是运行状态；currentEpoch 故障转移+1的一个纪元计数器；以及一些其他信息。<strong>ClusterNode</strong>里展示了 name（runid）；flags表示节点的角色，还有ip，port，纪元等</li></ul></li></ul><h4 id="18-集群-槽与槽指派"><a href="#18-集群-槽与槽指派" class="headerlink" title="18.集群 - 槽与槽指派"></a>18.<strong>集群</strong> <strong>-</strong> <strong>槽与槽指派</strong></h4><p>现在如下图所示，一个集群中有三个节点，现在要进行key的set操作，set key value 操作进行6个不同的key value操作，我们如何利用好集群中的节点呢？</p><ol><li>轮询机制，6个操作分配给三个节点，每个节点2个。set key1 value1 分给了7000. set key2 value2 分给了7001 ， set key3 value3 分给了7002 … <strong>但是随着时间流逝，我需要进行get key1 操作的时候，不知道去哪个节点进行数据取出，所以不可取</strong></li><li>类似于一致性hash方式。我们对每个key进行一个算法，得出一个值，这个值如果是a，分配给7000，如果是b，分配给7001，如果是c分配给7002. 然后get key的时候，算出key的值，就知道从哪里获取。</li></ol><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231224143736370.png" class title="image-20231224143736370"><ul><li><p>槽</p><ul><li>Redis就是基于第二种方法的思想，用一个函数计算key的值 key &#x3D; CRC16(key) &amp; 16383. 这个key的值，任何情况下计算出来的结构，都是0 - 16383 之间的一个数字。这样就把每个键值对放到对应的槽中了</li></ul></li><li><p>槽指派</p><ul><li>槽指派就是规定每一个节点管理那哪些槽。例如：7000节点处理 0 -5000；70001 处理5001-10000；7002 处理 10001 - 16383；通过向节点发送CLUSTER ADDSLOTS命令，我们可以将一个或多个槽指派给节点负责，例如：将0-5000槽分配给7000节点，就是127.0.0.1:7000&gt; CLUSTER ADDSLOTS 0 1 2 3 4 … 5000</li></ul></li></ul><p><strong>只有所有的槽都有了对应节点的分配，那么这个集群才能处于上线状态</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> slots[<span class="number">16384</span>/<span class="number">8</span>];</span><br><span class="line">  <span class="type">int</span> numslots;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>集群中的每个节点还维护了一个slots数组，数组的长度是2048，表示2048个字节，然后每个字节是8位，2048 * 8 &#x3D; 16384 正好可以表示所有的槽位，数组的值为1表示该槽由这个节点负责。节点和节点之间也会通过发消息的形式告诉其他节点自己负责哪些槽</p><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231224152609966.png" class title="image-20231224152609966"><p>例如，7000节点的slots数组的前5000位都是1</p><p>同时在clusterState中也维护了一个slots数组，长度位16384，表示每个槽由哪个节点负责</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  clusterNode *slots[<span class="number">16384</span>];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231224152954424.png" class title="image-20231224152954424"><p>在对数据库中的16384个槽都进行了指派之后，集群就会进入上线状态，这时客户端就可以向集群中的节点发送数据命令了。</p><p>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己：</p><ul><li><p>如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令。</p></li><li><p>如果键所在的槽并没有指派给当前节点，那么节点会向客户端返回一个<strong>MOVED并重定向到正确的节点</strong>，并再次发送之前想要执行的命令。</p></li></ul><h4 id="19-集群-重新分片、复制与故障转移"><a href="#19-集群-重新分片、复制与故障转移" class="headerlink" title="19.集群 - 重新分片、复制与故障转移"></a>19.<strong>集群</strong> <strong>-</strong> <strong>重新分片</strong>、<strong>复制与故障转移</strong></h4><ul><li>重新分片</li></ul><p>当集群中要加入新的节点的时候，新节点也需要负责这16384个槽中的某些槽，这时就需要进行重新分片</p><ul><li>复制与故障转移</li></ul><p>Redis集群中的节点分为主节点和从节点，<strong>其中主节点用于处理槽</strong>，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。如图：</p><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231224154050492.png" class title="image-20231224154050492"><p>如果这时，节点7000进入下线状态，那么集群中仍在正常运作的几个主节点将在节点7000的两个从节点——节点7004和节点7005中选出一个节点作为新的主节点，这个新的主节点将接管原来节点7000负责处理的槽，并继续处理客户端发送的命令请求。</p><p>集群中的每个节点都会定期地向集群中的其他节点发送PING消息，以此来检测对方是否在线，如果接收PING消息的节点没有在规定的时间内，返回PONG消息，那么发送PING消息的节点就会将接收PING消息的节点标记为<strong>疑似下线</strong>(类似于哨兵的主观下线)，如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点x报告为疑似下线，那么这个主节点x将被标记为<strong>已下线</strong>(类似于哨兵的客观下线)</p><p>当一个从节点发现自己正在复制的主节点进入了已下线状态时，将进行故障转移：</p><p>1）选出一个下线主节点的从节点</p><p>2）被选中的从节点会执行SLAVEOF no one命令，成为新的主节点。</p><p>3）新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。</p><p>4）新的主节点向集群广播一条PONG消息，通知其他节点自己的状态更新。</p><p>5）新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</p><h3 id="Redis自身特性"><a href="#Redis自身特性" class="headerlink" title="Redis自身特性"></a>Redis自身特性</h3><h4 id="1-发布订阅介绍"><a href="#1-发布订阅介绍" class="headerlink" title="1.发布订阅介绍"></a>1.<strong>发布订阅介绍</strong></h4><p>Redis的发布与订阅功能由<strong>PUBLISH</strong>、<strong>SUBSCRIBE</strong>、<strong>PSUBSCRIBE</strong>等命令组成。</p><ul><li>SUBSCRIBE订阅</li></ul><p>通过执行SUBSCRIBE命令，客户端可以订阅一个或多个频道，每当有其他客户端向被订阅的频道发送消息时，频道的所有订阅者都会收到这条消息。</p><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231224224938070.png" class title="image-20231224224938070"><p>向”news.it”频道发送消息”hello”，那么”news.it”的三个订阅者都将收到这条消息。</p><ul><li>PSUBSCRIBE订阅</li></ul><p>PSUBSCRIBE命令可以订阅一个或多个<strong>模式</strong>，每当有其他客户端向某个频道发送消息时，消息不仅会被发送给这个频道的所有订阅者，它还会被发送给所有与这个频道相匹配的模式的订阅者。例如：向”news.it”频道发送消息”hello”，那么不仅正在订阅”news.it”频道的客户端A会收到消息，客户端C和客户端D也同样会收到消息，因为这两个客户端正在订阅匹配”news.it”频道的”news.[ie]t”模式。</p><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231224225105227.png" class title="image-20231224225105227"><p><strong>通过分析看到了效果，相当于 acd同时订阅了 news.it，bcd 同时订阅了 news.et. 如果没有这种模式订阅的话，cd客户端需要发送两次suscribe it和et频道。而模式订阅之后，cd 只需要维护这个模式就行了，而不需要考虑模式匹配的频道。</strong></p><h4 id="2-订阅和退订原理"><a href="#2-订阅和退订原理" class="headerlink" title="2.订阅和退订原理"></a>2.订阅和退订原理</h4><ul><li><p>频道的订阅与退订</p><ul><li><p>所有频道的订阅关系都保存在redisServer的pubsub_channels字典里面，这个字典的键是某个被订阅的频道，而键的值则是一个链表，链表里面记录了所有订阅这个频道的客户端</p></li><li><pre><code class="c">struct redisServer &#123;  // ...  // 保存所有频道的订阅关系  dict *pubsub_channels;  // ...&#125;;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - &#123;% asset_img image-20231225204530014.png image-20231225204530014 %&#125;</span><br><span class="line"></span><br><span class="line">  - 当某个频道没有一个客户端订阅的时候，这时频道连同频道对应空链表都会移除字典</span><br><span class="line"></span><br><span class="line">* 模式的订阅与退订</span><br><span class="line"></span><br><span class="line">  - 所有频道的订阅关系都保存在redisServer状态的pubsub_patterns属性里面</span><br><span class="line"></span><br><span class="line">  - ```c</span><br><span class="line">    struct redisServer &#123;</span><br><span class="line">      // 保存所有模式订阅关系</span><br><span class="line">      list *pubsub_patterns;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>pubsub_patterns属性是一个链表，链表中的每个节点都包含着一个pubsub Pattern结构，这个结构的pattern属性记录了被订阅的模式，而client属性则记录了订阅模式的客户端：</p></li><li><pre><code class="c">typedef struct pubsubPattern &#123;  // 订阅模式的客户端  redisClient *client;  // 被订阅的模式  robj *pattern;&#125; pubsubPattern;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - &#123;% asset_img image-20231225205319591.png image-20231225205319591 %&#125;</span><br><span class="line"></span><br><span class="line">  - 模式的订阅和退订就是链表节点的入队和出队</span><br><span class="line"></span><br><span class="line">* 当一个Redis客户端执行PUBLISH&lt;channel&gt;&lt;message&gt;命令将消息message发送给频道channel的时候，服务器需要执行以下两个动作：</span><br><span class="line"></span><br><span class="line">  1）将消息message发送给channel频道的所有订阅者。PUBLISH命令要做的就是在pubsub_channels字典里找到频道channel的订阅者名单（一个链表），然后将消息发送给名单上的所有客户端。</span><br><span class="line"></span><br><span class="line">  2）如果有一个或多个模式与频道相匹配，那么要将消息发送给模式的订阅者。PUBLISH命令要做的就是遍历整个pubsub_patterns链表，查找那些与channel频道相匹配的模式，并将消息发送给订阅了这些模式的客户端。</span><br><span class="line"></span><br><span class="line">#### 3.事务</span><br><span class="line"></span><br><span class="line">事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且**在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。**</span><br><span class="line"></span><br><span class="line">事务首先以一个MULTI命令为开始，接着将多个命令放入事务队列当中，最后由EXEC命令将这个事务提交（commit）给服务器执行。</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231225210631861.png image-20231225210631861 %&#125;</span><br><span class="line"></span><br><span class="line">MULTI命令的执行标志着事务的开始，**MULTI命令可以将执行该命令的客户端从非事务状态切换至事务状态，这一切换是通过在客户端状态的flags属性中打开REDIS_MULTI标识来完成的。**当一个客户端处于非事务状态时，这个客户端发送的命令会立即被服务器执行，与此不同的是，当一个客户端切换到事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作：</span><br><span class="line"></span><br><span class="line">在事务状态下，如果客户端发送的命令是EXEC、DISCARD、WATCH、MULTI四个命令以外的其他命令，那么服务器并不立即执行这个命令，而是将这个命令放入一个事务队列里面，然后向客户端返回QUEUED回复。只有服务器收到客户端发送的EXEC命令时，才会开始执行事务，并把所有的执行结果返回给客户端</span><br><span class="line"></span><br><span class="line">* 每个Redis客户端都有自己的事务状态，这个事务状态保存在客户端的mstate属性里面。事务状态包含一个事务队列，以及一个已入队命令的计数器，事务队列是一个multiCmd类型的数组，数组中的每个multiCmd结构都保存了一个已入队命令的相关信息，包括指向命令实现函数的指针、命令的参数，以及参数的数量。事务队列以先进先出（FIFO）的方式保存入队的命令，较先入队的命令会被放到数组的前面，而较后入队的命令则会被放到数组的后面。</span><br><span class="line">* &#123;% asset_img image-20231225211606820.png image-20231225211606820 %&#125;</span><br><span class="line">* &#123;% asset_img image-20231225211707303.png image-20231225211707303 %&#125;</span><br><span class="line"></span><br><span class="line">#### 4.WATCH命令</span><br><span class="line"></span><br><span class="line">WATCH命令是一个乐观锁，在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键如果至少有一个已经被其他客户端修改过了，那么服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。例如：</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231225212630925.png image-20231225212630925 %&#125;</span><br><span class="line"></span><br><span class="line">如上图，客户端A的事务就会拒绝执行</span><br><span class="line"></span><br><span class="line">* WATCH命令的实现</span><br><span class="line"></span><br><span class="line">  - 每个Redis数据库都保存着一个watched_keys字典，这个字典的键是被监视的数据库键，值则一个链表，链表中记录了该键被哪些客户端监视</span><br><span class="line"></span><br><span class="line">  - &#123;% asset_img image-20231225212901315.png image-20231225212901315 %&#125;</span><br><span class="line"></span><br><span class="line">  - 所有对数据库进行修改的命令，比如SET、LPUSH、DEL等等，在执行之后都会调用**touchWatchKey**函数对字典进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键，如果有的话，那么touchWatchKey函数会打开对应客户端的**REDIS_DIRTY_CAS**标识，表示该客户端的事务安全性已经被破坏。当服务器接收到一个客户端发来的EXEC命令时，服务器会根据这个客户端是否打开了REDIS_DIRTY_CAS标识来决定是否执行事务：</span><br><span class="line"></span><br><span class="line">    如果客户端的REDIS_DIRTY_CAS标识已经被打开，拒绝执行事务，否则会提交事务</span><br><span class="line"></span><br><span class="line">#### 5.Lua</span><br><span class="line"></span><br><span class="line">* lua在Redis中的使用</span><br><span class="line"></span><br><span class="line">  - Redis从2.6版本开始引入对Lua脚本的支持，Redis通过在服务器中嵌入Lua环境，Redis客户端可以使用Lua脚本，直接在服务器端**原子地**执行多个Redis命令。</span><br><span class="line">    - 可以事先准备好lua脚本，然后通过 script load命令进行脚本的载入； 然后再通过evalsha命令进行lua脚本的执行。</span><br><span class="line">    - 可以直接使用eval 这个命令，对lua脚本直接执行。eval 和 evalsha区别在于，eval是直接执行我们的lua脚本，而且是一次性的执行。 evalsha可以对我们已经load的脚本随时执行。</span><br><span class="line"></span><br><span class="line">* eval/evalsha命令的实现原理</span><br><span class="line"></span><br><span class="line">  1. 根据客户端给定的Lua脚本，在Lua环境中定义一个Lua函数。当客户端向服务器发送EVAL命令，服务器首先要做的就是在Lua环境中，为传入的脚本定义一个与这个脚本相对应的Lua函数，其中，Lua函数的名字由f_前缀加上脚本的SHA1校验和（四十个字符长）组成，而函数体则是脚本本身(所以只要记住了脚本的SHA1校验和就可以执行对应的lua脚本，这就是evalsha的实现原理)。</span><br><span class="line"></span><br><span class="line">  2. EVAL命令要做的第二件事是将客户端传入的脚本保存到服务器的lua_scripts字典里面。</span><br><span class="line"></span><br><span class="line">     &#123;% asset_img image-20231225215319207.png image-20231225215319207 %&#125;</span><br><span class="line"></span><br><span class="line">  3. 执行刚刚在Lua环境中定义的函数，以此来执行客户端给定的Lua脚本。</span><br><span class="line"></span><br><span class="line">* lua脚本管理命令</span><br><span class="line"></span><br><span class="line">  - SCRIPT LOAD 命令：</span><br><span class="line">    - SCRIPT LOAD命令所做的事情和EVAL命令执行脚本时所做的前两步完全一样：命令首先在Lua环境中为脚本创建相对应的函数，然后再将脚本保存到lua_scripts字典里面。</span><br><span class="line">    - &#123;% asset_img image-20231225215818792.png image-20231225215818792 %&#125;</span><br><span class="line">  - SCRIPT KILL 命令：</span><br><span class="line">    - 如果服务器设置了lua-time-limit配置选项，那么在每次执行Lua脚本之前，服务器都会在Lua环境里面设置一个超时处理钩子。超时处理钩子会定期检查脚本已经运行了多长时间，一旦钩子发现脚本的运行时间已经超过了lua-time-limit选项设置的时长，钩子将定期在脚本运行的间隙中，查看是否有SCRIPT KILL命令或者SHUTDOWN命令到达服务器。</span><br><span class="line">  - SCRIPT FLUSH命令：</span><br><span class="line">    - 用于清除服务器中所有和Lua脚本有关的信息，释放并重建lua_scripts字典，关闭现有的Lua环境并重新创建一个新的Lua环境。</span><br><span class="line">  - SCRIPT EXISTS命令：</span><br><span class="line">    - SCRIPT EXISTS命令根据输入的SHA1校验和，检查校验和对应的脚本是否存在于服务器中。</span><br><span class="line"></span><br><span class="line">* lua脚本复制</span><br><span class="line"></span><br><span class="line">  - 当主服务器执行完EVAL、SCRIPT FLUSH、SCRIPT LOAD三个命令的其中一个时，主服务器会直接将被执行的命令传播给所有从服务器</span><br><span class="line"></span><br><span class="line">  - EVALSHA命令则不同，因为主服务器与从服务器载入Lua脚本的情况可能有所不同，对于一个在主服务器被成功执行的EVALSHA命令来说，相同的EVALSHA命令在从服务器执行时却可能会出现脚本未找到错误。原因如下：</span><br><span class="line"></span><br><span class="line">    - 假设有主服务器master和从服务器slave1，并且slave1一直复制着master，所以master载入的所有Lua脚本，slave1也有载入（通过传播EVAL命令或者SCRIPT LOAD命令来实现）。如果这时，一个新的从服务器slave2开始复制主服务器master，master和slave1都将成功执行这个EVALSHA命令，而slave2却会发生脚本未找到错误。</span><br><span class="line"></span><br><span class="line">      为了防止以上假设的情况出现，**Redis要求主服务器在传播EVALSHA命令的时候，必须确保EVALSHA命令要执行的脚本已经被所有从服务器载入过**，如果不能确保这一点的话，主服务器会将EVALSHA命令转换成一个等价的EVAL命令，然后通过传播EVAL命令来代替EVALSHA命令。</span><br><span class="line"></span><br><span class="line">      主服务器使用服务器状态的repl_scriptcache_dict字典记录自己已经将哪些脚本传播给了所有从服务器</span><br><span class="line"></span><br><span class="line">#### 6.SORT命令实现</span><br><span class="line"></span><br><span class="line">SORT命令的最简单执行形式为：SORT &lt;key&gt;。 这个命令默认可以对一个包含**数字值的键key**进行排序。</span><br><span class="line"></span><br><span class="line">服务器执行SORT numbers命令的详细步骤如下：</span><br><span class="line"></span><br><span class="line">1）创建一个和numbers列表长度相同的数组，该数组的每个项都是一个redisSortObject结构</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">typedef struct _redisSortObject &#123;</span><br><span class="line">    // 被排序键的值</span><br><span class="line">    robj *obj;</span><br><span class="line">    // 权重</span><br><span class="line">    union &#123;</span><br><span class="line">        // 排序数字值时使用</span><br><span class="line">        double score;</span><br><span class="line">        // 排序带有BY选项的字符串值时使用</span><br><span class="line">        robj *cmpobj;</span><br><span class="line">    &#125; u;</span><br><span class="line">&#125; redisSortObject;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>2）遍历数组，将各个数组项的obj指针分别指向numbers列表的各个项，构成obj指针和列表项之间的一对一关系，如图</p><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231225222341795.png" class title="image-20231225222341795"><p>3）遍历数组，将各个obj指针所指向的值转换成一个double类型的浮点数，并将这个浮点数保存在相应数组项的u.score属性里面</p><img src="/2023/12/18/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231225222606167.png" class title="image-20231225222606167"><p>4）根据u.score属性的值，对数组进行数字值排序，排序后的数组项默认按u.score属性的值从小到大排列。</p><p><strong>所以自始至终，原始的列表是没有变化的，改变的都是新创建的_redisSortObject数组</strong></p><ul><li>如果要排序的键对应的值不是数字值，那么就会在类型转换为double的时候报错，所以在命令上加一个<strong>ALPHA</strong>参数，即SORT <key>ALPHA，这样的效果就是根据字符串的值进行大小的排序</key></li><li>如果想要列表中的部分内容，可以使用limit参数，即SORT <key> ALPHA 0 3，表示从第0个值开始往后取3个</key></li></ul><h4 id="7-慢查询命令"><a href="#7-慢查询命令" class="headerlink" title="7.慢查询命令"></a>7.慢查询命令</h4><p>Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度。</p><p>服务器配置有两个和慢查询日志相关的选项：</p><ul><li><p>slowlog-log-slower-than选项指定执行时间超过多少微秒（1秒等于1 000 000微秒）的命令请求会被记录到日志上。</p></li><li><p>slowlog-max-len选项指定服务器最多保存多少条慢查询日志。</p></li></ul><p>服务器使用<strong>先进先出</strong>的方式保存多条慢查询日志，当服务器存储的慢查询日志数量等于slowlog-max-len选项的值时，服务器在添加一条新的慢查询日志之前，会先将最旧的一条慢查询日志删除。</p><p>举例： CONFIG SET slowlog-log-slower-than 0 表示执行时间超过0毫秒的操作会被记录，即所有的命令都会被记录。</p><p>通过slowlog get 可以查看慢查询日志。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深入理解Java虚拟机》阅读笔记</title>
      <link href="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="JVM学习链路"><a href="#JVM学习链路" class="headerlink" title="JVM学习链路"></a>JVM学习链路</h3><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231210224137170.png" class title="image-20231210224137170"><h3 id="Class-文件结构"><a href="#Class-文件结构" class="headerlink" title="Class 文件结构"></a>Class 文件结构</h3><h4 id="1-魔数与次主版本号"><a href="#1-魔数与次主版本号" class="headerlink" title="1.魔数与次主版本号"></a>1.<strong>魔数与次主版本号</strong></h4><p>每个Class文件的头4个字节被称为魔数(CAFEBABE)，它的<strong>唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。</strong></p><p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号，第7和第8个字节是主版本号。高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。</p><h4 id="2-常量池计数器"><a href="#2-常量池计数器" class="headerlink" title="2.常量池计数器"></a>2.<strong>常量池计数器</strong></h4><p>紧接着主、次版本号之后的是常量池入口,由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项<strong>u2类型的数据</strong>，代表常量池的容量，就是常量池计数器。与Java中语言习惯不同，<strong>这个容量计数是从1而不是0开始的</strong>。因为常量池中的内容是需要被其他东西所指向的，所以在常量池0这个位置提供了一个空，为了给那些没有东西指的一个指向，例如：</p><p>例子1 ：Object类没有父类，他的父类索引指向哪里呢？</p><p>指向 00 00 （指向常量池里的第 0 个常量，第0 个常量什么都没有，这个第 0 个常量，就是为了给所有无法指向的情况提供的一个空常量指向）</p><p>例子2： 匿名内部类。（类名称指向哪里？指向 00 00）</p><h4 id="3-常量池"><a href="#3-常量池" class="headerlink" title="3.常量池"></a>3.<strong>常量池</strong></h4><ul><li>常量池存放内容</li></ul><p>常量池中主要存放两大类常量：<strong>字面量</strong> 和 <strong>符号引用</strong></p><p><strong>字面量</strong>比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。</p><p><strong>符号引用</strong>主要包括：包名，类名，接口名，字段名，方法名，方法类型等等</p><p>在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用<strong>不经过虚拟机在运行期转换</strong>的话是无法得到真正的内存入口地址（也就是说，你的虚拟机不运行，你的类就是无用的。一切都要基于jvm运行的时候，类才有他的意义），也就无法直接被虚拟机使用的。</p><ul><li><p><strong>常量池的项目类型</strong></p><ul><li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231211215024248.png" class title="image-20231211215024248"></li><li>重点类型介绍<ul><li><strong>CONSTANT_Class_info型常量的结构</strong></li><li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231211215110658.png" class title="image-20231211215110658"></li><li>tag是标志位，它用于区分常量类型；name_index是常量池的索引值，它指向常量池中一个CONSTANT_Utf8_info类型常量（因为CONSTANT_Utf8_info里存放着这个class的名称），此常量代表了这个类（或者接口）的全限定名。</li><li><strong>CONSTANT_Utf8_info型常量的结构</strong></li><li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231211215320105.png" class title="image-20231211215320105"></li><li>length值说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度。而这里的最大长度就是length的最大值，既u2类型能表达的最大值65535(u2代表两个字节，一共16位，也就是2的16次方减一)。<strong>所以Java程序中如果定义了超过64KB英文字符的变量或方法名，即使规则和全部字符都是合法的，也会无法编译。（超出了 常量池里的utf8 info里的u2的最大限度）</strong></li></ul></li></ul></li><li><p>jvm是如何确定我们类的符号引用的（寻找到类的名称的）（索引类的）？</p><ul><li>当我们的jvm运行过程中，如果需要加载额外的类，那么首先会通过 我们的 对当前类的一个引用，去指向常量池中的class info类型，然后由class info类型指向utf8 info 类型，找到类的全限定名。在解析的过程中，<strong>将全限定名的符号引用转为直接引用。</strong></li></ul></li></ul><h4 id="4-访问标志、类索引、父类索引与接口索引集合"><a href="#4-访问标志、类索引、父类索引与接口索引集合" class="headerlink" title="4.访问标志、类索引、父类索引与接口索引集合"></a>4.<strong>访问标志</strong>、类索引、父类索引与接口索引集合</h4><p>在常量池结束之后，紧接着的2个字节代表访问标志，这个<strong>标志用于识别这个类或者接口层次的访问信息</strong>，主要有以下几个信息</p><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231211220807086.png" class title="image-20231211220807086"><p>访问标志之后是类索引和父类索引，他们都是一个<strong>u2类型的数据</strong>，而接口索引集合（interfaces）是一组<strong>u2类型的数据的集合</strong>，类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字后的接口顺序从左到右排列在接口索引集合中（如果这个Class文件表示的是一个接口，则应当是extends关键字）。</p><h4 id="5-字段表集合、方法表集合"><a href="#5-字段表集合、方法表集合" class="headerlink" title="5.字段表集合、方法表集合"></a>5.<strong>字段表集合、方法表集合</strong></h4><ul><li><p>字段表集合</p><ul><li><p>字段表用于描述接口或者类中声明的变量。Java语言中的“字段”包括<strong>类变量</strong>以及<strong>实例变量</strong>，但不包括在方法内部声明的局部变量。</p><ul><li>类变量和 实例变量有啥区别？</li><li>类变量是一个static的变量，<code>class Test &#123;    public static string name = &#39;123&#39; // 类变量 &#125;</code> 实例变量是非静态的全局的变量。<code>class Test &#123;    public  string name = &#39;123&#39; // 实例变量 &#125; </code>类变量可以直接用 类名.变量名进行调用； 实例变量必须通过new 对象的形式进行调用。</li></ul></li><li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231211222828550.png" class title="image-20231211222828550"><ul><li><p>access_flags和name_index</p><ul><li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231211223033409.png" class title="image-20231211223033409"></li><li>access_flags标志就是上表中标志值，如果含有多个修饰词就把标志值进行相加即可；name_index和descriptor_index，它们都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符。</li></ul></li><li><p>descriptor_index</p><ul><li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231211223310562.png" class title="image-20231211223310562"></li><li><p>对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组将被记录成“[[Ljava&#x2F;lang&#x2F;String；”，一个整型数组“int[]”将被记录成“[I”。</p><p>用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法void inc()的描述符为“()V”，方法java.lang.String toString()的描述符为“()Ljava&#x2F;lang&#x2F;String；”，方法int indexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex)的描述符为“([CII[CIII)I”</p></li></ul></li><li><p>attributes_count</p><ul><li>字段表所包含的固定数据项目到descriptor_index为止就全部结束了，不过在descrip-tor_index之后跟随着一个属性表集合，用于存储一些额外的信息，字段表可以在属性表中附加描述零至多项的额外信息。如果将字段m的声明改为“final static int m&#x3D;123；”，那就可能会存在一项名称为<strong>ConstantValue的属性</strong>，其值指向常量123。关于attribute_info的其他内容<strong>重点看属性表集合那部分。</strong></li></ul></li></ul></li></ul></li><li><p>对于方法表集合，其和字段表基本相同，方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在<strong>方法属性表集合</strong>中一个名为“<strong>Code</strong>”的属性里面，code里面存放的常用属性有操作数栈的最大深度，局部变量表所需要的最大空间，整个方法代码的长度等，属性表作为Class文件格式中最具扩展性的一种数据项目。</p></li></ul><h4 id="6-属性表集合"><a href="#6-属性表集合" class="headerlink" title="6.属性表集合"></a>6.<strong>属性表集合</strong></h4><p>Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。</p><p>Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性(在方法表下边)内。Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性，如果方法表有Code属性存在，那么它的结构将如下表：</p><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231211225851335.png" class title="image-20231211225851335"><ul><li><p>几个重点参数</p><ul><li><p><strong>attribute_name_index</strong>是一项指向CONSTANT_Utf8_info型常量的索引，<strong>此常量值固定为“Code”</strong>，它代表了该属性的属性名称，attribute_length指示了属性值的长度</p></li><li><p><strong>max_stack</strong>代表了操作数栈深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧中的操作栈深度（如果超过该深度会出现stackOverflow 异常）。</p></li><li><p><strong>max_locals</strong>代表了<strong>局部变量表所需的存储空间</strong>。max_locals的单位是<strong>变量槽（Slot）</strong>，变量槽是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，<strong>每个局部变量占用一个变量槽</strong>，而<strong>double和long这两种64位的数据类型则需要两个变量槽来存放</strong>。方法参数（包括实例方法中<strong>的隐藏参数“this”</strong>）、<strong>显式异常处理程序的参数</strong>（就是try-catch语句中catch块中所定义的异常）、方法体中定义的局部变量都需要依赖局部变量表来存放。<strong>注意，</strong>首先从以下代码里能够看到有四个局部变量分别是 ： a和b（string）， i和x （int类型）。直观上看，需要分配至少这个 4 个变量槽。但是。只需要分配两个就行了。因为，第一个for循环使用了 i 和 a； 第二个for循环执行的时候，就超出了变量i和a的作用域。 此时 x 变量可以重用 i 变量的变量槽， b可以重用 a 变量的变量槽。根据同时生存的最大局部变量数量和类型计算出max_locals的大小。</p><ul><li><pre><code class="java">public void testMethod（） &#123;    String a = &#39;123&#39;;    String b = &#39;456&#39;;    for(int i = 0; i &lt; 10; i++) &#123;        System.out.println(i);        System.out.println(a);    &#125;         for(int x = 0; x &lt; 10; x++) &#123;        System.out.println(x);        System.out.println(b);    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - **code_length**和**code**用来存储Java源程序编译后生成的字节码指令。code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令,从这里就可以看出，**我们的方法里边的代码，并不是以二进制的形式被完全照搬转化的，而是，通过我们的code属性保存的 jvm 指令码。**</span><br><span class="line"></span><br><span class="line">* 对  max_locals中隐藏参数this，显式异常处理程序的参数  的说明</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public class JVMThisAndException &#123;</span><br><span class="line">        private int m; // 实例变量，不是局部变量</span><br><span class="line">        private static int n;</span><br><span class="line">    </span><br><span class="line">        public int inc()&#123; // 方法。这个东西肉眼看见： 没有参数</span><br><span class="line">            return this.m + 1; // 没有局部变量。</span><br><span class="line">            // 使用javap命令对class字节码文件进行反编译得到locals=1, args_size=1</span><br><span class="line">            // 参数问题，对于我们的 所有普通方法 都会有一个隐藏的this参数。这样我们在使用this的时候，就能够像我们的inc方法那样，进行this.m的调用了。</span><br><span class="line">            // 局部变量表来说，也会为我们的this开辟一个单独的区域进行this的存储。这个存储的是我们this指向的这个当前对象。</span><br><span class="line">        &#125;</span><br><span class="line">        public static int inc2() &#123;</span><br><span class="line">            return n; //这个地方不能使用this，因为该方法是static的，这时对象可能还没有创建</span><br><span class="line">            // locals=0, args_size=0</span><br><span class="line">        &#125;</span><br><span class="line">        public int inc3 () &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return m + 1;</span><br><span class="line">            &#125; catch (Exception e) &#123; // e 是个局部使用的变量名称，局部变量</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            return 0;</span><br><span class="line">            // locals=2(this, e), args_size=1 (this)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li><li><p>字段表集合中属性表的ConstantValue 属性</p><ul><li><p><strong>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值（提前赋值，不需要运行时赋值，加快运行时的获取速度）</strong>。只有被static关键字修饰的变量（类变量）才可以使用这项属性。对非static类型的变量的赋值是在实例构造器<init>()方法中进行的；而对于static类型变量，则有两种方式可以选择：<strong>在类构造器<clinit>()方法中或者使用ConstantValue属性。</clinit></strong></init></p><p>目前<strong>Oracle公司实现的Javac编译器</strong>的选择是，如果同时使用final和static来修饰一个变量，并且这个变量的数据类型是<strong>基本类型或者String类型</strong>的话，<strong>就将会生成ConstantValue属性来进行初始化</strong>；如果这个变量没有被final修饰，或者并非基本类型及字符串，则将会选择在<clinit>()方法中进行初始化。</clinit></p></li><li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231211234007233.png" class title="image-20231211234007233"></li><li><p>constantvalue_index数据项代表了常量池中一个字面量常量的引用</p></li></ul></li></ul><h4 id="7-JVM-字节码指令"><a href="#7-JVM-字节码指令" class="headerlink" title="7.JVM 字节码指令"></a>7.<strong>JVM</strong> <strong>字节码指令</strong></h4><p>在Java虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。举个例子，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在Class文件中它们必须拥有各自独立的操作码。</p><ul><li><p>常见的JVM 字节码指令</p><ul><li><p>·将一个局部变量加载到操作栈：<strong>iload</strong></p><p>·将一个数值从操作数栈存储到局部变量表：<strong>istore</strong></p></li><li><p>加法指令：iadd</p><p>·减法指令：isub</p><p>·按位或指令：ior</p><p>·按位与指令：iand</p><p>·按位异或指令：ixor</p></li><li><p>类型转换指令包括i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。</p></li><li><p>·创建类实例的指令：new</p><p>·创建数组的指令<strong>：</strong>newarray<strong>、</strong>anewarray<strong>、</strong>multianewarray</p><p>·访问类字段（static字段）和实例字段（非static字段）的指令：getfield<strong>、</strong>putfield<strong>、</strong>getstatic<strong>、</strong>putstatic</p></li><li><p>·invokevirtual指令：用于调用对象的实例方法</p><p>·invokeinterface指令：用于调用接口方法</p><p>·invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法(init)、私有方法(private)和父类方法(父类方调用)。</p><p>·invokestatic指令：用于调用类静态方法（static方法）。</p></li></ul></li></ul><h3 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h3><h4 id="1-类加载流程概述"><a href="#1-类加载流程概述" class="headerlink" title="1.类加载流程概述"></a>1.类加载流程概述</h4><p>Java虚拟机把描述类的数据从<strong>Class文件加载到内存</strong>，并对数据进行<strong>校验、转换解析和初始化</strong>，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。与那些在编译时需要进行连接的语言不同，在Java语言里面，<strong>类型的加载、连接和初始化过</strong>程都是在<strong>程序运行期间完成的</strong>，这会让类加载时稍微增加一些性能开销，但是却为Java应用提供了极高的扩展性和灵活性，Java天生可以动态扩展的根本就是依赖运行期<strong>动态加载和动态连接</strong>这个特点实现的。</p><p><em>动态加载是指在程序运行时根据条件选择性地加载类</em></p><p><em>动态链接就是将指令中的符号引用转化为真实的方法地址。（依据常量池）</em></p><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231212133815269.png" class title="image-20231212133815269"><p><strong>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的</strong>，类型的加载过程必须按照这种顺序<strong>按部就班</strong>地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性。请注意，这里按部就班是指按部就班地“开始”，而不是按部就班地“进行”或按部就班地“完成”，强调这点是<strong>因为这些阶段通常都是互相交叉地混合进行的</strong>，会在一个阶段执行的过程中调用、激活另一个阶段。</p><h4 id="2-类加载过程-加载"><a href="#2-类加载过程-加载" class="headerlink" title="2.类加载过程 - 加载"></a>2.<strong>类加载过程</strong> <strong>-</strong> <strong>加载</strong></h4><p>类加载的加载流程：</p><p>1）通过一个<strong>类的全限定名</strong>来获取定义此类的二进制字节流。（class文件字节流）（加载）<br>2）连接 - 验证 - <strong>文件格式验证</strong><br>3）将这个字节流所代表的<strong>静态存储结构转化为方法区的运行时数据结构</strong>。（class文件是一个静态的二进制文件，里边存放的是我们的类中所有的一些常量，字段，方法，属性，这些都是静态存储在class文件中的。 转化为方法区所需要的运行时的一种数据结构。）（加载）<br>4） 连接 - 验证 - 元数据验证<br>5） 连接 - 验证 - 字节码验证<br>6）在<strong>内存</strong>中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。（生成的对象在堆内存，所有的对象的里边的字段，方法的访问入口在我们的堆里，这个入口，直通方法区。）（加载）<br>7） 连接 - 准备 （类变量的初始化，有类变量的前提是有个类）（初始化 “零”值）</p><p>？） 连接 - 解析<br>？）连接 - 验证 - 符号引用验证</p><p>相对于类加载过程的其他阶段，<strong>非数组类型的加载阶段</strong>是开发人员可控性最强的阶段。加载阶段既可以使用Java虚拟机里内置的类加载器来完成，也可以由用户自定义的类加载器去完成（<strong>重写一个类加载器的findClass()或loadClass()方法</strong>）</p><p>对于<strong>数组类</strong>而言，情况就有所不同，数组类<strong>本身不通过类加载器创建</strong>，它是<strong>由Java虚拟机直接在内存中动态构造出来的</strong>。但数组类与类加载器仍然有很密切的关系，因为数组类的<strong>元素类型</strong>最终还是要靠类加载器来完成加载，一个数组类（下面简称为C）创建过程遵循以下规则：</p><p>Ø·如果数组的组件类型是引用类型，那就递归采用定义的加载过程去加载这个组件类型，<strong>数组C将被标识在加载该组件类型的类加载器的类名称空间上</strong>（例如一个String类型的数组，哪个类加载器加载的String这个类，那么就把数组C标识到哪个类加载器的类名称空间上）（这点很重要，<strong>一个类型必须与类加载器一起确定唯一性</strong>）。</p><p>Ø·如果数组的组件类型不是引用类型（例如int[]数组的组件类型为int），Java虚拟机将会把数组C标记为与<strong>启动类加载器</strong>关联。</p><h4 id="3-类加载过程-连接-验证"><a href="#3-类加载过程-连接-验证" class="headerlink" title="3.类加载过程 - 连接 - 验证"></a>3.<strong>类加载过程</strong> <strong>-</strong> <strong>连接</strong> <strong>-</strong> <strong>验证</strong></h4><p><strong>加载阶段与连接阶段的部分动作</strong>（如一部分字节码文件格式验证动作）<strong>是交叉进行的</strong>，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的<strong>开始时间</strong>仍然保持着固定的先后顺序。</p><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p><p>验证阶段大致上会完成下面四个阶段的检验动作：<strong>文件格式验证、元数据验证、字节码验证和符号引用验证</strong>。</p><ul><li><p><strong>文件格式验证</strong></p><ul><li>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。主要有以下几个方面：<ul><li>是否以魔数0xCAFEBABE开头。</li><li>主、次版本号是否在当前Java虚拟机接受范围之内。</li><li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。</li></ul></li><li>实际上第一阶段的验证点还远不止这些，上面所列的只是从HotSpot虚拟机源码中摘抄的一小部分内容，该验证阶段的主要目的是保证输入的<strong>字节流能正确地解析并存储于方法区之内</strong>。<strong>这阶段的验证是基于二进制字节流进行的</strong>，<strong>只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储</strong>，所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。</li></ul></li><li><p><strong>元数据验证</strong></p><ul><li>对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求，主要包括：<ul><li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</li><li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li></ul></li><li>总之该阶段的验证就是检查是否存在与《Java语言规范》相悖的元数据信息</li></ul></li><li><p><strong>字节码验证</strong></p></li></ul><ul><li>阶段对类的方法体<strong>（Class文件中的Code属性）进行校验分析</strong>，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，例如：<ul><li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。</li><li>保证方法体中的类型转换总是有效的。</li><li>但是，它所消耗的验证时间在 类加载的过程里。能不能把这部分验证，在我们的javac 编译为class文件的时候，就做一些东西呢？<ul><li>Java虚拟机的设计团队为了避免过多的执行时间消耗在字节码验证阶段中，<strong>在JDK 6之后的Javac编译器和Java虚拟机里进行了一项联合优化</strong>，<strong>把尽可能多的校验辅助措施挪到Javac编译器里进行。</strong>具体做法是给方法体Code属性的属性表中新增加了一项名为“StackMapTable”的新属性，这项属性记录了方法体所有的基本块开始时<strong>本地变量表和操作数栈</strong>应有的状态，在字节码验证期间，Java虚拟机就不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中的记录是否合法即可。<strong>这样就将字节码验证的类型推导转变为类型检查</strong>，从而节省了大量校验时间。</li></ul></li></ul></li></ul><ul><li><p><strong>符号引用验证</strong></p><ul><li><strong>最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的解析阶段中发生</strong>。符号引用保存在常量池中，无非包括了java.lang.String或者java.lang.Object，这个阶段的验证目的是确保解析行为能正常执行，主要包括：<ul><li>能否根据符号引用中全限定名找到对应的类。</li><li>指定类中是否存在符合引用的方法和字段。</li><li>符号引用中的类、字段、方法的可访问性是否可被当前类访问。</li></ul></li><li><strong>验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但却不是必须要执行的阶段</strong>，如果对自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码都十分自信，可以通过-<strong>Xverify：none</strong>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</li></ul></li></ul><h4 id="4-类加载过程-连接-准备"><a href="#4-类加载过程-连接-准备" class="headerlink" title="4.类加载过程 - 连接 - 准备"></a>4.<strong>类加载过程</strong> <strong>-</strong> <strong>连接</strong> <strong>-</strong> <strong>准备</strong></h4><p><strong>准备阶段是</strong>正式为类中定义的变量（即<strong>静态变量，被static修饰的变量</strong>）<strong>分配内存并设置类变量初始值的阶段</strong>，从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，在JDK 7及之前，HotSpot使用永久代来实现方法区；而在JDK 8及之后，<strong>类变量</strong>则<strong>会随着Class对象一起存放在Java堆中</strong></p><p>关于准备阶段，还有两个容易产生混淆的概念，<strong>首先</strong>是这时候进行内存分配的仅包括类变量(静态变量)，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。<strong>其次</strong>是这里所说的初始值<strong>“通常情况”</strong>下是数据类型的<strong>零值</strong>，假设一个类变量的定义为：</p><p>public static int value &#x3D; 123;</p><p>那变量value在准备阶段过后的初始值为0而不是123，因为这时尚未开始执行任何Java方法，而<strong>把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值为123的动作要到类的初始化阶段才会被执行。</clinit></strong></p><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231212184431988.png" class title="image-20231212184431988"><p><strong>上面提到在“通常情况”下初始值是零值，那言外之意是相对的会有某些“特殊情况”：</strong>比如，如果类字段的字段表下边属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值，假设上面类变量value的定义修改为 </p><p>public static final int value &#x3D; 123;</p><p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p><h4 id="5-类加载过程-连接-解析"><a href="#5-类加载过程-连接-解析" class="headerlink" title="5.类加载过程 - 连接 - 解析"></a>5.类加载过程 - 连接 - 解析</h4><p>解析阶段是Java虚拟机将常量池内的<strong>符号引用</strong>替换为<strong>直接引用</strong>的过程</p><p>Ø·符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量如String，只要使用时能无歧义地定位到目标即可。</p><p>Ø·直接引用：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。</p><p>《Java虚拟机规范》之中并未规定解析阶段发生的具体时间，<strong>只要求了在执行anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield和putstatic</strong>这17个用于操作符号引用的字节码<strong>指令之前</strong>，完成解析即可。</p><p>对同一个符号引用进行多次解析请求是很常见的事情，除invokedynamic指令以外，虚拟机实现可以对第一次解析的结果进行缓存，譬如在运行时直接引用常量池中的记录，并把常量标识为已解析状态，从而避免解析动作重复进行。而invokedynamic指令动态的进行加载，动态的进行解析，这里“动态”的含义是指必须等到程序实际运行到这条指令时，解析动作才能进行。解析动作主要针对<strong>类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行</strong>，分别对应于常量池的<strong>CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info</strong>、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_Dyna-mic_info和CONSTANT_InvokeDynamic_info 8种常量类型</p><h4 id="6-类加载过程-初始化"><a href="#6-类加载过程-初始化" class="headerlink" title="6.类加载过程 - 初始化"></a>6.<strong>类加载过程</strong> <strong>-</strong> <strong>初始化</strong></h4><p>进行<strong>准备</strong>阶段时，<strong>静态变量</strong>已经赋过一次系统要求的<strong>初始零值</strong>，而在初始化阶段，则会根据编码去初始化类变量和其他资源。我们也可以从另外一种更直接的形式来表达：<strong>初始化阶段就是执行类构造器<clinit>()方法的过程。</clinit></strong></p><p><clinit>()并不是程序员在Java代码中直接编写的方法，它是<strong>Javac</strong>编译器的自动生成物</clinit></p><p><clinit>()方法是由编译器自动收集类中的<strong>所有类变量的赋值动作</strong>和<strong>静态代码块（static{}块）中的语句合并产生的， <clinit>()方法与类的构造函数（即实例构造器<init>()方法）不同，它不需要显式地调用父类构造器</init></clinit></strong>，Java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。因此在Java虚拟机中<strong>第一个被执行的<clinit>方法的类型肯定是java.lang.Object</clinit></strong>。由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</clinit></clinit></clinit></clinit></p><p><clinit>()方法对于类或接口来说<strong>并不是必需</strong>的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。</clinit></clinit></p><p>接口中不能使用静态语句块，但仍然有<strong>变量初始化的赋值操作</strong>，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，<strong>执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。</clinit></clinit></strong>此外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。</clinit></clinit></p><p>Java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<clinit>()方法（并发编程篇 <strong>–</strong> 双重检查锁 <strong>–</strong> 通过实例化我们的类进行的双重检查锁实现。static变量，只有一个线程能执行clinit 方法），其他线程都需要阻塞等待，直到活动线程执行完毕<clinit>()方法。</clinit></clinit></clinit></p><ul><li>但是对于初始化阶段，《Java虚拟机规范》则是严格规定了<strong>有且只有</strong>以下六种情况必须立即对类进行“初始化”：</li></ul><p>1）遇到new、getstatic、putstatic或invokestatic这四条字节码指令时。能够生成这四条指令的典型Java代码场景有<strong>：</strong></p><p>·使用new关键字实例化对象的时候<strong>。</strong></p><p>·读取或设置一个类型的静态字段（被final修饰<strong>、</strong>已在编译期把结果放入常量池的静态字段除外）的时候<strong>。</strong></p><p>·调用一个类型的静态方法的时候。</p><p>2）使用java.lang.reflect包的方法对类型进行反射调用的时候。</p><p>3）当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化<strong>。</strong></p><p>4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p><p>5）当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</p><p>6）当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个<strong>接口的实现类发生了初始化</strong>，那该接口要在其之前被初始化。</p><p>以上六种场景中的行为称为<strong>对一个类型进行主动引用</strong>。</p><ul><li><p>初始化的典型代码案例</p><ul><li><pre><code class="java">class Parent &#123;    static &#123;        System.out.println(&quot;Parent init!&quot;);    &#125;    public static int value = 123;    public static final int value2 = 456;&#125;class Child extends Parent &#123;    static &#123;        System.out.println(&quot;Child init!&quot;);    &#125;&#125;public class SuperClass &#123;    public static void main(String[] args) &#123;//        System.out.println(Child.value2);        //知打印了 456. 还是没有触发 Parent的初始化。        //static final int 在 编译器 提前存储到 字段表的 属性表里的 constantvalue属性里。使用的时候        //直接使用，不会触发类的初始化。//        Parent[] pars = new Parent[2];        // 没有打印结果。说static代码块没有执行，说明Parent类没有初始化。但是我们看到了new关键字啊。        //new Parent[2]; JVM对应的指令是 ： newarray。 而newarray不会触发类的初始化。//        System.out.println(Child.value);        //打印结果： Parent init! // 123        // 因为我们value 这个static属性属于我们的parent类，如果想要调用 value，就需要初始化 Parent类        // 而不需要初始化 Child类。    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 7.类加载器</span><br><span class="line"></span><br><span class="line">启动类加载器：这个类加载器负责加载存放在**&lt;JAVA_HOME&gt;\lib目录**，或者**被-Xbootclasspath参数所指定的路径中存放的**，而且是Java虚拟机能够识别的（**按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载**）类库加载到虚拟机的内存中。</span><br><span class="line"></span><br><span class="line">·扩展类加载器：它负责加载**&lt;JAVA_HOME&gt;\lib\ext目录中**，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</span><br><span class="line"></span><br><span class="line">·应用程序类加载器：它负责加载**用户类路径**（ClassPath）上所有的类库。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</span><br><span class="line"></span><br><span class="line">  &#123;% asset_img image-20231212231709365.png image-20231212231709365 %&#125;</span><br><span class="line"></span><br><span class="line">* 双亲委派机制</span><br><span class="line">  - **双亲委派过程：**如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的**启动类加载器**中，只有当父加载器搜索范围中没有找到所需的类时，子加载器才会尝试自己去完成加载。</span><br><span class="line">  - 使用双亲委派模型好处</span><br><span class="line">    - 例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的**各种类加载器环境中**都能够保证是同一个类。反之，如果没有使用双亲委派模型，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object的类，并放在程序的ClassPath中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。（保证程序的安全性，类加载的有规则性）</span><br><span class="line">  - 对于任意一个类，**都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性**。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。**（确保类的唯一可确定性**）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 自定义类加载器(重写findClass方法)</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public class SelfClassLoader &#123;</span><br><span class="line">        public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">            ClassLoader myClassLoader = new ClassLoader() &#123;</span><br><span class="line">                @SneakyThrows</span><br><span class="line">                @Override</span><br><span class="line">                // 首先我们自定义的类加载器加载的SelfClassLoader 这个文件，如果没有自定义的类加载器，这个文件是应该被我们的 系统类加载器进行加载的。现在我们自定义了一个加载器，jvm为了保证只有一个类能够被加载，所以，我们的jvm中只有一份儿该类的信息。对于我们进行自定义类加载器的书写的时候，复写 findClass 永远不会破坏双亲委派。因为双亲委派的代码逻辑存在于 loadClass 这个方法中。对于我们这个例子来说，这个类其实就是被 系统类 加载器加载的。 哪怕我们的在代码中用自己的类加载器进行再次加载，也会在 Class&lt;?&gt; c = findLoadedClass(name); 从系统类加载器里获取该类。</span><br><span class="line">                protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">                    String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;;</span><br><span class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">                    byte[] b = new byte[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    return defineClass(name, b, 0, b.length);</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                @SneakyThrows</span><br><span class="line">                @Override</span><br><span class="line">                // 现在我的自定义类加载器复写了 loadClass 方法，里边没有双亲委派的任何逻辑。</span><br><span class="line">                // 对于我们这个自定义的类加载器加载的类，就会出现类名重复的问题。</span><br><span class="line">                // 我们不小心复写了 loadclass方法，破坏了我们双亲委派模型。导致 com.boot.jvm.SelfClassLoader 被我们的</span><br><span class="line">                // 系统类加载器和 自定义类加载器，进行了两次加载。而且最要命的是，我们系统类加载器标注的类名称空间是一份，</span><br><span class="line">                // 我们自定义的类加载器也标注了一份儿类名称空间。</span><br><span class="line">                // 由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性.</span><br><span class="line">                public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">                    String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;;</span><br><span class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">                    if(is == null) &#123;</span><br><span class="line">                        return super.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                        byte[] b = new byte[is.available()];</span><br><span class="line">                        is.read(b);</span><br><span class="line">    </span><br><span class="line">                    return defineClass(name, b, 0, b.length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">            Object obj = myClassLoader.loadClass(&quot;com.boot.jvm.SelfClassLoader&quot;).newInstance();</span><br><span class="line">            System.out.println(obj.getClass()); //com.boot.jvm.SelfClassLoader</span><br><span class="line">    </span><br><span class="line">            System.out.println(obj // com.boot.jvm.SelfClassLoader</span><br><span class="line">                    instanceof com.boot.jvm.SelfClassLoader);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>自定义类加载器的使用场景</p><ul><li>大家都用过class文件的反编译工具，发现 class文件反编译为 java 文件，可读性还是很不错的。有一些企业，为了保障核心代码不被反编译器反编译，要将我们的class文件再进行一次文件加密。 加密后的class文件不能够被 jvm直接加载，此时需要我们自定义一个类加载器将该class文件进行解密之后，再加载到jvm。</li><li>有时候，我们需要通过一些网络的文件，zip文件，db存储的class二进制文件，进行jvm的加载，这个时候，由于我们的加载源不同，加载文件类型不同，会有不同的自定义的类加载器。</li></ul></li></ul><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><h4 id="1-运行时数据区概述及程序计数器"><a href="#1-运行时数据区概述及程序计数器" class="headerlink" title="1.运行时数据区概述及程序计数器"></a>1.运行时数据区概述及程序计数器</h4><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分以下几个不同的数据区域。</p><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231213134147424.png" class title="image-20231213134147424"><ul><li><p>程序计数器</p><ul><li><p>程序计数器可以看作是记录当前线程所执行的字节码的行号指示器<strong>。通过改变这个计数器的值来选取下一条需要执行的字节码指令，</strong>分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于Java虚拟机的多线程是通过线程轮流切换、处理器分配执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，所以存放在线程的私有区域</strong></p><p>如果线程正在执行的是一个Java方法，这个<strong>计数器记录的是正在执行的虚拟机字节码指令的地址</strong>；<strong>如果正在执行的是本地（Native）方法，这个计数器值则应为空</strong>。</p><p><strong>此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</strong></p></li></ul></li></ul><h4 id="2-堆"><a href="#2-堆" class="headerlink" title="2.堆"></a>2.堆</h4><p>Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的<strong>唯一目的就是存放对象实例</strong>，Java世界里几乎所有的对象实例都在这里分配内存。但是随着逃逸分析技术的日渐强大，<strong>栈上分配、标量替换</strong>优化手段的出现，让Java对象实例都分配在堆上也渐渐变得不是那么绝对了。</p><p>Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。</p><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231213155621199.png" class title="image-20231213155621199"><ul><li><p><strong>堆大小 &#x3D; 新生代 + 老年代</strong>。堆的大小可通过参数–Xms（堆的初始容量）、-Xmx（堆的最大容量） 来指定。</p><ul><li>其中，<strong>新生代被细分为 Eden 和 两个 Survivor 区域</strong>，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。<strong>默认的，Edem : from : to &#x3D; 8 : 1 : 1</strong> 。(可以通过参数 –XX:SurvivorRatio 来设定 )</li></ul></li><li><p>JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。新生代实际可用的内存空间为 9&#x2F;10 (即 90%) 的新生代空间。</p></li></ul><h4 id="3-Java对象的创建过程"><a href="#3-Java对象的创建过程" class="headerlink" title="3.Java对象的创建过程"></a>3.Java对象的创建过程</h4><p>Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常<strong>（除了复制、反序列化以外）</strong>仅仅是一个new关键字而已，而在虚拟机中，对象（仅限于普通Java对象，不包括数组和Class对象等）的创建共有五步：</p><ol><li><p>当Java虚拟机遇到一条字节码new指令时，<strong>首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用</strong>(例如：new String()的时候，能不能常量池中找到Ljava&#x2F;lang&#x2F;String这个符号引用)，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程；</p></li><li><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存(<strong>对象所需内存的大小在类加载完成后便可完全确定</strong>)。为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。</p><ul><li><p>假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为<strong>“指针碰撞”</strong>。</p></li><li><p>假设Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，<strong>虚拟机就必须维护一个列表</strong>，<strong>记录上哪些内存块是可用的</strong>，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为<strong>“空闲列表”</strong>。</p></li><li><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除算法的收集器时，只能采用较为复杂的空闲列表来分配内存。</p><ul><li><p>对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p><ul><li><p>解决这个问题有两种可选方案：</p><p>1）一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；</p><p>2）每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，<strong>只有本地缓冲区用完了要分配新的缓存区时才需要同步锁定(使用CAS)。</strong>虚拟机是否使用TLAB，可以通过-XX：+&#x2F;-UseTLAB参数来设定。</p></li></ul></li></ul></li></ul></li><li><p>内存分配完成之后，虚拟机必须将分配到的内存空间都初始化为零值（连接 - 准备），如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。<strong>这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用</strong></p></li><li><p>接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p></li><li><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象创建才刚刚开始,这时执行构造函数，即Class文件中的<init>()方法。一般来说，new指令之后会接着执行<init>()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</init></init></p></li></ol><h4 id="4-Java对象的内存布局"><a href="#4-Java对象的内存布局" class="headerlink" title="4.Java对象的内存布局"></a>4.<strong>Java对象的内存布局</strong></h4><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头、实例数据和对齐填充。</p><ul><li>对象头<ul><li>HotSpot虚拟机对象的对象头部分包括两类信息。<ul><li>第一类是用于存储对象<strong>自身的运行时数据</strong>，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别为32个比特和64个比特，官方称它为“Mark Word”。</li><li>对象头的另外一部分是类型指针，即<strong>对象指向它的类型元数据的指针</strong>，Java虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，具体讨论看下节（如何定位对象）。此外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。</li></ul></li></ul></li><li>实例数据<ul><li>实例数据部分是对象真正存储的有效信息，即我们在<strong>程序代码里面所定义的各种类型的字段内容</strong>，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。这部分的存储顺序会受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配顺序为longs&#x2F;doubles、ints、shorts&#x2F;chars、bytes&#x2F;booleans、oops（Ordinary Object Pointers，普通对象指针），从以上默认的分配策略中可以看到，<strong>相同宽度的字段总是被分配到一起存放</strong>，在满足这个前提条件的情况下，<strong>在父类中定义的变量会出现在子类之前</strong>。如果HotSpot虚拟机的+XX：CompactFields参数值为true（默认就为true），那<strong>子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。</strong></li></ul></li><li>对齐填充<ul><li>这并不是必然存在的，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求<strong>对象起始地址</strong>必须是8字节的整数倍，换句话说就是<strong>任何对象的大小都必须是8字节的整数倍。</strong>对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</li></ul></li></ul><h4 id="5-Java对象的访问定位"><a href="#5-Java对象的访问定位" class="headerlink" title="5.Java对象的访问定位"></a>5.<strong>Java对象的访问定位</strong></h4><p>对象访问方式主要有使用句柄和直接指针两种：</p><ul><li>直接指针<ul><li>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销，如图</li><li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231213171813766.png" class title="image-20231213171813766"></li><li>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本</li></ul></li><li>句柄<ul><li>如果使用句柄访问的话，Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息</li><li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231213172104081.png" class title="image-20231213172104081"></li><li>使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时使用标记整理算法，移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</li></ul></li></ul><h4 id="6-方法区"><a href="#6-方法区" class="headerlink" title="6.方法区"></a>6.方法区</h4><p>方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等数据。到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了JDK 8，终于完全废弃了永久代的概念，改用元空间来代替，把JDK 7中永久代还剩余的内容全部移到元空间中。<strong>方法区就像一个抽象接口，永久代和元空间就像方法区接口的两个具体实现</strong></p><p>《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。<strong>这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，</strong>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的(例如动态加载类型信息)。</p><h4 id="7-运行时常量池"><a href="#7-运行时常量池" class="headerlink" title="7.运行时常量池"></a>7.运行时常量池</h4><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。对于运行时常量池，<strong>除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。</strong></p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备<strong>动态性</strong>，在运行期间调用String类的intern()方法也可以将新的常量放入池中</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h4 id="8-Java虚拟机栈与本地方法栈"><a href="#8-Java虚拟机栈与本地方法栈" class="headerlink" title="8.Java虚拟机栈与本地方法栈"></a>8.<strong>Java</strong>虚拟机栈与本地方法栈</h4><p>与程序计数器一样，Java虚拟机栈也是线程<strong>私有</strong>的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于<strong>存储局部变量表、操作数栈、动态连接、方法出口等信息</strong>(后续详细解读)。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>局部变量表存放了编译期可知的各种Java虚拟机<strong>基本数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄）和<strong>returnAddress类型</strong>（指向了一条字节码指令的地址）。</p><p>这些数据类型在局部变量表中的存储空间<strong>以局部变量槽来表示</strong>，<strong>其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。</strong>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>这个内存区域的异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；</p><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别<strong>只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</strong></p><h3 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h3><h4 id="1-判断对象是否存活"><a href="#1-判断对象是否存活" class="headerlink" title="1.判断对象是否存活"></a>1.<strong>判断对象是否存活</strong></h4><ul><li><p><strong>引用计数算法</strong>(基本没人用)</p><ul><li><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；<strong>任何时刻计数器为零的对象就是不可能再被使用的。</strong>这个简单的算法有很多例外情况没有考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决<strong>对象之间相互循环引用</strong>的问题。</p><p>举个简单的例子：对象objA和objB都有字段instance，赋值令objA.instance&#x3D;objB及objB.instance&#x3D;objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。 <strong>所以</strong>主流的Java虚拟机不选用该算法。</p></li></ul></li><li><p><strong>可达性分析算法</strong>(比较主流)</p><ul><li><p>这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再被使用的。</p><p>如图所示，对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的，因此它们将会被判定为可回收的对象。</p><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231213215736441.png" class title="image-20231213215736441"></li><li><p>固定可作为GC Roots的对象(主要记忆前五个和临时GC Roots对象)：</p><ul><li>所有被同步锁（<strong>synchronized</strong>关键字）持有的对象。</li><li>在方法区中<strong>静态属性引用的对象</strong>，譬如Java类的引用类型的静态变量。</li><li>在方法区中<strong>常量引用的对象</strong>，譬如字符串常量池里的引用。</li><li>在虚拟机栈中<strong>reference引用的对象</strong>，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li><li>Java<strong>虚拟机内部的引用</strong>，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li><li><em>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</em></li><li><em>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</em></li><li>除了这些固定的GC Roots集合以外，根据<strong>用户所选用的垃圾收集器以及当前回收的内存区域不同</strong>，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。例如，如果只针对Java堆中某一块区域发起垃圾收集时（如最典型的只针对新生代的垃圾收集），这个区域里的对象完全有可能被位于堆中其他区域的对象所引用(例如老年代)，这时候就需要将这些关联区域的对象(也就是老年代对象)也临时加入GC Roots集合中去，才能保证可达性分析的正确性。</li></ul></li><li><p>Java中的引用类型(强度由强到弱)：</p><ul><li>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj&#x3D;new Object()”这种引用关系。无论任何情况下，<strong>只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</strong></li><li>软引用是用来描述一些还有用，但非必须的对象。<strong>如果一次垃圾回收之后，系统发现仍会发生OOM时，这时就会回收这些被软引用引用的对象。</strong>在JDK 1.2版之后提供了SoftReference类来实现软引用。</li><li>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象，<strong>无论当前内存是否足够，只能生存到下一次垃圾收集发生为止。</strong>在JDK 1.2版之后提供了WeakReference类来实现弱引用。</li><li>虚引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的<strong>唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</strong></li></ul></li></ul></li></ul><h4 id="2-如果对象不可达，一定会被回收吗？"><a href="#2-如果对象不可达，一定会被回收吗？" class="headerlink" title="2.如果对象不可达，一定会被回收吗？"></a>2.<strong>如果对象不可达，一定会被回收吗？</strong></h4><p>不一定。即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历<strong>两次标记</strong>过程：<strong>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记</strong>，随后进行一次筛选，<strong>筛选的条件是此对象是否有必要执行finalize()方法</strong>。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</p><p>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由<strong>一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。</strong>这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。<strong>finalize()方法是对象逃脱死亡命运的最后一次机会</strong>，<strong>稍后收集器将对F-Queue中的对象进行第二次小规模的标记</strong>，<strong>只要这次标记发现队列中的某个对象重新与引用链上的任何一个对象建立关联，就会被移出“即将回收”的集合；</strong>如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</p><p>但是，finalize()方法它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已被官方明确声明为不推荐使用的语法。</p><h4 id="3-再谈方法区回收"><a href="#3-再谈方法区回收" class="headerlink" title="3.再谈方法区回收"></a>3.<strong>再谈方法区回收</strong></h4><p>方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。</p><p><strong>判定一个常量是否“废弃”还是相对简单，但是要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻。需要同时满足下面三个条件：</strong></p><ol><li><p>该类及其派生子类的所有实例都已经被回收。</p></li><li><p>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，否则通常是很难达成的。</p></li><li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li></ol><h4 id="4-垃圾收集算法-分代收集理论"><a href="#4-垃圾收集算法-分代收集理论" class="headerlink" title="4.垃圾收集算法 - 分代收集理论"></a>4.<strong>垃圾收集算法</strong> <strong>-</strong> <strong>分代收集理论</strong></h4><p>1）<strong>弱分代假说</strong>：绝大多数对象都是朝生夕灭的。</p><p>2）<strong>强分代假说</strong>：熬过越多次垃圾收集过程的对象就越难以消亡。</p><p>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄分配到不同的区域之中存储。显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</p><p>3）<strong>跨代引用假说</strong>：跨代引用相对于同代引用来说仅占极少数。</p><p>因为如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。</p><p>依据这条假说，我们就<strong>不应再为了少量的跨代引用去扫描整个老年代</strong>，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为<strong>“记忆集”</strong>），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描</p><h4 id="5-几种垃圾收集算法-按出现时间"><a href="#5-几种垃圾收集算法-按出现时间" class="headerlink" title="5.几种垃圾收集算法(按出现时间)"></a>5.几种垃圾收集算法(按出现时间)</h4><ul><li><p><strong>标记清除算法</strong></p><ul><li>1960年出现，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</li><li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231214210455031.png" class title="image-20231214210455031"><ul><li>优点：最基础的收集算法，是因为后续的收集算法大多都是以标记-清除算法为基础</li><li>缺点：第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低(这像一句废话，因为任何收集算法都会随着对象数量的增多，效率下降)；第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，<strong>空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</strong></li></ul></li></ul></li><li><p><strong>标记复制算法</strong></p><ul><li>1969年出现，它将可用<strong>内存按容量划分为大小相等的两块，每次只使用其中的一块</strong>。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</li><li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231214211040907.png" class title="image-20231214211040907"><ul><li>优点：解决了垃圾清除算法产生的内存碎片问题</li><li>缺点：如果内存中多数对象都是存活的，这种算法将会产生大量的内存间<strong>复制的开销</strong>，而且这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一点。</li></ul></li></ul></li><li><p><strong>标记整理算法</strong></p><ul><li><p>1974年出现，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存</p><p>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策</p></li><li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231214211837723.png" class title="image-20231214211837723"><ul><li>优点：没有内存碎片，也不会浪费空间</li><li>缺点：如果移动存活对象，尤其是在老年代这种每次回收都有<strong>大量对象存活</strong>区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行<strong>“Stop The World”</strong></li></ul></li></ul></li><li><p><strong>Appel式回收</strong></p><ul><li>1989年出现，Appel式回收的具体做法是把新生代分为一块较大的<strong>Eden空间和两块较小的Survivor空间</strong>，<strong>每次分配内存只使用Eden和其中一块Survivor。</strong>发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1</li><li>结合了标记复制和标记整理算法的思想，既解决了标记复制出现的空间浪费问题，又解决了标记整理出现的Stop The World问题</li></ul></li></ul><ul><li>Appel式回收为什么不需要Stop The World？<ul><li>因为Appel式回收是要把存活的对象放到一个指定的Survivor区，然后剩余的其他区域在垃圾收集结束以后一定是空的，可以存放对象的，所以即使存活的对象在往Survivor进行复制，也不影响其他对象继续向Eden添加对象，而标记整理算法，在完全整理完成之前无法确定那些空间可以使用，所以需要Stop The World</li></ul></li></ul><h4 id="6-垃圾收集-根节点枚举"><a href="#6-垃圾收集-根节点枚举" class="headerlink" title="6.垃圾收集 - 根节点枚举"></a>6.<strong>垃圾收集</strong> <strong>-</strong> <strong>根节点枚举</strong></h4><p>固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与虚拟机栈中reference引用的对象，迄今为止，<strong>所有</strong>收集器在根节点枚举这一步骤时都是必须暂停用户线程的，因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰。<strong>根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行</strong>，因为如果根节点集合的对象引用关系还在不断变化，那么分析结果准确性也就无法保证。这是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因</p><ul><li>但是现在Java应用越做越庞大，光是方法区的大小就常有数百上千兆，里面的类、常量等更是恒河沙数，若要逐个检查以这里为起源的引用肯定得消耗不少时间。这样合适吗？<ul><li>当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有reference引用和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。在HotSpot的解决方案里，是使用一组称为OopMap的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象什么偏移量是什么类型的数据计算出来，在即时编译过程中，<strong>也会在特定的位置记录下栈里和寄存器里哪些位置是引用</strong>。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等开始查找。</li></ul></li></ul><h4 id="7-垃圾收集-安全点"><a href="#7-垃圾收集-安全点" class="headerlink" title="7.垃圾收集 - 安全点"></a>7.<strong>垃圾收集</strong> <strong>-</strong> <strong>安全点</strong></h4><p>在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举，但一个很现实的问题随之而来：导致OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外存储空间，这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。</p><p>实际上HotSpot也的确没有为每条指令都生成OopMap，只是上述在“特定的位置”记录了这些信息，这些位置被称为安全点。有了安全点的设定，也就决定了<strong>用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集</strong>，而是强制要求必须执行到达安全点后才能够暂停。因此，安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的，<strong>“长时间执行”的最明显特征就是指令序列的复用，例如方法调用(线程在调用方法等待方法返回值的时间是无法预估的)、循环跳转、异常跳转等都属于指令序列复用</strong>，所以只有具有这些功能的指令才会产生安全点。</p><ul><li>如何在垃圾收集发生时让所有线程都跑到最近的安全点，然后停顿下来？<ol><li>抢先式中断在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。(几乎没人用)</li><li>主动式中断的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询检查这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。由于<strong>轮询操作在代码中会频繁出现</strong>，这要求它必须足够高效。HotSpot使用内存<strong>保护陷阱</strong>的方式，把<strong>轮询操作精简至只有一条汇编指令的程度。</strong>当需要暂停用户线程时，虚拟机把0x160100的内存页设置为不可读，那线程执行到<strong>test指令</strong>时就会产生一个自陷异常信号，然后线程就会到最近的一个安全点进行挂起等待</li></ol></li></ul><h4 id="8-垃圾收集-安全区域"><a href="#8-垃圾收集-安全区域" class="headerlink" title="8.垃圾收集 - 安全区域"></a>8.<strong>垃圾收集</strong> <strong>-</strong> <strong>安全区域</strong></h4><p>安全区域的出现是由于用户线程<strong>处于Sleep状态或者Blocked状态</strong>，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。</p><p><strong>安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化(例如上述的睡觉和阻塞)，</strong>因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的<strong>安全点</strong>。</p><p>当用户线程执行到安全区域里面的代码时，<strong>首先会标识自己已经进入了安全区域</strong>，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，线程继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</p><h4 id="9-垃圾收集-记忆集与卡表"><a href="#9-垃圾收集-记忆集与卡表" class="headerlink" title="9.垃圾收集 - 记忆集与卡表"></a>9.<strong>垃圾收集</strong> <strong>-</strong> <strong>记忆集与卡表</strong></h4><p>为解决对象跨代引用所带来的问题，垃圾收集器在<strong>新生代</strong>中建立了名为记忆集的数据结构，用以避免把整个老年代加进GC Roots扫描范围。事实上并不只是新生代、老年代之间才有跨代引用的问题，<strong>所有涉及部分区域收集行为的垃圾收集器，典型的如G1、ZGC，都会面临相同的问题，</strong>所以，记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。</p><p>记忆集不需要知道具体的引用细节，只需要知道某一区域是否存在跨代指向即可，所以为了降低维护成本，提供以下几种记忆精度：</p><ol><li><p>字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位），该字包含跨代指针。</p></li><li><p>对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。</p></li><li><p>卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</p></li></ol><ul><li>卡精度的实现<ul><li>“卡精度”所指的是用一种称为“卡表”的方式去实现记忆集，这也是目前最常用的一种记忆集实现形式，卡表最简单的形式可以只是一个字节数组，字节数组的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页”。一个卡页的内存中通常包含不止一个对象，<strong>只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏</strong>，没有则标识为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素即可</li><li>卡表是如何维护的，例如它们何时变脏、谁来把它们变脏？<ul><li>卡表元素何时变脏的答案是很明确的——有其他<strong>分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏</strong>，变脏时间点发生在引用类型字段赋值的那一刻。在HotSpot虚拟机里是通过<strong>写屏障技术</strong>维护卡表状态的。<strong>写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面</strong>，在引用对象赋值时会产生一个环形（Around）通知。应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦出现了跨代引用就会执行更新卡表的操作，虽然每次只要对引用进行更新，就会产生额外的开销，不过这个开销与Minor GC时扫描整个老年代的代价相比还是低得多的。</li></ul></li></ul></li></ul><h4 id="10-并发的可达性分析-三色标记"><a href="#10-并发的可达性分析-三色标记" class="headerlink" title="10.并发的可达性分析 - 三色标记"></a>10.<strong>并发的可达性分析</strong> <strong>-</strong> <strong>三色标记</strong></h4><p>从GC Roots出发，扫描整个堆上的对象，如果这个时候停止用户线程，虽然可以保证扫描结果的准确，但是随着堆的增大会导致用户线程的停顿时间过长，但是如果不停顿用户线程，就会出现某些错误情况：一种是把原本消亡的对象错误标记为存活，这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾而已，下次收集清理掉就好(例如，扫描过的黑色对象断开了某个引用)。另一种是把原本存活的对象错误标记为已消亡，这就是非常致命的后果了(例如，正在扫描的灰色对象断开了某个引用，同时扫描过的黑色引用又引用了灰色断开的引用)</p><ul><li><p>可达性分析过程中的三色标记：</p><ul><li>白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</li><li>黑色：表示对象已经被垃圾收集器访问过，<strong>且这个对象的所有引用都已经扫描过</strong>。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。</li><li>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。（大概率将来也是存活对象）</li></ul></li><li><p>当且仅当以下<strong>两个条件同时满足</strong>时，会产生“该存活的对象消失”的问题，即原本应该是黑色的对象被误标为白色：</p><ol><li><p>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</p></li><li><p>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</p></li></ol></li><li><p>解决对象消失的办法</p><ul><li><strong>增量更新</strong>：要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</li><li><strong>原始快照</strong>：要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，也将这个要删除的引用记录下来，在并发扫描结束之后，对这些记录进行重新扫描</li></ul></li></ul><h4 id="11-垃圾收集器概述"><a href="#11-垃圾收集器概述" class="headerlink" title="11.垃圾收集器概述"></a>11.垃圾收集器概述</h4><p>下图展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用</p><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231215003344397.png" class title="image-20231215003344397"><h4 id="12-三款新生代收集器"><a href="#12-三款新生代收集器" class="headerlink" title="12.三款新生代收集器"></a>12.三款新生代收集器</h4><ul><li><p><strong>Serial收集器</strong></p><ul><li>Serial收集器是最基础、历史最悠久的收集器。这个收集器是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它<strong>只会使用一个处理器或一条收集线程去完成垃圾收集工作</strong>，更重要的是强调在它进行垃圾收集时，<strong>必须暂停其他所有工作线程，</strong>直到它收集结束。</li><li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231215003854923.png" class title="image-20231215003854923"></li><li>迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方，那就是简单而高效（与其他收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的；对于单核处理器或处理器核心数较少的环境来说，<strong>Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</strong></li></ul></li><li><p><strong>ParNew收集器</strong></p><ul><li><strong>ParNew收集器实质上是Serial收集器的多线程并行版本</strong>，除了同时使用多条线程进行垃圾收集之外，其余的行为与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。</li><li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231215004521431.png" class title="image-20231215004521431"></li><li><strong>除了Serial收集器外，目前只有它能与CMS收集器配合工作。</strong>ParNew收集器在单核心处理器的环境中绝对不会有比Serial收集器更好的效果。当然，随着可以被使用的处理器核心数量的增加，ParNew对于垃圾收集时系统资源的高效利用还是很有好处的。它默认开启的收集线程数与处理器核心数量相同，可以使用-XX：ParallelGCThreads参数来限制垃圾收集的线程数。但是一般情况下都是直接使用默认配置，因为ParNew收集器在开启GC线程进行垃圾收集的时候，用户线程处于挂起状态，所以即使GC线程和处理器核数一样多也不会占用其他线程的资源</li></ul></li><li><p><strong>Parallel Scavenge收集器</strong></p><ul><li><p>Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器，Parallel Scavenge的诸多特性从表面上看和ParNew非常相似。但是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，<strong>而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量</strong>。</p></li><li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231215010027207.png" class title="image-20231215010027207"></li><li><p>停顿时间越短就越适合需要保证服务响应质量的程序，良好的响应速度能提升用户体验；而<strong>高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算的分析任务。</strong></p><p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是<strong>控制最大垃圾收集停顿时间</strong>的-XX：MaxGCPauseMillis参数以及直接<strong>设置吞吐量大小</strong>的-XX：GCTimeRatio参数。</p><p>-XX：MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值。不过，<strong>垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的</strong>：系统把新生代调得小一些，收集300MB新生代肯定比收集500MB快，但这也直接导致垃圾收集发生得更频繁，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。</p><p>-XX：GCTimeRatio参数的值则应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。譬如把此参数设置为19，那允许的最大垃圾收集时间就占总时间的5%（即1&#x2F;(1+19)），默认值为99，即允许最大1%（即1&#x2F;(1+99)）的垃圾收集时间。</p><p>除上述两个参数之外，Parallel Scavenge收集器还有一个参数-XX：+UseAdaptiveSizePolicy值得我们关注。这是一个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold）等细节参数了，<strong>虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量</strong>。这种调节方式称为垃圾收集的<strong>自适应的调节策略</strong>。但是使用之前需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用-XX：MaxGCPauseMillis参数（更关注最大停顿时间）或-XX：GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。<strong>自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性。</strong></p></li></ul></li></ul><h4 id="13-三款老年代处理器"><a href="#13-三款老年代处理器" class="headerlink" title="13.三款老年代处理器"></a>13.三款老年代处理器</h4><ul><li><p><strong>Serial Old收集器</strong></p><ul><li>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用<strong>标记-整理算法</strong>。这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。如果在服务端模式下，它也可能有两种用途：一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用，另外一种就是作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用</li><li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231215035037374.png" class title="image-20231215035037374"></li></ul></li><li><p><strong>Parallel Old收集器</strong></p><ul><li><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于<strong>标记-整理</strong>算法实现。这个收集器是直到JDK 6时才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于相当尴尬的状态，原因是如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old收集器以外别无选择，其他表现良好的老年代收集器，如CMS无法与它配合工作。由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用Parallel Scavenge收集器也未必能在整体上获得吞吐量最大化的效果。同样，由于单线程的老年代收集中无法充分利用服务器多处理器的并行处理能力，在老年代内存空间很大而且硬件规格比较高级的运行环境中，这种组合的总吞吐量甚至不一定比ParNew加CMS的组合来得优秀。</p><p><strong>直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的搭配组合，在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。</strong></p></li><li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231215035400044.png" class title="image-20231215035400044"></li></ul></li><li><p>CMS</p><ul><li><p>CMS收集器是一种以获取<strong>最短回收停顿时间</strong>为目标的收集器。希望系统停顿时间尽可能短，以给用户带来良好的交互体验。CMS收集器就非常符合这类应用的需求。</p><p>从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于标记-清除算法实现的，它的运作过程分为四个步骤，包括：</p><p>1）初始标记：“Stop The World” 初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快</p><p>2）并发标记：并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是<strong>不需要停顿用户线程，可以与垃圾收集线程一起并发运行</strong></p><p>3）重新标记：“Stop The World” 而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，如浮动垃圾和漏检的情况</p><p>4）并发清除：最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于标记清除不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</p></li><li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231215041314884.png" class title="image-20231215041314884"></li><li><p>CMS收集器的缺点：</p><ul><li>CMS收集器对处理器资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程而导致应用程序变慢，降低总吞吐量。<strong>CMS默认启动的回收线程数是（处理器核心数量+3）&#x2F;4</strong>，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，这时影响不大。但是当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大。</li><li>由于CMS收集器无法处理“浮动垃圾”，有可能出现“Con-current Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。同样也是<strong>由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集</strong>。可以调节参数-XX：CMSInitiatingOccu-pancyFraction的值来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。到了JDK 6时，CMS收集器的启动阈值就已经默认提升至92%。但这又会更容易面临另一种风险：要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“Con-current Mode Failure”，这时候虚拟机将不得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了。(总之，存活的对象＋浮动垃圾+用户线程新产生的对象 如果超过了内存上限就会出现Con-current Mode Failure，然后就只能叫Serial Old收集器来进行单线程的收集)</li><li>还有最后一个缺点，CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。</li></ul></li></ul></li></ul><h4 id="14-Garbage-First收集器"><a href="#14-Garbage-First收集器" class="headerlink" title="14.Garbage First收集器"></a>14.<strong>Garbage First收集器</strong></h4><ul><li><p>概述</p><ul><li><p>Garbage First收集器开创了收集器面向局部收集的设计思路和<strong>基于Region的内存布局形式。</strong>G1是一款主要面向服务端应用的垃圾收集器。<strong>JDK 9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器</strong>，而CMS则沦落至被声明为不推荐使用（Deprecate）的收集器。</p><p>在G1收集器出现之前的所有其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），再要么就是整个Java堆（Full GC）。而G1跳出了这个樊笼，它可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。</p><p>G1开创的基于Region的堆内存布局是它能够实现这个目标的关键。虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：<strong>G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。</strong>收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。Region中还有一类特殊的Humongous区域，专门用来存储大对象。<strong>G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。</strong>每个Region的大小可以通过参数-XX：G1HeapRegionSize设定，取值范围为1MB～32MB，且应为2的N次幂。<strong>而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待</strong></p><p>虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。G1收集器之所以能建立可预测的停顿时间模型，是因为<strong>它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集</strong>。<strong>更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region</strong>。保证了G1收集器在有限的时间内获取尽可能高的收集效率。</p></li></ul></li><li><p>将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象如何解决？</p><ul><li>同样使用记忆集避免全堆作为GC Roots扫描，它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。和跨代引用维护的卡表，跨Region引用是“双向”卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”）比原来的卡表实现起来更复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃圾收集器有着更高的内存占用负担。</li></ul></li><li><p>在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？</p><ul><li><strong>CMS收集器采用增量更新算法实现，而G1收集器则是通过原始快照（SATB）算法来实现的。</strong>此外，垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上，程序要继续运行就肯定会持续有新对象被创建，G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。与CMS中的“Concurrent Mode Failure”失败会导致Full GC类似，如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行，导致Full GC而产生长时间“Stop The World”。</li></ul></li><li><p>怎样建立起可靠的停顿预测模型？</p><ul><li>G1收集器会记录每个区域进行回收能获得价值，并且还会记录每个区域回收需要的时候，同时根据指定的-XX：MaxGCPauseMillis参数(停顿时间的预期值)尽可能保证停顿时间在预期值以内</li></ul></li><li><p><strong>G1收集器运作的四个步骤：</strong></p><ul><li><p>初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短。–stop the world</p><p>并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</p><p>最终标记：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。(就是使用原始快照的方式对对象进行重新扫描) –stop the world</p><p>筛选回收：对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。 –stop the world</p></li><li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231215060206527.png" class title="image-20231215060206527"></li><li><p>G1收集器除了并发标记之外都需要stop the world</p></li></ul></li><li><p>G1和CMS的对比</p><ul><li><p>相比CMS，G1的优点有很多，<strong>可以指定最大停顿时间、分Region的内存布局、按收益动态确定回收集</strong>这些创新性设计。与CMS的“标记-清除”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片</p><p>比起CMS，G1的弱项在于在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比CMS要高。就内存占用来说，虽然G1和CMS都使用卡表来处理跨代指针，但G1的卡表实现更为复杂，而且堆中每个Region，无论扮演的是新生代还是老年代角色，都必须有一份卡表；相比起来CMS的卡表就相当简单，只有唯一一份，而且只需要处理老年代到新生代的引用</p></li></ul></li></ul><h4 id="15-内存分配策略"><a href="#15-内存分配策略" class="headerlink" title="15.内存分配策略"></a>15.<strong>内存分配策略</strong></h4><ul><li><p><strong>对象优先在Eden分配，大对象直接进入老年代</strong></p><ul><li><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p><p>大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组，HotSpot虚拟机提供了-XX：PretenureSizeThreshold参数，<strong>指定大于该设置值的对象直接在老年代分配</strong>，这样做的目的就是<strong>避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作。</strong></p></li></ul></li><li><p><strong>长期存活的对象将进入老年代</strong></p><ul><li>虚拟机给每个对象定义了一个分代年龄计数器，存储在对象头中。对象通常在Eden区里诞生，如果经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置。（对于这个对象年龄的设置，一般情况下，不要去做任何变更。如果我们的年轻代里边的新生对象大部分都是存活1岁，只有特别小的部分会存活时间很长，并且程序长时间运行的时候，这部分大对象所占用的空间几乎不变。可以考虑适当增大这个年龄。）</li></ul></li><li><p>如果年龄不够配置的年龄，并且也不属于大对象，那么一定不会进入老年代吗？</p><ul><li>为了能更好地适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄必须达到-XX：MaxTenuringThreshold才能晋升老年代，<strong>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX：MaxTenuringThreshold中要求的年龄。</strong></li></ul></li><li><p><strong>空间分配担保策略及垃圾回收过程</strong></p><ul><li>在发生Minor Gc之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看-XX: HandlePromotionFailure参数的设置值<strong>是否允许担保失败</strong>（Handle Promotion Failure) ;如果允许，那会继续检查老年代最大可用的连续空间是否大于<strong>历次晋升到老年代对象的平均大小</strong>，如果大于， 将尝试进行一次Minor Gc，尽管这次Minor Gc是有风险的;如果小于，或者-XX:HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。</li></ul></li></ul><h3 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h3><h4 id="1-运行时栈帧结构"><a href="#1-运行时栈帧结构" class="headerlink" title="1.运行时栈帧结构"></a>1.<strong>运行时栈帧结构</strong></h4><ul><li><p>概述</p><ul><li><p>Java虚拟机以方法作为最基本的执行单元，“栈帧”则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈的栈元素。<strong>栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。</strong>每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p><p>在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中。换言之，<strong>一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式</strong>。</p><p>一个线程中的方法调用链可能会很长，以Java程序的角度来看，同一时刻、同一条线程里面，在调用堆栈的所有方法都同时处于执行状态。<strong>而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的</strong>。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作</p></li><li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231215071625783.png" class title="image-20231215071625783"></li></ul></li></ul><h4 id="2-局部变量表"><a href="#2-局部变量表" class="headerlink" title="2.局部变量表"></a>2.局部变量表</h4><p>局部变量表的容量以变量槽为最小单位，没有规定每个槽的具体大小，只要求每个变量槽都能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据，它允许变量槽的长度可以随着处理器、操作系统或虚拟机实现的不同而发生变化</p><p>Java虚拟机通过索引定位的方式使用局部变量表，<strong>索引值的范围是从0开始至局部变量表最大的变量槽数量</strong>。如果访问的是32位数据类型的变量，索引N就代表了使用第N个变量槽（对于非静态的方法，第0个变量槽，放置的是this。），如果访问的是64位数据类型的变量，则说明会同时使用第N和N+1两个变量槽。<strong>对于两个相邻的共同存放一个64位数据的两个变量槽，虚拟机不允许采用任何方式单独访问其中的某一个。</strong></p><p>当一个方法被调用时，Java虚拟机会使用局部变量表来完成实参到形参的传递。如果执行的是实例方法（没有被static修饰的方法），那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从1开始的局部变量槽，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。</p><p><strong>为了尽可能节省栈帧耗用的内存空间，局部变量表中的变量槽是可以重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的变量槽就可以交给其他变量来重用。</strong></p><h4 id="3-操作数栈"><a href="#3-操作数栈" class="headerlink" title="3.操作数栈"></a>3.操作数栈</h4><p>操作数栈，同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。操作数栈元素可以是包括long和double在内的任意Java数据类型。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。Javac编译器的数据流分析工作保证了在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。</p><p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。譬如在<strong>做算术运算的时候是通过将运算涉及的操作数压入栈顶后调用运算指令来进行的</strong>，又譬如<strong>在调用其他方法的时候是通过操作数栈来进行方法参数的传递</strong>。举个例子，例如整数加法的字节码指令iadd，这条指令在运行的时候要求操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会把这两个int值出栈并相加，然后将相加的结果重新入栈。</p><p>两个不同栈帧作为不同方法的虚拟机栈的元素，是完全相互独立的。但是在大多虚拟机的实现里都会进行一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样上面的栈帧中不需要存储下面栈帧操作数栈里面的元素到自己的局部变量表，可以节约了一些空间，也无须进行额外的参数复制传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> i)</span> &#123; </span><br><span class="line"></span><br><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> getAdd(i);</span><br><span class="line">          <span class="keyword">return</span> j;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> in <span class="title function_">getAdd</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i +<span class="number">100</span>;   </span><br><span class="line">   <span class="comment">//最接近栈顶的两个元素已经存入了两个int型的数值</span></span><br><span class="line">  <span class="comment">// 好处就是 getAdd这个栈帧不需要存储 i 到局部变量表了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231215215427479.png" class title="image-20231215215427479"><h4 id="4-动态连接和方法返回地址"><a href="#4-动态连接和方法返回地址" class="headerlink" title="4.动态连接和方法返回地址"></a>4.<strong>动态连接</strong>和方法返回地址</h4><ul><li><p>动态连接</p><ul><li>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。通过第6章的讲解，我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。（后续方法调用中详细分解）。</li></ul></li><li><p>方法返回地址</p><ul><li><p>当一个方法开始执行后，只有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令退出该方法，被称为“正常调用完成”。另外一种退出方式是在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理。这种退出方法的方式称为“异常调用完成“。</p><p><strong>无论采用何种退出方式，在方法退出之后，都必须返回到最初方法被调用时的位置，程序才能继续执行，方法退出的过程实际上等同于把当前栈帧出栈，</strong>因此退出时可能执行的操作有：<strong>恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等</strong></p></li></ul></li></ul><h4 id="5-方法调用-解析调用"><a href="#5-方法调用-解析调用" class="headerlink" title="5.方法调用 - 解析调用"></a>5.<strong>方法调用</strong> <strong>-</strong> <strong>解析调用</strong></h4><p>方法调用并不等同于方法中的代码被执行，<strong>方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还未涉及方法内部的具体运行过程</strong>。一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（也就是之前说的直接引用）。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂，某些调用需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</p><p><strong>所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用</strong>，在类加载的解析阶段，会将其中的<strong>一部分</strong>符号引用转化为直接引用，即方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为解析调用。</p><p>调用不同类型的方法，字节码指令集里设计了不同的指令：</p><ul><li><p>invokestatic。用于调用静态方法。</p></li><li><p>invokespecial。用于调用实例构造器<init>()方法、私有方法和父类中的方法。</init></p></li><li><p>invokevirtual。用于调用所有的虚方法。</p></li><li><p>invokeinterface。用于调用接口方法，会在运行时再确定一个实现该接口的对象。</p></li><li><p>invokedynamic。先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。</p></li></ul><p><strong>只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本</strong>，Java语言里符合调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来这个条件的方法共有<strong>静态方法、私有方法、实例构造器、父类方法4种，再加上被final修饰的方法（尽管它使用invokevirtual指令调用）</strong>，这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为“非虚方法”，与之相反，其他方法就被称为“虚方法”。</p><p><strong>解析调用一定是个静态的过程，在编译期间就完全确定</strong>，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成。</p><p>而另一种主要的方法调用形式：分派调用则要复杂许多，它可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派。这两类分派方式两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派4种分派组合情况。</p><h4 id="6-方法调用-分派调用"><a href="#6-方法调用-分派调用" class="headerlink" title="6.方法调用 - 分派调用"></a>6.<strong>方法调用</strong> <strong>-</strong> <strong>分派调用</strong></h4><ul><li><p>静态分派</p><ul><li><p><strong>静态分派的最典型应用表现就是方法重载。静态分派发生在编译阶段，</strong>因此确定静态分派的动作实际上不是由虚拟机来执行的(静态分派是发生在编译期间，也就是说编译期间就固定了我们方法的版本；我们解析调用也是在编译期间确定了方法的版本。<strong>解析它是在类加载的过程中将我们的符号引用转化为直接引用; 静态分派方法调用的符号引用转为直接引用是发生在 运行期间</strong>)</p></li><li><pre><code class="java">public class StaticDispatch &#123;    static abstract class Human &#123;    &#125;    static class Man extends Human &#123;    &#125;    static class Woman extends Human &#123;    &#125;    public void sayHello(Human guy) &#123;        System.out.println(&quot;hello,guy!&quot;);    &#125;    public void sayHello(Man guy) &#123;        System.out.println(&quot;hello,gentleman!&quot;);    &#125;    public void sayHello(Woman guy) &#123;        System.out.println(&quot;hello,lady!&quot;);    &#125;    public static void main(String[] args) &#123;        Human man = new Man();        Human woman = new Woman();        StaticDispatch sr = new StaticDispatch();        sr.sayHello(man);        sr.sayHello(woman);        //此时两次输出都是hello,guy!        // Human 属于静态类型（外观类型）； new Man 和 new Woman 属于 实际类型（运行时类型）        //对于方法的重载，在编译器会直接通过我们的静态类型（外观类型） 进行方法版本的确认。    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 但是，Javac编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本可能并不是“唯一”的，往往只能确定一个“相对更合适的”版本。</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public class StaticDispatch1 &#123;</span><br><span class="line">      public static void sayHello(Object arg) &#123;</span><br><span class="line">          System.out.println(&quot;hello Object&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      public static void sayHello(int arg) &#123;</span><br><span class="line">          System.out.println(&quot;hello int&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      public static void sayHello(long arg) &#123;</span><br><span class="line">          System.out.println(&quot;hello long&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      public static void sayHello(Character arg) &#123;</span><br><span class="line">          System.out.println(&quot;hello Character&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      public static void sayHello(char arg) &#123;</span><br><span class="line">          System.out.println(&quot;hello char&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      public static void sayHello(char... arg) &#123;</span><br><span class="line">          System.out.println(&quot;hello char ...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      public static void sayHello(Serializable arg) &#123;</span><br><span class="line">          System.out.println(&quot;hello Serializable&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          sayHello(&#x27;a&#x27;);</span><br><span class="line">          //通过依次注释它调用的方法，然后得出编译器选择的方法</span><br><span class="line">          //初看他就是一个 char，所以选择char参数的</span><br><span class="line">          //第二选择是 int，因为char类型本身就可以转化成数字类型</span><br><span class="line">          //第三选择是long，因为int类型向上提升类型，到long型</span><br><span class="line">          //第四选择是 hello Character，找自己的封装类型</span><br><span class="line">          // 第五选择，序列化，发现 Character implements java.io.Serializable。</span><br><span class="line">          //第六选择，找祖宗 Object</span><br><span class="line">          //第七选择：多参数的char，因为对于方法的重载，编译器肯定是首选择参数个数以及参数类型更为接近的类型。</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>动态分派</p><ul><li><p>动态分派和重写有着很密切的关联</p></li><li><pre><code class="java">public class DynamicDispatch &#123;    static abstract class Human &#123;        protected abstract void sayHello();    &#125;    static class Man extends Human &#123;        @Override        protected void sayHello() &#123;            System.out.println(&quot;man say hello&quot;);        &#125;    &#125;    static class Woman extends Human &#123;        @Override        protected void sayHello() &#123;            System.out.println(&quot;woman say hello&quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        Human man = new Man();        Human woman = new Woman(); // 与我们之前做静态分派的时候很相似，他的静态类型（外观类型） 都是选择的Human        man.sayHello();  // &quot;man say hello&quot;        woman.sayHello(); // woman say hello    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 上面main方法对应的字节码指令</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  0: new           #2              // class com/boot/jvm/DynamicDispatch$Man  创建Man</span><br><span class="line">  3: dup    复制我们的变量 man --》 操作数栈的栈顶</span><br><span class="line">  4: invokespecial #3              // Method com/boot/jvm/DynamicDispatch$Man.&quot;&lt;init&gt;&quot;:()V  初始化man对象</span><br><span class="line">  7: astore_1  // 将我们的man变量存入我们的局部变量表（栈帧里边呢）</span><br><span class="line">  8: new           #4              // class com/boot/jvm/DynamicDispatch$Woman  创建Woman</span><br><span class="line">  11: dup</span><br><span class="line">  12: invokespecial #5              // Method com/boot/jvm/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  15: astore_2</span><br><span class="line">           //以上步骤，进行了man对象的创建和woman对象的创建，并且将其存入线程的栈帧的里边的局部变量表</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  16: aload_1  //将我们的 man 这个变量压入 操作数栈的栈顶</span><br><span class="line">  17: invokevirtual #6              // Method com/boot/jvm/DynamicDispatch$Human.sayHello:()V</span><br><span class="line">           //invokevirtual 后边跟的是 Human.sayHello， 不是Man.sayHello</span><br><span class="line">  </span><br><span class="line">  20: aload_2  //将我们的 woman 这个变量压入 操作数栈的栈顶</span><br><span class="line">  21: invokevirtual #6              // Method com/boot/jvm/DynamicDispatch$Human.sayHello:()V</span><br><span class="line">           //invokevirtual 后边跟的是 Human.sayHello， 不是Woman.sayHello</span><br><span class="line">                   //invokevirtual 调用的是 ： 虚方法 。</span><br><span class="line">  </span><br><span class="line">  24:return</span><br></pre></td></tr></table></figure></code></pre></li><li><p>实现动态分派的关键在于invokevirtual这个指令调用的虚方法，下面是invokevirtual指令的执行步骤</p><ul><li><p>1）<strong>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。</strong></p><p>2）如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回java.lang.IllegalAccessError异常。</p><p>3）否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。</p><p>4）如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</p></li><li><p>重点就是第一步，直接找实际类型，后面的几步就是校验访问权限和查找父类的过程。正是因为invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法版本，这个过程就是Java语言中方法重写的本质。</p></li></ul></li></ul></li><li><p><strong>单分派与多分派</strong></p><ul><li><p><strong>重载</strong> <strong>是静态多分派</strong></p><p><strong>重写</strong> <strong>是动态单分派</strong></p></li></ul></li></ul><h3 id="OOM异常与Jvm调优"><a href="#OOM异常与Jvm调优" class="headerlink" title="OOM异常与Jvm调优"></a>OOM异常与Jvm调优</h3><h4 id="1-Oom案例一"><a href="#1-Oom案例一" class="headerlink" title="1.Oom案例一"></a>1.<strong>Oom</strong>案例<strong>一</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OomTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);<span class="comment">//此处关键点不是说的线程池问题</span></span><br><span class="line">    <span class="keyword">static</span> CompletionService&lt;String&gt; service = <span class="keyword">new</span> <span class="title class_">ExecutorCompletionService</span>&lt;&gt;(executor); </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        service.submit(() -&gt; <span class="string">&quot;Successfully!--&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">//if(service.take().get().startsWith(&quot;Successfully!&quot;))&#123;</span></span><br><span class="line">        <span class="comment">//    updateDBStatus();</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateDBStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//更新DB执行状态。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">45000</span>;i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;========&quot;</span> + i);</span><br><span class="line">                test();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">10000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>ExecutorCompletionService和ExecutorService的区别</p><ul><li><p>ExecutorCompletionService： 当我们需要获取每一个线程执行的返回值的时候，使用ExecutorCompletionService<br>ExecutorService + Future也可以实现这种效果，但是这样如果有10个返回值; 一个返回值对应一个线程执行；如果有9个返回值1s返回，剩下的一个100s，那么在执行以下代码的时候<br>&#x2F;&#x2F; List.add(future);<br>&#x2F;&#x2F; for(List) {<br>&#x2F;&#x2F;   future.get() 在进行结果获取的时候阻塞第10个返回值直到 100 s<br>&#x2F;&#x2F;  }<br>&#x2F;&#x2F; 所以ExecutorService + Future这个组合一般适用于所有线程全部执行完毕才向下执行的场景</p><p>&#x2F;&#x2F; ExecutorCompletionService 这个东西是，有10个异步线程，他不管谁快谁慢，都会将这个10个返回值存储到队列里。调用端想取出来随时就能取出来。future的get是自身的，ExecutorCompletionService返回值放队列里边了。</p></li></ul></li><li><p>目前代码没有任何问题，但是现在需求改为了我们这个不需要返回值了，DB这边也不需要更新了。因为我们直接在我们的异步线程run方法里进行我们的异常的catch以及log记录。updateDBStatus();性能问题。所以我们采取了这种方式，如果有异常，就重试。</p><ul><li><p>然后根据这个这个需求直接将下面三行进行注释就可以了</p><ul><li><pre><code class="java">    //if(service.take().get().startsWith(&quot;Successfully!&quot;))&#123;    //    updateDBStatus();    //&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 上线五天出现OOM</span><br><span class="line"></span><br><span class="line">  - 内存泄露的点在于：我们的返回值实际上已经不再使用了，但是仍然被 static service 中的 LinkedBq所引用。所以就会一直无法被垃圾收集器回收</span><br><span class="line"></span><br><span class="line">  - &#123;% asset_img image-20231217143425746.png image-20231217143425746 %&#125;</span><br><span class="line"></span><br><span class="line">    &#123;% asset_img image-20231217143832934.png image-20231217143832934 %&#125;</span><br><span class="line"></span><br><span class="line">  - 问题的根源就在120行</span><br><span class="line"></span><br><span class="line">#### 2.OOM问题排查</span><br><span class="line"></span><br><span class="line">* 排查步骤：</span><br><span class="line"></span><br><span class="line">1. 可以通过参数dump堆内存快照</span><br><span class="line"></span><br><span class="line">    -XX:+HeapDumpOnOutOfMemoryError 发生OOM时，理解dump堆内存 </span><br><span class="line"></span><br><span class="line">   -XX:HeapDumpPath=E:\Temp 堆内存快照保存路径</span><br><span class="line"></span><br><span class="line">2. 也可以通过 JPS 获取虚拟机进程ID， 通过jmap 命令dump堆内存快照 jmap -dump:format=b,file=E:\Temp\dump.hprof 4676。</span><br><span class="line"></span><br><span class="line">3. 将dump下来的堆内存快照进行分析。此处介绍 jvisualvm 可视化分析方式。 </span><br><span class="line"></span><br><span class="line">在jvisualvm 可以看出，char[],String,LinkedBlockingQueue,FutureTask占用内存最多，这四部分其实是存在联系的，FutureTask占用了22.4%的内存，他的返回结果要存在LinkedBlockingQueue，而存储的内容是用String类型表示的，String类型的底层是char[]，所以可以初步把问题定位到FutureTask中</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231217165318702.png image-20231217165318702 %&#125;</span><br><span class="line"></span><br><span class="line">#### 3.内存泄漏和内存溢出</span><br><span class="line"></span><br><span class="line">* 内存泄漏</span><br><span class="line"></span><br><span class="line">  - 对象已经没有实际的使用意义，但是仍然有被**错误引用（非必要的引用）**，而无法被垃圾收集，导致内存泄漏。</span><br><span class="line">  - 内存泄漏的常见原因</span><br><span class="line"></span><br><span class="line">  1. 静态集合类引起内存泄漏(例如static来修饰的list集合，它属于类属性，不会被回收)</span><br><span class="line"></span><br><span class="line">  2. 数据库连接（dataSourse.getConnection ()），网络连接 (socket) 和 io 连接，除非其显式的调用了其 close () 方法将其连接关闭，否则是不会自动被 GC 回收的。</span><br><span class="line"></span><br><span class="line">  3. 内部类持有外部类。如果一个外部类的实例对象的一个方法的返回值是内部类的实例，然后内部类实例被长期引用，这时即使外部类的实例对象已经没有用了，也不会被垃圾收集器回收</span><br><span class="line"></span><br><span class="line">* 内存溢出</span><br><span class="line"></span><br><span class="line">  - 内存溢出实际上是内存不够的表现。内存泄漏最终会导致内存溢出。 如果所有的对象都有实际的使用意义无法被回收导致内存不够使用的话，称之为内存溢出。（创建很多个对象，还在被使用；加载大量的数据文件）</span><br><span class="line"></span><br><span class="line">#### 4.OOM案例二</span><br><span class="line"></span><br><span class="line">直接由内存溢出导致</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//-Xms10m -Xmx10m</span><br><span class="line">public class OomTest2 &#123;</span><br><span class="line">    // 一个数据转储一个服务</span><br><span class="line">    // 接收数据，然后对数据进行转储。</span><br><span class="line">    // 接收数据通过 中间件 进行监听接收（mq)</span><br><span class="line">    </span><br><span class="line">// 可能出现的场景</span><br><span class="line">    // 读取数据库大量数据</span><br><span class="line">    // 读取大文件</span><br><span class="line">    // 从网络上加载大的数据包</span><br><span class="line"></span><br><span class="line">    //解决方案</span><br><span class="line">    //1 . 可以通过中间件进行数据的缓冲</span><br><span class="line">    //2. 分批进行数据的获取</span><br><span class="line">    //3. 增加我们的内存量（堆内存）-- 考虑： 越大的堆内存面临着时间停顿越长，垃圾量太多。</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        byte[] bytes = getData(); // 接收数据</span><br><span class="line">        processData(bytes); // 进行数据的处理和转储</span><br><span class="line">        // getDataFromMq(一次性取多少分batch还是一条条的)</span><br><span class="line">        //processData</span><br><span class="line">    &#125;</span><br><span class="line">    public static byte[] getData()&#123;</span><br><span class="line">        return new byte[10*1024*1024];</span><br><span class="line">    &#125;</span><br><span class="line">    private static void processData(byte[] bytes) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul><p>直接读取一个大文件，然后对文件进行处理转储等后续操作，此时文件会作为局部变量存到内存当中，所以很容易出现内存溢出</p><h4 id="5-JVM调优总结"><a href="#5-JVM调优总结" class="headerlink" title="5.JVM调优总结"></a>5.JVM调优总结</h4><ol><li><p>在大访问压力下，MinorGC 频繁，每次在MGC 存活下来的对象，会移动到Survivor1区。只要MGC 延迟不导致停顿时间过长或者引发FGC ，那可以适当的增大Eden 空间大小，降低频繁程度，<strong>同时要保证，空间增大对垃圾回收时间产生的停顿时间增长也是可以接受的</strong>。如果MinorGC 频繁，且容易引发 Full GC。需要从如下几个角度进行分析。</p><ul><li>每次MGC存活的对象的大小，是否能够全部移动到 S1区，如果S1 区大小 &lt; MGC 存活的对象大小，这批对象会直接进入老年代。注意了，这批对象的年龄才1岁，很有可能再多等1次MGC 就能被回收了，可是却进入了老年代，只能等到Full GC 进行回收。这种情况下，应该在系统压测的情况下，实时监控每次MGC存活的对象大小，并合理调整eden和s区的大小以及比例。</li><li>如果S1区的对象，相同年龄的对象所占总空间大小&gt;s1区空间大小的一半，这时S1区的所有年龄大于等于这些相同年龄对象的对象会直接进入老年代，所以为了应对这种情况，对于S区的大小的调整就要考虑：尽量保证峰值状态下，S1区的对象所占空间能够在MGC的过程中，相同对象年龄所占空间不大于S1区空间的一半，因此对于S1空间大小的调整，也是十分重要的。</li></ul></li><li><p>由于大对象创建频繁，导致Full GC 频繁。对于大对象，JVM专门有参数进行控制，-XX：PretenureSizeThreshold。超过这个参数值的对象，会直接进入老年代，只能等到full GC 进行回收，所以在系统压测过程中，要重点监测大对象的产生。</p><ul><li>如果能够优化对象大小，则进行代码层面的优化，优化如：该大对象是否可以进行拆分使用，或者如果大对象确定使用完成后，将该对象赋值为null，方便垃圾回收。</li><li>如果代码层面无法优化，则需要考虑：a:调高-XX：PretenureSizeThreshold参数的大小，使对象有机会在eden区创建，有机会经历MGC以被回收。但是这个参数的调整要结合MGC过程中Eden区的大小是否能够承载，包括S1区的大小承载问题。b：如果必须要进入老年代，也要尽量保证，该对象确实是长时间使用的对象，放入老年代的总对象创建量不会造成老年代的内存空间迅速长满发生Full GC，在这种情况下，可以通过定时脚本，在业务系统不繁忙情况下，主动触发full gc。</li></ul></li><li><p>MGC 与 FGC 停顿时间长导致影响用户体验。其实对于停顿时间长的问题无非就两种情况：</p><ul><li>gc 真实回收过程时间长，即real time时间长。这种时间长大部分是因为内存过大导致，导致从标记到清理的过程中需要对很大的空间进行操作，导致停顿时间长。</li><li>b：gc真实回收时间 real time 并不长，但是user time(用户态执行时间) 和 sys time（核心态执行时间）时间长，导致从客户角度来看，停顿时间过长。<ul><li>user time：进程执行用户态代码所耗费的处理器时间。（执行我们书写的代码）</li><li>sys time：进程执行核心态代码所耗费的处理器时间。（用户态转为内核态后，内核态执行时间）</li><li>real time：执行垃圾收集动作从开始到结束耗费的时钟时间。（真正的时间消耗）</li></ul></li><li>对于a情况，要考虑减少堆内存大小，包括新生代和老年代，比如之前使用16G的堆内存，可以考虑将16G 内存拆分为4个4G的内存区域，可以单台机器部署JVM逻辑集群，也可以为了降低GC回收时间进行4节点的分布式部署，这里的分布式部署是为了降低GC垃圾回收时间。</li><li>对于b情况，要考虑线程是否及时达到了安全点，安全点一般放置在方法调用、循环跳转、异常跳转这些位置，<strong>但是HotSpot虚拟机为了避免安全点过多带来过重的负担，对循环还有一项优化措施，认为循环次数较少的话，执行时间应该也不会太长，所以使用int类型或范围更小的数据类型作为索引值的循环默认是不会被放置安全点的。相对应地，使用long或者范围更大的数据类型作为索引值的循环将会被放置安全点。</strong>通常情况下这个优化措施是可行的，<strong>但循环执行的时间不单单是由其次数决定，如果循环体单次执行就特别慢，那即使是可数循环也可能会耗费很多的时间。</strong>主要考虑以下两种改进方式<ul><li>修改我们的代码。加快代码执行速度</li><li>将发生问题的这部分循环代码以 long型进行循环索引数据类型。</li></ul></li></ul></li><li><p>内存泄漏导致的MGC和FGC频繁，最终引发oom。</p></li><li><p>纯代码级别导致的MGC和FGC频繁。如果是这种情况，那就只能对代码进行大范围的调整，这种情况就非常多了，而且会很糟糕。如大循环体中的new 对象，未使用合理容器进行对象托管导致对象创建频繁，不合理的数据结构使用等等。</p></li></ol><p>总之，JVM的调优无非就一个目的，在系统可接受的情况下达到一个<strong>合理的MGC和FGC的频率以及可接受的回收时间。</strong></p><ul><li><p>如何直到垃圾回收的时候，每个区的使用率和垃圾回收所用的时间</p><ul><li>jstat -gcutil + 虚拟机进程号 这个命令</li><li><img src="/2023/10/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231217180240548.png" class title="image-20231217180240548"></li></ul></li><li><p>直接内存溢出</p><ul><li><p>虚拟机虽然会对直接内存进行回收，但是直接内存却不能像新生代、老年代那样，发现空间不足了就主动通知收集器进行垃圾回收，<strong>它只能等待老年代满后Full GC出现后，“顺便”帮它清理掉内存的废弃对象</strong>。否则就不得不一直等到抛出内存溢出异常。</p><p>直接内存溢出，加入-XX：+HeapDumpOnOutOfMemoryError参数，也没有任何反应，抛出内存溢出异常时什么文件都没有产生。</p><p>·直接内存：可通过**-XX：MaxDirectMemorySize**调整大小，内存不足时抛出OutOf-MemoryError或者OutOfMemoryError：Direct buffer memory。</p></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java并发编程的艺术》阅读笔记</title>
      <link href="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="并发编程初探"><a href="#并发编程初探" class="headerlink" title="并发编程初探"></a>并发编程初探</h3><h4 id="1-Java天生的多线程"><a href="#1-Java天生的多线程" class="headerlink" title="1.Java天生的多线程"></a>1.Java天生的多线程</h4><p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位</strong></p><p>在Java中仅仅运行一个main函数，在相当于启动了一个JVM进程，而且这个进程有六条线程，这些线程都拥有各自的<strong>计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量</strong>。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。</p><hr><p>main函数启动后开启的六条线程：</p><p>[6] Monitor Ctrl-Break （跟JVM 关系不大，他是 IDEA 通过反射的方式，开启一个随着我们运行的jvm进程开启与关闭的一个监听线程。）</p><p>[5] Attach Listener （附加监听器。 简单来说，他是jdk里边一个工具类提供的<strong>jvm</strong> <strong>进程之间通信</strong>的工具。 cmd – java -version; jvm – jstack、jmap、dump） 进程间的通信。</p><p>开启我们这个线程的两个方式： 1. 通过jvm参数开启。-XX: StartAttachListener</p><ol start="2"><li>延迟开启： cmd – java -version –&gt; JVM 适时开启A L 线程</li></ol><p>[4] Signal Dispatcher （信号分发器。 我们通过cmd 发送jstack，传到了jvm进程，这时候信号分发器就要发挥作用了。）</p><p>[3] Finalizer （JVM 垃圾回收相关的内容。此处只做简单的介绍。 1. 只有当开始一轮垃圾收集的时候，才会开始调用finalize方法。 2. daemon prio&#x3D;10 高优先级的守护线程。  3. jvm在垃圾收集的时候，会将失去引用的对象封装到我们的 Fianlizer 对象（Reference）， 放入我们的 F-queue 队列中。由 Finalizer 线程执行inalize方法）</p><p>[2] Reference Handler （引用处理的线程。强，软，弱，虚。 -GC 有不同表现 - JVM深入分析）</p><p>[1] main 主线程</p><hr><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231119213444916.png" class title="image-20231119213444916"><h4 id="2-线程的优先级和守护线程"><a href="#2-线程的优先级和守护线程" class="headerlink" title="2.线程的优先级和守护线程"></a>2.线程的优先级和守护线程</h4><ul><li><p>优先级</p><ul><li>通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，setPriority(int)这个方法是 jvm 提供的一个方法，并且能够调用 本地方法 setPriority0. 但是设置以后发现没有作用，为什么？ <ul><li>1.我们现在的计算机都是多核的，t1，t2 会让哪个cpu处理不好说。由不同的cpu同时提供资源执行。 2.优先级不代表先后顺序。哪怕你的优先级低，也是有可能先拿到我们的cpu时间片的，只不过这个时间片比高优先级的线程的时间片短。 <strong>优先级针对的是 cpu时间片的长短问题。</strong>这个 setPriority方法很少使用，很难控制。实际的运行环境太复杂。</li></ul></li></ul></li><li><p>守护线程</p><ul><li><p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这 意味着，<strong>当一个Java虚拟机中不存在非Daemon线程的时候，守护线程也会立即终止(这也是finally块中代码不一定执行的一个原因)，</strong>Java虚拟机将会退出。</p></li><li><p>可以通过调 用Thread.setDaemon(true)将线程设置为Daemon线程。但是注意设置守护线程的时候一定要在调用thread.start()之前设置，如果线程已经启动了在进行设置会抛出异常</p></li></ul><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231119220444532.png" class title="image-20231119220444532"></li></ul><h4 id="3-线程状态转换"><a href="#3-线程状态转换" class="headerlink" title="3.线程状态转换"></a>3.线程状态转换</h4><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231119223427696.png" class title="image-20231119223427696"><ul><li>注意：①上面图中有一个错误，就是红框里面的join方法是Thread的。②BLOCKED状态只针对sync锁。③通过调用join方法导致状态转为WAITING时，也是需要调用notify方法转为RUNNABLE状态，因为join方法底层就是调用了wait方法</li></ul><h4 id="4-init方法和start方法"><a href="#4-init方法和start方法" class="headerlink" title="4.init方法和start方法"></a>4.init方法和start方法</h4><ul><li>init方法<ul><li>当使用new关键词进行线程创建的时候，底层调用的是init方法，一个新构造的线程对象是由其parent线程来进行空间分配的，而child线程继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的ThreadLocal，同时还会分配一个唯一的（sync）ID来标识这个child线程(之所以能保证唯一是因为nextThreadID这个方法是被synchronized修饰的)。此时这个线程会被添加到Unstarted线程组，也就是NEW状态，因为还没有调用start方法;至此，一个能够运行的线程对象就初始化好了，在堆内存中等待着运行。</li></ul></li><li>start方法<ul><li>start方法也是一个被synchronized修饰的方法，这样可以避免多线程同时启动一个线程，start方法底层调用的是用native修饰的start0方法，在start0方法完全执行完成之前，线程处于READY状态，在start0方法完全执行结束以后，线程就处于RUNNING状态，线程start()方法的含义是：当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程。</li></ul></li></ul><h4 id="5-sleep方法和wait方法"><a href="#5-sleep方法和wait方法" class="headerlink" title="5.sleep方法和wait方法"></a>5.sleep方法和wait方法</h4><ul><li>sleep方法<ul><li>是否释放锁？<ul><li>不释放</li><li>通过源码发现sleep方法是一个native方法，但是可以根据注释**The thread does not lose ownership of any monitors.**，说明他不会释放锁</li></ul></li><li>是否响应中断？<ul><li>响应，他会先清除中断标志然后抛出异常，所以调用Thread.isInterrupted()方法的时候会返回false</li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231121191452253.png" class title="image-20231121191452253"></li></ul></li><li>是否释放CPU<ul><li>释放，通过jstack命令可以查看到它没有占用任何CPU</li></ul></li></ul></li><li>wait方法<ul><li>是否释放锁？<ul><li>释放</li><li>wait方法也是一个native方法，使用上面的方法可以查看到，线程会释放锁</li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231121192241133.png" class title="image-20231121192241133"></li></ul></li><li>是否响应中断？<ul><li>响应</li></ul></li><li>是否释放CPU？<ul><li>释放，他会让出CPU时间片，然后进入到等待队列中</li></ul></li></ul></li></ul><h4 id="6-join方法"><a href="#6-join方法" class="headerlink" title="6.join方法"></a>6.join方法</h4><ul><li>是否释放锁？<ul><li>释放，但是它释放的是当前调用 join方法的那个对象的锁。</li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231121192631058.png" class title="image-20231121192631058"></li></ul></li><li>是否响应中断？<ul><li>响应</li></ul></li><li>是否释放CPU？<ul><li>释放，其底层调用的是wait方法</li></ul></li></ul><h4 id="7-线程间的通信方式"><a href="#7-线程间的通信方式" class="headerlink" title="7.线程间的通信方式"></a>7.线程间的通信方式</h4><ul><li>volitate 、synchronize、lock。（都保证可见性）</li><li>wait、notify、await() 、 signal</li><li>管道输入&#x2F;输出流和普通的文件输入&#x2F;输出流或者网络输入&#x2F;输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</li><li>Thread.join() ： 隐式唤醒。等待其他线程执行完成，其他线程会发送唤醒信号。</li><li>ThreadLocal() </li><li>线程中断</li></ul><h4 id="8-ThreadLocal"><a href="#8-ThreadLocal" class="headerlink" title="8.ThreadLocal"></a>8.ThreadLocal</h4><p>ThreadLocal之所以能够实现线程的隔离，主要是依靠线程自身有一个名叫threadLocals的ThreadLocalMap类型的变量，threadLocal底层是使用一个table数组进行数据的存放，存放的时候使用斐波那契散列法把对应不同的threadlocal进行散列，存放的数据是使用threadlocal和要set的值封装成的Entry对象，每次从map中获取信息的时候是通过thradLocal的get方法，当前线程拿到这个map，通过threadLocal散列得到存放的位置，最终得到数据，如果线程一直不终止，那么这个数据会一直存放在threadLocals，<strong>ThreadLocalMap中ThreadLocal是弱引用，</strong></p><p>如果在ThreadLocalMap中使用强引用来存储ThreadLocal对象，那么ThreadLocal对象会一直存在于内存中，即使在实际的应用中已经不再需要该ThreadLocal对象。这是因为ThreadLocalMap是与线程相关联的，保存在ThreadLocalMap的table数组中，ThreadLocalMap中的键值对不会被自动清理，而是会一直保留，从而造成内存泄漏。也就是说ThreadLocal永远不会被清理，除非手动清理，ThreadLocalMap调用set(),get()，remove()方法的时候会被清除value值。</p><p>为了解决这个问题，ThreadLocal存放的Entry对象被设计为弱引用。<strong>弱引用的特点是，当一个对象只被弱引用所引用时，在垃圾回收时会被自动回收。当ThreadLocal对象被垃圾回收时，对应的键值对也会被自动从ThreadLocalMap中移除。但是我们set的value是强引用的，当一个线程长时间运行，有可能不会及时清理导致内存泄漏，为了避免泄漏问题应做手动清理的动作</strong></p><p><a href="https://blog.csdn.net/qq_45260619/article/details/135994700">【面试进阶之路】这次彻底说明白 ThreadLocal 内存泄漏问题-CSDN博客</a></p><h3 id="synchronized-全解读"><a href="#synchronized-全解读" class="headerlink" title="synchronized 全解读"></a>synchronized 全解读</h3><h4 id="1-Synchronized的使用方法"><a href="#1-Synchronized的使用方法" class="headerlink" title="1.Synchronized的使用方法"></a>1.Synchronized的使用方法</h4><ul><li><p>synchonized关键字的三种使用方式</p><ul><li>用在同步代码块上，此时锁是括号里面配置的对象</li><li>用在普通方法上，此时锁是当前调用该方法的实例对象</li><li>用在静态方法上，此时锁是当前类的Class对象</li></ul><p>当一个线程试图访问同步代码块的时候，必须要先获取到锁，在退出或者出现异常的时候必须释放锁</p></li><li><p>synchonized在JVM的实现原理</p><ul><li>JVM是基于进入和退出Monitor对象来实现同步方法和同步代码块，二者的实现细节略有不同<ul><li>对于同步代码块来说，在编译后会在进入同步代码块之前会加一个monitorenter指令，在同步代码块结束退出或者发生异常的地方monitorexit指令，任何一个对象都有一个monitor与之关联，当monitor被持有后将处于锁定状态，线程执行到monitorenter的时候会尝试获取对应monitor的所有权，即尝试获取对象的锁</li><li>对于同步方法和静态方法来说，通过反编译得到字节码后可以发现，在方法的flags中多了一个ACC_SYNCHONIZED标志，这会告诉JVM这是一个同步方法</li></ul></li></ul></li></ul><h4 id="2-Synchronized的特性"><a href="#2-Synchronized的特性" class="headerlink" title="2.Synchronized的特性"></a>2.Synchronized的特性</h4><ol><li>有序性 （读读、读写、写读、写写 互斥）</li><li>可见性 （可见性是指多个线程访问⼀个资源时，该资源的状态、值信息等对于其他线程都是可见的。 synchronized和volatile都具有可见性，其中synchronized对⼀个类或对象加锁时，⼀个线程如果要访问该类或对象必须先获得它的锁，⽽这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到共享内存当中，保证资源变量的可见性。）</li><li>原子性 (本质上是线程互斥保证的原子性)</li><li>可重入性 （一个线程获取到某个锁以后，再次请求该对象的锁的时候，还可以获取到执行权）</li></ol><h4 id="3-Synchronized锁–偏向锁"><a href="#3-Synchronized锁–偏向锁" class="headerlink" title="3.Synchronized锁–偏向锁"></a>3.Synchronized锁–偏向锁</h4><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231122222424235.png" class title="image-20231122222424235"><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231122222444063.png" class title="image-20231122222444063"><ul><li>偏向锁使用的前提<ul><li>在jdk1.6版本以后，并且开启了使用偏向锁这一配置，但是它默认情况下是延迟开启的，可以通过-     XX:BiasedLockingStartupDelay&#x3D;0这个配置关闭延迟，如果我们关闭了延迟开启这一配置，那么<strong>锁对象在创建出来的时候markword的状态就是偏向锁对应的状态</strong>，只不过现在没有任何的线程竞争，此时就是一个没有偏向任何线程的偏向锁</li><li>锁对象在被获取之前没有显式&#x2F;隐式的调用hashCode方法(隐式调用比如说以这个锁对象作为hashmap的key进行保存)，如果调用了hashcode方法，由于我们偏向锁的markword中没有地方存储这个hashcode，所以此时就会升级为轻量级锁</li></ul></li></ul><p>为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在<strong>锁的对象头中存储线程id并在线程的栈帧中的锁记录里(线程有自己的栈帧，LOCK RECORD) 存储当前线程id</strong>,存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里存储的id和线程栈帧里面锁记录的id是否匹配，如果匹配，表示线程已经获得了锁。如果不匹配，则需要再测试一下锁对象的Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程： 其实是cas竞争替换 线程id。</p><h4 id="4-偏向锁撤销"><a href="#4-偏向锁撤销" class="headerlink" title="4.偏向锁撤销"></a>4.偏向锁撤销</h4><p><em><strong>面试过程中，如果聊到偏向锁的撤销可以先通过一句简短的话来描述一下，然后通过面试官后续的发问逐步展开，即偏向锁使用了一种当出现线程竞争才撤销偏向锁的机制，一旦出现竞争偏向锁就会升级为轻量级锁</strong></em></p><ul><li>在竞争偏向锁的时候会出现以下可能性<ol><li>A线程获取偏向锁，并且A线程死亡退出。B线程争抢偏向锁，会直接升级当前对象的锁为轻量级锁。<strong>这只是针对我们争抢了一次。</strong></li><li>A线程获取偏向锁，并且A线程没有释放偏向锁，还在sync的代码块里边。B线程此时过来争抢偏向锁，会直接升级为重量级锁。</li><li>A线程获取偏向锁，并且A线程释放了锁，但是A线程并没有死亡还在活跃状态。此时锁处于无锁状态，B线程过来争抢，会直接升级为轻量级锁。</li><li>A线程获取偏向锁，并且A线程没有释放偏向锁，还在sync的代码块里边。B线程多次争抢锁，会在加锁过程中采用重量级锁；但是，一旦锁被释放，当前对象还是会以轻量级锁的初始状态执行。但是这里不能称之为锁降级，因为锁升级是在线程运行过程中和争抢过程中的一种升级。而现在是线程已经释放了锁，然后又重新获取锁的情况，不属于线程运行中。</li><li>A线程获取偏向锁，并且A线程释放了锁，但是A线程并没有死亡还在活跃状态。B线程过来争抢。部分争抢会升级为轻量级锁；部分争抢会依旧保持偏向锁。</li></ol></li></ul><p>所以，偏向锁的撤销过程很复杂，即使是锁升级的官方文档中对这一部分也没有特别细致的说明，所以面试过程中不要较真</p><p>以下面试过程中推荐说的：</p><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态(<strong>如上述情况1</strong>)；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向的线程对象的栈帧中的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程(<strong>如上述情况5</strong>)，要么恢复到无锁(<strong>如上述情况3</strong>)或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。 </p><ul><li>偏向锁的批量重偏向和批量撤销<ul><li>批量重偏向，一个已经偏向A线程Object类型的对象，在经过另外B线程争抢超过二十次的情况下，该类所创建出来的其他对象会直接重新偏向于B线程，此时jvm认为这个对象更适合偏向于B线程(20这个数字不是一定的，<strong>不同机器环境参数配置不一样</strong>)</li><li>批量撤销，如果基于批量重偏向的基础上，还在继续进行争抢达到40次，并且有第三条线程C也来争抢这个对象锁，这个时候会触发批量撤销。JVM会标记该对象不能使用偏向锁，以后新创建的对象，直接以轻量级锁开始。 这个时候，才是真正的完成了锁升级。</li></ul></li></ul><p><strong>注意，真正的锁升级，是依赖于 class 的，而并不是依赖于 某一个 new出来的对象（这句话适用于偏向锁升级为轻量级锁），这里更加可以说明锁可以升级，而不能降级，也就是说上面出现的线程争抢锁过程中升级的锁，在使用new关键字对该类进行重新创建的时候还是偏向锁这一现象不能称之为锁降级</strong></p><h4 id="5-轻量级锁的加锁和解锁"><a href="#5-轻量级锁的加锁和解锁" class="headerlink" title="5.轻量级锁的加锁和解锁"></a>5.轻量级锁的加锁和解锁</h4><ul><li>轻量级锁加锁</li></ul><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间（Lock Record记录），并将对象头中的Mark Word（前30位 （25位的hashcode，4位的分代年龄，1位是否为偏向锁））复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针（指向线程栈帧里边的Lock Record的指针）。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用<strong>自旋</strong>来获取锁。</p><ul><li>轻量级锁解锁</li></ul><p>轻量级锁解锁时，会使用原子的CAS操作将Displaced Mark Word（Lock Record记录）替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p><p><strong>注意，这里真正的锁升级依赖的是对象，对象升级为重量级锁，而对象对应的类再new一个的新对象锁，这时还是从轻量级锁开始(这句话适用于轻量级锁升级为重量级锁)</strong></p><h4 id="6-轻量级锁膨胀流程"><a href="#6-轻量级锁膨胀流程" class="headerlink" title="6.轻量级锁膨胀流程"></a>6.轻量级锁膨胀流程</h4><p>线程A在获取到锁以后，线程B也想要获得这个锁，通过CAS进行markword和指针的替换，如果替换失败，会自旋尝试十次，如果线程A一直没有释放锁那么十次自旋也失败，进入膨胀流程，此时线程B会用一个临时的指针指向重量级锁，当线程A执行完代码进行解锁的时候，发现有竞争要升级锁，线程A即会做以下五步：</p><ol><li><p>线程A 初始化monitor 对象；</p></li><li><p>将状态设置为膨胀中（inflating）；</p></li><li><p>将monitor里边的header属性，set称为对象的markword；（即将自己lock record里边的存放的mark word的hashcode，分代年龄，是否为偏向锁 set 到 objectmonitor对象的header属性里）</p></li><li><p>设置对象头为重量级锁状态（标记为改为00）；然后将前30位指向第1步他初始化的monitor 对象；（<strong>真正的锁升级是由线程A操控的</strong>）</p></li><li><p>唤醒线程B；</p></li></ol><p>线程B开始争抢重量级锁。（线程B就干了一件事儿，就是弄了一个临时的重量级锁指针吧？还不是最后的重量级锁指针。因为最后的重量级锁指针是线程A初始化的并且是线程A修改的。 而且，线程B被唤醒之后，还不一定能够抢到这个重量级锁。Sync是非公平锁。 线程B费力不讨好，但是线程B做了一件伟大的事情：他是锁升级的奠基者。）</p><h4 id="7-锁升级过程中markword的转移流程"><a href="#7-锁升级过程中markword的转移流程" class="headerlink" title="7.锁升级过程中markword的转移流程"></a>7.锁升级过程中markword的转移流程</h4><p>创建一个对象，此时对象里边没有hashcode，所以该对象可以使用我们的偏向锁，偏向锁不会考虑hashcode，</p><p>他会直接将自己的线程id放到我们的markword里边，不需要考虑后续的替换问题。 所以呢，一旦我们的对象主动调用了Object的hashcode方法，我们的偏向锁就自动不可用了。</p><p>如果我们的对象有了hashcode和分代年龄和是否为偏向锁（30位）。在轻量级锁的状态下，这30位会被复制到我们的轻量级锁线程持有者的栈帧里的lock record里边记录。与此同时，我们的对象的markword里边存放的是我们的指向轻量级锁线程持有者的栈帧的lock recod里的指针。如果一直存在轻量级锁竞争，在未发生锁膨胀的前提下，一直会保持轻量级锁，A线程释放的时候，会将markword替换回对象的markword里边，B线程下次再从新走一遍displace mark word；</p><p>一旦发生了轻量级膨胀为重量级锁。前提，A线程持有锁；B线程争抢。</p><p>B线程将marikword里边A线程的指针替换成一个临时的（过度的）重量级锁指针，为了让A线程在cas往回替换markword的时候失败。</p><p>A线程替换回markword失败后，会发起：1.初始化monitor对象；2. 将状态设置为膨胀中；3 将替换失败的 markword放到objectmonitro的head属性里； 4。改变markword的锁标志为10；将markword里的 30 位设置为指向自己第一步初始化的那个monitor对象；5唤醒B线程； 6以后这个对象只能作为重量级锁；</p><p>Markword从未丢失。</p><h4 id="8-死锁的避免方式"><a href="#8-死锁的避免方式" class="headerlink" title="8.死锁的避免方式"></a>8.死锁的避免方式</h4><p>概念：死锁是指两个或两个以上的线程在执行过程中，由于竞争资源而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p><p>避免死锁的几个常见方法：</p><ol><li><p>避免一个线程同时获取多个锁。</p></li><li><p>尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。</p></li><li><p>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</p></li></ol><h4 id="9-ObjectMonitor的属性"><a href="#9-ObjectMonitor的属性" class="headerlink" title="9.ObjectMonitor的属性"></a>9.<strong>ObjectMonitor</strong>的属性</h4><ol><li><p>header ： 重量级锁保存markword的地方；对象的markword里边也保存了指向monitor的指针；</p></li><li><p>own: 指向我们持有锁的线程；</p></li><li><p>_cxq 队列： 竞争队列。 A线程持有锁没有释放； B和C线程同时过来争抢锁，都被block了，此时会将B和C线程加入到 该队列。</p></li><li><p>EntryList队列：同步队列。A线程释放锁，B和C线程中会选定一个继承者（可以去争抢锁的这个线程），另外一个线程会被放入我们的EntryList队列里边。 </p></li><li><p>waitset：等待队列。Object wait的线程。</p></li></ol><ul><li>这个地方为什么要使用cxq和EntryList两个数据结构来存储被阻塞的线程<ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20240201153952655.png" class title="image-20240201153952655"></li><li>_cxq是一个栈的数据结构，EntryList是一个队列的数据结构，如果想要任何一个数据结构不发生ABA问题，那么就需要限制线程对该数据结构的操作，比如这里的cxq只能添加不能删除</li></ul></li></ul><p>A线程持有锁，BC线程过来竞争失败，进入cxq – 下轮竞争会把 cxq里的线程移动到EntrylIst中。假设B线程竞争到了锁，然后B线程调用了 Object.Wait方法，这时候B线程进入waitset，并释放锁。C线程拿到了锁，然后唤醒B线程。B线程会从waitset里边出来，直接竞争锁。如果竞争失败进入cxq，继续轮回，如果竞争成功，ok了。</p><h4 id="10-CPU的用户态与内核态"><a href="#10-CPU的用户态与内核态" class="headerlink" title="10.CPU的用户态与内核态"></a>10.CPU的用户态与内核态</h4><ul><li>内核态：</li></ul><ol><li><p>系统中既有操作系统的程序，也有普通用户程序。为了安全性和稳定性，操作系统的程序不能随便访问，这就是内核态。即需要执行操作系统的程序就必须转换到内核态才能执行！</p></li><li><p>内核态可以使用计算机所有的硬件资源！</p></li></ol><ul><li><p>用户态：不能直接使用系统资源，也不能改变 CPU 的工作状态，并且只能访问这个用户程序自己的存储空间！</p></li><li><p>用户态与内核态转换的条件</p><ul><li>用户态进程要使用操作系统资源主动申请状态转换</li><li>CPU出现没有预知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常。</li></ul></li></ul><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><h4 id="1-Java内存模型基础"><a href="#1-Java内存模型基础" class="headerlink" title="1. Java内存模型基础"></a>1. Java内存模型基础</h4><p>Java线程之间的通信由Java内存模型控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在<strong>主存</strong>中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读&#x2F;写共享变量的副本。</p><h4 id="2-指令重排序"><a href="#2-指令重排序" class="headerlink" title="2.指令重排序"></a>2.指令重排序</h4><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。</p><ol><li><p><strong>编译器优化的重排序</strong>。编译器在不改变<strong>单线程程序语义</strong>的前提下，可以重新安排语句的执行顺序。</p></li><li><p><strong>指令级并行的重排序</strong>。现代处理器采用了指令级并行技术来将多条指令<strong>重叠</strong>执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p></li><li><p><strong>内存系统的重排序</strong>。由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p></li></ol><p>举个例子解释上面三种重排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br></pre></td></tr></table></figure><p>例如上面三行代码，其中第一行和第二行在单线程的情况下，即使发生指令顺序的改变，但是也不会改变其语意，所以在编译阶段，编译器就可以对其进行重排序，这就是编译器优化的重排序；同时第一行和第二行不存在数据依赖性，所以在并行执行的时候，可以改变执行顺序，甚至两条指令重叠执行，这也可以提高程序执行效率，这就是指令集并行重排序；由于处理器是使用内存的，所以需要对数据进行加载(i load)和存储(i store)，在保证程序执行结果正确的前提下，这两个操作的顺序也可以被改变，这就是内存系统重排序</p><p>JMM的处理器重排序规则会要求 <strong>Java编译器在生成指令序列时，插入特定类型的内存屏障指令</strong>，通过内存屏障指令来禁止特定类型的处理器重排序。</p><h4 id="3-内存屏障"><a href="#3-内存屏障" class="headerlink" title="3.内存屏障"></a>3.内存屏障</h4><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231126212750679.png" class title="image-20231126212750679"><h4 id="4-as-if-serial语义和Happen-Before原则"><a href="#4-as-if-serial语义和Happen-Before原则" class="headerlink" title="4.as-if-serial语义和Happen-Before原则"></a>4.<strong>as-if-serial语义</strong>和<strong>Happen-Before</strong>原则</h4><p>as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（<strong>单线程</strong>）程序的执行结果不能被改变。</p><p><strong>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。</strong>但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p><p><strong>happens-before关系本质上和as-if-serial语义是一回事。</strong></p><p><strong>as-if-serial语义保证单线程</strong>内程序的执行结果不被改变，<strong>happens-before关系保证正确同步的多线程</strong>程序的执行结果不被改变。</p><p>as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。</p><p><strong>as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度</strong>。</p><h4 id="5-锁的内存语义"><a href="#5-锁的内存语义" class="headerlink" title="5.锁的内存语义"></a>5.锁的内存语义</h4><p>线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（<strong>线程A对共享变量进行修改</strong>）消息。</p><p>线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（<strong>在释放这个锁之前对共享变量所做修改的</strong>）消息。</p><p>线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过<strong>主存</strong>向线程B发送消息。（<strong>隐式通信</strong>）</p><h3 id="volatile全解读"><a href="#volatile全解读" class="headerlink" title="volatile全解读"></a>volatile全解读</h3><h4 id="1-volatile定义"><a href="#1-volatile定义" class="headerlink" title="1.volatile定义"></a>1.volatile定义</h4><p>Java语言规范第3版中对volatile的定义如下：Java编程语言允许线程访问共享变量，<strong>为了确保共享变量能被准确和一致地更新</strong>，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁要更加方便（读多写少）。<strong>如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。</strong></p><p>volatile主要做的三件事：1. 保证可见性 2. 禁止指令重排序 3. 双重检查锁</p><h4 id="2-volatile可见性"><a href="#2-volatile可见性" class="headerlink" title="2.volatile可见性"></a>2.volatile可见性</h4><p>在修改volatile修饰的变量时，Java转变成的<strong>汇编代码会多加一个lock前缀指令</strong>(这一步叫做声言lock信号)，lock前缀指令在多核处理器的条件下会引发两件事，1. 将当前处理器缓存行的数据过总线写回主存。2. 使在其他CPU里缓存了该内存地址的数据无效。</p><p>声言lock信号的期间，系统内存只有当前处理器可以访问也就是说锁总线，但是锁总线的开销太大了，所以最近的处理器如果发现要访问的数据缓存到了处理器内部，这时不会声言lock信号，而是锁定这块内存区域的缓存并回写到内存，并使用缓存一致性协议机制确保修改的原子性。(缓存一致性协议会阻止由多个处理器同时缓存的数据同时被修改)。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。如果通过嗅探一个处理器来检测其他处理器打算修改的内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行(缓存行是缓存可以分配的最小单位，所以缓存行中不一定只有这一条被修改的数据)无效，在下次访问相同内存地址时，强制执行缓存行填充(即从系统内存中重新读取最新数据)。</p><h4 id="3-volatile的使用优化"><a href="#3-volatile的使用优化" class="headerlink" title="3. volatile的使用优化"></a>3. volatile的使用优化</h4><p>先说问题：问题在于一个使用volatile修饰的队列，如果该队列的头尾节点都不足64位，那么他们就会被缓存到同一个缓存行，这时如果是多核处理器都对该数据进行了缓存，那么在缓存一致性的机制下，当一个处理器对头&#x2F;尾节点的修改会导致其他处理器不能访问这个队列的尾&#x2F;头节点，由于队列的入队和出队操作会频繁的修改头尾节点，这样会严重影响性能。</p><p>优化方法是基于缓存行是64位的处理器，处理器的高速缓存行一旦对数据进行缓存，那么就不支持进行部分填充，LinkedTransferQueue这个队列集合则使用追加字节的方式优化入队和出队的性能，它使用一个内部类类型来定义队列的头节点（head）和尾节点（tail），而这个内部类PaddedAtomicReference就是将共享变量追加到64字节。一个对象的引用占4个字节，它追加了15个变量（共占60个字节），再加上父类的value变量，一共64个字节。这样就能保证队列的首尾节点不在同一个缓存行中，</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231130220926320.png" class title="image-20231130220926320"><h4 id="4-volatile禁止指令重排序"><a href="#4-volatile禁止指令重排序" class="headerlink" title="4. volatile禁止指令重排序"></a>4. volatile禁止指令重排序</h4><p>Ø·在每个volatile<strong>写操作的前面</strong>插入一个<strong>StoreStore</strong>屏障，防止前面的写操作与当前的volatile写操作发生指令重排序。</p><p>Ø·在每个volatile<strong>写操作的后面</strong>插入一个<strong>StoreLoad</strong>屏障，防止当前的volatile写操作和后面的读操作发生指令重排序。</p><p>Ø·在每个<strong>volatile读操作的</strong>后面插入一个<strong>LoadLoad</strong>屏障。</p><p>Ø·在每个<strong>volatile读操作的</strong>后面插入一个<strong>LoadStore</strong>屏障。</p><ul><li>为什么volatile读前面没有屏障？<ul><li>JMM原本是在每个volatile写的后面，或者在每个volatile读的前面都插入一个StoreLoad屏障。从整体执行效率的角度考虑，JMM最终选择了只在每个volatile写的后面插入一个StoreLoad屏障。因为volatile写-读内存语义的常见使用模式是：一个写线程写volatile变量，多个读线程读同一个volatile变量。<strong>当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。</strong>因此可以看出JMM是<strong>先保证正确性然后才考虑的性能。</strong></li></ul></li></ul><p>由于JMM是<strong>先保证正确性然后才考虑的性能。</strong>所以在真正代码执行屏障插入的时候，编译器可以根据实际情况省略某些屏障！！</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231130223957979.png" class title="image-20231130223957979"><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231130224007219.png" class title="image-20231130224007219"><ul><li>为什么volatile写和普通写不能重排序？<ul><li>因为可能会引发以下问题<ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231130225009541.png" class title="image-20231130225009541"></li><li>当1和2之间没有数据依赖关系时，1和2之间就可能被重排序（3和4类似）。其结果就是：读线程B执行4时，不一定能看到写线程A在执行1时对共享变量的修改。</li></ul></li><li>所以在新的内存模型中进行了volatile的语意增强<ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231130225208019.png" class title="image-20231130225208019"></li></ul></li></ul></li></ul><h4 id="5-双重检查锁存在的问题"><a href="#5-双重检查锁存在的问题" class="headerlink" title="5.  双重检查锁存在的问题"></a>5.  双重检查锁存在的问题</h4><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231201164120235.png" class title="image-20231201164120235"><p>问题出现在第七行，因为创建对象的过程分为三个步骤，分别是1. 为创建的对象开辟一片内存空间 2. 对象的初始化 3. 把初始化好的对象指向开辟好的内存空间，这三步如果发生指令的重排序，比如第二行和第三行进行重排序，就会出现以下问题：</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231201164510079.png" class title="image-20231201164510079"><p>指令交换后，当其他线程发现instance不为空了，但是return回去对象可能还没有初始化</p><h4 id="6-基于volatile的解决方案"><a href="#6-基于volatile的解决方案" class="headerlink" title="6.基于volatile的解决方案"></a>6.基于volatile的解决方案</h4><p>在instance对象上加一个volatile修饰即可解决。</p><p>原理(大众式理解)：volatile禁止了 new 对象里边三行代码的重排序，所以初始化对象的操作一定在指向内存地址这一操作之前，所以不会发生问题。</p><p>个人理解：这个地方new instance对应的JVM指令也是new，所以这个地方可以看成一个volatile写，所以会在new这个操作前加一个storestore屏障，操作之后加一个storeload屏障，这时其他线程想要读取这个变量必须在storeload屏障以后进行读取，也就是说只有当new操作全部执行完时候才能读取，从而解决以上问题，但是new对象过程中的三个步骤还是有可能发生重排序</p><h4 id="7-基于类初始化的解决方案"><a href="#7-基于类初始化的解决方案" class="headerlink" title="7.基于类初始化的解决方案"></a>7.基于类初始化的解决方案</h4><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231201170222111.png" class title="image-20231201170222111"><p>JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。<strong>在执行类的初始化期间，JVM会去获取一个锁。</strong>这个锁可以防止多个线程对同一个类的初始化。锁可以保证原子性可见性，所以在一个线程完成类的初始化之前，其他线程看不见这个类</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231201170333032.png" class title="image-20231201170333032"><h3 id="Lock全解读"><a href="#Lock全解读" class="headerlink" title="Lock全解读"></a>Lock全解读</h3><h4 id="1-Lock锁的由来及API"><a href="#1-Lock锁的由来及API" class="headerlink" title="1. Lock锁的由来及API"></a>1. Lock锁的由来及API</h4><p>Lock锁放弃了隐式获取和释放锁的便捷性，但是却拥有了<strong>锁获取与释放的可操作性、可中断的获取锁以及超时获取锁</strong>等多种synchronized关键字所不具备的同步特性</p><ul><li>特性</li></ul><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231204214927802.png" class title="image-20231204214927802"><ul><li>API</li></ul><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231204215022959.png" class title="image-20231204215022959"><h4 id="2-队列同步器AQS"><a href="#2-队列同步器AQS" class="headerlink" title="2.队列同步器AQS"></a>2.队列同步器AQS</h4><p>队列同步器AQS是用来构建锁和其他同步组件的基础框架，他提供了一个int类型变量来获取锁的状态，通过维护一个先进先出的双端队列管理来竞争的线程，同步器重写以下方法，然后调用同步器提供的模板方法，模板方法中会调用自己重写的方法，最终是实现自定义锁</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231204221226033.png" class title="image-20231204221226033"><p>当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。在线程获取锁失败，加入同步队列尾端的时候需要保证线程安全，使用CAS提供当前线程认为的头节点和尾节点进行判断，看看现在是否能加入尾节点***(设置尾节点需要使用CAS的原因)***。</p><p><strong>设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，</strong>因此设置头节点的方法并不需要使用CAS来保证，它只需要将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可***(设置头节点不需要CAS的原因)***。</p><h4 id="3-ReentrantLock-非公平-的lock方法"><a href="#3-ReentrantLock-非公平-的lock方法" class="headerlink" title="3.ReentrantLock(非公平)的lock方法"></a>3.ReentrantLock(非公平)的lock方法</h4><p>调用lock方法后，会先后执行AQS中的以下方法</p><ul><li>compareAndSetState</li><li>acquire</li><li>addWaiter</li><li>enq</li><li>acquireQueued</li><li>shouldParkAfterFailedAcquire</li><li>parkAndCheckInterrupt</li><li>cancelAcquire</li></ul><p>acquire 方法是 aqs提供的模板方法，是为了进行锁的获取；tryAcquire 方法是aqs提供的可以复写的方法，主要是完成了加锁状态变化的逻辑（state）；addWaiter将我们的获取失败的线程放到我们的同步队列里；enq 如果addwaiter第一次没有成功，就进行死循环添加；acquireQueued：这部分其实是通过<strong>循环的自我检查</strong>，如果当前节点的pred节点是头节点，那么就尝试获取锁；如果不是头节点，就调用 shouldParkAfterFailedAcquire 方法，判断pred节点是否为 SIGNAL 状态，如果是signal状态，自己就好好的等着；如果是 cancel状态，就移除cancel的节点。其他状态的节点，会通过cas操作替换为 SIGNAL状态。parkAndCheckInterrupt方法是为了清除中断标志把当前线程挂起。在循环自我检查的过程中发现任何异常，这时会调用finally块中的cancelAcquire方法，把出现异常的线程状态设置为Cancelled </p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231205160117700.png" class title="image-20231205160117700"><p>两个比较重要的状态：</p><ol><li>SIGNAL：等待被通知状态，如果pre节点是这个状态，那么当前节点就会进行park操作</li><li>Cancelled ： 一个取消的线程状态。这个状态的线程会被移除</li></ol><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231205162740351.png" class title="image-20231205162740351"><h4 id="4-ReentrantLock的tryLock方法"><a href="#4-ReentrantLock的tryLock方法" class="headerlink" title="4.ReentrantLock的tryLock方法"></a>4.ReentrantLock的tryLock方法</h4><ul><li>不含参数<ul><li>表示一次性获取锁，获取成功了就成功了，获取失败了就失败了，不会进行重试</li></ul></li><li>含参数<ul><li>含有一个时间参数，表示可以在获取锁失败以后，在规定的时间内进行重试，循环获取锁，循环获取锁的逻辑和lock方法一样，都是先把线程封装成一个Node节点，然后判断自己前节点是不是头节点，如果是头节点则开始尝试获取锁</li><li>含参数的这个方法是支持中断的</li></ul></li></ul><h4 id="5-ReentrantLock的lockInterruptibly方法"><a href="#5-ReentrantLock的lockInterruptibly方法" class="headerlink" title="5.ReentrantLock的lockInterruptibly方法"></a>5.ReentrantLock的lockInterruptibly方法</h4><ul><li>lockInterruptibly方法，是一个支持中断的加锁方式。他与 lock.tryLock(1,null) 这个有什么区别？<br>相同点：都支持中断<br>不同点： lockInterruptibly方法仅仅支持中断；不支持超时。lock.tryLock(1,null)即支持超时，也支持超时内的时间中断</li></ul><h4 id="6-ReentrantLock的isHeldByCurrentThread方法"><a href="#6-ReentrantLock的isHeldByCurrentThread方法" class="headerlink" title="6.ReentrantLock的isHeldByCurrentThread方法"></a>6.ReentrantLock的isHeldByCurrentThread方法</h4><p>直接判断getExclusiveOwnerThread() &#x3D;&#x3D; Thread.currentThread()直接返回锁的持有线程是不是当前线程</p><h4 id="7-ReentrantLock的unlock方法"><a href="#7-ReentrantLock的unlock方法" class="headerlink" title="7.ReentrantLock的unlock方法"></a>7.ReentrantLock的unlock方法</h4><p>调用了unlock方法以后，会直接调用AQS的release方法，这也是一个模板方法，会直接调用到ReentrantLock复写的tryRelease方法，还是对state的值进行修改，只有当state的值被修改为0的时候，才会把当前锁的线程置为null，只有线程释放了锁，才会通知后继节点对锁进行争抢，通知的方式是先把线程自己的状态置为0，然后判断当前节点的后继节点状态是不是1，如果是1或者线程为空说明线程等待超时，或者被中断，这时会从后向前遍历整个同步队列，找到队列中第一个可以对锁进行争抢的节点，使用unpark方法对锁进行唤醒</p><h4 id="8-ReentrantLock-公平"><a href="#8-ReentrantLock-公平" class="headerlink" title="8.ReentrantLock(公平)"></a>8.ReentrantLock(公平)</h4><ol><li><p>synchronized 他是一个非公平锁。</p></li><li><p>Lock分为非公平锁（默认） 还有公平锁。</p><ul><li>非公平锁： 当我们的线程在同步队列里排队完成之后，获取锁的时候，这个时间点上如果有其他新的线程来竞争锁，那么我当前的排队的锁可能会被插队（当前线程可能竞争不过新来的线程，导致自己竞争锁失败。）这是不公平的，我（当前线程） 已经在同步队列里排了好长时间了，你这新来的线程直接抢走了。</li><li>公平锁：获取锁的时候，这个时间点上如果有其他新的线程来竞争锁，那么新的线程会直接加入到同步队列里（使用CAS放入队列的尾端）。</li></ul></li><li><p>性能比较：肯定是非公平锁性能更高。（所有新来的线程都要同步队列里，都要进行我们源码中的一系列的操作，公平锁会有更多的上下文切换）</p></li><li><p>非公平锁容易造成线程饥饿。（<strong>会被插队，极限情况考虑，如果一直被插队，同步队列里的其他线程就一直等着</strong>）</p></li><li><p>很多情况我们在进行实战开发的时候，如果要限定我们的线程的访问先后顺序，就要使用公平锁了。</p></li></ol><ul><li>公平锁的实现主要执行tryAcquire方法的时候，在线程使用CAS对state变量进行修改的时候，多了一个hasQueuedPredecessors方法的判断条件，就是判断当前这个要获取锁的线程是不是在队列中，如果不在队列中直接进入队列的tail等待</li></ul><h4 id="9-ReentrantReadWriteLock原理"><a href="#9-ReentrantReadWriteLock原理" class="headerlink" title="9.ReentrantReadWriteLock原理"></a>9.<strong>ReentrantReadWriteLock</strong>原理</h4><p>读线程获取读锁，写线程获取写锁，所以支持多个线程同时读，但是对于读写和写写依然是排他的，一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231205224745413.png" class title="image-20231205224745413"><p><strong>注意：上面的锁降级的意思是，读锁和写锁相互可以相互转换，而不是synchronized中的那个锁降级</strong></p><ul><li><p>ReentrantReadWriteLock也是维护了一个FIFO队列实现线程同步，也是维护了一个int类型的state变量，表示获取锁的次数，那么一个int变量是如何对读写两种锁进行统计的呢？</p><ul><li>在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写</li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231205225236301.png" class title="image-20231205225236301"></li></ul></li><li><p>写锁的获取</p><ul><li>通过lock.writeLock().lock()的方式进行锁的获取，然后依然是调用AQS提供的模板方法acquire，acquire调用ReentrantReadWriteLock复写的tryAcquire方法，进入加锁逻辑，先获取到读写锁当前的状态，然后把这个状态和1 &lt;&lt; 16 - 1进行&amp;操作，得到的就是写锁的状态，然后进行判断<ul><li>如果读写锁的状态不为0，但是写锁的状态为0，说明此时有线程正在读，所以return false</li><li>如果读写锁的状态不为0，写锁的状态也不为0，这时要判断写锁的线程主人是否是当前线程，如果不是当前线程，仍然return false</li><li>如果读写锁的状态不为0，同时写锁的状态也不同于以上两种情况，说明此时是写锁的重入，这时在可重入范围(0 — 1 &lt;&lt; 16 - 1)以内都可以进行加锁</li><li>如果读写锁的状态为0，那就好办了，说明此时还没有任何线程获取到锁，只需要看当前这个线程是否是公平的，如果是非公平的直接加锁，如果是公平的那么只有在队列中的线程才可以加锁</li></ul></li></ul></li><li><p>读锁的获取</p><ul><li>通过lock.readLock().lock()的方式进行锁的获取，然后调用的是AQS中提供的acquireShared这个模板方法，然后模板方法调用ReentrantReadWriteLock复写的tryAcquireShared方法，进入获取锁的逻辑，先判断写锁有没有被获取，如果写锁被获取，且获取写锁的线程还不是自己，那么就直接获取读锁失败，如果写锁没有被获取，或者获取写锁的线程就是当前线程，那么就获取读锁，并且读状态加一(加的是 1 &lt;&lt; 16)</li><li>读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在ThreadLocal中（A 和 B 线程获取读锁，A线程重入了3次, B线程只有1次，那么对于我们读锁的读状态&#x3D; 3+1 &#x3D; 4；<strong>A线程的ThreadLoca保存了 3，B线程的ThreadLocal保存了1</strong>）<strong>，</strong>由线程自身维护，所以在释放锁的时候要对应减去自己ThreadLocal中保存的获取锁的状态。</li></ul></li></ul><h4 id="10-ReentrantReadWriteLock的锁降级"><a href="#10-ReentrantReadWriteLock的锁降级" class="headerlink" title="10.ReentrantReadWriteLock的锁降级"></a>10.ReentrantReadWriteLock的锁降级</h4><p><strong>锁降级指的是写锁降级成为读锁</strong>。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指<strong>把持住（当前拥有的）写锁</strong>，<strong>再获取到读锁</strong>，<strong>随后释放（先前拥有的）写锁的过程</strong>。</p><ul><li>锁降级中读锁的获取是否必要呢？<ul><li>必要。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻<strong>另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。</strong>如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会一直被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。</li></ul></li></ul><h4 id="11-LockSupport工具"><a href="#11-LockSupport工具" class="headerlink" title="11.LockSupport工具"></a>11.<strong>LockSupport</strong>工具</h4><p>LockSupport定义了一组的公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231206200046659.png" class title="image-20231206200046659"><p>上面的park和unpark方法都是直接调用的native方法，所以是直接和操作系统进行了交互，在Java 6中，LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos)和parkUntil(Object blocker,long deadline)3个方法，也就是在原方法的基础上加了一个参数，其中参数<strong>blocker是用来标识当前线程在等待的对象</strong>，调用这个方法会导致线程dump的日志中多出等待对象的信息(下图黄色部分)，从而方便问题排查和系统监控。</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231206200726045.png" class title="image-20231206200726045"><h4 id="12-Condition解读"><a href="#12-Condition解读" class="headerlink" title="12.Condition解读"></a>12.<strong>Condition</strong>解读</h4><ul><li><p>Condition介绍</p><ul><li>Condition接口提供了类似Object的监视器(wait&#x2F;notify)方法，与Lock配合可以实现等待&#x2F;通知模式，但是这两者在使用方式以及功能特性上还是有差别的。</li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231206215911098.png" class title="image-20231206215911098"></li></ul></li><li><p>Condition使用</p><ul><li>通过lock.newCondition()的形式进行队列的创建，Condition调用await方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的singal方法，通知当前线程，当前线程才从await方法返回，并且在返回前已经获取了锁。多用于生产者和消费者的形式中，例如当生产者的队列满了以后，调用await方法等待，然后唤醒消费者线程。当没东西可以消费的时候，消费者线程会调用await方法进入等待状态，然后通知生产者线程继续生产</li></ul></li><li><p>Condition的原理</p><ul><li>通过newCondition得到的队列也是一个FIFO队列，称为等待队列，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。事实上，节点的定义复用了同步器中节点的定义，也就是AbstractQueuedSynchronizer.Node，一个Condition包含一个等待队列，Condition拥有首节点（firstWaiter）和尾节点（lastWaiter）。上述节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。</li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207125211837.png" class title="image-20231207125211837"></li><li>并发包中的Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列，其对应关系如图所示。一个线程持有锁，调用了await方法之后加入了<strong>等待队列</strong>进行排队，当我们的这个线程被唤醒（需要执行await后边的代码），需要重新竞争锁（因为await方法将锁释放掉了）。如果竞争成功执行后续代码，如果竞争失败，就会加入到<strong>同步队列</strong>里进行排队。如果排到了同步队列的头部且争抢锁成功，就继续执行await方法后边的代码。如果在执行过程中又调用了await方法，就再次回到等待队列。依次循环下去。</li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207125453697.png" class title="image-20231207125453697"></li></ul></li><li><p>await和signal重点源码</p><ul><li><p>await</p><ul><li><pre><code class="java">if (Thread.interrupted())//先查看线程的中断标记，如果被中断则直接抛出异常    throw new InterruptedException();Node node = addConditionWaiter();//加入到等待队列的尾端int savedState = fullyRelease(node);//释放锁<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- signal</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    if (first != null)</span><br><span class="line">        doSignal(first);//唤醒等待队列的首节点</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul><h3 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h3><h4 id="1-什么是原子操作类"><a href="#1-什么是原子操作类" class="headerlink" title="1.什么是原子操作类"></a>1.什么是原子操作类</h4><p><strong>原子操作类：提供了可以保证我们线程安全的类。可以直接使用。</strong>Java从JDK 1.5开始提供了java.util.concurrent.atomic包，这个包中的原子操作类提供了一种用法简单、性能高效（使用CAS不会阻塞线程）、线程安全地更新一个变量的方式。</p><p>因为变量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是<strong>原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。</strong>Atomic包里的类基本都是使用Unsafe实现的包装类。</p><h4 id="2-原子更新基本类型类"><a href="#2-原子更新基本类型类" class="headerlink" title="2.原子更新基本类型类"></a>2.<strong>原子更新基本类型类</strong></h4><p>使用原子的方式更新基本类型，Atomic包提供了以下3个类。</p><p>·AtomicBoolean：原子更新布尔类型。</p><p>·AtomicInteger：原子更新整型。</p><p>·AtomicLong：原子更新长整型。</p><p>以原子更新整型为例，可以调用其incrementAndGet方法，先对初始化的值进行加一，然后返回相加后的值</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207220113917.png" class title="image-20231207220113917"><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207220241440.png" class title="image-20231207220241440"><p>底层直接调用了native方法，使用CAS保证了原子性</p><h4 id="3-原子更新数组型类"><a href="#3-原子更新数组型类" class="headerlink" title="3.原子更新数组型类"></a>3.原子更新数组型类</h4><p>通过原子的方式更新数组里的某个元素，Atomic包提供了以下3个类。</p><p>·AtomicIntegerArray：原子更新整型数组里的元素。</p><p>·AtomicLongArray：原子更新长整型数组里的元素。</p><p>·AtomicReferenceArray：原子更新引用类型数组里的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayAtomicTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        array[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">        array[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">        <span class="type">AtomicIntegerArray</span> <span class="variable">aia</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(array);</span><br><span class="line">        aia.compareAndSet(<span class="number">0</span>, <span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line">        System.out.println(aia.get(<span class="number">0</span>)); <span class="comment">// 11</span></span><br><span class="line">        System.out.println(array[<span class="number">0</span>]);<span class="comment">// 10</span></span><br><span class="line">        <span class="comment">//我们的数组的原子操作类，只是复制了我们之前的array的对象，并不会</span></span><br><span class="line">        <span class="comment">//在操作中改变原有array的值。</span></span><br><span class="line">        <span class="comment">//原始的array只作为一个入参。真正保障我们的原子性的还是我们的AtomicIntegerArray</span></span><br><span class="line">        <span class="comment">//备份的这个一份儿数据。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>AtomicIntegerArray的备份操作，克隆了一份原数组，而不是对原数组直接进行修改<ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207221600191.png" class title="image-20231207221600191"></li></ul></li></ul><p>里面的方法基本都见名知意，而底层基本也都是使用Unsafe类的CAS方法来保证原子性</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207221058981.png" class title="image-20231207221058981"><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207221116257.png" class title="image-20231207221116257"><h4 id="4-原子更新引用类"><a href="#4-原子更新引用类" class="headerlink" title="4.原子更新引用类"></a>4.<strong>原子更新引用类</strong></h4><p>原子更新引用类型提供的类中常用的两个类：</p><p>·AtomicReference：原子更新引用类型。</p><p>·AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</p><p>底层依然是CAS</p><ul><li><p>对于原子更新数组和引用的总结：</p><ul><li><p><strong>对于原子更新数组类和原子更新对象引用类，他们实质上就是将我们的数组和对象的外层进行了一次 Atomic</strong> <strong>的封装。所以，在进行替换的时候，其实是外层的这个封装保证了原子性。</strong></p><p><strong>想想我们的原子更新基本类型如：Integer，也是在他的外层进行了一次封装。</strong></p></li></ul></li></ul><h4 id="5-原子更新字段类"><a href="#5-原子更新字段类" class="headerlink" title="5.原子更新字段类"></a>5.<strong>原子更新字段类</strong></h4><p>如果需要原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新。</p><p>·AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</p><p>·AtomicLongFieldUpdater：原子更新长整型字段的更新器。</p><p>·AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的ABA问题。(ABA问题：<a href="https://blog.csdn.net/weixin_45839894/article/details/105286123">并发编程的艺术08-并发队列与ABA问题_队列 aba-CSDN博客</a>)</p><p>要想原子地更新字段类需要两步。<strong>第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新类的字段（属性）必须使用public volatile修饰符。</strong></p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207223857004.png" class title="image-20231207223857004"><p>底层依然是CAS</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207224000538.png" class title="image-20231207224000538"><h3 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h3><h4 id="1-CountDownLatch介绍"><a href="#1-CountDownLatch介绍" class="headerlink" title="1. CountDownLatch介绍"></a>1. <strong>CountDownLatch</strong>介绍</h4><p>CountDownLatch 中 count down 是倒数的意思，latch 则是门闩的含义。整体含义可以理解为<strong>倒数完成后，门栓打开。倒数没有完成，门栓紧闭。</strong>CountDownLatch 类似于join方法，等待其他线程执行完成后，才会统一继续执行下边的代码。但是它比join的功能更多。</p><p>常用方法说明：</p><p>Ø<strong>CountDownLatch(int count)</strong>; &#x2F;&#x2F;构造方法，创建一个值为count 的计数器。</p><p>Ø<strong>await()</strong>;&#x2F;&#x2F;阻塞当前线程，将当前线程加入阻塞队列。</p><p>Ø<strong>await(long timeout, TimeUnit unit)</strong>;&#x2F;&#x2F;在timeout的时间之内阻塞当前线程,时间一过则当前线程可以执行，</p><p>Ø<strong>countDown()</strong>;&#x2F;&#x2F;对计数器进行递减1操作，当计数器递减至0时，当前线程会去唤醒阻塞队列里的所有线程。</p><ul><li><p>使用示例：每条线程执行完之后，倒数的计数器都会减一，直到减为0，才能执行await后面的代码</p><ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208173827228.png" class title="image-20231208173827228"></li></ul></li><li><p>CountDownLatch 的源码也是一个实现类AQS的Sync，调用await方法相当于是获取锁，调用countDown方法相当于是对锁的状态不断减一，直到减到零，才能释放锁</p></li></ul><h4 id="2-CyclicBarrier介绍"><a href="#2-CyclicBarrier介绍" class="headerlink" title="2.CyclicBarrier介绍"></a>2.<strong>CyclicBarrier</strong>介绍</h4><p>CyclicBarrier的字面意思是<strong>可循环使用（Cyclic）的屏障（Barrier</strong>）。它要做的事情是，让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p><p>CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p><p><strong>CountDownLatch的计数器只能使用一次</strong>，<strong>而CyclicBarrier的计数器可以使用reset()方法重置</strong>。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。CyclicBarrier在初始化时候的传参，除了设置屏障个数以外，能够支持传入一个 Runnable的 action去做后续的数据的操作。能够适用于更加复杂的场景。</p><p>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。</p><ul><li><p>CyclicBarrier和CountDownLatch 的使用区别(需求：A线程完成3+5，B线程完成10+2，然后主线程对结果进行相加)</p><ul><li>使用CountDownLatch完成<ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208182601180.png" class title="image-20231208182601180"></li></ul></li><li>使用CyclicBarrier完成<ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208182813315.png" class title="image-20231208182813315"></li></ul></li><li>总结：CountdownLatch里边的参数直接写的是2，就是进行2次倒计时，我们的main函数调用的await。就是告诉我们main线程在等待其他两个线程执行完毕。 然而，对于 CyclicBarrier 这种实现形式，main函数和其他两个线程都被阻塞到了一个地方。此处main函数到达了屏障之后挂起自己，等待其他两个线程达到屏障之后才开始执行。<strong>CountdownLatch 针对业务完成之后放行；CyclicBarrier 针对的是所有的线程在统一的屏障集合之后开始执行后续代码</strong></li></ul><ul><li>使用CyclicBarrier传入的Runnable的 action完成<ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208183829168.png" class title="image-20231208183829168"></li></ul></li></ul></li></ul><h4 id="3-Semaphore介绍"><a href="#3-Semaphore介绍" class="headerlink" title="3.Semaphore介绍"></a>3.<strong>Semaphore</strong>介绍</h4><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p><p>Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制。</p><ul><li>示例代码<ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208185046260.png" class title="image-20231208185046260"></li><li>这样就可以保证同一时间数据库最多只有十条线程对其进行连接</li></ul></li></ul><h4 id="4-Exchanger介绍"><a href="#4-Exchanger介绍" class="headerlink" title="4.Exchanger介绍"></a>4.<strong>Exchanger</strong>介绍</h4><p>Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果<strong>第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</strong></p><p>下面来看一下Exchanger的应用场景。Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作，比如我们需要将<strong>纸制银行流水通过人工的方式录入成电子银行流水</strong>，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致。</p><h3 id="Java阻塞与非阻塞队列"><a href="#Java阻塞与非阻塞队列" class="headerlink" title="Java阻塞与非阻塞队列"></a>Java阻塞与非阻塞队列</h3><h4 id="1-ConcurrentLinkedQueue非阻塞队列"><a href="#1-ConcurrentLinkedQueue非阻塞队列" class="headerlink" title="1.ConcurrentLinkedQueue非阻塞队列"></a>1.<strong>ConcurrentLinkedQueue</strong>非阻塞队列</h4><p>在多线程并发环境下，如果想要实现一个线程安全的队列，无非两种方式</p><ol><li>加锁</li><li>使用CAS</li></ol><p>ConcurrentLinkedQueue是一个基于<strong>链接节点的无界线程安全队列</strong>，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元素时，它会返回队列头部的元素，底层使用CAS保证线程安全。</p><p>ConcurrentLinkedQueue在节点入队的时候，先会检查tail的next节点是不是为空，如果tail的next节点为空，那么新来的节点直接放到tail的next的位置，如果tail的next节点不为空，那么新来的节点直接放到tail的next节点的next节点，同时把tail指向新来的节点，所以tail指向的不一定是尾节点</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208220706859.png" class title="image-20231208220706859"><p>ConcurrentLinkedQueue在节点出队的时候，当head节点里有元素时，直接弹出head节点里的元素，而不会更新head节点。只有当head节点里没有元素时，出队操作才会更新head节点(head指向弹出节点的next节点)。所以，并不是每次出队时都更新head节点，也就是说head并不一定一直指向头节点</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208220848350.png" class title="image-20231208220848350"><h4 id="2-阻塞队列介绍"><a href="#2-阻塞队列介绍" class="headerlink" title="2.阻塞队列介绍"></a>2.阻塞队列介绍</h4><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列：</p><p>1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。</p><p>2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。</p><p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208221559308.png" class title="image-20231208221559308"><p><em>注：返回特殊值例如true或者false</em></p><ul><li>JDK7提供的阻塞队列：<ul><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ul></li></ul><h4 id="3-有界阻塞队列"><a href="#3-有界阻塞队列" class="headerlink" title="3.有界阻塞队列"></a>3.有界阻塞队列</h4><p>ArrayBlockingQueue是一个用<strong>数组</strong>实现的<strong>有界阻塞队列</strong>。此队列按照<strong>先进先出（FIFO）</strong>的原则对元素进行排序。</p><p>LinkedBlockingQueue是一个用<strong>链表</strong>实现的<strong>有界阻塞队列</strong>。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照<strong>先进先出</strong>的原则对元素进行。</p><ul><li><p>相同点：</p><ul><li>都是阻塞队列，且有界；</li><li>都是先进先出</li></ul></li><li><p>不同点：</p><ul><li>锁使用的不同，ArrayBlockingQueue元素入队和出队使用的是一把ReentrantLock，所以进出会相互影响，LinkedBlockingQueue使用的是两把ReentrantLock，一个take锁，一个put锁，入队出队只需要获取对应的锁即可，所以进出互不影响。所以从这一方面来看LinkedBlockingQueue更适合高并发场景，具有更高的吞吐量(单位时间处理更多请求)</li><li>ArrayBlockingQueue使用的是object的数组存储的元素，而LinkedBlockingQueue使用的是Node节点进行的元素存储，而且有next节点。如果数据量非常大的情况下，随着数据量的增长，我们需要构建的Node节点的数量就越多，Node节点数量代表的是对象的数量，一旦有这么多对象的产生，就会有产生对象的jvm的消耗;使用完成需要进行垃圾回收; 而且还存在next指针问题。反观我们的 array，就是一个数组,内存空间连续,不需要额外构造node节点了。直接object定义的我们的底层数组，可以存放任何类型的对象，不需要构造 node。</li><li>队列长度问题。如果我们要创建ArrayBlockingQueue,需要严格指定queue的大小，也就是说，我们在使用这个queue之前就开辟好了内存空间。而LinkedBlockingQueue不强制指定大小。因为每次插入一个新的节点，都会new 一个Node对象，都会开辟一块新的内存空间。如果我们能够确定定长的队列，建议使用arrayqueue。</li></ul></li></ul><p>总结：至于谁的效率更好，真的没有办法界定。因为你永远无法知道，创建节点开辟内存空间的消耗，创建Node对象的消耗，回收Node对象的消耗，和ArrayBlockingQueue 的单锁的消耗谁大谁小。所以有条件一定进行压测然后再选取</p><h4 id="4-优先级队列和延时队列"><a href="#4-优先级队列和延时队列" class="headerlink" title="4.优先级队列和延时队列"></a>4.优先级队列和延时队列</h4><ul><li>PriorityBlockingQueue优先级队列的介绍：</li></ul><p>PriorityBlockingQueue是一个支持优先级的无界阻塞队列。底层是使用数组来进行元素的保存,如果达到数组的大小会进行扩容，默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PriorityBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityBlockingQueue</span>&lt;&gt;(<span class="number">10</span>,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                    <span class="comment">// 降序排列，如果o1小于o2，返回-1，如果o1等于o2，返回0，如果o1大于o2，返回1</span></span><br><span class="line">                    <span class="keyword">return</span> o2 - o1;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>DelayQueue延时队列介绍</li></ul><p>DelayQueue是一个<strong>支持延时</strong>获取元素的<strong>无界阻塞队列</strong>。队列使用<strong>PriorityQueue</strong>来实现。队列中的元素必须实现<strong>Delayed接口</strong>，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。</p><p><strong>DelayQueue非常有用，可以将DelayQueue运用在以下应用场景。</strong></p><p><strong>缓存系统的设计</strong>(很少有公司自己设计大型缓存：Redis，ehcache)：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</p><p><strong>定时任务调度</strong>：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。</p><p>由于它底层的队列是由PriorityQueue实现的，所以它可以实现优先级排序，可以根据加入任务的时间进行升序排列，剩余时间越小的越靠前，当从队列中取数据的时候，会先调用peek方法，看看第一个任务是不是空，看看第一个任务是不是到期可以执行了，然后才会取出任务，其中poll方法在取任务的时候发现任务不能取出，会直接返回null，而take方法在取数据的时候如果第一个任务不能取出，那么这时会死循环返回获取</p><ul><li>signal和await在这个地方的配合<ul><li>如果取任务的线程发现队列中第一个任务不可取，或者第一个去取得线程(leader)不为空，那么说明这个取线程一定取不到任务，这时会调用await进入等待队列，当放任务的线程把一个任务放到空队列的时候，会调用signal方法唤醒正在等待队列中等待的取线程</li></ul></li></ul><h4 id="5-SynchronousQueue介绍"><a href="#5-SynchronousQueue介绍" class="headerlink" title="5.SynchronousQueue介绍"></a>5.<strong>SynchronousQueue</strong>介绍</h4><p>SynchronousQueue<strong>是一个不存储元素的阻塞队列</strong>。每一个put操作必须等待一个take操作，否则不能继续添加元素。</p><p>它支持公平访问队列。<strong>默认情况下线程采用非公平性策略访问队列</strong>。如果设置为true，则等待的线程会采用先进先出的顺序访问队列。</p><ul><li><p>使用场景</p><ul><li><p>不存储数据的队列，阻塞队列。适合短期的小并发场景，且数据处理相当快速。</p><p>硬说点好处：首先他没有缓冲容量，那么他可以避免在服务器宕机的情况下，从queue的角度来说，没有数据丢失这么一说。 他类似于一个<strong>传球手</strong>，中间没有任何介质阻碍。如果单纯的进行数据的传递且生产的线程与消费的线程生产时间和消费时间比较同步的话，他的性能能够很高。</p></li><li><p>CachedThreadPool 里边使用的就是SynchronousQueue。CachedThreadPool 的使用场景就是处理<strong>快速的短期的小并发场景。</strong>CachedThreadPool 是没有核心线程数，完全依赖max线程数，直接依赖操作系统创建线程，如果是短期的小并发，在线程达到 keep live 时间以后，可以自行销毁。</p></li></ul></li></ul><h4 id="6-LinkedTransferQueue介绍（无界、传球手、阻塞）"><a href="#6-LinkedTransferQueue介绍（无界、传球手、阻塞）" class="headerlink" title="6.LinkedTransferQueue介绍（无界、传球手、阻塞）"></a>6.<strong>LinkedTransferQueue</strong>介绍（无界、传球手、阻塞）</h4><p>LinkedTransferQueue是一个由<strong>链表结构</strong>组成的<strong>无界阻塞TransferQueue队列</strong>。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。</p><p>LinkedTransferQueue是一个高效阻塞无界链表队列(被称为综合性的阻塞队列) 。和 SynchronousQueue.TransferQueue (<strong>公平模式</strong>) 相比，它是可以统计长度(使用getWaitingConsumerCount方法查询有多少个正在等待获取的线程，没有获取到的线程会被封装成Node节点)；和 LinkedBlockingQueue 相比，它拥有更高的性能（使用 CAS 自旋，LinkedBlockingQueue使用的是lock锁）；和 ConcurrentLinkedQueue 相比，它拥有阻塞功能（因为它实现了TransferQueue，TransferQueue继承了BlockingQueue）。</p><p><strong>（1）transfer方法</strong></p><p>如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者（与SynchronousQueue相似<strong>）。如果没有消费者在等待接收元素，transfer方法会将元素</strong>存放在队列的tail节点，并等到该元素被消费者消费了才返回。</p><p><strong>（2）tryTransfer方法</strong> </p><p>tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。</p><p>对于带有时间限制的tryTransfer（E e，long timeout，TimeUnit unit）方法，试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</p><h4 id="7-LinkedBlockingDeque介绍"><a href="#7-LinkedBlockingDeque介绍" class="headerlink" title="7.LinkedBlockingDeque介绍"></a>7.<strong>LinkedBlockingDeque</strong>介绍</h4><p>LinkedBlockingDeque是一个由<strong>链表结构</strong>组成的<strong>双向阻塞队列</strong>。所谓双向队列指的是可以从队列的两端插入和移出元素（LinkedBlockingDeque产生的原因是什么？1.首先它是对LinkedBlockingQueue的一个补充，能支持双向存取； 2.对阻塞队列的补充支持双向存取）。</p><p>双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法</p><p>在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“**工作窃取(Fork&#x2F;Join框架中细说)**”模式中。</p><ul><li>既然有双向队列，还那么方便，为什么不直接把单向队列移除? <ul><li>功能越多，向 越多，Node节点越复杂，添加，移除越复杂，维护起来更加麻烦；虽然是减小了竞争压力，但是对于一些不是很大竞争压力下的场景，我们的单向的队列还是非常好用的</li></ul></li></ul><h4 id="8-Fork-x2F-Join框架"><a href="#8-Fork-x2F-Join框架" class="headerlink" title="8.Fork&#x2F;Join框架"></a>8.<strong>Fork&#x2F;Join框架</strong></h4><ul><li><p>Fork&#x2F;Join框架介绍</p><ul><li>Fork&#x2F;Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务(调用compute方法)，最终汇总每个小任务结果后得到大任务结果的框架。再通过Fork和Join这两个单词来理解一下Fork&#x2F;Join框架。Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。</li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231209221211915.png" class title="image-20231209221211915"></li></ul></li><li><p>工作窃取算法</p><ul><li>介绍<ul><li>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。那么，为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，<strong>把这些子任务分别放到不同的队列里</strong>，并为每个队列<strong>创建一个单独的线程来执行队列里的任务</strong>，线程和队列一一对应。比如A线程负责处理A队列里的任务。但是，有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。</li></ul></li><li>与双端队列的配合<ul><li>窃取其他队列中的任务时，它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。工作窃取算法的缺点：如果队列中只剩一个任务，还是会出现竞争，<strong>并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</strong></li></ul></li></ul></li><li><p>Fork&#x2F;Join框架使用</p><ul><li><p>Fork&#x2F;Join使用两个类来完成以上两件事情。</p><p>①<strong>ForkJoinTask</strong>：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中<strong>执行fork()<strong>和</strong>join()<strong>操作的机制。通常情况下，我们</strong>不需要直接继承ForkJoinTask类</strong>，只需<strong>要继承它的子类</strong>，Fork&#x2F;Join框架提供了以下两个子类。</p><p>·<strong>RecursiveAction</strong>：用于没有返回结果的任务。</p><p>·<strong>RecursiveTask</strong>：用于有返回结果的任务。</p><p>②<strong>ForkJoinPool</strong>：ForkJoinTask需要通过ForkJoinPool来执行。</p></li><li><pre><code class="java">//使用fork/join计算从一加到一百public class ForkJoinTest extends RecursiveTask&lt;Integer&gt; &#123; //需要返回结果    private static final int THRESHOLD = 2; // 最多几个数字做子任务    private int start; //从那块相加    private int end;// 加到几    public ForkJoinTest(int start, int end) &#123;        this.start = start;        this.end = end;    &#125;    @Override    protected Integer compute() &#123; //拆分任务，获取结果        int sum = 0;        // 如果任务足够小就计算任务        boolean canCompute = (end - start) &lt; THRESHOLD;        if (canCompute) &#123;            for (int i = start; i &lt;= end; i++) &#123;                sum += i;            &#125;        &#125; else &#123;            // 如果任务大于阈值，就分裂成两个子任务计算            int middle = (start + end) / 2;            ForkJoinTest leftTask = new ForkJoinTest(start, middle);            ForkJoinTest rightTask = new ForkJoinTest(middle + 1, end);            // 执行子任务            leftTask.fork();            rightTask.fork();            // 等待子任务执行完，并得到其结果            int leftResult = leftTask.join();            int rightResult = rightTask.join();            // 合并子任务            sum = leftResult + rightResult;        &#125;        return sum;    &#125;    public static void main(String[] args) &#123;        ForkJoinPool forkJoinPool = new ForkJoinPool();        // 生成一个计算任务，负责计算1+2+3+4        ForkJoinTest task = new ForkJoinTest(1, 100);        // 执行一个任务        Future&lt;Integer&gt; result = forkJoinPool.submit(task);        try &#123;            System.out.println(result.get());        &#125; catch (InterruptedException e) &#123;        &#125; catch (ExecutionException e) &#123;        &#125;    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 线程池与Executor框架</span><br><span class="line"></span><br><span class="line">#### 1.**线程池的原理**</span><br><span class="line"></span><br><span class="line">* 线程池运行步骤：</span><br><span class="line"></span><br><span class="line">1）使用者提交任务以后，如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</span><br><span class="line"></span><br><span class="line">2）如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue队列。</span><br><span class="line"></span><br><span class="line">3）如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。</span><br><span class="line"></span><br><span class="line">4）如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231209225302725.png image-20231209225302725 %&#125;</span><br><span class="line"></span><br><span class="line">* ThreadPoolExecutor为什么采取上述步骤的总体设计思路？(或者问：线程池为什么要有一个核心线程数和最大线程数的区分呢？)</span><br><span class="line"></span><br><span class="line">**是为了在执行execute()方法时，尽可能地避免获取全局锁**</span><br><span class="line"></span><br><span class="line">1. 核心线程数和最大线程数中间还有一个queue，向queue里添加任务不需要获取全局锁。如果核心线程数够用，不一定先要去创建其他的线程，因为需要看queue是否还能够继续容纳新的请求； 如果没有所谓的最大的线程数，只有一个核心线程数，那么当我们线程池的核心线程数配置小了的话，那么很多任务都会添加到queue里。如果queue满了，我们就没有其他的办法创建新的额外的线程了。</span><br><span class="line"></span><br><span class="line">2. 如果仅仅依靠核心线程数，比如说我们将核心线程数的值设置的非常大，每次有新任务过来，都有可能在核心线程数里边创建新的线程，可能会造成全局锁的获取，导致性能一个瓶颈。</span><br><span class="line"></span><br><span class="line">* 全局锁？在那块儿有这个逻辑？</span><br><span class="line"></span><br><span class="line">当我们的ThreadPoolExecutor进行execute方法执行的时候，如果当前的工作线程小于 Coresize，就会进行一个新的工作线程的添加，调用 addWorker 方法，这个方法里，当我们进行最终的worker.add的时候，是在一个ReentrantLock里执行的。也就是说，此处不允许并发添加新的worker。如果同时有多个线程进来，且都小于coresize，只能排队添加。</span><br><span class="line"></span><br><span class="line">#### 2.线程池参数</span><br><span class="line"></span><br><span class="line">1）**corePoolSize**（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</span><br><span class="line"></span><br><span class="line">2）**runnableTaskQueue**（任务队列）**建议选用有界队列**。1. 如果是无界队列，那么queue永远不会满，永远不会触发到maximumPoolSize，意味着maximumPoolSize这个参数就没有他的作用了； 2. 最重要的是无界队列无法控制队列最终包含的数据量，导致内存资源的极大的消耗甚至耗尽。3. 最好是选用有界队列并合理的配置maximumPoolSize。4 饱和策略的使用根据需求选择。一旦我们触发了饱和策略，就说明：要么是我们的线程池配置有问题，要么真的是并发量太高，任务太多，导致的问题。警醒我们进行深入的参数调查及合理分配。</span><br><span class="line"></span><br><span class="line">3）**maximumPoolSize**（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。</span><br><span class="line"></span><br><span class="line">4）ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线程设置有意义的名字</span><br><span class="line"></span><br><span class="line">5）**RejectedExecutionHandler**（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略。</span><br><span class="line"></span><br><span class="line">·**AbortPolicy**：直接抛出异常。相对多一些，因为我们会在异常处理的过程中进行各种手段：如果记录日志，存入数据库等待重试</span><br><span class="line"></span><br><span class="line">·**CallerRunsPolicy**：只用调用者所在线程来运行任务。用的也相对少一些。调用者线程也是系统资源，说明线程数量已经很多了，调用者线程的加入其实是变相增加了 maxsize</span><br><span class="line"></span><br><span class="line">·**DiscardOldestPolicy**：丢弃队列里最近的一个任务，并执行当前任务。几乎没有人使用。</span><br><span class="line"></span><br><span class="line">·**DiscardPolicy**：不处理，丢弃掉。 这种使用的也少</span><br><span class="line"></span><br><span class="line">当然，也可以根据应用场景需要来实现**RejectedExecutionHandler**接口**自定义策略**。（最推荐）</span><br><span class="line"></span><br><span class="line">6）keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率,如果是一个多线程一同执行的一个大任务，例如一个定时任务，一天执行一次，这时可以把keepAliveTime的时间调小一些。</span><br><span class="line"></span><br><span class="line">7）TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</span><br><span class="line"></span><br><span class="line">#### 3.如何合理的配置线程池</span><br><span class="line"></span><br><span class="line">1. 我们的线程池是生存在一个复杂的系统环境里，我们还有其他的接口需要使用我们的服务器资源，所以在进行线程池coresize的配置以及maxsize的配置的时候，我们需要明确我们当前的接口的重要性，如果当前接口占据了未来业务访问的50%，那么就可以分配50%的系统资源给当前接口。（我们一个服务，总有一些重要接口和非重要接口，在我们进行项目开发初期，需求就定好了。）</span><br><span class="line">2. 线程池参数的配置一定要基于压测。来评估线程池的参数是否合理。</span><br><span class="line">   - 初次压测的参数配置：</span><br><span class="line">     - 情况一：当前的服务器只为当前的线程池服务。这时可以站在前辈的肩膀，根据前辈的经验，看当前任务是CPU密集型任务还是IO密集型任务，如果是CPU密集型的，那么可以选与当前CPU核数差不多的线程数，或者稍微大一点点的，如果是IO密集型的，那么可以选择CPU核数的两倍或者稍微大一点点的</span><br><span class="line">     - 情况二：当前的服务器不是只为这一个线程池服务。举个场景，一个服务共有五个接口，其中两个重要接口，三个不重要接口(访问量大的时候可以做降级处理，保障另外两个接口可以尽可能多的使用服务器资源)，这两个重要接口都创建了线程池来提高单接口的并发处理速度，这时首先要做的是拿到线上高并发访问压力下该服务每个接口的访问比例，比如这五个接口的访问比例是4：3：1：1：1，那么对于第二个接口而言，它就有资格占用3/10的服务器资源，那么他的线程池的最大线程数可以粗略的设置为当前CPU核数的3/10，首次压测，把核心线程数也设置为和最大线程数相同的大小，然后开始压测，看当前线程池能否撑得住现在的并发访问量，如果撑得住慢慢调小核心线程数，如果撑不住这时queue就要登场了，至于队列大小的计算，需要根据接口访问峰值和持续时间，比如，双11，618等等活动，都会有一个高峰的访问持续时间，假如高峰情况下访问一个小时，打到该接口的请求一共有1000个，而当前接口正常情况下一个小时能处理的请求数量是800个，这时可以得到1000-800=200这个值，然后把200这个值稍微调高50%(为了避免访问不均匀的问题，当然如果访问量曲线比较平稳可以适当降低这个值，比如就调高10%-20%)，也就是300作为这个有界队列的初始大小，然后再次压测，这时如果可以达到要求，那么为了避免资源的浪费，再次降低核心线程数的数量 ，但是如果还没有达到预期要求，可以从以下几点进行解决，1.再次提高队列的长度(不要首先想提高线程数，而是先动队列的长度上限，因为这样一定不会影响到其他接口，属于空间换时间)2.如果由于调高了队列的长度，没有提高线程数导致接口性能下降，这时考虑对代码进行优化(比如可不可以把目前的接口做成异步的，对于消息的处理可不可进行服务的拆分，把他放到RabbitMQ里，由下游的服务从RabbitMQ里边，进行多线程的处理，提高当前接口的并发量)3.如果对代码优化之后还是不能达到预期，这时才可以考虑调高一下线程数，因为如此大的并发情况下，另外三个接口可能做出了服务的降级处理让出了一定服务器资源，但是并不建议这么做，因为虽然其他接口做了降级处理，还是有可能因为提高线程数而引起其他节点的一些问题4.增加节点数量。</span><br><span class="line">3. 我们要给线程池开后门，可以动态的调整线程池的参数。（我们现在很多大型项目都有自己的配置中心，appolo是一个非常好的配置组件，你可以将coresize和maxsize配置到配置中心，一旦发生不可控的高并发场景，可以随时修改配置中心的参数，我们的项目就会按照新的标准进行调整。）</span><br><span class="line"></span><br><span class="line">#### 4.**线程池的监控及关闭**</span><br><span class="line"></span><br><span class="line">* 线程池的监控</span><br><span class="line"></span><br><span class="line">  * 如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根据线程池的使用状况快速定位问题。可以通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性。</span><br><span class="line"></span><br><span class="line">    ·taskCount：线程池需要执行的任务数量。</span><br><span class="line"></span><br><span class="line">    ·completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。</span><br><span class="line"></span><br><span class="line">    ·largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。</span><br><span class="line"></span><br><span class="line">    ·getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。</span><br><span class="line"></span><br><span class="line">    ·getActiveCount：获取活动的线程数。</span><br><span class="line"></span><br><span class="line">    通过扩展线程池进行监控。可以**通过继承线程池来自定义线程池**，重写线程池的beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。</span><br><span class="line"></span><br><span class="line">* 关闭线程池：</span><br><span class="line">  </span><br><span class="line">  - 可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的**原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。**但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后**尝试停止所有的正在执行或暂停任务的线程**，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后**中断所有没有正在执行任务的线程。**</span><br><span class="line"></span><br><span class="line">#### 5.**Executor框架**</span><br><span class="line"></span><br><span class="line">Executor框架就是一个上层的用户级的调度器。</span><br><span class="line"></span><br><span class="line">在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231210145801348.png image-20231210145801348 %&#125;</span><br><span class="line"></span><br><span class="line">应用程序通过Executor框架控制上层的调度；而下层的调度由操作系统内核控制，下层的调度不受应用程序的控制。</span><br><span class="line"></span><br><span class="line">* Executor框架的组成</span><br><span class="line"></span><br><span class="line">  **·任务**。包括被执行任务需要实现的接口：Runnable接口(没有返回值)或Callable接口(有返回值)。</span><br><span class="line"></span><br><span class="line">  **·任务的执行**。包括任务执行机制的核心接口Executor，以及继承自Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口（ThreadPoolExecutor(用来执行被提交的任务)和ScheduledThreadPoolExecutor(在给定的延迟后运行命令，或者定期执行命令。)）。</span><br><span class="line"></span><br><span class="line">  **·异步计算的结果**。包括接口Future和实现Future接口的FutureTask类。</span><br><span class="line"></span><br><span class="line">  - &#123;% asset_img image-20231210150303335.png image-20231210150303335 %&#125;</span><br><span class="line"></span><br><span class="line">#### 6.**Executor框架**的使用</span><br><span class="line"></span><br><span class="line">主线程首先要创建实现Runnable或者Callable接口的任务对象。然后可以把Runnable对象直接交给ExecutorService调用execute或者submit来执行，如果执行ExecutorService.submit，ExecutorService将返回一个实现Future接口的对象（到目前为止的JDK中，返回的是FutureTask对象）。最后，主线程可以执行FutureTask.get()方法来等待任务执行完成。主线程也可以执行FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。</span><br><span class="line"></span><br><span class="line">* 示例代码</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public class ThreadPoolSimpleTest &#123;</span><br><span class="line">        public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">            ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10,</span><br><span class="line">                    200, TimeUnit.MILLISECONDS,</span><br><span class="line">                    new ArrayBlockingQueue&lt;Runnable&gt;(5));</span><br><span class="line">    </span><br><span class="line">            for(int i=0;i&lt;15;i++)&#123;</span><br><span class="line">                //创建任务对象</span><br><span class="line">                MyTask myTask = new MyTask(i);</span><br><span class="line">                //任务的执行</span><br><span class="line">    //            executor.execute(myTask);</span><br><span class="line">                //异步计算的结果</span><br><span class="line">                Future&lt;?&gt; submit = executor.submit(myTask);</span><br><span class="line">                System.out.println(&quot;线程池中线程数目：&quot;+executor.getPoolSize()+&quot;，队列中等待执行的任务数目：&quot;+</span><br><span class="line">                        executor.getQueue().size()+&quot;，已执行完的任务数目：&quot;+executor.getCompletedTaskCount());</span><br><span class="line">            &#125;</span><br><span class="line">            executor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    class MyTask implements Runnable &#123;</span><br><span class="line">        private int taskNum;</span><br><span class="line">    </span><br><span class="line">        public MyTask(int num) &#123;</span><br><span class="line">            this.taskNum = num;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;正在执行task &quot; + taskNum);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.currentThread().sleep(4000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;task &quot; + taskNum + &quot;执行完毕&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="7-FixedThreadPool详解"><a href="#7-FixedThreadPool详解" class="headerlink" title="7.FixedThreadPool详解"></a>7.<strong>FixedThreadPool详解</strong></h4><p>Executor框架最核心的类是ThreadPoolExecutor，通过Executor框架的工具类Executors，可以创建4种类型的ThreadPoolExecutor。</p><ol><li><p>最大的类型是自定义创建的类型(所有的参数自己输入)</p></li><li><p>FixedThreadPool。</p></li><li><p>SingleThreadExecutor。</p></li><li><p>CachedThreadPool。</p></li></ol><ul><li><p>为什么命名不同呢？ </p><ul><li><p>（不同的pool都是return new ThreadPoolExecutor）ThreadPoolExecutor参数不同导致的。</p></li><li><p>例如通过使用Executors的newFixedThreadPool创建的FixedThreadPool</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231210153132819.png" class title="image-20231210153132819"></li></ul></li><li><p>FixedThreadPool介绍</p><ul><li><p>FixedThreadPool被称为<strong>可重用固定线程数的线程池</strong>。FixedThreadPool的corePoolSize和maximumPoolSize都被设置为创建FixedThreadPool时指定的参数nThreads。<strong>当线程池中的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的最长时间</strong>，超过这个时间后多余的线程将被终止。这里把keepAliveTime设置为0L，意味着多余的空闲线程会被立即终止。</p></li><li><p>执行步骤</p><ul><li><p>1）如果当前运行的线程数少于corePoolSize，则创建新线程来执行任务。</p><p>2）在线程池完成预热之后（当前运行的线程数等于corePoolSize），将任务加入LinkedBlockingQueue。</p><p>3）线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue获取任务来执行。</p></li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231210154714279.png" class title="image-20231210154714279"></li></ul></li><li><p>FixedThreadPool使用无界队列LinkedBlockingQueue(<strong>这个地方的无界指的是有没有在创建队列的时候手动的限制队列大小，而不是说队列元素有上限就是无界队列</strong>)作为线程池的工作队列<strong>（</strong>队列的容量为Integer.MAX_VALUE）。使用无界队列作为工作队列会对线程池带来如下影响。</p><p>1）当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize。</p><p>2）由于1，使用无界队列时<strong>maximumPoolSize将是一个无效参数</strong>。</p><p>3）由于1和2，使用无界队列时keepAliveTime将是一个无效参数。</p><p>4）由于使用无界队列，运行中的FixedThreadPool（未执行方法shutdown()或shutdownNow()）不会拒绝任务</p></li></ul></li></ul><h4 id="8-SingleThreadExecutor详解"><a href="#8-SingleThreadExecutor详解" class="headerlink" title="8.SingleThreadExecutor详解"></a>8.<strong>SingleThreadExecutor详解</strong></h4><p>SingleThreadExecutor是使用单个worker线程的Executor。属于FixedThreadPool的一种特殊情况</p><p>SingleThreadExecutor的corePoolSize和maximumPoolSize被设置为1。其他参数与FixedThreadPool相同。SingleThreadExecutor使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）。</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231210155443356.png" class title="image-20231210155443356"><h4 id="9-CachedThreadPool详解"><a href="#9-CachedThreadPool详解" class="headerlink" title="9.CachedThreadPool详解"></a>9.<strong>CachedThreadPool详解</strong></h4><p>CachedThreadPool是一个会根据需要创建新线程的线程池。</p><p>CachedThreadPool的corePoolSize被设置为0，maximumPoolSize被设置为Integer.MAX_VALUE，即maximumPool是<strong>无界的</strong>。这里把keepAliveTime设置为60秒，CachedThreadPool使用没有容量的SynchronousQueue作为线程池的工作队列，但CachedThreadPool的maximumPool是无界的。这意味着，如果主线程提交任务的速度高于maximumPool中线程处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下，CachedThreadPool会因为创建过多线程而耗尽CPU和内存资源。</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20240130154349994.png" class title="image-20240130154349994"><ul><li><p>总结：</p><ul><li><p>对于fixed，single和 cache，我们在实际的工作中最多使用到的是 single（相对于fixed和cache）。一般情况下，对于并发量不高的场景，并且需要单条异步线程进行处理的时候，会使用一下 single。 真正的业务处理中，如果使用线程池，99%的情况下，需要自定义线程池（自己传入参数）。只有1%的情况会使用fixed，single和 cache。在这1%里，single稍微多一些。</p><p>Fixed和 single 容易造成我们的queue的消息无限积压，还会导致无法触发拒绝策略。所以一般没人用</p><p>Cache可能高并发下无法控制最高的线程创建数量，造成cpu和内存资源的消耗甚至耗尽。所以没人用</p><p>这三个，仅仅是为了让我们创建线程池的时候方便一些，不代表他们很实用。</p></li></ul></li></ul><h4 id="10-ScheduledThreadPoolExecutor详解"><a href="#10-ScheduledThreadPoolExecutor详解" class="headerlink" title="10.ScheduledThreadPoolExecutor详解"></a>10.<strong>ScheduledThreadPoolExecutor详解</strong></h4><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的<strong>延迟</strong>之后运行任务，或者<strong>定期</strong>执行任务。ScheduledThreadPoolExecutor的功能与Timer类似，但ScheduledThreadPoolExecutor功能更强大、更灵活。Timer对应的是单个后台线程，而ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数（创建线程池）。</p><ul><li><p>ScheduledThreadPoolExecutor的创建</p><ul><li><p>ScheduledThreadPoolExecutor的创建一般有以下三种方法</p></li><li><pre><code class="java">ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(5);ScheduledExecutorService service = Executors.newScheduledThreadPool(5);ScheduledThreadPoolExecutor pool    = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(5);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 一般使用第三种方法，一方面使用Executors工具类便于new的创建，不许使用new这个关键词，另一方面，源码中就是直接new的ScheduledThreadPoolExecutor只不过返回值是ScheduledExecutorService，所以只需要对其强转，获取其子类就可以同时使用父类和子类的方法</span><br><span class="line"></span><br><span class="line">  - &#123;% asset_img image-20231210163550997.png image-20231210163550997 %&#125;</span><br><span class="line"></span><br><span class="line">* ScheduledThreadPoolExecutor常见方法</span><br><span class="line"></span><br><span class="line">  - schedule方法</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      pool.schedule(new STask(1), 5, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>- 第一个参数是要执行的任务，第二个参数是要延迟多少时间执行，第三个参数是时间的单位</code></pre></li><li><p>scheduleAtFixedRate方法</p><ul><li><pre><code class="java">pool.scheduleAtFixedRate(new STask(1), 5, 5, TimeUnit.SECONDS);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 第一次参数是要执行的任务，第二个参数是要延迟多少时间执行，第三个参数是执行的周期时间，第四个参数是时间的单位</span><br><span class="line"></span><br><span class="line">- scheduleWithFixedDelay方法</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    pool.scheduleWithFixedDelay(new STask(1), 5, 5, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></code></pre></li><li><p>参数含义和第二个方法完全一致</p></li></ul></li><li><p>scheduleAtFixedRate方法和scheduleWithFixedDelay方法的区别</p><ul><li>scheduleWithFixedDelay的周期执行是等待上一次任务执行完成后才开始计算下一次要执行任务的时间，例如第一次执行任务在0秒开始，然后耗时4秒，第二次执行就会在第9秒开始执行，而scheduleWithFixedDelay的周期执行不会管上一次任务是否执行完毕，严格按照在周期在第5秒，第10秒的时间进行执行(注意：如果第一次执行任务的耗时超过了周期时间，比如第一次耗时6秒，周期是5秒，那么第二次任务的开始时间就是第6秒，因为task是周期执行的，下一次执行的时间是在上一个任务执行完成后进行计算，并且 add 到我们的delayQueue里。现在如果是一个 while循环，那么永远不能执行结束我们的ScheduledThreadPoolExecutor就没有办法再次的重新计算时间，并且从新添加到我们的delayQueue中。)</li></ul></li><li><p>延时执行的实现方式就是把传入的任务，延迟时间，周期时间封装成一个ScheduledFutureTask，然后放入到延时队列中，获取任务并执行的逻辑和延迟队列相同(看队列中第一个任务是不是空，或者第一个任务是否到期可执行，如果可以则赶紧执行，否则继续等待)</p><ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231210165113464.png" class title="image-20231210165113464"></li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231210165709980.png" class title="image-20231210165709980"></li></ul></li></ul></li></ul><h4 id="11-FutureTask详解"><a href="#11-FutureTask详解" class="headerlink" title="11.FutureTask详解"></a>11.FutureTask详解</h4><p><strong>Future接口</strong>和<strong>实现Future接口的FutureTask类</strong>，代表异步计算的结果。</p><p>FutureTask除了实现Future接口外，还实现了Runnable接口。因此，FutureTask可以交给Executor执行，也可以由调用线程直接执行（FutureTask.run()）。根据FutureTask.run()方法被执行的时机，FutureTask可以处于下面3种状态。</p><p>1）未启动。FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态。当创建一个FutureTask，且没有执行FutureTask.run()方法之前，这个FutureTask处于未启动状态。</p><p>2）已启动。FutureTask.run()方法被执行的过程中，FutureTask处于已启动状态。</p><p>3）已完成。FutureTask.run()方法执行完后正常结束，或被取消（FutureTask.cancel（…）），或执行FutureTask.run()方法时抛出异常而异常结束，FutureTask处于已完成状态。</p><ul><li><p>FutureTask的使用示例</p><ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231210221934132.png" class title="image-20231210221934132"></li></ul></li><li><p>使用FutureTask.get()方法的几种结果</p><ul><li>当FutureTask处于未启动或已启动状态时，执行FutureTask.get()方法将导致调用线程阻塞</li><li>当FutureTask处于已完成状态时，执行FutureTask.get()方法将导致调用线程立即返回结果或抛出异常。</li></ul></li><li><p>使用FutureTask.cancel()方法的几种结果</p><ul><li>当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将导致此任务永远不会被执行；</li><li>当FutureTask处于已启动状态时，执行FutureTask.cancel（true）方法将以中断执行此任务线程的方式来试图停止任务；</li><li>当FutureTask处于已启动状态时，执行FutureTask.cancel（false）方法将不会对正在执行此任务的线程产生影响（让正在执行的任务的线程正常运行完成）；</li><li>当FutureTask处于已完成状态时，执行FutureTask.cancel（…）方法将返回false。</li></ul></li></ul><hr><hr><h3 id="两个关键字"><a href="#两个关键字" class="headerlink" title="两个关键字"></a>两个关键字</h3><ul><li>volatile <ul><li>保证可见性<ul><li>可见性是让其他线程可见，现在的处理器都是多核的处理器，多核处理器就有多核CPU，每个CPU理论上可以提供一条线程，多个线程共同修改一个volatile 修饰的共享变量的时候，一旦一个线程拿到修改权限并且修改完之后，会立即把修改后的值过<strong>总线</strong>推送到主存中，此时其他的CPU会一直嗅探总线的数据流通，在<strong>缓存一致性协议</strong>的保障下，他能够嗅探到这条数据的修改，如果自己的缓存行中有这条数据，就会把这条数据置为不可用，当该线程再次用到这条数据的时候，需要在主存中重新读取，并保存到自己缓存行中</li><li>关于CPU在嗅探总线的数据流通的时候，它这么知道这个数据就是volatile 修饰的呢？<ul><li>当一个数据被volatile修饰后，被一个线程修改，并通过总线保存到主存时，它的汇编指令的码会在里面加一个lock关键词，lock指令有两层含义，第一，是将信息的修改推送到主存；第二，lock指令过总线的时候其他CPU会嗅探含有lock的指令，然后置其他缓存行为不可用</li></ul></li></ul></li><li>禁止指令重排序<ul><li>volatile写之前加入storestore屏障，表示上面的普通写和volatile写不能重排序</li><li>volatile写之后加入storeload屏障，表示下面的volatile读写和volatile写不能重排序</li><li>volatile读之后加入loadload屏障，表示下面的普通读和volatile读不能重排序</li><li>volatile读之后加入loadstore屏障，表示下面的普通写和volatile读不能重排序</li></ul></li><li>在特殊情况下还能保证原子性<ul><li>比如volatile修饰的变量i，进行i++操作的时候，就不能保证原子性，因为i++有三条JVM指令字节码。第一条，i load读取i这个变量；第二条，i add进行加一的操作；第三条，i store然后把相加后结果写回。所以被volatile修饰的变量是单条JVM指令字节码的时候就可以保证原子性，而volatile修饰的变量是多条JVM指令字节码的时候就不能保证原子性</li></ul></li></ul></li><li>synchronized<ul><li>三种使用方式<ul><li>作用到代码块上(锁可以是Object类型的成员变量，也可以使用this作为锁)</li><li>多用在静态方法上(锁是当前的Class，因为静态方法在调用的时候是 类.方法 的形式进行调用，不需要创建对象，所以只能使用当前类的Class作为锁)</li><li>作用到普通方法上(锁是当前的类的对象)</li></ul></li><li>有一个Student类，其中有一个int类型的成员变量，同时提供set和get方法。给int变量加上volatile修饰可以保证原子性，因为set和get都是对应单条JVM字节码指令；不给int变量加上volatile进行修饰，而是给get和set方法加上synchronized也可以保证原子性<ul><li>如果此时get操作多，set操作少，即读多写少的场景，volatile的方法更快，因为如果不对volatile修饰的变量进行修改，那么每个线程可以直接从线程的缓存行里面直接拿到</li><li>如果此时get操作少，set操作多，即读少写多的场景，这个时候volatile就慢了，此时volatile修饰的变量一直修改，一直过总线写到主存中，其他的CPU一直在嗅探总线，一直把自己缓存行的数据置为不可用，每次都要透过总线从主存中拉取最新数据，严重损耗计算机的总线资源，synchronized这是就比较快了，因为写比较多，一个线程写的时候其他线程处于BLOCK状态，对于set方法来说处理器执行的是非常快的，也就是其他线程BLOCK的时间会非常短，<em>重量级锁可以提高程序的吞吐量</em></li></ul></li></ul></li></ul><h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p><em>lock相关的问题比较繁杂，所以要找到一个好的切入点进行总结，先从lock和synchronized的区别切入</em></p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ul><li>synchronized是一个关键字，lock是一个接口，使用lock的话需要new出其子类来<ul><li>lock接口中的方法<ul><li>lock()方法：加锁</li><li>unlock()方法：锁释放</li><li>tryLock()方法：可以非阻塞的进行加锁</li><li>tryLock(long time , TimeUnit unit)方法：可以超时性的非阻塞式加锁</li><li>lockInterruptibly()方法：可中断式加锁</li><li>newCondition()方法：配合实现等待通知机制</li></ul></li><li>常用的实现子类是ReentrantLock和ReentrantReadWriteLock</li></ul></li><li>synchronized是隐式加锁，lock是显式加锁<ul><li>synchronized肉眼看不到加锁和解锁的过程，lock一定要在finally代码块中释放锁</li></ul></li><li>synchronized可以作用到方法和代码块上，lock只能作用到代码块上<ul><li>synchronized三种加锁方式<ul><li>加到静态方法上使用的当前类的Class</li><li>加到普通方法上使用的当前类的对象</li><li>加到代码块上可以用this关键字，也可以new一个Object对象</li><li>lock加锁就不用多说了，只能加在代码块上，同时别忘了进行锁的释放</li></ul></li><li>synchronized作用到代码块上和作用到方法上，使用javap命令反编译成字节码指令有什么区别<ul><li>synchronized作用到代码块上反编译之后，在代码块进入的点有一个monitorenter指令，在代码块出的点有一个monitorexit指令，而且monitorexit这个指令最少要有两个，一个是正常出代码块释放锁，一个是发生异常释放锁</li><li>synchronized作用到方法上会在方法的flag上加一个acc_synchronized，<strong>后续学完JVM进行详细补充</strong></li></ul></li></ul></li><li>lock支持非阻塞式加锁<ul><li>lock接口中有两个关于非阻塞式加锁的方法，tryLock()方法和tryLock(long time , TimeUnit unit)方法，如果尝试获加锁失败直接返回，不会阻塞线程，那么线程就不会从用户态转为内核态，少一次线程上下文切换</li></ul></li><li>lock支持可超时性加锁<ul><li>tryLock(long time , TimeUnit unit)方法可以超时性加锁，一定时间内尝试加锁失败了，直接返回，是一个避免发生死锁的好办法</li></ul></li><li>lock支持可中断式加锁<ul><li>可中断的意思是一个线程在运行的时候，另一个线程想要对这个线程进行中断，lock中的lockInterruptibly()方法可以接受这种中断，synchronized做不到这一点</li></ul></li><li>synchronized采用对象监视器，lock采用AQS<ul><li>两个线程竞争一个synchronized锁，一条线程竞争成功，另一条线程竞争失败进入到ObjectMonitor中的EntryList(同步队列)，等到当前执行线程释放锁，被唤醒以后才重新进入到锁的竞争，但是当前执行线程调用了wait方法释放锁以后，会进入到ObjectMonitor中的WaitSet(等待队列)中</li><li>AQS根据一个int类型的state变量，来确定这个锁有没有被获取，如果被获取则会加入到AQS双端队列的尾部，这里注意此时有可能是大量的线程同时竞争锁失败，然后同时放到双端队列的尾部，此时就会有线程安全的问题，这里采用的CAS的方式来保证进入双端队列尾部的线程安全，当获取锁的线程执行完成释放锁的时候，会通知自己的后继节点进行锁的竞争</li></ul></li><li>在加锁和解锁时，synchronized有一个同步队列和一个等待队列，lock有一个同步队列和多个等待队列<ul><li>lock可以new出多个Condition，一个Condition就有一个等待队列</li></ul></li><li>锁竞争方面，synchronized只支持非公平锁，lock支持非公平锁和公平锁<ul><li>到底什么叫公平，什么叫非公平(场景举例)<ul><li>假设此时有A,B,C三条线程对lock锁进行竞争，A线程获取到锁了，B,C线程要依次进入到双端队列中进行等待，当A线程执行完成释放锁，唤醒B线程进行锁的竞争时，此时又来了另外十条线程竞争这个lock，如果B和这十条线程进行锁的竞争那么就是不公平，因为B线程已经在队列中排队等待了很久了，如果B不用和新来的线程竞争(新来的十条线程在CAS的保证下直接加入到双端队列的尾端)那么就是公平的</li></ul></li><li>新来的十条线程怎么知道这是一个公平锁，并且加入到队列的？<ul><li>新来的线程对于公平锁的竞争之前，会进行一个判断，就是判断自己是否有前置节点，如果没有就进入到队列排队，但是对于非公平锁的竞争就不会有这个判断</li></ul></li><li>非公平锁的线程饥饿问题？<ul><li>一条线程在竞争失败后进入到等待队列进行等待，下一次再次失败再次等待，如此反复线程一直处于等待状态，这就叫做线程饥饿</li></ul></li></ul></li><li>对于等待唤醒机制，synchronized与Object进行配合，lock与Condition接口进行配合<ul><li>synchronized与Object的wait&#x2F;notify进行配合</li><li>lock与Condition接口await和signal进行配合<ul><li>拿到lock锁的线程，调用await方法时，就会进入到Condition的等待队列的尾节点中，<strong>不需要使用CAS直接加就行</strong>，因为线程在调用await方法之前先回把自己加入到等待队列的尾部，正因为此时还没有调用await方法，线程还持有着锁，所以进入到尾节点的时候不用CAS</li></ul></li><li>调用await方法之后，这个线程经历了什么？<ul><li>拿到lock锁的线程，调用await方法时，就会进入到Condition的等待队列的尾节点中，当他达到队列的头部时会被唤醒，此时这条线程会重新竞争lock锁，一旦竞争失败会使用CAS加入到同步队列的尾端，排队到同步队列的头部，直到他的前置节点线程释放锁以后，根据是否是公平锁重新竞争，竞争失败继续等待，竞争成功继续执行完await后面的逻辑</li></ul></li></ul></li><li>lock锁可以根据需要进行个性化开发 </li><li>ReentrantReadWriteLock支持并发读<ul><li>读-读可以并发执行，读-写，写-读，写-写 都不可以并发执行</li><li>通过一个int类型的state变量来控制读写权限，他把一个32位的int变量分成高16位和低16位，高16位负责控制读，低16位负责控制写。当一个读线程来的时候会检查低16，如果低16位为0说明没有写线程，直接对高16位加一，然后进行读取，如果有写线程那么就会被阻塞。当一个写线程来的时候会检查高16位和低16位，此时不管是有写还是有读直接被阻塞，这是ReadWriteLock的加锁细节。如果是ReentrantReadWriteLock(表示可重入读写锁)的话，加读锁的时候，如果低16位不为0，会先判断持有写锁的线程是不是当前线程，如果是也会在高16位加一，加写锁的时候，如果低16位和高16位都不为0，此时会先判断持有这些锁的线程是不是当前线程，如果是则会在低16位加一</li></ul></li></ul><h4 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h4><p><em>背景：32位JVM虚拟机</em></p><ul><li><p>无锁状态</p><ul><li>当我们新创建一个对象的时候，它的对象头MarkWord里有25位的HashCode，4位的对象分代年龄，1位的偏向锁标记位，2位的锁标记位</li><li><strong>当我们仅仅只是用new关键字创建一个对象的时候，此时如果没有显式&#x2F;隐式的调用Object里面的hashCode方法，那么hashCode的值不会存储在对象头中</strong>，此时的占位是0<ul><li>显示调用hashCode：比如在类的构造器中直接调用super.hashCode()方法，这样我们对象头的MarkWord中是有hashCode的</li><li>隐式调用hashCode：比如在构造函数中，对象创建完毕的一瞬间直接把该对象放入到了HashMap，HashSet这样的类Hash集合中，因为put方法的第一个参数就是哈希值，这个哈希值就是靠调用Object类的hashCode方法得到的</li><li>如果该类重写了hashCode方法，然后在对象的创建过程中调用了重写以后的hashCode方法，那么同样不会把hashCode的值存放到对象头的MarkWord中，<strong>必须调用父类的hashCode方法才会把值存到对象头的MarkWord中</strong></li></ul></li><li>对于分代年龄，此时由于对象刚刚创建，没有分代年龄，所以还是以0表示</li><li>对于锁标记位，无锁状态和偏向锁状态的锁标记位都是01，他们的区别在于偏向锁标记位，无锁的偏向锁标记位是0，偏向锁状态的偏向锁标记位是1</li></ul></li><li><p>无锁状态升级为偏向锁</p><ul><li>无锁状态想要升级位偏向锁状态，此时<strong>对象头的MarkWord中必须不能有hashCode值</strong>，理论上hashCode这个位置要保存上23位的线程ID和2位的Epoch，但是如果这个位置有hashCode的值就会对这个值进行覆盖，因为hashCode值没有替换这个逻辑也无法对这个值进行保存，所以这个行为是不允许的，所以此时就不能成为偏向锁</li><li>如果想要成为偏向锁的对象的对象头的MarkWord没有存放hashCode值，此时就可以把线程ID放到前23位，Epoch的值放到后2位，偏向锁标记位从0变成1，锁标记位还是01不变</li><li>偏向锁的好处在于，当一个线程想要再次获取锁，可以直接检查一下MarkWord里面保存的线程ID是不是当前线程的ID，如果是那么直接加锁成功，性能会有所提升</li></ul></li><li><p>偏向锁升级为轻量级锁</p><ul><li>发生线程竞争的时候偏向锁一定会升级为轻量级锁吗？</li><li>偏向锁升级为轻量级锁发生了线程的竞争这句话是对的，但是反过来说就不一定对了，例如下面加粗斜体的例子，虽然有线程的竞争但是锁的偏向发生了改变但是没有升级为轻量级锁</li><li>偏向锁升级为轻量级锁的过程：<em><strong>加入A线程获取到了偏向锁把自己的线程ID存放到MarkWord中，此时又来了一个B线程也想要获取偏向锁，他会先检查锁标记状态是不是01，偏向锁标记位是不是1，如果锁标记位是01，且偏向锁标记位是1，那么线程B就知道此时这个锁已经有线程偏向了，这时线程B会检查线程A的线程存活状态，如果此时A线程没有在执行同步代码，那么B线程会直接把这个偏向锁置为无锁状态，然后去竞争这个偏向锁，如果竞争成功则把自己的线程ID放入到MarkWord当中，此时偏向锁就偏向B线程了</strong></em>，但是如果线程B争抢失败了，线程C争抢成功了，把线程C的ID存放到了MarkWord中并执行线程C对应的代码，这是时候线程B就很烦，他会执行一个更加高级的操作，叫做<strong>偏向锁的撤销</strong>，线程B会等待线程C执行到JVM安全点，对线程C的栈进行遍历，遍历的是锁记录，遍历完成可能会有三种情况</li><li>可能会直接把锁的状态变为无锁状态，然后把锁标记位置为00，即轻量级锁<ul><li>这个地方可以理解为锁从偏向锁直接升级为轻量级锁，所谓把锁的状态变为无锁状态就是把锁标记位置为00，并且把偏向线程ID和Epoch置为空，偏向锁标记位是0。之所以上面说把锁的状态变为无锁状态，是因为真正的轻量级锁的对象头应该除了2位的锁标记位之外，其余的30位都应该指向栈帧中锁记录的指针，但是此时的状态比较<strong>游离</strong>，暂且理解为无锁状态</li></ul></li><li><em><strong>可能会把偏向锁重新偏向到线程B</strong></em><ul><li>JVM除了有开启偏向锁的配置之外，还有批量重偏向和批量撤销的操作。场景举例：比如有一个Student类，然后这个Student类创建了40个对象，线程A把这四十个对象进行偏向锁的加锁操作，然后线程A一直对这四十个对象保持代码的执行，此时来了个线程B，<strong>线程B要对这四十个对象进行锁撤销的操作</strong>，此时这1-19个对象直接升级为轻量级锁也就是上面所说的游离状态，当执行到第20个对象时，JVM就会反思自己是不是最开始的时候偏向错了，然后就把后面的20-39个对象批量重偏向到线程B，因为JVM里有配置批量偏向锁的阈值是20，但是当线程B撤销到第40个对象的时候，此时已经有20个对象偏向给线程B了，线程B还在继续要求偏向，JVM又不高兴了，既然这个对象的竞争这么激烈那么你就不适合作为偏向锁，然后直接把这个对象置为不可使用偏向锁</li><li>可能会把该锁直接置为不可使用偏向锁<ul><li>书接上文，至于置为不可使用偏向锁体现在new出第41个student对象的时候，此时该对象的对象头的MarkWord的锁标记位直接就是00，其实JVM这个地方还有一个默认参数，也就是两万五千毫秒，如果25秒以内批量撤销没有达到40这个阈值，那么从20-39的这个重偏向可以重新计数，<strong>也就是说25秒内批量撤销没有达到阈值，那么此时就不会发生置为不可使用偏向锁这一状态</strong></li></ul></li></ul></li></ul></li><li><p>轻量级锁record</p><ul><li>竞争过程：假设此时多条线程竞争时，如果A线程竞争成功了，A线程会直接把锁对象头里的MarkWord里面的25位hashCode，4位的分代年龄和1位的偏向锁标记，这30位的内容复制到A线程的栈帧中的一个叫做lockRecord即锁记录中，然后把对象头的MarkWord中对应的30位的位置放上一个指向当前线程栈帧中lockRecord这块区域的一个指针，当B线程来竞争轻量级锁的时候，他会使用CAS的方式把锁对象头对应位置的内容放到自己栈帧的lockRecord中，此时肯定是失败的，因为锁对象头本来该存放的hashCode，分代年龄等内容已经被替换成了指针了，此时B线程会进行一个CAS的自旋，再次尝试替换，默认循环十次，如果这十次还没有成功，那么轻量级锁将会升级为重量级锁</li><li>轻量级锁升级为重量级锁： 自旋十次没有成功的B线程，会把原本指向A线程中栈帧的lockRecord的指针替换为指向重量级锁的指针即ObjectMonitor，此时线程A执行完对应代码要使用CAS进行锁的释放时，会发现此时锁对象头内的指针已经不是轻量级锁的指针了，已经变成了重量级锁的指针了，所以这个时候他就知道要进行重量级锁解锁的过程了</li><li>重量级锁解锁的过程：线程A会先把栈帧中lockRecord记录的hashcode，分代年龄等内容保存到ObjectMonitor的header属性中保证这些内容不丢失，然后把ObjectMonitor的owner属性保存成自己</li></ul></li></ul><h4 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a>双重检查锁</h4><p><em>双重检查锁是基于单例模式的两次改造，第一次改造实是在synchronized同步代码块的外边，加一个判空处理，减少一些线程对于锁的竞争而变为阻塞状态，导致从用户态转化为内核态对于资源的消耗，这样会导致一些问题，因为在new对象的时候有三个步骤，第一，开辟一块内存空间，第二，初始化对象，第三，把instance指向这片内存空间，此时如果不用volatile修饰的话，可能会导致第二步和第三步发生指令重排序，在多线程的情况下其他线程访问到判空处理那一步时，他只会关心这个instance是否有指向，所以此时他会认为instance已经初始化好了，导致得到一个错误的结果</em></p><p><em><strong>加上volatile修饰的话会导致第二步和第三步不会发生重排序</strong></em>，这句话是错误的！！！！！！！！！！！</p><p>因为当我们new一个对象的时候，new是写在我们Java代码里面的，new这个关键词对应的JVM字节码指令也是new，volatile作为Java中的一个关键词，他做的添加屏障只能做到JVM字节码指令这个级别，它无法涉及到new这个关键词带来的更加底层的操作，也就是创建对象的那三步操作，这就像lock锁锁住了三行代码，在这三行代码执行结束前其他的线程进不来，而volatile就像是包住了new的这个过程保证了创建对象结束前其他线程进不来，从而保证线程安全</p><h4 id="线程状态转化"><a href="#线程状态转化" class="headerlink" title="线程状态转化"></a>线程状态转化</h4><p><em>new 一个线程出来进入new状态，然后调用start方法进入runnable状态，在runnable状态下调用join，wait，park方法会进入waiting状态，调用sleep，wait(long)等方法会进入到timed_waiting状态，加锁失败的话会进入到blocked状态，最后是线程的TERMINATED终止状态，在Java的Thread类中的state内部枚举类中只有这六种状态</em></p><p><strong>网上说的七种状态区别在于把runnable状态分成了running状态和ready状态，在running状态的线程调用了yield方法会进入到ready状态，此时放弃了CPU的执行权</strong></p><ul><li>NEW状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NEW</span><br></pre></td></tr></table></figure><p>线程还没有开始的状态，也就是说还没有调用start方法</p><ul><li>RUNNABLE状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment"> * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment"> * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment"> * such as processor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RUNNABLE</span><br></pre></td></tr></table></figure><p>在JVM中线程已经开始了，但会因为其他的一些调用进入到waiting状态</p><ul><li>WAITING状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment"> * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment"> * following methods:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment"> * perform a particular action.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WAITING</span><br></pre></td></tr></table></figure><p>在调用wait，join，park方法后会进入到waiting状态，调用notify，unpark等方法会使线程从waiting状态切换到runnable状态</p><ul><li>TIMED_WAITING状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment"> * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment"> * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TIMED_WAITING</span><br></pre></td></tr></table></figure><p>在调用sleep，wait(long)，join，parkNanos，parkUntil这些方法后会进入到TIMED_WAITING状态</p><ul><li>BLOCKED状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment"> * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment"> * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment"> * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BLOCKED</span><br></pre></td></tr></table></figure><p>只有在synchronized代码块或者synchronized修饰的方法的范围内才有可能进入到BLOCKED状态</p><ul><li>TERMINATED状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment"> * The thread has completed execution.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TERMINATED</span><br></pre></td></tr></table></figure><p>线程运行完毕，执行结束</p><ul><li>锁释放(使用join来说明)</li></ul><p>join方法底层也调用了wait方法，但是很多博客文章上说调用join方法不会释放锁，他会释放锁，但是他释放的是调用join方法的线程对应的对象的锁，举个例子，在synchronized(Object obj)代码块里面创建一个thread1线程，然后thread1线程调用join方法，此时释放的不是obj这个对象锁，而是thread1线程自身对象的Object Monitor锁</p><ul><li>waiting和timed_waiting的区别</li></ul><p>time_waiting状态不用唤醒，等时间到了以后自动执行后续代码，waiting状态需要显式或者隐式的唤醒，显式唤醒就是通过调用wait或者park方法进入waiting状态，通过调用notify或者unpark方法进行唤醒，隐式唤醒就是通过调用join方法，等到其他线程执行结束后会在线程内部接收到一条消息，然后执行后面的代码</p><ul><li>有了waiting和timed_waiting这两种状态为什么还要一个blocked状态</li></ul><p>线程在竞争锁失败后会进到EntryList同步队列，线程状态变为blocked状态，线程在调用wait方法进入到WaitSet等待队列，线程进入到waiting状态，当waiting状态被唤醒时会重新进行锁的竞争，此时如果竞争失败，那么会进入到EntryList同步队列，状态变位block，所以此时状态和队列进行了一个对应，为了把不同的线程状态进行一个更加细致的划分</p><h3 id="并发编程重点问题"><a href="#并发编程重点问题" class="headerlink" title="并发编程重点问题"></a>并发编程重点问题</h3><ul><li><p>进程和线程的区别</p><ul><li>进程是系统进行资源分配和调度的基本单位，线程是进程的一个执行路径，一个进程最少有一个线程，进程中的每个线程共享进程中的资源</li><li>操作系统分配资源的时候是分配给进程的，而CPU分配资源是分配给线程的，真正占用CPU的是线程，所以说线程是CPU分配的基本单位</li><li>一个进程中的多个线程共享进程的堆和方法区的资源，每个线程有自己的程序计数器和栈区域</li></ul></li><li><p>为什么将程序计数器设为线程私有的区域</p><ul><li>程序计数器记录线程当前要执行的指令地址，因为线程在用时间片轮转的方式的占用CPU，当前时间片用完后下次再次继续执行的时候，需要从线程私有的程序计数器这个内存区域拿到指定地址继续执行，如果要执行的是native方法那么程序计数器记录的undefined地址，只有要执行的是Java代码程序计数器记录的才是下一条指令的地址</li></ul></li><li><p>局部变量，对象实例，JVM加载的类，常量及静态常量都存在主存的哪个部分，是线程私有的吗？</p><ul><li>每个线程有自己的栈资源，该栈用于存储线程的局部变量，局部变量是线程私有的，除了局部变量，栈还可以用来存放线程的调用栈帧</li><li>new操作创建的实例对象存放在堆中，堆是进程在创建的时候分配的，是进程中最大的一块内存，所有线程可以共享</li><li>JVM加载的类，常量和静态常量放在方法区，也是线程共享的</li></ul></li><li><p>继承Thread类实现多线程的优劣</p><ul><li>好处：在run()方法中，想要获取当前线程的时候直接this就可以，不用Thread.currentThread()方法</li><li>坏处：Java不支持多继承，如果继承了Thread类就无法在继承其他的类了。</li></ul></li><li><p>IllegalMonitorStateException出现的原因</p><ul><li>调用wait()方法之前没有获得该对象的监视器锁</li></ul></li><li><p>什么是虚假唤醒，如何避免</p><ul><li><p>虚假唤醒指的是，一条线程在没有被其他线程调用notify(),notifyAll()方法进行通知，也没有被中断，也没有等待超时，这时如果还被唤醒那么就是虚假唤醒</p></li><li><p>可以在while循环中调用wait方法来防止虚假唤醒，只有满足while中条件才可以退出循环详见以下伪代码</p><ul><li><pre><code class="java">synchronized(obj)&#123;    while(条件不成立)&#123;        obj.wait();    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 调用共享对象的notify()方法后，会唤醒一个在该共享变量上调用wait的线程，这两个线程对于锁获取和释放的过程</span><br><span class="line"></span><br><span class="line">  - 首先一个线程一定是在拿到共享变量锁之后才能调用wait方法，调用wait方法后该线程会先释放锁，进入到WaitSet队列中进行等待，然后另外一条线程拿到该共享对象的锁，调用了notify方法唤醒了在队列中等待的线程，等到该线程释放了锁以后，被唤醒的线程会重新进行该共享对象的锁的竞争，只有竞争到锁后才能继续执行后序代码</span><br><span class="line"></span><br><span class="line">* join()方法和yeild()方法</span><br><span class="line"></span><br><span class="line">  - join方法的使用场景在需要多个线程同时完成某个事情的时候才继续向下执行，比如多个线程同时加载同一个资源，使用join方法可以等到所有线程完成后进行汇总处理，join方法底层就是使用了while循环和wait方法实习无限等待和带时间参数的等待</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      //join方法源码</span><br><span class="line">      public final synchronized void join(long millis)</span><br><span class="line">          throws InterruptedException &#123;</span><br><span class="line">              long base = System.currentTimeMillis();</span><br><span class="line">              long now = 0;</span><br><span class="line">      </span><br><span class="line">              if (millis &lt; 0) &#123;</span><br><span class="line">                  throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">      </span><br><span class="line">              if (millis == 0) &#123;</span><br><span class="line">                  while (isAlive()) &#123;</span><br><span class="line">                      wait(0);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  while (isAlive()) &#123;</span><br><span class="line">                      long delay = millis - now;</span><br><span class="line">                      if (delay &lt;= 0) &#123;</span><br><span class="line">                          break;</span><br><span class="line">                      &#125;</span><br><span class="line">                      wait(delay);</span><br><span class="line">                      now = System.currentTimeMillis() - base;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>线程的执行需要操作系统分配时间片来轮询占用CPU，正常情况下当时间片用完后，线程调度器会进行下一轮线程调度，而调用了yeild方法，表示线程告诉线程调度器虽然现在分配的时间片还没用完，但是此时可以进行下一轮的线程调度了，此时该线程让出CPU的使用权，线程计数器可以从就绪队列中找出一个优先级最高的线程执行</p></li></ul></li><li><p>sleep()方法和yeild()方法的区别</p><ul><li>调用了sleep方法的线程处于阻塞状态，且线程调度器在指定时间内不会调度该线程</li><li>调用了yeild方法的线程处于就绪状态，如果该线程的优先级较高线程调度器可能下一次调度仍然调度到当前线程执行</li></ul></li><li><p>interrupt(),isInterrupted()和interrupted()的特点和区别</p><ul><li>interrupt方法表示中断线程，例如线程A正在执行，线程B调用线程A的interrupt方法，会使线程A的线程中断标记为true，但是此时的线程不会真正中断，还需继续向下执行后面的代码，如果线程A调用了wait，sleep，join方法挂起阻塞，此时线程B还调用线程A的interrupt方法，就会在调用方法的地方抛出InterruptedExpection</li><li>isInterrupted方法用于判断某个线程是否被中断，如果被中断返回true，没有被中断返回false</li><li>interrupted方法也是用于判断某个线程是否被中断，如果被中断返回true，没有被中断返回false，与isInterrupted不同的是调用interrupted方法后发现线程已被中断，那么此时会清除中断标记，并且interrupted是static方法；interrupted调用的是currentThread()的native方法isInterrupted，而isInterrupted调用的是实例对象的native方法，其中native方法的传参如果是true表示清除中断标志，是false表示不清除中断标志</li></ul></li><li><p>什么是死锁</p><ul><li>死锁是两个或两个以上的线程在执行过程中，为了获取某一资源而相互等待的现象，在无外力帮助的情况下会一直等待下去无法继续运行，例如线程A持有资源1，想要资源2，线程B持有资源2，想要资源1，两个线程都在等待其他线程已经持有的资源就会一直等待下去处于死锁状态</li></ul></li><li><p>线程发生死锁的条件</p><ul><li><p>资源具有排他性，即资源在同一时刻只能由一条线程持有，另外的线程想要持有必须等待到当前线程释放该资源</p></li><li><p>持有某个资源的线程，想要获取其他被持有的资源的时候，进行等待，但此时该线程在阻塞期间不会释放原有的资源</p></li><li><p>持有的资源只能由自己使用完后释放，释放前其他线程不能抢占</p></li><li><p>发生死锁时，一定会有一条 线程 &#x3D;&gt; 资源的环形链，例如 T0线程 &#x3D;》T1线程占用的资源 &#x3D;》T2线程占有的资源。。。。&#x3D;》 Tn线程占有的资源 &#x3D;》 T0线程占有的资源</p><ul><li><p>类似伪代码</p></li><li><pre><code class="java">//线程A重写的run方法synchronized(A)&#123;    sleep(1000);    synchronized(B)&#123;        //do something    &#125;&#125;//线程B重写的run方法synchronized(B)&#123;    sleep(1000);    synchronized(A)&#123;        //do something    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 如何避免死锁</span><br><span class="line"></span><br><span class="line">  - 要想避免死锁，只需破环形成死锁的四个条件中的至少一个条件，我们人为能进行破坏的只有第二条和第四条，破环的方法都是调整资源的访问顺序，保证资源获取的有序性。*所谓有序性，就是假如线程A，B都需要1，2，3....n这些资源，那么获取到资源n条件是已经获取了n-1这个资源*</span><br><span class="line"></span><br><span class="line">    - 以上代码进行如下优化，就会谦让有序不会发生死锁</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      //线程A重写的run方法</span><br><span class="line">      synchronized(A)&#123;</span><br><span class="line">          sleep(1000);</span><br><span class="line">          synchronized(B)&#123;</span><br><span class="line">              //do something</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //线程B重写的run方法</span><br><span class="line">      synchronized(A)&#123;</span><br><span class="line">          sleep(1000);</span><br><span class="line">          synchronized(B)&#123;</span><br><span class="line">              //do something</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li><li><p>对ThreadLocal的了解</p><ul><li>ThreadLocal是JDK包提供的，它提供的是每个线程的本地变量，也就是创建一个ThreadLocal变量以后，当有线程访问这个变量的时候都会有这个变量的本地副本，当多个线程对同一个变量进行操作的时候其实操作的是自己本地内存中的变量，可以避免线程安全问题。即创建ThreadLocal变量后，每个线程都会复制一个变量到自己的本地内存中</li></ul></li><li><p>ThreadLocal的原理</p><ul><li>Thread类中维护了两个ThreadLocalMap类型的变量，一个叫做threadLocals，一个叫做inheritableThreadLocals(下图1)，默认情况下这两个的值都为null，只有当该线程第一次调用ThreadLocal的set或get方法的时候才会创建他们，其实每个线程的本地变量不是存在ThreadLocal中的，而是存在threadLocals这个变量中的，ThreadLocal其实就是一个工具壳，它通过set方法把值存放到调用方法线程的threadLocals变量中，调用get方法再从当前线程的threadLocals变量中拿出来使用(如图2)，如果调用线程一直不终止那么这个本地变量就只存在当前线程的threadLocals中，之所以threadLocals的类型是ThreadLocalMap类型，是因为一个线程可以关联多个ThreadLocal变量(如图3)<ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231010225027854.png" class title="image-20231010225027854"></li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231010225102302.png" class title="image-20231010225102302"></li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231010225251621.png" class title="image-20231010225251621"></li></ul></li></ul></li></ul><ul><li><p>关于ThreadLocal的set方法</p><ul><li>set方法先是获取到当前线程，通过当前线程得到threadLocals这个成员变量，如果这个threadLocals不为null，那么就以this作为key，this代表当前对象，要set的值作为value，放到threadLocals这个map中，如果threadLocals为空，那么就调用cteateMap方法以当前线程为key，要set的值为value新建一个threadLocals对象<ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231012224747251.png" class title="image-20231012224747251"></li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231012224757298.png" class title="image-20231012224757298"></li></ul></li></ul></li><li><p>ThreadLocal支持继承吗</p><ul><li>对于同一个ThreadLocal变量，父线程set的值，子线程是get不到的，因为父线程在set时候村的key是父线程，而子线程在get的时候是以当前线程作为key来获取的threadLocals，所以自然获取不到</li></ul></li><li><p>如何让子线程访问到父线程的ThreadLocal中的值</p><ul><li>可以使用InheritableThreadLocal，InheritableThreadLocal继承自ThreadLocal，同时重写了getMap，createMap，childValue方法，这个类的作用就是为了让父线程设置的本地变量子线程可以访问到，主要就是在Thread类的init方法，父线程在构造子线程的时候，先判断出父类的inheritableThreadLocals这个成员变量是否为空，如果不为空就把父线程中的inheritableThreadLocals这个变量复制一份保存到子线程的inheritableThreadLocals这个成员变量中</li></ul></li><li><p>InheritableThreadLocal的使用场景</p><ul><li>例如子线程需要访问父线程存放到ThreadLocal中的用户登录信息，其实子线程想要获取到父线程的信息还有其他的方式，例如在创建子线程的时候传入父线程的变量复制到子线程中，或者在父线程中构造一个map作为参数传递给子线程，但是这些方法违背了我们使用的习惯，这时InheritableThreadLocal类就显得很关键</li></ul></li><li><p>程序CPU100%，内存和IO利用率都正常，是什么原因，如何排查</p><ul><li>有可能发生死锁，通过java程序的进程ID，使用jstack命令dump出线程文件，查看所有线程处于什么状态，看看是否存在处于BLOCKED状态的线程</li></ul></li><li><p>volatile如何保证可见性</p><ul><li>被volatile修饰的变量在进行写操作的时候，会多出一个lock汇编代码，有了lock前缀在多核处理器会发生两件事，第一件事是将当前处理器缓存行的数据写回到系统内存，第二件事是其他CPU缓存该内存地址的数据置为无效，在多核处理器下，为了保证每个处理器的缓存是一致的，会实现缓存一致性协议，每个处理器在嗅探总线上的传输的数据检查自己缓存的数据是不是过期了，当发现缓存行对应的内存地址发生的修改，那么就会置该缓存行的数据为无效，当处理器再次对该数据进行修改操作的时候会重新从系统内存中重新读取数据保存到处理器缓存行中</li></ul></li><li><p>synchonized关键字的三种使用方式</p><ul><li>用在同步代码块上，此时锁是括号里面配置的对象</li><li>用在普通方法上，此时锁是当前实例对象</li><li>用在静态方法上，此时锁是当前类的Class对象</li></ul><p>当一个线程试图访问同步代码块的时候，必须要先获取到锁，在退出或者出现异常的时候必须释放锁</p></li><li><p>synchonized在JVM的实现原理</p><ul><li>JVM是基于进入和退出Monitor对象来实现同步方法和同步代码块，二者的实现细节略有不同<ul><li>对于同步代码块来说，在编译后会在进入同步代码块之前会加一个monitorenter指令，在同步代码块结束退出或者发生异常的地方monitorexit指令，任何一个对象都有一个monitor与之关联，当monitor被持有后将处于锁定状态，线程执行到monitorenter的时候会尝试获取对应monitor的所有权，即尝试获取对象的锁</li><li>对于同步方法来说，通过反编译得到字节码后可以发现，在方法的flags中多了一个ACC_SYNCHONIZED标志，这会告诉JVM这是一个同步方法</li></ul></li></ul></li><li><p>synchonized锁信息在对象的存储位置</p><ul><li><p>无锁状态</p><ul><li><table><thead><tr><th>锁状态</th><th>25bit</th><th>4bit</th><th>1bit是否是偏向锁</th><th>2bit锁标志位</th></tr></thead><tbody><tr><td>无锁状态</td><td>对象的hashCode</td><td>对象分代年龄</td><td>0</td><td>01</td></tr></tbody></table></li></ul></li><li><p>不同的加锁状态</p><ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231027113647593.png" class title="image-20231027113647593"></li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构算法笔记</title>
      <link href="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><a href="https://leetcode.cn/problems/binary-search/submissions/">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &gt; target)&#123;</span><br><span class="line">                j = m - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[m] &lt; target)&#123;</span><br><span class="line">                i = m + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[m] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>区间开闭分析<ul><li>左闭右闭<ul><li>此时数组中所有的元素都在查找范围内，所以j的大小应该等于数组最后一个元素的索引大小，所以j &#x3D; nums.length - 1，然后判断while循环条件时，根据数组是否合法来判断是否有等于号。左闭右闭的情况下[1,1]这个数组是合法的所以需要等于号。然后进入循环，当nums[m] &gt; target时，此时要更新原数组的右边界，因为已经判断过nums[m] &gt; target了，所以nums[m]一定不是要查找的数，所以 j &#x3D; m - 1。nums[m] &lt; target的情况同理。</li></ul></li><li>左闭右开<ul><li>此时数组中最后一个元素不在查找范围内，所以j的大小应该等于数组最后一个元素的索引大小，所以j &#x3D; nums.length，然后判断while循环条件时，根据数组是否合法来判断是否有等于号。左闭右开的情况下[1,1)这个数组是不合法的所以不能加等于号。然后进入循环，当nums[m] &gt; target时，此时要更新原数组的右边界，由于右边界是开区间 j 还等于m - 1话，此时数组就少了一个元素，所以j应该等于m，如果nums[m] &lt; target的情况同理。</li></ul></li></ul></li></ul><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素 - 力扣（LeetCode）</a></p><ul><li>暴力解法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val == nums[i])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;j &lt; size;j++)&#123;</span><br><span class="line">                    nums[j-<span class="number">1</span>] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">                i --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接两层for循环，第一层for循环主要遍历整个数组，查找要删除的值，找到要删除的值以后，进入第二层for循环，把当前位置后面的所有元素向前移一位，即覆盖要删除的值，此时要把数组的长度减一，<strong>循环i的值减一</strong>,因为此时的数组相当于目标值之后元素都向前移了一位，如果循环的i不减一，那么就会少校验一个元素</p><ul><li>快慢指针法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="type">int</span> <span class="variable">slowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">quickIndex</span> <span class="operator">=</span> <span class="number">0</span>;quickIndex&lt;nums.length;quickIndex++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(val != nums[quickIndex])&#123;</span><br><span class="line">               nums[slowIndex] = nums[quickIndex];</span><br><span class="line">               slowIndex++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure><p><strong>核心思想</strong>：当快指针找到目标值的时候，快指针移向下一位，没有其他任何操作，当快指针指向的不是目标值的时候，把指向的值赋给慢指针所指的位置</p><p>快指针：要去寻找目标值</p><p>慢指针：始终指向的是当快指针找到目标元素后要覆盖的位置</p><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项 - 力扣（LeetCode）</a></p><p>同样使用快慢指针的思想</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">quickIndex</span> <span class="operator">=</span> <span class="number">1</span>;quickIndex&lt;nums.length;quickIndex++)&#123;</span><br><span class="line">            tmp = nums[slowIndex];</span><br><span class="line">            <span class="keyword">if</span>(tmp != nums[quickIndex])&#123;</span><br><span class="line">                nums[++slowIndex] = nums[quickIndex]; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h3><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            nums[i] *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> res.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[begin] &gt;= nums [end])&#123;</span><br><span class="line">                res[k] = nums[begin];</span><br><span class="line">                begin++;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[k] = nums[end];</span><br><span class="line">                end--;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思路：非递减的有序数组就是一个相等或者递增的数组，之所以平方之后会出现不递增的情况，是因为数组中可能含有负数，所以此时可以发现<strong>平方之后的数组的最大值一定出现的数组的两端</strong>，所以定义两个指针分别指向数组的第一个元素和数组的最后一个元素，遍历整个数组，向新的数组中赋值。</p><h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h3><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums.length + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">real</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">fast</span>  <span class="operator">=</span> <span class="number">0</span>;fast &lt; nums.length;fast++)&#123;</span><br><span class="line">            sum += nums[fast];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                real = fast - slow + <span class="number">1</span>;</span><br><span class="line">                res = Math.min(res,real);</span><br><span class="line">                sum -= nums[slow];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == nums.length + <span class="number">1</span> ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是双指针的思想，通过双指针来卡数组的长度，其中for循环中的fast一定指的是截取数组的末尾，类似于快指针，通过结尾和开始来判断中间的数的和是否大于target，当大于target的时候慢指针才开始移动，直到截取的数组之和小于target时，此时快指针继续向前移动。其中<strong>res的值在最开始定义的时候必须是一个比数组长度大的数字</strong>，如果定义数字小于等于数组的长度，此时如果原数组中所有的数字相加正好等于target的时候，就会出现问题。</p><h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h3><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II - 力扣（LeetCode）</a></p><ul><li>方法一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">startx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">starty</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i , j;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num &lt; n/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = starty;j &lt; n - offset;j++)&#123;</span><br><span class="line">                res[startx][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i = startx;i &lt; n - offset;i++)&#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;j &gt;= offset;j--)&#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;i &gt;= offset; i--)&#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            offset++;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            res[startx][starty] = n*n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遵循左闭右开或者左开右闭的原则，通过i和j循环递增和递减的方式，上边右边下边左边依次填充</p><p>这个方法的难点：为什么要转n&#x2F;2圈？因为n是正方形的边长，可以通过startx和starty发现每一圈起点的规律，每一圈的起点一定是从左上角开始向正方形的中心递进</p><ul><li>方法二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        res[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; n*n)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; n - <span class="number">1</span>&amp;&amp;res[i][j+<span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                res[i][++j] = ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n - <span class="number">1</span>&amp;&amp;res[i+<span class="number">1</span>][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                res[++i][j] = ++count;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span>&amp;&amp;res[i][j-<span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                res[i][--j] = ++count;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &gt; <span class="number">0</span>&amp;&amp;res[i - <span class="number">1</span>][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                res[--i][j] = ++count;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接螺旋写数字，关键在于要在写数字的时候知道什么时候要拐弯，这里的判断方法是判断下一个点的数是不是零和判断到没到边界的前一个点（判断是不是边界用于写第一圈，判断是不是零用于写第二圈），如果是零说明可以写数字，因为矩阵中不可能有零，如果到了边界的前一个点说明拐弯了。</p><h3 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h3><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素 - 力扣（LeetCode）</a></p><ul><li>不使用虚拟头节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; head.val == val) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val == val)&#123;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时要分情况讨论</p><ol><li>头节点的值等于要删除的值</li></ol><p>while (head !&#x3D; null &amp;&amp; head.val &#x3D;&#x3D; val)，此时要循环移动head所对应的节点</p><ol start="2"><li>头节点的值不等于要删除的值</li></ol><p>此时要用一个pre变量记录头节点，来完成接下来的一系列操作，因为最后要求返回的是链表的头节点，同时头节点的值不等于要删除的值，所以head的指向不能改变，用cur记录pre的下一个节点，相当于cur和pre两个指针遍历整个链表</p><ul><li>使用虚拟头节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val == val) &#123;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加虚拟头节点的好处是不需要单独判断头节点是否为要删除的val，核心思路就是把<strong>pre指向虚拟头节点！虚拟头节点！虚拟头节点！</strong>，cur指向头节点，然后让这俩个指针遍历整个链表即可</p><h3 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode()&#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//size存储链表元素的个数</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//虚拟头结点</span></span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取第index个节点的数值，注意index是从0开始的，第0个节点就是头结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//如果index非法，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//包含一个虚拟头节点，所以查找第 index+1 个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentNode.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表最前面插入一个节点，等价于在第0个元素前添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表的最后插入一个节点，等价于在(末尾+1)个元素前添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class="line">    <span class="comment">// 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// 如果 index 大于链表的长度，则返回空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">//找到要插入节点的前驱</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pred</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">toAdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        toAdd.next = pred.next;</span><br><span class="line">        pred.next = toAdd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除第index个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pred</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index ; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pred.next = pred.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典题目，基本包含了包含了链表的所有常见操作，主要想好<strong>在get节点的时候，指针要指向该节点，在增删节点的时候，指针指向的是要增删位置节点的前一个节点</strong></p><p>一个小坑：在增加节点的时候先把新增节点的next指向下一个节点，在将cur指向的节点的next指向新增节点，因为如果cur指向的节点先指向了新增节点，那么新增的节点就找不到next要指向谁了</p><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表 - 力扣（LeetCode）</a></p><ul><li>双指针法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个指针指向头节点的前一个即为null，第二个指针指向头节点，注意遍历到cur为null而不是cur的next为null，因为当cur的next为空的时候，此时cur指向的是原链表的最后一个，此时应该进入循环，tmp指针需要保存的是cur的next，因为如果不保存的话，cur的指向已经发生改变了，下一次循环就找不到cur.next了</p><ul><li>递归写法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reverseList(<span class="literal">null</span>,head);      </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode pre,ListNode cur)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        </span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">        <span class="keyword">return</span> reverseList(pre,cur);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路和双指针一摸一样，注意递归终止的条件是cur为空</p><h3 id="两两交换链表中节点"><a href="#两两交换链表中节点" class="headerlink" title="两两交换链表中节点"></a>两两交换链表中节点</h3><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp1</span> <span class="operator">=</span> cur.next.next;</span><br><span class="line">            cur.next = tmp1;</span><br><span class="line">            tmp.next = tmp1.next;</span><br><span class="line">            tmp1.next = tmp;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是使用虚拟头节点的方式，首先要判断什么时候循环结束，当前指向的后两个只要有null就停止循环，交换的顺序一定是要交换的两个节点的前一个节点的前一个节点指向要交换的后一个，要交换的前一个指向下一组的前一个，要交换的后一个节点指向要交换的前一个节点</p><h3 id="删除倒数第几个节点"><a href="#删除倒数第几个节点" class="headerlink" title="删除倒数第几个节点"></a>删除倒数第几个节点</h3><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一提到删除就要想到指针指向的是要删除节点的前一个节点，此时我们就要知道要删的节点的前一个在哪，这时有一个比较巧妙的方法，使用一种<strong>特殊的快慢指针</strong>，开始的时候，快慢指针同时指向虚拟头节点，然后快指针向前移动n个位置，然后快慢指针一起移动，直到快指针到达链表最后一个节点，此时慢指针刚好指向要删除的前一个节点，很巧妙，可以多画图理解</p><h3 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur1</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur2</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            size1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">            size2++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = headA;</span><br><span class="line">        cur2 = headB;</span><br><span class="line">        <span class="keyword">if</span>(size2 &gt; size1)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> size1;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmpList</span> <span class="operator">=</span> cur1;</span><br><span class="line">            size1 = size2;</span><br><span class="line">            size2 = tmp;</span><br><span class="line">            cur1 = cur2;</span><br><span class="line">            cur2 = tmpList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> size1 - size2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; count;i++)&#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1 == cur2)&#123;</span><br><span class="line">                <span class="keyword">return</span> cur1;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解题的关键是要想找到相交的链，这两个链表一定是尾部对齐的，然后短链的指针指向该链的第一个节点，长链的指针从头节点开始向后移动两链表长度之差，这样在链表尾部对齐的情况下，两指针就在同一个位置了，然后依次向后遍历判断是否有相同的节点</p><h3 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h3><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index1</span> <span class="operator">=</span> fast;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index2</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="keyword">while</span>(index1 != index2)&#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题可以分成两个部分，第一是判断是否有环，第二是找出环的入口</p><ol><li>判断是否有环</li></ol><p>使用快慢指针的方法，让快指针每次走两个节点，慢指针走一个节点，如果快慢指针能相遇，那么一定有环</p><ul><li>为什么快慢指针一定能相遇？不会跨过去吗？</li></ul><p>因为快指针的移动速度是2，慢指针的移动速度是1，快指针相对慢指针的速度是1，所以在慢指针看来，快指针是在一个节点一个节点的靠近自己，所以不会跨过去</p><ol start="2"><li>找出环的入口</li></ol><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230909145914203.png" class title="image-20230909145914203"><p>根据公式可以发现，环的入口位置一定等于z加上n倍的圈数，所以可以定两个指针，一个指向头节点位置，一个指向快慢指针相遇位置，两个指针同时以1的速度前进，相遇的位置就是入口位置。</p><hr><p>第二次求解环的入口：</p><p>设此时的链表有环，环的入口之前的长度为a(不包括入口节点)，环的长度为b，快指针f一次走两步，慢指针s一次走一步。</p><p>根据假设可得f &#x3D; 2s，快慢指针要想相遇，那么一定是快指针比慢指针多走了n个圈，所以f &#x3D; s + nb</p><p>联立以上两式，可得f &#x3D; 2nb，s &#x3D; nb，也就是快慢指针相遇的时候，慢指针的步数一定是n个环的长度</p><p>对于一个普通的慢指针，要想走到环入口的位置，走的步数k一定是k &#x3D; a + nb</p><p>而此时的慢指针已经走了nb的长度，想要再次到达环的入口位置还需要走a步，也就是入口之前的长度</p><h3 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h3><p><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            hash[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; t.length();i++)&#123;</span><br><span class="line">            hash[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; hash.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用一个数组来表示要存放26个字母，a是索引0的数据，z是索引25的数据，然后分别遍历s和t这两个字符串的每一个字母，s和t的每一个字母分别和’a’相减得到每个字母对应的索引，s得到索引后把对应位置的数字加一，t得到索引后把对应位置的数字减一，最后遍历数组的每个数字，如果每个位置的数字都等于0‘，那么每个位置加的次数和减的次数相同，说明是字母异位词</p><h3 id="两个数组元素交集-去重"><a href="#两个数组元素交集-去重" class="headerlink" title="两个数组元素交集(去重)"></a>两个数组元素交集(去重)</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1 == <span class="literal">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="literal">null</span> || nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; resSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历数组1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            set1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历数组2的过程中判断哈希表中是否存在该元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set1.contains(i)) &#123;</span><br><span class="line">                resSet.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[resSet.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : resSet)&#123;</span><br><span class="line">            arr[j++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数组内的元素大小不确定时，可以考虑使用set集合来找交集，思路很简单就是先把第一个数组中所有的元素放到set集合中，然后遍历第二个数组，看set集合中是否包含该元素，如果包含直接放到新的set集合中，因为set集合可以帮我们去重。重点记住相关api，判断是否包含的：set1.contains(i)，往集合中添加元素set1.add(i)，获得集合大小Set.size()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1 == <span class="literal">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="literal">null</span> || nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1001</span>];</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums1.length;i++)&#123;</span><br><span class="line">            hash[nums1[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i &lt; nums2.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[nums2[i]] == <span class="number">1</span>)&#123;</span><br><span class="line">                set.add(nums2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> set.stream().mapToInt(x -&gt; x).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在力扣改版之后，这道题新增了一个条件是元素的大小在0到1000中，此时元素的大小有了范围，所以可以考虑使用数组解决，思路和集合一样，第一个传入的数组直接放到新的，容量为1000的数组中，第二个传入的数组在这个容量为1000的数组中查询</p><h3 id="两个数组元素交集-不去重"><a href="#两个数组元素交集-不去重" class="headerlink" title="两个数组元素交集(不去重)"></a>两个数组元素交集(不去重)</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/submissions/">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[Math.min(nums1.length,nums2.length)];</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; nums1.length &amp;&amp; p2 &lt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[p1] &lt; nums2[p2])&#123;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums2[p2] &lt; nums1[p1])&#123;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                arr[index] = nums1[p1];</span><br><span class="line">                index++;</span><br><span class="line">                p1++;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(arr,<span class="number">0</span>,index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先对两个数组进行从小打到的排序，然后分别定义两个指针分别指向两个数组索引为0的位置，比大小让小的元素对应的指针向前进一个，然后如果相等那么就把该元素记录到新数组重，然后两个指针同时向后前进一位</p><h3 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h3><p><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span>&amp;&amp;!set.contains(n))&#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">            n = getNextNumber(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNumber</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">            res += tmp * tmp;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意获取一个数，每位之和的方法，循环模10的方法取到最后一位，然后除10一直循环到这个数除10为0。然后的关键点在于判断是不是快乐数的终止条件，如果平方和为1了，直接终止循环是快乐数，如果set集合中出现了这个数，说明这个数每位的平方和进入了循环且不等于1，此时一定不是快乐数</p><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和 - 力扣（LeetCode）</a></p><ul><li>暴力</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                    res[<span class="number">0</span>] = i;</span><br><span class="line">                    res[<span class="number">1</span>] = j;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两层循环直接找，时间复杂度O(n²)，不好</p><ul><li>哈希法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(tmp))&#123;</span><br><span class="line">                res[<span class="number">0</span>] = map.get(tmp);</span><br><span class="line">                res[<span class="number">1</span>] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们想到要通过数组的元素来判断是不是我们需要的下标，所以元素和下标我们都需要，所以考虑使用map，注意此时<strong>把元素的值作为map的key，元素的下标作为map的value</strong>，因为要通过元素的值来判断是否符合要求，把他作为key能迅速的查找他是否在map中出现过，一定要在判断的过程中往map里添加，<strong>千万不能把数组全部添加到map中再进行判断，这样可能重复的元素索引值会被覆盖</strong></p><h3 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加"></a>四数相加</h3><p><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums2.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> nums1[i] + nums2[j];</span><br><span class="line">                map.put(s,map.getOrDefault(s,<span class="number">0</span>) + <span class="number">1</span>);                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums3.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums4.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums3[i] + nums4[j];    </span><br><span class="line">                count += map.getOrDefault(-m,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路和两数之和很像，这道题为了降低时间复杂度，可以把四个数组两两分组，然后先遍历其中两个数组，得到他们的和放到map集合中，其中map的key是两元素之和，map的value是这个和出现的次数，然后遍历剩下两个数组，也是先得到两个数的和m，然后在map中找有没有和m相加等于0的key，即-m的key，如果有统计出现-m的次数即可</p><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(right &gt; left)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>])&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三数之和虽然可以考虑和两数之和一样使用哈希法来解决，但是要考虑去重，太麻烦，所以推荐使用双指针法(其实是三个指针，分别指向要想加的三个元素)，核心思路是，先对数组进行从小到大的排序，i先指向数组的第一个元素，left指向i的下一个元素，right指向数组的最后一个元素，然后三个数相加，如果等于大于零说明这三个数相加比目标值大了，让right向前移动，如果小于零则left向后移一位。</p><ul><li>去重细节<ul><li>i的去重，一定是i和i的前一个元素进行比较，即nums[i] &#x3D;&#x3D; nums[i - 1]，因为如果是nums[i] &#x3D;&#x3D; nums[i +1]这样进行比较去重的话，可能会漏掉一些结果，比如{-1，-1，2}，题目只要求数组与数组之间不能重复，没有说数组内的元素不能重复，这样i和i的前一个进行比较如果相等说明这个数已经用过了无需再次遍历直接coontinue</li><li>left和right的去重，一定要保证left&lt;right的情况之下，然后left和后一个进行比较，right和前一个进行计较即可</li></ul></li></ul><h3 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h3><p><a href="https://leetcode.cn/problems/4sum/">18. 四数之和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;k &lt; nums.length;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">0</span>&amp;&amp;nums[k] == nums[k - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; k + <span class="number">1</span>&amp;&amp;nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>)nums[k] + nums[i] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[k],nums[i],nums[left],nums[right]));</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right&amp;&amp;nums[left] == nums[left + <span class="number">1</span>])&#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span>(right &gt; left&amp;&amp;nums[right] == nums[right - <span class="number">1</span>])&#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑和三数之和一样，只是在三数之和的代码逻辑之上加上一层循环，注意去重细节，k指向数组第一个元素，然后去重的时候和前一个元素进行比较，如果相等向前移动，<strong>这里就不要考虑剪枝了，因为数组中可能有负数，有可能两个数越加越小导致直接return漏掉结果</strong></p><h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><p><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典双指针的思路，一个指针指向数组的头节点，另一个指针指向数组的尾节点，然后同时向中间移动</p><h3 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h3><p><a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] strChar = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; strChar.length;i += <span class="number">2</span>*k)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Math.min(strChar.length - <span class="number">1</span>,left + k -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> strChar[left];</span><br><span class="line">                strChar[left] = strChar[right];</span><br><span class="line">                strChar[right] = tmp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(strChar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反转过程和第一个反转字符串一样，但是注意这个遍历的时候需要以2k为单位向前移动for(int i &#x3D; 0;i &lt; strChar.length;i +&#x3D; 2*k)，反转的头节点就是每一次遍历的i，反转尾节点就是数组长度和i+k中较小的一个，这样正好可以满足题目的两个条件</p><h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格 - 力扣（LeetCode）</a></p><ul><li>复制元素直接求解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用StringBuilder追加字符串的方式，遍历原字符串，如果遇到’ ‘就替换成“%20”，思路简单，注意StringBuilde的API使用，另外还需要额外的内存空间</p><ul><li>双指针法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sb.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        s += sb.toString();</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[left] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                ch[right--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                ch[right--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                ch[right] = <span class="string">&#x27;%&#x27;</span>; </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ch[right] = ch[left];</span><br><span class="line">            &#125;</span><br><span class="line">            left--;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路就是遍历原字符串，如果遇到’ ‘的情况就直接在字符串的后面追加两个空位，然后一个指针指向原字符串的最后一个元素，另一个指针指向追加后字符串的最后一个空位，然后向前对新字符串进行填充</p><h3 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h3><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> ch.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch[left] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ch[right] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(index &gt;= left &amp;&amp; ch[index] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index+<span class="number">1</span>;i &lt;= right;i++)&#123;</span><br><span class="line">                sb.append(ch[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(index &gt; left)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(index &gt;= left &amp;&amp; ch[index] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">            right = index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>难点在于多出来的空格如何处理，使用双指针法，先去除字符串两端的空格，一个指针指向字符串的最前面，一个指针指向字符串的最后面，然后向前遍历，直到不是’ ‘，然后使用一个index指针，从后向前遍历每个单词(即等于空的时候停下)，此时有了单词的开始索引(index的指向)和单词结束的索引(right的指向)，这时可以使用StringBuilder拼接这个单词，如果此时index大于left再拼接一个空格表示不是最后一个单词，然后index继续向前走，直到不是空格的时候，让right指向该位置(下一个单词最后一个字母的位置)，此后一直循环即可</p><p>详细图解：<a href="https://leetcode.cn/problems/reverse-words-in-a-string/solutions/1153820/yi-ci-bian-li-shi-xian-fan-zhuan-zi-fu-c-cmos/">https://leetcode.cn/problems/reverse-words-in-a-string/solutions/1153820/yi-ci-bian-li-shi-xian-fan-zhuan-zi-fu-c-cmos/</a></p><h3 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h3><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &gt;= s.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] res = <span class="keyword">new</span> <span class="title class_">char</span>[ch.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n;i &lt; ch.length;i++)&#123;</span><br><span class="line">            res[index] = ch[i];</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            res[index] = ch[i];</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(res);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启一个新的数组，然后先遍历原数组的n到末尾的位置，放到新数组，再遍历原数组的首个元素到n的前一个位置，放到新数组中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &gt;= s.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        reverse(ch,<span class="number">0</span>,n - <span class="number">1</span>);</span><br><span class="line">        reverse(ch,n,ch.length - <span class="number">1</span>);</span><br><span class="line">        reverse(ch,<span class="number">0</span>,ch.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] ch,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> ch[start];</span><br><span class="line">            ch[start] = ch[end];</span><br><span class="line">            ch[end] = tmp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接在原字符串数组中操作，先把数组的首个元素到n的前一个进行反转，然后再把数组的第n个元素到最后一个元素进行反转，最后把数组整个反转，这样可以直接得到返转好的数组</p><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> haystack.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> needle.length();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; h)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>;right &lt; n;right++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &gt; <span class="number">0</span>&amp;&amp;needle.charAt(left) != needle.charAt(right))&#123;</span><br><span class="line">                left = next[left - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(needle.charAt(left) == needle.charAt(right))&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[right] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">0</span>;i &lt; h;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span>&amp;&amp;haystack.charAt(i) != needle.charAt(j))&#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(haystack.charAt(i) == needle.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == n)&#123;</span><br><span class="line">                <span class="keyword">return</span> i - n + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>haystack查询字符串，needle被查询字符串</p><p>暴力解法就是两层for循环遍历两个字符串，如果找不到从查找字符串的第二个字符再次遍历，KMP的核心思路就是找到字符串的最长前后缀长度，可以少遍历几个几个字符串</p><p>前缀：以第一个字符开头的任意长度的字符串</p><p>后缀：以最后一个字符结尾的任意长度字符串</p><p>其中，前缀表示的是被查询的字符串的前几个字符，后缀表示的是查询字符串中的几个字符</p><p>next数组存放的就是每个字符所对应的最长前后缀长度，这样我们遍历到不相符的字符的时候，直接找到该字符前一个字符对应的最长前后缀长度，指针直接指向最长前缀的后一个字符，从那个位置开始遍历，最长的前缀的东西一定在要查询的字符串出现了。。。。。。胡言乱语，刷算法的第一道坎，还是多练吧</p><p>详细分解：<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/1119642/duo-tu-yu-jing-xiang-jie-kmp-suan-fa-by-w3c9c/">https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/1119642/duo-tu-yu-jing-xiang-jie-kmp-suan-fa-by-w3c9c/</a></p><h3 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h3><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串 - 力扣（LeetCode）</a></p><ul><li>拼接法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> s + s;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(ss);</span><br><span class="line">        sb.deleteCharAt(ss.length() - <span class="number">1</span>);</span><br><span class="line">        sb.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">newString</span> <span class="operator">=</span> newStr.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[pre];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>;right &lt; pre;right++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &gt; <span class="number">0</span>&amp;&amp;s.charAt(left) != s.charAt(right))&#123;</span><br><span class="line">                left = next[left - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[right] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">0</span>;i &lt; newString;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span>&amp;&amp;newStr.charAt(i) != s.charAt(j))&#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(newStr.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == pre)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个字符串是ababab这样的由一个子字符串重复出现构成的，那么两个这样的字符串相加，并且掐头去尾后，一定会包含原本的字符串，即相加后abababababab，掐头去尾后bababababa，此时ababab一定在该字符串中，所以就可以使用kmp算法解决</p><ul><li>next数组妙用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[pre];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>;right &lt; pre;right++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &gt; <span class="number">0</span>&amp;&amp;s.charAt(left) != s.charAt(right))&#123;</span><br><span class="line">                left = next[left - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[right] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(next[pre - <span class="number">1</span>] &gt; <span class="number">0</span>&amp;&amp;pre%(pre - next[pre - <span class="number">1</span>]) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果s是一个重复的子字符串，那么他的最大前后缀长度一定是next数组的最后一个位置，此时数组的长度减去最长前后缀长度，得到就是一个子字符串的长度，所以如果原字符串长度%子字符串长度为0，那么它就是重复的子字符串</p><h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Stack stackIn;</span><br><span class="line">    Stack stackOut;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(stackOut.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stackIn.isEmpty())&#123;</span><br><span class="line">                stackOut.push(stackIn.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> (<span class="type">int</span>)stackOut.peek();</span><br><span class="line">        stackOut.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="built_in">this</span>.pop();</span><br><span class="line">        stackOut.push(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stackIn.isEmpty()&amp;&amp;stackOut.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理是使用两个栈来模拟队列，一个栈模拟队列的入口，一个栈模拟队列的出口，队列每次添加数据从入口栈添加，获取数据从出口栈获取，每当出口栈为空的时候，把入口栈的数据全部放到出口栈，因为栈是先进后出的，所以后进入入口栈的数据会先出来放到出口栈的最下面，先进入口栈的数据放到出口栈的最上面形成先进先出的效果</p><h3 id="使用队列实现栈"><a href="#使用队列实现栈" class="headerlink" title="使用队列实现栈"></a>使用队列实现栈</h3><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈 - 力扣（LeetCode）</a></p><ul><li>使用两个队列实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="comment">//q1作为主要的队列，其元素排列顺序和出栈顺序相同</span></span><br><span class="line">    Queue&lt;Integer&gt; q1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//q2仅作为临时放置</span></span><br><span class="line">    Queue&lt;Integer&gt; q2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在加入元素时先将q1中的元素依次出栈压入q2，然后将新加入的元素压入q1，再将q2中的元素依次出栈压入q1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(q1.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            q2.add(q1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        q1.add(x);</span><br><span class="line">        <span class="keyword">while</span>(q2.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            q1.add(q2.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个队列辅助另一个队列实现栈，每次新增元素的时候把第一个队列的所有元素放入第二个队列，然后在第一个队列放入新元素，然后把第二个队列的所有元素放入第一个队列中，实现先进后出</p><ul><li>一个队列实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">     <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        q.add(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        size = q.size();</span><br><span class="line">        <span class="keyword">while</span>(size &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            q.add(q.poll());</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> q.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思路就是在每次弹出元素的时候，根据队列的长度先弹出前n - 1个元素并放到队列尾端，这样再弹出的时候就是最后加入进来的元素，Deque 接口继承了 Queue 接口, 所以 Queue 中的 add、poll、peek等效于 Deque 中的 addLast、pollFirst、peekFirst，peekLast,这样在获取栈顶部元素的时候，直接调用peekLast获取队列的最后一个即可</p><h3 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h3><p><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">Stack</span> <span class="variable">sk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ch.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                sk.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch[i] == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                sk.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch[i] == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                sk.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sk.isEmpty() || !sk.peek().equals(ch[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sk.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无效的括号无非就三种情况，1. 左括号多了 2. 右括号多了 3. 左右括号不匹配，所以可以利用栈先进后出的特点，遍历字符串，如果遇到左括号那么就往栈里面加一个与之对应的右括号，如果遇到右括号看栈里面的peek元素是不是和遍历的右括号相符，如果相符就从栈中把该右括号取出，如果栈空了或者不相符直接返回false，最后整个遍历完根据栈里是否有元素判断是否为有效括号</p><h3 id="删除字符串的相邻重复项"><a href="#删除字符串的相邻重复项" class="headerlink" title="删除字符串的相邻重复项"></a>删除字符串的相邻重复项</h3><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ch.length;i++)&#123;</span><br><span class="line">            ch[slow] = ch[fast];</span><br><span class="line">            <span class="keyword">if</span>(slow &gt; <span class="number">0</span>&amp;&amp;ch[slow] == ch[slow - <span class="number">1</span>])&#123;</span><br><span class="line">                slow--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch,<span class="number">0</span>,slow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用经典的双指针解法就可以搞定，一个快指针遍历整个字符串，慢指针用来判断前后两个字符是不是相等，如果相等慢指针后退，不相等慢指针前进一个，注意最后返回的字符串是从零到慢指针指向的位置</p><h3 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h3><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; sk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; tokens.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;+&quot;</span>.equals(tokens[i])||<span class="string">&quot;-&quot;</span>.equals(tokens[i])||<span class="string">&quot;*&quot;</span>.equals(tokens[i])||<span class="string">&quot;/&quot;</span>.equals(tokens[i]))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> sk.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> sk.pop();</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;+&quot;</span>.equals(tokens[i]))&#123;</span><br><span class="line">                    sk.push(num1 + num2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;-&quot;</span>.equals(tokens[i]))&#123;</span><br><span class="line">                    sk.push(num2 - num1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;*&quot;</span>.equals(tokens[i]))&#123;</span><br><span class="line">                    sk.push(num1 * num2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;/&quot;</span>.equals(tokens[i]))&#123;</span><br><span class="line">                    sk.push(num2/num1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(tokens[i]);</span><br><span class="line">                sk.push(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带有”+-*&#x2F;“这种运算符的都可以考虑用栈来解决，这道题可以把传入的字符串数组看成一个二叉树，按照左右中的顺序进行计算，把整个字符串数组进行遍历放到栈里，然后如果遇到运算符号，从栈顶取出两个元素进行运算，把运算结果放到栈里，当字符换数组遍历完之后栈里剩的数就是最后的结果，很神奇</p><h3 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h3><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> nums.length - k + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[count];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!d.isEmpty()&amp;&amp;nums[d.peekLast()] &lt; nums[i])&#123;</span><br><span class="line">                d.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            d.addLast(i);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!d.isEmpty()&amp;&amp;d.peekFirst() &lt;= i - k)&#123;</span><br><span class="line">                    d.pollFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                res[i - k + <span class="number">1</span>] = nums[d.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法是维护一个单调队列，遍历整个数组，把数组的每一个元素的<strong>索引</strong>放到队列中，但是在每次加入前都要先进行判断，看看当前加入的索引对应的元素是不是比队列尾部索引对应的值大，如果大则队列中尾部索引就删除掉，判断到上一个索引元素大于要加入的或者队列为空为止，然后开始取元素，取元素的条件是遍历的次数要大于等于k-1，然后从头开始看这个队列，如果开头元素索引比i - k还小，说明此时的滑动窗口以及到了开头元素的后面，所以开头的不符合滑动窗口范围的也要进行删除，最后队列的头部就是想要的元素</p><p>以上代码第一个while是从后开始删除不符合的元素索引(<strong>比新加的元素索引对应的值还小</strong>)，第二个while是从前删除不符合的元素索引(不在滑动窗口的范围以内)，i可以代表滑动窗口的最后的位置</p><h3 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h3><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            map.put(nums[i],map.getOrDefault(nums[i],<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((n1, n2) -&gt;n1[<span class="number">1</span>] - n2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> keyValue : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &lt; k)&#123;</span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;keyValue,map.get(keyValue)&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(map.get(keyValue) &gt; pq.peek()[<span class="number">1</span>])&#123;</span><br><span class="line">                pq.remove();</span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;keyValue,map.get(keyValue)&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> [] tmp = pq.remove();</span><br><span class="line">            res[i++] = tmp[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先遍历整个数组，把数组元素作为key，元素出现的频率作为value，保存到map集合中，然后使用PriorityQueue这个优先队列(底层是用栈来实现的)，泛型指定为数组形式，把map中的每一个键值对的两个数作为一个数组放到队列中，<strong>因为我们要保留出现频率高的，所以使用的是小顶堆</strong>，所以规定好排序规则即按照传入数组索引为1的值进行升序排列，然后放入到队列中，保留前K多的数组即可，最后留在队列中的就是前K个最高频率的</p><h3 id="二叉树的前-x2F-中-x2F-后序遍历"><a href="#二叉树的前-x2F-中-x2F-后序遍历" class="headerlink" title="二叉树的前&#x2F;中&#x2F;后序遍历"></a>二叉树的前&#x2F;中&#x2F;后序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历 - 力扣（LeetCode）</a></p><ul><li>递归法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preorderTraversal(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorderTraversal</span><span class="params">(TreeNode cur,List list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(cur.val);</span><br><span class="line">        preorderTraversal(cur.left,list);</span><br><span class="line">        preorderTraversal(cur.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前序遍历：<strong>中</strong>左右，中序遍历：左<strong>中</strong>右，后序遍历：左右<strong>中</strong>。根据”中”这个字位置来记忆这几个遍历的顺序</p><p>使用递归法遍历的核心代码就三行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.add(cur.val);<span class="comment">//中</span></span><br><span class="line">preorderTraversal(cur.left,list);<span class="comment">//左</span></span><br><span class="line">preorderTraversal(cur.right,list);<span class="comment">//右</span></span><br></pre></td></tr></table></figure><p>不管是哪种遍历只需要调整这三行代码顺序即可</p><ul><li>迭代法前序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; sk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        sk.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!sk.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> sk.pop();</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                list.add(cur.val);<span class="comment">//中</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sk.push(cur.right);<span class="comment">//右</span></span><br><span class="line">            sk.push(cur.left);<span class="comment">//左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的是栈这个数据结构，理论上所以的递归操作都可以用栈来模拟，前序遍历的顺序是中左右，然后栈是先进后出的，所以思路就是中节点先入栈，然后处理中间节点，然后中间节点的右节点和左节点先后入栈，这样在弹出元素的时候就可以左节点先弹出处理，右节点后弹出</p><ul><li>迭代法后序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; sk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        sk.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!sk.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> sk.pop();</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                list.add(cur.val);<span class="comment">//中</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sk.push(cur.left);<span class="comment">//左</span></span><br><span class="line">            sk.push(cur.right);<span class="comment">//右</span></span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历的代码直接在前序遍历的基础上改就行，思路就是在我们处理前序遍历<strong>中左右</strong>的时候，处理和放入栈的顺序是<strong>中右左</strong>，此时遍历的顺序是<strong>左右中</strong>，所以只需要在处理和放入栈的时候把在前序遍历的基础上改为<strong>中左右</strong>，这样放入链表的顺序就是<strong>中右左</strong>，最后再使用reverse方法对链表进行反转就变成了<strong>左右中</strong></p><ul><li>迭代法中序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; sk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>||!sk.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                sk.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = sk.pop();</span><br><span class="line">                res.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路就是从根节点开始，一路向左向栈中添加遍历的节点，当遍历到空的时候，从栈中取出栈顶的元素，让当前指针指向该元素，此时这个元素一定是二叉树最左下角的那一个，把他的值加到链表中，然后让指针再指向当前元素的右节点，进入到下一次循环即可，注意进入循环的条件：当前节点的元素和栈有一个不为空即可</p><ul><li>二叉树层序遍历</li></ul><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            d.addLast(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!d.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> d.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> d.pollFirst();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层序遍历的意思是按照二叉树的每一层的元素顺序放到集合中，思路是使用队列，先把根节点放到队列中，然后记录此时队列的大小，然后进入循环，每次循环的次数根据队列中队开始的元素个数决定，把根节点放入到结果集中，然后先后把根节点的左右节点加入到队列中，循环到队列为空</p><h3 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            d.addLast(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!d.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> d.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> d.pollFirst();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层序遍历就是二叉树每一层从左到右遍历一遍，使用的是ArrayDeque这个队列，每从队列中取出一个元素的时候，就看看该元素是否含有子节点，如果有把子节点放入到队列中，注意每次循环此时是最开始遍历时记录的队列的大小，最后方法的调用pollFirst和addLast</p><h3 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h3><p><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        invert(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invert</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span> || (cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.left;</span><br><span class="line">        cur.left = cur.right;</span><br><span class="line">        cur.right = tmp;</span><br><span class="line">        invert(cur.left);</span><br><span class="line">        invert(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归的写法其实很简答，但是写之前一定先想好自己要使用哪种遍历方式，理论上前中后序遍历都可以，但是推荐前序和后序，因为中序写起来比较绕，举个例子：校长说去年是一年级的学生打扫学校，今年轮到二年级的打扫，乍一听没毛病，但仔细一想还是一批人，中序遍历是左中右，把左孩子处理完了，然后处理中间孩子的时候，右孩子变成左孩子了，然后再处理右孩子的时候其实还是左孩子。所以尽量不要使用中序遍历</p><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p><a href="https://leetcode.cn/problems/symmetric-tree/">101. Symmetric Tree - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left,TreeNode right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left.val != right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">out</span> <span class="operator">=</span> compare(left.left,right.right);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">inside</span> <span class="operator">=</span> compare(left.right,right.left);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> out &amp;&amp; inside;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(left.val != right.val)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过了这四个if的筛选此时后面递归处理的情况一定是左右节点都不为空且值相等的情况</p><p>然后进入递归逻辑</p><ul><li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li><li>比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。</li><li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li></ul><h3 id="最大深度"><a href="#最大深度" class="headerlink" title="最大深度"></a>最大深度</h3><ul><li>递归法</li></ul><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getHight(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHight</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHight</span> <span class="operator">=</span> getHight(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHight</span> <span class="operator">=</span> getHight(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span> + Math.max(leftHight,rightHight);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求一个二叉树的最大深度，就是二叉树的最大高度，所以从最下面的叶子节点开始往上数，碰见空节点说明这个空节点的父节点的高度是1，这样父节点的父节点就知道自己的其中一个孩子高度是1，数数的操作体现在int res &#x3D; 1 + Math.max(leftHight,rightHight)这一行，不好理解建议使用层序遍历</p><ul><li>层序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        d.addLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!d.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> d.size();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> d.pollFirst();</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用层序遍历的原因是二叉树的层数正好是二叉树的最大深度，所以每遍历一层计数器加一</p><h3 id="最小深度"><a href="#最小深度" class="headerlink" title="最小深度"></a>最小深度</h3><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        d.addLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!d.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> d.size();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> d.pollFirst();</span><br><span class="line">                <span class="keyword">if</span>(tmp.left == <span class="literal">null</span> &amp;&amp; tmp .right == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接使用层序遍历比较好理解，从根节点开始遍历遇到左右节点都为空的时候，清空直接返回当前的层数就是最小的深度</p><h3 id="完全二叉树节点个数"><a href="#完全二叉树节点个数" class="headerlink" title="完全二叉树节点个数"></a>完全二叉树节点个数</h3><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数 - 力扣（LeetCode）</a></p><ul><li>层序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        d.addLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!d.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> d.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> d.pollFirst();</span><br><span class="line">                list.add(tmp);</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层序遍历一个个数，时间复杂度有点高</p><ul><li>递归</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNums(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNums</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> getNums(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightNum</span> <span class="operator">=</span> getNums(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> leftNum + rightNum + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用递归分别求出根节点左右子树的的个数最后加上根节点的1就是全部节点的数量</p><ul><li>利用完全二叉树的特性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分别看看左右子树是不是满二叉树</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lef</span> <span class="operator">=</span> getNums(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rig</span> <span class="operator">=</span> getNums(root.right);</span><br><span class="line">        <span class="keyword">return</span> lef + rig + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNums</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftCur</span> <span class="operator">=</span> node.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightCur</span> <span class="operator">=</span> node.right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(leftCur != <span class="literal">null</span>)&#123;</span><br><span class="line">            leftCur = leftCur.left;</span><br><span class="line">            leftNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(rightCur != <span class="literal">null</span>)&#123;</span><br><span class="line">            rightCur = rightCur.right;</span><br><span class="line">            rightNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rightNum == leftNum)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; rightNum) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp1</span> <span class="operator">=</span> getNums(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp2</span> <span class="operator">=</span> getNums(node.right);</span><br><span class="line">        <span class="keyword">return</span> tmp1 + tmp2 + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完全二叉树可能出现其根节点的左子树为满二叉树或者完全二叉树本身就是一棵满二叉树，如果是满二叉树可以利用满二叉树的特性，如果不是满二叉树可以按照之前的遍历方式数数，如果是满二叉树的话节点数量为2^depth - 1 ，完全二叉树判断是不是满二叉树的方法是看左节点个数和右节点个数是否相等，利用这个公式还有一个好处是不用遍历完树的所有节点，上面的层序遍历和递归都需要遍历所有节点，而如果是一个满二叉树只需要遍历最左侧和最右侧的节点</p><h3 id="是否是平衡二叉树"><a href="#是否是平衡二叉树" class="headerlink" title="是否是平衡二叉树"></a>是否是平衡二叉树</h3><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> getHigh(root);</span><br><span class="line">        <span class="keyword">if</span>(res &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHigh</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHigh</span> <span class="operator">=</span> getHigh(node.left);</span><br><span class="line">        <span class="keyword">if</span>(leftHigh == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHigh</span> <span class="operator">=</span> getHigh(node.right);</span><br><span class="line">        <span class="keyword">if</span>(rightHigh == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(rightHigh - leftHigh) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + Math.max(rightHigh,leftHigh);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路很简单，就是判断二叉树的每个节点的高度是否超过了一，这个设计很巧妙，先是自底向上查看每个节点的高度，但是如果发现了某个节点已经不是平衡二叉树了就向上返回-1，这样最后只需判断最后返回的结果是不是-1即可</p><h3 id="二叉树所有路径"><a href="#二叉树所有路径" class="headerlink" title="二叉树所有路径"></a>二叉树所有路径</h3><p><a href="https://leetcode.cn/problems/binary-tree-paths/">257. Binary Tree Paths - 力扣（LeetCode）</a></p><ul><li>使用栈</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Object&gt; sk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        sk.push(root);</span><br><span class="line">        sk.push(root.val + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(!sk.isEmpty())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> (String)sk.pop();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> (TreeNode)sk.pop();</span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                res.add(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                sk.push(node.left);</span><br><span class="line">                sk.push(path + <span class="string">&quot;-&gt;&quot;</span> + node.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                sk.push(node.right);</span><br><span class="line">                sk.push(path + <span class="string">&quot;-&gt;&quot;</span> + node.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把已经拼接到路径和遍历到的当前节点放到一个栈中，注意要同时放入和取出，放入栈的路径便于返回，放入栈的节点为判断该节点是否为叶子节点，如果是叶子节点直接把路径放到集合即可，如果不是先给路径拼接好其左右节点的值，然后连同节点放入到栈中，这样做比较简单好理解，但是时间复杂度较高，还可以使用递归+回溯的方法，但是还没有悟道，等想明白了再补充</p><h3 id="左叶子节点之和"><a href="#左叶子节点之和" class="headerlink" title="左叶子节点之和"></a>左叶子节点之和</h3><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftSum(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leftSum</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> leftSum(node.left);</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span> &amp;&amp; node.left.left == <span class="literal">null</span> &amp;&amp; node.left.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            leftNum = node.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightNum</span> <span class="operator">=</span> leftSum(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> rightNum + leftNum;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意左叶子节点的定义，首先他得是一个叶子节点，其次他是父节点的左孩子。而<strong>不是计算所有的左孩子之和</strong>，然后从跟节点开始递归，遇到空节点返回0，**遇到左右孩子都为空的节点也返回0(因为这样的节点一定是叶子节点，但是现在不确定是不是左叶子节点，所以没有必要向下递归了)**，然后在下面进行判断如果当前节点的左孩子的左右孩子都是空那么记录这个数值即可</p><h3 id="树左下角的值"><a href="#树左下角的值" class="headerlink" title="树左下角的值"></a>树左下角的值</h3><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值 - 力扣（LeetCode）</a></p><ul><li>层序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        d.addLast(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!d.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> d.size();</span><br><span class="line">            res = d.peekFirst().val;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> d.pollFirst();</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历每一层之前，把该层的第一个节点的值保存起来，这一定是该层最左边的值</p><ul><li>递归</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> max,res;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        findBottom(root,<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findBottom</span><span class="params">(TreeNode node,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(depth &gt; max)&#123;</span><br><span class="line">            max = depth;</span><br><span class="line">            res = node.val;</span><br><span class="line">        &#125;</span><br><span class="line">        findBottom(node.left,depth + <span class="number">1</span>);</span><br><span class="line">        findBottom(node.right,depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化最大深度为0，然后递归的时候传两个参数，一个是节点一个是当前节点所在的高度，每次向下一层遍历的时候高度要加一，因为不管是前&#x2F;中&#x2F;后序遍历都是左在前，右在后，所以每次修改最大深度max这个参数的都是每层的最左节点，所以此时可以一同修改res的值为该节点的val值</p><h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h3><p><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hasPath(root,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPath</span><span class="params">(TreeNode node,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span>&amp;&amp;node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node.val == target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">leftPath</span> <span class="operator">=</span> hasPath(node.left,target - node.val);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rightPath</span> <span class="operator">=</span> hasPath(node.right,target - node.val);</span><br><span class="line">        <span class="keyword">return</span> leftPath || rightPath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次传入的是根节点和目标值，每次递归传入的是下一个节点和目标值减去当前节点的值，这样在遇到叶子节点时候，可以根据叶子节点值是否等于目标值来判断该路径是否符合要求</p><h3 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h3><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a></p><ul><li>直接构造截开的数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> postorder.length;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">        root.val = postorder[postorder.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="keyword">for</span>(index = <span class="number">0</span>;index &lt; size;index++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[index] == postorder[postorder.length - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] inLeft = <span class="keyword">new</span> <span class="title class_">int</span>[index];</span><br><span class="line">        <span class="type">int</span>[] inRight = <span class="keyword">new</span> <span class="title class_">int</span>[inorder.length - <span class="number">1</span> -index];</span><br><span class="line">        <span class="type">int</span>[] postLeft = <span class="keyword">new</span> <span class="title class_">int</span>[index];</span><br><span class="line">        <span class="type">int</span>[] postRight = <span class="keyword">new</span> <span class="title class_">int</span>[inorder.length - <span class="number">1</span> -index];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; inLeft.length;i++)&#123;</span><br><span class="line">            inLeft[i] = inorder[i];</span><br><span class="line">            postLeft[i] = postorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; inRight.length;i++)&#123;</span><br><span class="line">            inRight[i] = inorder[index + i + <span class="number">1</span>];</span><br><span class="line">            postRight[i] = postorder[inLeft.length + i];</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = buildTree(inLeft,postLeft);</span><br><span class="line">        root.right = buildTree(inRight,postRight);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题思路很简单，但是边界的处理很麻烦，一定注意边界使用的是左闭右开还是左闭右闭，核心思路是通过后序的数组的最后一个元素创建出根节点，然后拿到这个元素在中序遍历的数组中把中序的数组截开，截开后前半部分就是左树的长度，根据这个长度可以在后序的数组中拿到后序的截开后的数组，然后分别剩下的就是中后序遍历的右树的数组</p><ul><li>递归法(思路和上面完全一样)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map;  <span class="comment">// 方便根据数值查找位置</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123; <span class="comment">// 用map保存中序序列的数值对应位置</span></span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> findNode(inorder,  <span class="number">0</span>, inorder.length, postorder,<span class="number">0</span>, postorder.length);  <span class="comment">// 前闭后开</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">findNode</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> inBegin, <span class="type">int</span> inEnd, <span class="type">int</span>[] postorder, <span class="type">int</span> postBegin, <span class="type">int</span> postEnd)</span> &#123;</span><br><span class="line">        <span class="comment">// 参数里的范围都是前闭后开</span></span><br><span class="line">        <span class="keyword">if</span> (inBegin &gt;= inEnd || postBegin &gt;= postEnd) &#123;  <span class="comment">// 不满足左闭右开，说明没有元素，返回空树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> map.get(postorder[postEnd - <span class="number">1</span>]);  <span class="comment">// 找到后序遍历的最后一个元素在中序遍历中的位置</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(inorder[rootIndex]);  <span class="comment">// 构造结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lenOfLeft</span> <span class="operator">=</span> rootIndex - inBegin;  <span class="comment">// 保存中序左子树个数，用来确定后序数列的个数</span></span><br><span class="line">        root.left = findNode(inorder, inBegin, rootIndex,</span><br><span class="line">                            postorder, postBegin, postBegin + lenOfLeft);</span><br><span class="line">        root.right = findNode(inorder, rootIndex + <span class="number">1</span>, inEnd,</span><br><span class="line">                            postorder, postBegin + lenOfLeft, postEnd - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序和中序构造二叉树"><a href="#前序和中序构造二叉树" class="headerlink" title="前序和中序构造二叉树"></a>前序和中序构造二叉树</h3><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; inorder.length;i++)&#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(inorder,<span class="number">0</span>,inorder.length,preorder,<span class="number">0</span>,preorder.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] inorder,<span class="type">int</span> inBegin,<span class="type">int</span> inEnd,<span class="type">int</span>[] preorder,<span class="type">int</span> preBegin,<span class="type">int</span> preEnd)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inBegin &gt;= inEnd || preBegin &gt;= preEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(preorder[preBegin]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index - inBegin;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(inorder[index]);</span><br><span class="line">        root.left = build(inorder,inBegin,index,preorder,preBegin + <span class="number">1</span>,preBegin + <span class="number">1</span> + leftSize);</span><br><span class="line">        root.right = build(inorder,index + <span class="number">1</span>,inEnd,preorder,preBegin + <span class="number">1</span> + leftSize,preEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上一道题思路一模一样，只不过这次从前序数组中的第一个元素在中序数组来截开</p><p>详细分析一下构造二叉树的传参(左闭右开)</p><ul><li>构造左子树的时候：需要前序和中序的左部分<ul><li>中序的左部分<ul><li>开始：其实就是inorder的第一个元素，因为左中右的顺序每次截开后，第一个元素一定是截开后要的左部分的第一个</li><li>结束：直接就是截开位置的索引，因为左中右和左闭右开</li></ul></li><li>前序的左部分<ul><li>开始：每一次都是在上一次开始的基础上加一，因为中左右，每次舍弃掉中也就是第一个即可</li><li>结束：先找到<strong>本次</strong>前序的左部分开始位置的索引，在这个索引的基础上加上左部分的长度</li></ul></li></ul></li><li>构造右子树的时候：需要前序和中序的右部分<ul><li>中序的右部分<ul><li>开始：直接就是截开的索引位置加一</li><li>结束：就是每一次传入的inEnd，这个值其实和中序左部分开始一样是不变的</li></ul></li><li><strong>前序的右部分(这部分最关键，最容易弄错导致数组越界)</strong><ul><li>开始：在<strong>本次</strong>左部分开始位置的索引加上左部分的长度</li><li>就是每一次传入的preEnd</li></ul></li></ul></li></ul><p><strong>防错技巧：记住前序遍历的左部分的结尾就是右部分的开始索引，还是因为左闭右开</strong></p><h3 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h3><p><a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> constructMaximumBinaryTree1(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree1</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> leftIndex, <span class="type">int</span> rightIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rightIndex - leftIndex &lt; <span class="number">1</span>) &#123;<span class="comment">// 没有元素了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightIndex - leftIndex == <span class="number">1</span>) &#123;<span class="comment">// 只有一个元素</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[leftIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> leftIndex;<span class="comment">// 最大值所在位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxVal</span> <span class="operator">=</span> nums[maxIndex];<span class="comment">// 最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> leftIndex + <span class="number">1</span>; i &lt; rightIndex; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; maxVal)&#123;</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxVal);</span><br><span class="line">        <span class="comment">// 根据maxIndex划分左右子树</span></span><br><span class="line">        root.left = constructMaximumBinaryTree1(nums, leftIndex, maxIndex);</span><br><span class="line">        root.right = constructMaximumBinaryTree1(nums, maxIndex + <span class="number">1</span>, rightIndex);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造思路和上两题差不多，都是通过切割数组，注意好传参的边界，提前想好左闭右开还是左闭右闭，不用上两题的map结构，而是递归找最大值和索引的方式可以减少用时</p><h3 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h3><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span> &amp;&amp; root2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1 != <span class="literal">null</span> &amp;&amp; root2 ==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        root1.val += root2.val;</span><br><span class="line">        root1.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">        root1.right = mergeTrees(root1.right,root2.right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时操作两个二叉树，但是不难，如果递归到的两个节点都是null那么向上返回null，两个节点都有值返回相加值很好理解，主要是想明白如果一个为空另一个不为空的时候要直接返回那一个不为null的节点即可</p><h3 id="二叉搜索树搜索"><a href="#二叉搜索树搜索" class="headerlink" title="二叉搜索树搜索"></a>二叉搜索树搜索</h3><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索 - 力扣（LeetCode）</a></p><ul><li>直接递归找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> searchBST(root.left,val);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> searchBST(root.right,val);</span><br><span class="line">        <span class="keyword">if</span>(leftNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用二叉搜索树(左节点小于根节点，右节点大于根节点)的特性找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root.val)&#123;</span><br><span class="line">            res = searchBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root.val)&#123;</span><br><span class="line">            res = searchBST(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用迭代法找，还是根据二叉搜索树的特性，可以根据要得到的val的值的大小，来确定要递归的方向</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val &lt; root.val)&#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &gt; root.val)&#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证是否为二叉搜索树"><a href="#验证是否为二叉搜索树" class="headerlink" title="验证是否为二叉搜索树"></a>验证是否为二叉搜索树</h3><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树 - 力扣（LeetCode）</a></p><ul><li>中序递归遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">leftValid</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; pre.val &gt;= root.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rigthValid</span> <span class="operator">=</span> isValidBST(root.right);</span><br><span class="line">        <span class="keyword">return</span> leftValid &amp;&amp; rigthValid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是死死抓住二叉搜索树的特性进行求解，如果一个二叉树是二叉搜索树那么这个树的中序遍历一定是一个递增的数列，所以这道题直接使用二叉树的中序遍历，比较当前节点的值是否比上一个大即可，注意遍历到空节点的时候直接返回的是true而不是false，这里可以想一个极端的情况，比如这个树的跟节点就是空，那么这个树一定是个二叉搜索树</p><ul><li>中序迭代遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; sk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span> || !sk.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">                sk.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> sk.pop();</span><br><span class="line">            <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; pre.val &gt;= tmp.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = tmp;</span><br><span class="line">            root = tmp.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树最小差值"><a href="#二叉搜索树最小差值" class="headerlink" title="二叉搜索树最小差值"></a>二叉搜索树最小差值</h3><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        getMinimum(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMinimum</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getMinimum(cur.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span>)&#123;</span><br><span class="line">            res = Math.min(res,cur.val - pre.val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        getMinimum(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是利用二叉搜索树的中序遍历的特性，此时最小的插值一定出现在遍历后数组的相邻两个元素中，和上一题的递归法思路很像，仍然使用双指针操作一棵二叉树，每次比较之后把pre指针指向当前节点</p><h3 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h3><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. Find Mode in Binary Search Tree - 力扣（LeetCode）</a></p><ul><li>暴力</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        find(root,map);</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Integer key : map.keySet())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            <span class="keyword">if</span>(tmp == max)&#123;</span><br><span class="line">                list.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(TreeNode root,Map&lt;Integer,Integer&gt; map)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(root.val,map.getOrDefault(root.val,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(map.get(root.val) &gt; max)&#123;</span><br><span class="line">            max = map.get(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        find(root.left,map);</span><br><span class="line">        find(root.right,map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力法，第一遍使用任何一种遍历顺序，把二叉树中的所有元素进行一个统计，以二叉树的值为key，出现的次数作为value放到一个map中，同时不断地更新出现最大次数的值，第二次遍历这个map，如果map的value为最大出现的频率，那么直接放到结果集中</p><ul><li>双指针法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    TreeNode pre ;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        find(root);</span><br><span class="line">        <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        find(cur.left);</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="literal">null</span>)&#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pre.val == cur.val)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="keyword">if</span>(count == max)&#123;</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; max)&#123;</span><br><span class="line">            max = count;</span><br><span class="line">            list.clear();</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">        &#125;</span><br><span class="line">        find(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一些代码技巧可以只遍历一次，此时要维护两个变量，第一个max表示最大出现的频率，第二个count表示当前节点的值出现的频率，同时这种方法必须使用中序遍历，因为只有中序遍历后的顺序才能保证这个二叉树非递减排列，双指针计数的过程是如果pre节点为空，那么说明此时的cur节点指向了叶子节点此时count为1，如果cur和pre相同说明这个值的频率不为1，所以count要加一，如果pre和cur不相等了说明这个数统计完了，此时要统计新的数，把count重新初始为1，放入结果集的时候很有意思，刚放入的时候先不管这个最大频率是不是真正的最大频率，只要出现的频率等于这个最大频率那么就先放入结果集中，然后如果遇到了更大的频率那么把原先的结果集清空，然后修改最大频率，然后将此时的值放到结果集中</p><h3 id="二叉树最近公共祖先"><a href="#二叉树最近公共祖先" class="headerlink" title="二叉树最近公共祖先"></a>二叉树最近公共祖先</h3><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(leftNode != <span class="literal">null</span> &amp;&amp; rightNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(leftNode == <span class="literal">null</span> &amp;&amp; rightNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(leftNode != <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公共祖先一定是要从底向上遍历寻找，所以优先会考虑使用后序遍历，即先看左右孩子的情况再决改向上一层返回什么，核心思路就是碰到了p或q节点直接向上返回，如果一个节点的左右孩子都不是空那么这个节点一定就是想要的公共节点，如果只有一个节点不为空那么直接向上返回不为空的节点，这样处理的话可以考虑到所有情况</p><ol><li>第一种情况：公共节点不是pq本身，再结合题目所说二叉树中一定包含pq节点，这样一定会在</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(leftNode != <span class="literal">null</span> &amp;&amp; rightNode != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个条件中找到想要的公共祖先</p><ol start="2"><li>第二种情况：公共节点是pq本身，那么此时一定会在</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root == p || root == q)&#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个节点找到想要的公共节点，这时哪怕p或q有一个没遍历到也没有关系，因为公共节点已经找到了</p><h3 id="二叉搜索树最近公共祖先"><a href="#二叉搜索树最近公共祖先" class="headerlink" title="二叉搜索树最近公共祖先"></a>二叉搜索树最近公共祖先</h3><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）</a></p><ul><li>递归法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这道题使用上一题的代码完全没有问题，因为二叉搜索树也是二叉树，自底向上递归一定找到最近的公共节点，但是可以狠狠利用二叉搜索树的特性来提升代码的执行效率，再强调一遍什么时二叉搜索树，即根节点的<strong>所有</strong>子节点都比根节点的值要小，跟节点的<strong>所有</strong>右节点都比根节点的值要大，所以当pq的值都比根节点小的时候，此时一定只需要向左递归即可，当pq的值都比根节点的值要大的时候，此时一定只需要向右递归，<strong>当根节点的值处于pq的中间时，此时这个节点就是最大公共节点，因为此时不管是向左遍历还是向右遍历一定会错过pq其中一个节点</strong></p><h3 id="插入二叉搜索树"><a href="#插入二叉搜索树" class="headerlink" title="插入二叉搜索树"></a>插入二叉搜索树</h3><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. Insert into a Binary Search Tree - 力扣（LeetCode）</a></p><ul><li>递归法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题很简单，但是题目的描述很具与迷惑性，他说答案不一定唯一，比如要插入的值可能在叶子节点也可能在根节点，<strong>但是要想明白所有的二叉搜索树再插入一个不同的元素的时候一定可以找到一个叶子节点来插入的</strong>，所以只需要考虑如何找到这个叶子节点即可</p><ul><li>迭代法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">index</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur = root;</span><br><span class="line">            <span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(cur.val &lt; val)&#123;</span><br><span class="line">            cur.right = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.val &gt; val)&#123;</span><br><span class="line">            cur.left = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代法这个地方有个小坑，就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">    root = root.left;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">    root = root.right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方要写成if(){}else if(){}的形式,不能写成两个if，因为第一种形式表示如果第一个条件成立了，那么执行第一个if中的逻辑，同时不会判断第二个else if中的条件更不会执行其中的逻辑，如果是第二种形式会进行第二个if条件的判断，此时如果已经执行完了第一个if中的逻辑可能会发生空指针异常</p><h3 id="有序数组转为二叉搜索树"><a href="#有序数组转为二叉搜索树" class="headerlink" title="有序数组转为二叉搜索树"></a>有序数组转为二叉搜索树</h3><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左闭右开版</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin &gt;= end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(end - begin == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[begin]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (begin + end)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = sortedArrayToBST(nums,begin,mid);</span><br><span class="line">        root.right = sortedArrayToBST(nums,mid + <span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左闭右闭版</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(end == begin)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[begin]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (begin + end)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = sortedArrayToBST(nums,begin,mid - <span class="number">1</span>);</span><br><span class="line">        root.right = sortedArrayToBST(nums,mid + <span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和前面根据中序遍历和后序遍历构造二叉树思路相似，有序数组可以看成二叉搜索树的中序遍历，然后根据题目要求要左右的高度差不超过1，所以可以使用每次传递数组的中间的数值作为根节点，仍然要注意左闭右开和左闭右闭的问题</p><h3 id="二叉搜索树转累加树"><a href="#二叉搜索树转累加树" class="headerlink" title="二叉搜索树转累加树"></a>二叉搜索树转累加树</h3><p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        convert(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        convert(node.right);</span><br><span class="line">        node.val += pre;</span><br><span class="line">        pre = node.val;</span><br><span class="line">        convert(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题最难的是读题，他的意思是要先找到二叉搜索树中最大的节点的值，然后以此节点为基础不断向前累加，因为是一个二叉搜索树，所以遍历的顺序是右中左，使用双指针的思路不断累加即可</p><h3 id="删除二叉搜索树节点"><a href="#删除二叉搜索树节点" class="headerlink" title="删除二叉搜索树节点"></a>删除二叉搜索树节点</h3><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. Delete Node in a BST - 力扣（LeetCode）</a></p><ul><li>暴力删除，先把二叉树中序遍历，得到一个数组，在数组中删除目标节点，然后根据数组构造树二叉搜索树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        getArray(root);</span><br><span class="line">        <span class="keyword">if</span>(list.contains(key))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> list.indexOf(key);</span><br><span class="line">            list.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size();i ++)&#123;</span><br><span class="line">            arr[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> combine(arr,<span class="number">0</span>,arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getArray</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getArray(node.left);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        getArray(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">combine</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin &gt;= end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(end - begin == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(arr[begin]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (begin + end)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(arr[mid]);</span><br><span class="line">        root.left = combine(arr,begin,mid);</span><br><span class="line">        root.right = combine(arr,mid + <span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>递归法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right;</span><br><span class="line">                <span class="keyword">while</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                cur.left = root.left;</span><br><span class="line">                root = root.right;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; key)</span><br><span class="line">            root.left = deleteNode(root.left,key);</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; key)</span><br><span class="line">            root.right = deleteNode(root.right,key);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分五种情况考虑</p><ol><li><p>没有找到要删除的节点</p></li><li><p>要删除的节点左右子树都为空，即根节点不用调整二叉树结构</p></li><li><p>要删除的节点左不为空右为空，直接将该节点的父亲的左子树指向该节点的左子树</p></li><li><p>要删除的节点右不为空左为空，直接将该节点的父亲的右子树指向该节点的右子树</p></li><li><p>要删除的节点左右节点全不为空，可以将该节点的任意左右子节点替换该节点，同时调整二叉树结构，<br>例如：当把右孩子替换该节点的时候可以把左子树放到比要替换的节点大一位的节点的左侧 (即左下角)</p><p>​当把左孩子替换该节点的时候可以把右子树放到比要替换节点为跟的树的最大的位置(即右下角)</p></li></ol><h3 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h3><p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; low)&#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; high)&#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = trimBST(root.left,low,high);</span><br><span class="line">        root.right = trimBST(root.right,low,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>牢记三句话：<ul><li>当前节点的值小于目标范围的时候，只需要处理该节点的右孩子</li><li>当前节点的值大于目标范围的时候，只需要处理该节点的左孩子</li><li>当前节点符合要求范围的时候，直接处理其左右孩子</li></ul></li></ul><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p><a href="https://leetcode.cn/problems/combinations/">77. 组合 - 力扣（LeetCode）</a></p><ul><li>基础版</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        traceBack(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traceBack</span><span class="params">(<span class="type">int</span> length,<span class="type">int</span> size,<span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == size) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= length; i++) &#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            traceBack(length, size, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231023125112589.png" class title="image-20231023125112589"><p>通过递归函数的传参，来确定每一次遍历的次数，每次递归开始的值比上一次大一，因为上一次已经取走一个数了，当path的路径和要求一致的时候，就可以往结果集中放了，然后弹出最后一个元素，这就是回溯的过程，因为如果不弹出的话就会一直往一个集合中放入元素，导致超出要求范围</p><ul><li>剪枝版</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        traceBack(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traceBack</span><span class="params">(<span class="type">int</span> length,<span class="type">int</span> size,<span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == size)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt;= length - (size - path.size()) + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            traceBack(length,size,i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为什么需要剪枝？因为回溯是一个纯暴力的搜索的方式，如果不加以控制那么他会遍历整个树形结构，即便某些情况下条件一定不会成立，但是他还是会进行遍历，例如，当n&#x3D;4，k&#x3D;3的情况，当startIndex&gt;2的时候是没必要遍历的，因为3或者4开头凑不够要求的3个大小</p><p>剪枝操作往往是在每次递归后的for循环条件中做文章</p><p>本题的剪枝是n-(k - path.size())+1,(k - path.size())这部分是为算出还需要往path集合中放入多少元素，n-(k - path.size())+1就可以算出本次循环最多可以从哪个位置开始，+1是因为剪完之后的长度的后一个元素是符合条件的，例如n&#x3D;5，k&#x3D;3，size&#x3D;1，这样k - path.size()的值是2，说明此时path集合还需要两个元素，然后通过n-2+1&#x3D;4，说明4是至多开始的位置</p><h3 id="组合总和Ⅲ"><a href="#组合总和Ⅲ" class="headerlink" title="组合总和Ⅲ"></a>组合总和Ⅲ</h3><p><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        build(k,n,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum == n &amp;&amp; path.size() == k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt;= <span class="number">9</span> - (k - path.size()) + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            build(k,n,i + <span class="number">1</span>,sum);</span><br><span class="line">            sum -= i;</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和组合问题很像，组合问题只需要考虑收集的集合中元素个数，来作为递归终止的条件，但是这道题在组合的基础上加了一个集合内元素之和大小的限制，相当于加了一个递归终止的条件，然后也多了一个剪枝的可能性，即当组合中的和已经大于了目标值即使元素个数还没有达到要求这时也没必要向下递归了</p><h3 id="电话号码字母组合"><a href="#电话号码字母组合" class="headerlink" title="电话号码字母组合"></a>电话号码字母组合</h3><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String[] numString = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        backTracking(digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String digits,<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">            list.add(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> numString[digits.charAt(index) - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            path += String.valueOf(str.charAt(i));</span><br><span class="line">            backTracking(digits, index + <span class="number">1</span>);</span><br><span class="line">            path = path.substring(<span class="number">0</span>,path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是要把字符串的每个数字想象成一个树形结构，字符串的长度是要递归的深度，字符串的每一个数字对应的字符串长度代表每次循环的次数，首先要把每个数字对应的字符串保存到一个一维数组中，其中0和1这两个用空串表示，之所以这次递归使用的是index来表示接下来要遍历的数字而不是startIndex，是因为之前的题目实在同一个集合上进行的组合操作，而这道题是不同集合的组合操作，所以只需要保留要遍历字符串的索引即可，而每当递归到一个新的集合时候一定是从头遍历到尾</p><h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h3><p><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        combination(candidates,target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">combination</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target,<span class="type">int</span> index,<span class="type">int</span> sum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; candidates.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum + candidates[i] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            combination(candidates,target,i,sum);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题比较关键的地方在于数组中的数字可以重复使用，所以每次循环的开始和上一次递归的开始是一样的，这个题比较难想的地方在于如何剪枝，要想到对这个数组进行排序，然后在收集的过程中，如果收集的内容已经超过目标值了，这是就不需要接下来的递归了</p><h3 id="组合总和Ⅱ"><a href="#组合总和Ⅱ" class="headerlink" title="组合总和Ⅱ"></a>组合总和Ⅱ</h3><p><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">  <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">( <span class="type">int</span>[] candidates, <span class="type">int</span> target )</span> &#123;</span><br><span class="line">    <span class="comment">//为了将重复的数字都放到一起，所以先进行排序</span></span><br><span class="line">    Arrays.sort( candidates );</span><br><span class="line">    backTracking( candidates, target, <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">( <span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> start )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( sum == target ) &#123;</span><br><span class="line">      res.add( <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;( path ) );</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++ ) &#123;</span><br><span class="line">      <span class="comment">//正确剔除重复解的办法</span></span><br><span class="line">      <span class="comment">//跳过同一树层使用过的元素</span></span><br><span class="line">      <span class="keyword">if</span> ( i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] ) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      sum += candidates[i];</span><br><span class="line">      path.add( candidates[i] );</span><br><span class="line">      <span class="comment">// i+1 代表当前组内元素只选取一次</span></span><br><span class="line">      backTracking( candidates, target, i + <span class="number">1</span> );</span><br><span class="line">      sum -= candidates[i];</span><br><span class="line">      path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的难点在于给的数组元素含有重复元素，例如[10,1,2,7,6,1,5]，当target&#x3D;8的时候[1,7]这个结果可能会出现两次，所以需要进行去重操作，去重的时候要先对数组进行排序，[1,1,2,5,6,7,10]对于同一条路径不需要去重，因为两个1可以出现在结果中，当不是同一条路径的时候，比如把第一个1放到路径中然后递归完后面的所有元素，当要放第二个1到路径中的时候就需要去重，因为此时以1开头的结果在第一个1的时候已经收集完了，所以也就是candidates[i] &#x3D;&#x3D; candidates[i - 1]的时候，直接进入下一层循环即可</p><h3 id="分割回文子串"><a href="#分割回文子串" class="headerlink" title="分割回文子串"></a>分割回文子串</h3><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        part(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">part</span><span class="params">(String s,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= s.length())&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i  &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(decide(s,index,i))&#123;</span><br><span class="line">                path.add(s.substring(index,i + <span class="number">1</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            part(s,i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">decide</span><span class="params">(String s,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) != s.charAt(right))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的难点在于一定要想清楚这个切割过程的树形结构</p><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231029222404968.png" class title="image-20231029222404968"><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231029222511499.png" class title="image-20231029222511499"><p>例如这种位置，先判断是不是回文串，再放入到path中，判断的方法是固定index不动，改变i的值来确定要切割的长度，如果当前切割出来字符串不符合要求则直接continue，然后注意substring这个方法切割的时候是左闭右开的</p><h3 id="修复IP地址"><a href="#修复IP地址" class="headerlink" title="修复IP地址"></a>修复IP地址</h3><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">        backTracking(sb, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(StringBuilder s, <span class="type">int</span> startIndex, <span class="type">int</span> dotCount)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dotCount == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(s,startIndex,s.length() - <span class="number">1</span>))&#123;</span><br><span class="line">                result.add(s.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(s,startIndex,i))&#123;</span><br><span class="line">                s.insert(i + <span class="number">1</span>,<span class="string">&quot;.&quot;</span>);</span><br><span class="line">                backTracking(s,i + <span class="number">2</span>,dotCount + <span class="number">1</span>);</span><br><span class="line">                s.deleteCharAt(i + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//[start, end]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(StringBuilder s, <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(start) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i &lt;= end;i++)&#123;</span><br><span class="line">            num = num * <span class="number">10</span> + s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; <span class="number">255</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的关键在于，维护一个dotCount变量来记录当前IP地址已经被我们加了多少个”.”,当”.”的个数到了三个的时候，就达到了IP地址的标准，所以此时只需要验证最后一个点后面的部分是否合格即可，还有一个注意点是在进入下一次递归的时候，startIndex是2，因为已经加了一个”.”了</p><p>还有一个注意点就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(num &gt; <span class="number">255</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个判断一定要放在for循环中，因为字符串可能特别长导致超出Integer的最大值</p><h3 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h3><p><a href="https://leetcode.cn/problems/subsets/">78. 子集 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        backtracking(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= nums.length)&#123;<span class="comment">//相当于一个剪枝，可以不写</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; nums.length;i++)&#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtracking(nums,i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们每次递归往结果加入的path集合都是不一样的，而且这些集合一定都是原数组的子集，所以一上来不用判定任何条件直接加入到res集合中即可，</p><h3 id="子集问题Ⅱ"><a href="#子集问题Ⅱ" class="headerlink" title="子集问题Ⅱ"></a>子集问题Ⅱ</h3><p><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtracting(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracting</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= nums.length)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; index &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                backtracting(nums,i + <span class="number">1</span>);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和组合总和Ⅱ的去重思路相同，每次循环的时候，如果不是第一次往里面放元素，那么就要先检查要放入的元素和上一次放入的是不是相同即可，别忘了对数组进行排序</p><h3 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h3><p><a href="https://leetcode.cn/problems/non-decreasing-subsequences/">491. 递增子序列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        find(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!path.isEmpty() &amp;&amp; path.get(path.size() - <span class="number">1</span>) &gt; nums[i] || set.contains(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            find(nums,i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这个题一定不能对数组进行排列，因为排序以后他的子序列就变了</p><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231103212851949.png" class title="image-20231103212851949"><p>同一层的节点不能取相同的值，而同一个数枝上的数可以取相同的，例如[4,7,6,7,8,9]这个数组，同一个树枝指的是每次递归，所以[4，7，7]是可以作为递增子序列的，而同一层节点的时候，如果取了第一个7，那么7后面的所以可能都被第一个7尝试过了，所以同层时候不能取相同数值，即这种地方</p><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231103213600993.png" class title="image-20231103213600993"><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231103213624668.png" class title="image-20231103213624668"><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p><a href="https://leetcode.cn/problems/permutations/">46. 全排列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        find(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(path.contains(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                find(nums);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保证每次递归时候循环都是从零开始遍历的，然后每次向path集合中添加元素的时候，判断是否存在即可，因为原始数组是不重复的</p><h3 id="全排列Ⅱ"><a href="#全排列Ⅱ" class="headerlink" title="全排列Ⅱ"></a>全排列Ⅱ</h3><p><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        Arrays.fill(used,<span class="literal">false</span>);</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrack(nums,used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">boolean</span>[] used)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>&amp;&amp;nums[i] == nums[i - <span class="number">1</span>]&amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="literal">false</span>)&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                backtrack(nums,used);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题首先要明白为什么会出现重复，才能理解应该在什么地方剪枝，例如[1,1,2]，当选完第一个1的时候得到两个结果[1,1,2]和[1,2,1]的时候，回溯以后要选第二个1，此时会出现重复所以要剪枝，也就是说不同深度的元素可以重复，同一层级的元素不可以重复</p><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231105160110922.png" class title="image-20231105160110922"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span>&amp;&amp;nums[i] == nums[i - <span class="number">1</span>]&amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>)&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个判断条件的前两个就是看看要添加的元素和前一个是否相同，第三个判断条件就是看看是不是在同一层，如果是同一层要加入元素的前一个元素对应的使用情况应该是false，因为他刚刚被回溯撤销</p><h3 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h3><p><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[][] checkerboard = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] ch : checkerboard)&#123;</span><br><span class="line">            Arrays.fill(ch,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(<span class="number">0</span>,n,checkerboard);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> n,<span class="type">char</span>[][] checkerboard)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == row)&#123;</span><br><span class="line">            res.add(array2List(checkerboard));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>;col &lt; n;col++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isValid(row,col,n,checkerboard))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            checkerboard[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            backtrack(row + <span class="number">1</span>,n,checkerboard);</span><br><span class="line">            checkerboard[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">array2List</span><span class="params">(<span class="type">char</span>[][] checkerboard)</span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] ch : checkerboard)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">String</span>(ch));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col,<span class="type">int</span> n,<span class="type">char</span>[][] checkerboard)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; row;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(checkerboard[i][col] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span> , j = col - <span class="number">1</span>;i &gt;= <span class="number">0</span>&amp;&amp;j &gt;= <span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(checkerboard[i][j] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>,j = col + <span class="number">1</span>;i &gt;= <span class="number">0</span>&amp;&amp;j &lt;= n - <span class="number">1</span>;i--,j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(checkerboard[i][j] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>维护了一个char类型的二维数组来模拟一个棋盘，初始的时候棋盘里面元素都为’.’，然后进行循环判断，如果当前该位置合法，那么就把当前元素改为’Q’,然后再次递归，每次递归表示要处理的是下一行，所以传参的时候row要加一，for循环表示判断该行的每一个位置是否合法，然后是如何判断是否合法，根据当前遍历到的行和列为基准，进行三次判断分别是 1.该位置的这一列是否包含’Q’,2.该位置45°左上角是否包含’Q’，3.该位置45°右上角是否包含’Q’，如果全不包含那么这就是一个合法的位置</p><h3 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h3><p><a href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        backtrack(board);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; <span class="number">9</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">char</span> <span class="variable">num</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;num &lt;= <span class="string">&#x27;9&#x27;</span>;num++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(isValid(i,j,num,board))&#123;</span><br><span class="line">                            board[i][j] = num;</span><br><span class="line">                            <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> backtrack(board);</span><br><span class="line">                            <span class="keyword">if</span>(res)&#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col,<span class="type">char</span> num,<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] == num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[row][i] == num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startRow</span> <span class="operator">=</span> (row / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startCol</span> <span class="operator">=</span> (col / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startRow;i &lt; startRow + <span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> startCol;j &lt; startCol + <span class="number">3</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == num)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维递归，这道题和N皇后的区别在于，这道题的棋盘上的每一个位置都要填数，所以每一个位置都要遍历到，所以使用双重for循环来定位每一个位置，然后通过该位置是否是’.’来决定要不要处理，如果是’.’那么就需要对该位置进行处理，遍历1-9这九个数然后判断是否符合数独的条件，在判断行和列的时候很简单只需要遍历，看是否重复即可，然后每一个九宫格的话是先进行除3的操作，然后再乘以3可以定位到九宫格开始的位置，比如遍历到的列是第5列，（5&#x2F;3）&#x3D; 1 ，1*3&#x3D;3，3正好是5这一列开始判断合法的列，关于本题的剪枝操作是通过返回一个boolean类型的变量来剪枝的，当1-9这九个数字全部遍历完成后都不能满足要求那么，说明以前的插入就有问题了无需向下遍历，直接进行回溯，当所有的位置都不是’.’的时候说明找到了一个结果，这时直接返回true即可</p><h3 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h3><p><a href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> g.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(index &gt;= <span class="number">0</span>&amp;&amp;s[index] &gt;= g[i])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让更多的孩子吃到饼干，所以让大的饼干尽量给胃口大孩子吃，先对数组排序，饼干和胃口都是从大到小遍历，保证饼干不动胃口向前遍历，直接第一个满足饼干的胃口，这时就找到了这个饼干能满足的最大的胃，然后饼干再向前遍历</p><h3 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h3><p><a href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prediff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curdiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            curdiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="keyword">if</span>((prediff &gt;= <span class="number">0</span>&amp;&amp;curdiff &lt; <span class="number">0</span>)||(prediff &lt;= <span class="number">0</span>&amp;&amp;curdiff &gt; <span class="number">0</span>))&#123;</span><br><span class="line">                count++;</span><br><span class="line">                prediff = curdiff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求摆动序列的最大长度，其实并不需要把不符合的数组元素进行删除，只需要在出现波峰波谷的位置给计数器加一即可。</p><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231111115016474.png" class title="image-20231111115016474"><p>然后会出现三种情况：</p><ol><li>摆动中有平坡</li></ol><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231111115539808.png" class title="image-20231111115539808"><p>这时有两种方法，第一种就是从左向右删除二直到只剩一个二，第二种就是从右向左删除二直到只剩一个二，由于数组是从左向右遍历的，所以这里选择保留最后一个二，体现在代码中就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((prediff &gt;= <span class="number">0</span>&amp;&amp;curdiff &lt; <span class="number">0</span>)||(prediff &lt;= <span class="number">0</span>&amp;&amp;curdiff &gt; <span class="number">0</span>))<span class="comment">//左边是平坡，右边不是的时候，这时需要记录</span></span><br></pre></td></tr></table></figure><ol start="2"><li>波峰&#x2F;波谷出现在数组首尾</li></ol><p>这里的处理方式是默认尾部就是一个峰&#x2F;谷，所以计数器从一开始计数，然后对于第一个元素的判断可以看成第一个元素前面还有一个和第一个元素相同的虚拟值，例如[1,2]是两个，这时想象成[1,1,2]经过代码的判断还是两个</p><ol start="3"><li>单调坡中有平坡</li></ol><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231111120405222.png" class title="image-20231111120405222"><p>这里的处理方式是，不用每次遍历都更新prediff的值，由于平坡的存在导致不知道是摆动还是持续上升，所以只有当出现要记录的时候才更新prediff</p><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h3><p><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; max)&#123;</span><br><span class="line">                max = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思想是，进行求和运算的时候，实时记录最大值的大小，同时当某一个子序列的总和小于零的时候，让下一个元素成为新序列的头节点，因为总和小于零对于后面的元素来说一定是累赘</p><h3 id="买卖股票的最佳时机Ⅱ"><a href="#买卖股票的最佳时机Ⅱ" class="headerlink" title="买卖股票的最佳时机Ⅱ"></a>买卖股票的最佳时机Ⅱ</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++)&#123;</span><br><span class="line">            res += Math.max(prices[i] - prices[i - <span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常思路是在最低点的时候买股票，最高点的时候卖股票，比如prices[2] - prices[0]就是第三天的时候卖，第一天的时候买，这个式子可以拆成prices[2] - prices[1] + prices[1] - prices[0],也就是每一天的利润，我们可以计算出每一天的利润，然后只取赚的时候，最终就是赚的最多的</p><h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h3><p><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= cover;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + i&gt; cover)&#123;</span><br><span class="line">                cover = nums[i] + i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cover &gt;= nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题不需要关系具体是如何跳跃的，只需要记录当前位置可以跳跃到的最大范围，然后依次遍历范围内的所有元素，来寻找更大的范围，如果找到的范围超过了数组的最大索引，说明可以跳跃到，反之则不行</p><h3 id="跳跃游戏Ⅱ"><a href="#跳跃游戏Ⅱ" class="headerlink" title="跳跃游戏Ⅱ"></a>跳跃游戏Ⅱ</h3><p><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            next = Math.max(next,nums[i] + i);</span><br><span class="line">            <span class="comment">//能进到这个if中，说明下一次就可以跳到最后，所以res+1，然后break即可</span></span><br><span class="line">            <span class="keyword">if</span>(next &gt;= nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//到这里说明目前遍历的范围还不能到最后一个，所以还需要继续往前跳，所以当遍历到当前覆盖的最后一个的时候，直接更新下一次覆盖的最大范围，并且向前跳一步</span></span><br><span class="line">            <span class="keyword">if</span>(i == cover)&#123;</span><br><span class="line">                cover = next;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路很简单，就是每次跳到覆盖内能cover的最远位置，而不是跳到覆盖范围内元素最大的位置，cover表示当前能够覆盖的最大范围，next表示当前覆盖范围内，下一次覆盖的最远位置，res表示要跳的次数</p><h3 id="K-次取反后最大化的数组和"><a href="#K-次取反后最大化的数组和" class="headerlink" title="K 次取反后最大化的数组和"></a>K 次取反后最大化的数组和</h3><p><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> changeIndex(nums);</span><br><span class="line">            nums[index] = -nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">changeIndex</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; min)&#123;</span><br><span class="line">                min = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次符号的改变都找最小的数字，这样的话如果是负数，那么最小的负数变号之后就是最大的，利于求和，如果是正数，最小的正数在变号以后都会变成绝对值小的负数这样也利于求和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span>&amp;&amp;k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums[i] = -nums[i];</span><br><span class="line">                k--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; <span class="number">0</span>&amp;&amp;k % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            nums[<span class="number">0</span>] = -nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种思路是先对数组从小到大进行排序，然后从头开始变号，此时只有当数字小于零的时候，符号改变，如果全是正数那就跳出循环，看k的奇偶性，如果k是偶数那么就不用变号了，如果k是奇数那么就把最小的正数变为负数即可</p><h3 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h3><p><a href="https://leetcode.cn/problems/gas-station/">134. 加油站 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; gas.length; i++) &#123;</span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                index = i + <span class="number">1</span>; </span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于究竟从哪个站开始走，取决于该站对总体的作用是上升还是下降，如果是上升能不能后面的所有站，满足这两个要求就可以保证绕一圈，比如gas&#x3D;[2,5,2,3,5],cos&#x3D;[1,2,8,2,4]的情况下，我们要看对总体的作用就是看油和花费的差值，即[1,3,-6,1,4]这个数组，从头开始累加，如果累加过程中出现了负数，说明跨不过去，这时把累加的数值清零，然后索引记录当前累加到的后一个，然后重新累加，直到累加过程中没有负数</p><h3 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h3><p><a href="https://leetcode.cn/problems/candy/">135. 分发糖果 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] candy = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        Arrays.fill(candy,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; candy.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i - <span class="number">1</span>])&#123;</span><br><span class="line">                candy[i] = candy[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> candy.length - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i + <span class="number">1</span>])&#123;</span><br><span class="line">                candy[i] = Math.max(candy[i + <span class="number">1</span>] + <span class="number">1</span>,candy[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; candy.length;i++)&#123;</span><br><span class="line">            res += candy[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这种需要两边都考虑的题目，解决的策略是先考虑一边，然后再考虑另一边，首先每个孩子最少有一个糖，所以初始化一个值全为1的数组，然后先考虑右边孩子是否比左边孩子评分高，此时数组从左向右遍历，因为右边孩子的糖果是在左边孩子的基础上加的，如果高给对应孩子的糖果加一，然后考虑左边孩子是否比右边孩子评分高，此时需要数组从后向前遍历，因为左边孩子加糖果是在右边孩子糖果的基础上加的，然后加一之后在和这个孩子原本糖果的数量进行比较取最大值，因为最大值一定可以满足既比左边孩子高而且比右边孩子高的条件</p><h3 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h3><p><a href="https://leetcode.cn/problems/lemonade-change/">860. 柠檬水找零 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>[] bills)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">five</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ten</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bills.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bills[i] == <span class="number">5</span>) &#123;</span><br><span class="line">                five++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bills[i] == <span class="number">10</span>) &#123;</span><br><span class="line">                five--;</span><br><span class="line">                ten++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bills[i] == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ten--;</span><br><span class="line">                    five--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    five -= <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (five &lt; <span class="number">0</span> || ten &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题确实简单，记录好每次收到钱的面值即可，5元直接记录，10元只能用5元找零，20元可以用一张10元和一张5元找零或三张五元找零，这样的话在每次遍历以后看剩余的5元，10元是不是负的即可确认是否能找零，这道题贪心贪在20元找零的时候，这时优先使用10元和5元的组合找零，而不是3个五元的，因为5元更万能，既可以找零20，又可以找零10</p><h3 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h3><p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">        Arrays.sort(people,(a,b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> b[<span class="number">0</span>] - a[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] person : people)&#123;</span><br><span class="line">            list.add(person[<span class="number">1</span>],person);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[people.length][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目还是需要两个维度考虑，一个是自身的身高，一个是需要多少个比自己高的人，所以还是要先抓住一个维度，在考虑另外一个维度，比如people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]的时候，先考虑需要多少个比自己高的人的话，排序结果为[[5,0],[7,0],[6,1],[7,1],[5,2],[4,4]] (当需要相同个数高的人站在自己前面的时候身高高的往后站),这时发现再根据身高进行后序调整的时候不好操作了，所以先考虑身高，排序完的people： [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]，身高相同需要前面站的人多的往后站，排序完就会发现“需要多少个比自己高的人”这个条件变成了要插入队列的索引</p><p>插入的过程：</p><ul><li>插入[7,0]：[[7,0]]</li><li>插入[7,1]：[[7,0],[7,1]]</li><li>插入[6,1]：[[7,0],[6,1],[7,1]]</li><li>插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]</li><li>插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]</li><li>插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</li></ul><p>后面的人往中间插是一定不会影响之前的排序结果的，因为身高是降序排列，所以后面的人的位置变动只会影响自己的需要多少个比自己高的人这个元素，然后因为题目要求往队列里面插入的时候一般是中间插入较多，所以使用ArrayList效率要稍高于LinkedList</p><h3 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h3><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        Arrays.sort(points, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; points.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i - <span class="number">1</span>][<span class="number">1</span>] &lt; points[i][<span class="number">0</span>])&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                points[i][<span class="number">1</span>] = Math.min(points[i - <span class="number">1</span>][<span class="number">1</span>],points[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为题目传入的气球位置是乱序的，所以这时需要对气球的左边界进行升序排列，这样有利于对重叠的气球进行统计，<strong>注意这个地方要使用Integer内置的比较函数不会出现数值溢出，</strong>然后就可以判断左边气球的右边界和右边气球的左边界的大小关系，如果左边气球的右边界小于右边气球的左边界这时说明需要再多来一根弓箭，如果左边气球的有边界大于等于右边气球的左边界，说明这时一根弓箭可以直接射穿，此时为了判断下一个气球是不是可以一块射穿，需要更新这两个气球的最小右边界，只有下一个气球的左边界小于等于这俩气球的最小右边界才可以一块射穿</p><h3 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h3><p><a href="https://leetcode.cn/problems/non-overlapping-intervals/description/">435. 无重叠区间 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(intervals,(a,b) -&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt; intervals[i - <span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                count++;</span><br><span class="line"></span><br><span class="line">                intervals[i][<span class="number">1</span>] = Math.min(intervals[i][<span class="number">1</span>],intervals[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上一题很像，上一题是在两个区间不重叠的时候进行计数表示一个箭可以射穿，这道题是在两个区间重叠的时候进行计数，然后同样更新最小右边界方便下一个区间比较</p><h3 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h3><p><a href="https://leetcode.cn/problems/partition-labels/description/">763. 划分字母区间 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] lasIndex = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            lasIndex[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            right = Math.max(right,lasIndex[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span>(i == right)&#123;</span><br><span class="line">                res.add(right - left + <span class="number">1</span>);</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题的意思是同一个字符只能出现在分割之后的同一个字符串，也就说从原字符串的第一个位置开始收集，那么最少要收集到这个字符在字符串中最后一次出现的位置，在遍历的过程中还会收集到的字符，也要遍历到这些字符的最后位置，所以这个最后位置是动态更新的，取这些字符最后位置的最大值，最后放到集合中即可，记录字符最后出现的位置的方法是，遍历整个字符串，然后用每一个字符减去’a’作为字符所在数组的位置，然后不断更新最后一次在字符中出现就是最大值</p><h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><p><a href="https://leetcode.cn/problems/merge-intervals/description/">56. 合并区间 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//按照左边界排序</span></span><br><span class="line">        Arrays.sort(intervals, (x, y) -&gt; Integer.compare(x[<span class="number">0</span>], y[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">//initial start 是最小左边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightmostRightBound</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt; rightmostRightBound)&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start,rightmostRightBound&#125;);</span><br><span class="line">                start = intervals[i][<span class="number">0</span>];</span><br><span class="line">                rightmostRightBound = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                rightmostRightBound = Math.max(rightmostRightBound,intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, rightmostRightBound&#125;);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先按照范围的左边界进行排序，记录第一个元素的左右边界，然后判断下一个元素左边界和当前记录边界的右边界的关系，如果大于直接把当前记录的边界放入到的集合中，并且更新左右边界为当前遍历的元素，反之只需要更新右边界(如果右边界比当前记录的右边界大的话)，最后注意遍历到最后一个边界的时候，不管这个边界和之前记录的边界范围什么关系都需要把这个边界放到集合中，因为intervals[ i ][ 0]  &gt; rightmostRightBound这种情况放入集合的是当前记录边界，而不是最后一个边界</p><h3 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h3><p><a href="https://leetcode.cn/problems/monotone-increasing-digits/description/">738. 单调递增的数字 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(n);</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[i - <span class="number">1</span>] &gt; ch[i])&#123;</span><br><span class="line">                ch[i - <span class="number">1</span>]--;</span><br><span class="line">                flag = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> flag;i &lt; s.length();i++)&#123;</span><br><span class="line">            ch[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(<span class="keyword">new</span> <span class="title class_">String</span>(ch));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题的思路挺牛逼的，当前一位的数字比后一位大的时候，这个时候因为后一位不能变大了，但是为了让后面的大于前面的，所以让前一位减一，然后后一位变成9，例如332，此时个位比十位小，所以让十位减一，让个位等于九，此时是局部最优，然后依次遍历可以达到全局最优，注意要使用一个标记为表示该位后面的所有位都变成9，而不是当出现位数差值的时候才变成9，全部变成9才是全局最优</p><p>至于遍历顺序问题，可以带入模拟一下，如果从前往后遍历332，在遍历结束的时候就会变成329，就不对了，我们是要根据后面的结果来判断前面数字的改变</p><h3 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h3><p><a href="https://leetcode.cn/problems/binary-tree-cameras/description/">968. 监控二叉树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**状态表示：</span></span><br><span class="line"><span class="comment">        0：无覆盖</span></span><br><span class="line"><span class="comment">        1：有摄像头</span></span><br><span class="line"><span class="comment">        2：有覆盖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span>  res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCameraCover</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(getState(root) == <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getState(cur.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getState(cur.right);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">2</span>&amp;&amp;right == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="number">0</span>||right == <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>截至目前最简单的一个hard题，贪心的思路在于要想到叶子节点的个数一定是大于根节点的，为了让摄像头的个数最少，由于叶子节点的特性，不要让叶子节点出现的摄像头，因为他的覆盖范围小，要让叶子节点的父节点放摄像头，所以这里要使用后序遍历，从下往上安放摄像头，通过子节点的状态判断父节点的状态，来判断是否放摄像头</p><ol><li>当左右节点都是有覆盖状态，这时该节点的状态是无覆盖</li><li>当左右节点至少有一个无覆盖，这时该节点必须放一个摄像头，状态为一</li><li>当左右节点至少有一个摄像头，这时该节点的状态是有覆盖</li></ol><p>之所以遇到空节点的时候要返回有覆盖的状态，是为了让叶子节点的父节点来放摄像头，如果返回另外两种状态那么父节点就放不上摄像头了，最后的根节点返回的状态结果记得处理，也就是根节点如果是无覆盖的状态，那么要在跟节点上放一个摄像头</p><h3 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><p><a href="https://leetcode.cn/problems/fibonacci-number/description/">509. 斐波那契数 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">0</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            list.add(list.get(i - <span class="number">2</span>) + list.get(i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动规五部曲：</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p><ol start="2"><li>确定递推公式</li></ol><p>因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] &#x3D; dp[i - 1] + dp[i - 2];</p><ol start="3"><li>dp数组如何初始化</li></ol><p>题目中把如何初始化也直接给我们了，如下：</p><p>dp[0] &#x3D; 0;<br>dp[1] &#x3D; 1;</p><ol start="4"><li>确定遍历顺序</li></ol><p>从递归公式dp[i] &#x3D; dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p><ol start="5"><li>当题目通过不了的时候可以通过打印dp数组的方法，查看打印出来的内容和预想内容有何不同</li></ol><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p><a href="https://leetcode.cn/problems/climbing-stairs/description/">70. 爬楼梯 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;i &lt; dp.length;i++)&#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题最关键的点在于区分开 <em>到达第n阶有几种方法</em> 和 <em>到达第n阶走几步</em> 这两个说法的区别，走到第一阶有一种方法，走到第二节有两种走法，然后从后往前想更易于理解，例如 达到第五阶有几种方法？</p><p>想要达到第五阶至少要达到第三阶或者第四阶，这样才能到第五阶，所以到达第五阶的方法就是到达第四阶和到达第三阶方法的总和，那依次类推到达第四阶就是至少要达到第二阶或者第三阶，也就是到达第四阶需要到达第三阶和第二阶方法的总和，所以这就可以抽象斐波那契数列</p><p>还有一个点是dp数组的意义：dp数组表示到达第i阶的方法有dp[i]种方法，所以在初始化数组的时候dp[0]表示达到第零阶的方法，其实是没有意义的，所以dp数组从dp[1]开始复制即可</p><h3 id="爬楼梯最少消费"><a href="#爬楼梯最少消费" class="headerlink" title="爬楼梯最少消费"></a>爬楼梯最少消费</h3><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/description/">746. 使用最小花费爬楼梯 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cost.length + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt; cost.length + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>],dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先要明确题意，题目中的cost数组表示的是站在某一个台阶上向上跳的时候要花费的钱，而不是站上去就要花钱，因此dp[0]和dp[1]都是0，dp数组的含义是到达第i个台阶需要花费的钱是dp[i]，所以初始化dp数组的时候长度要比cost长度多一个，因为cost数组的最后一个元素表示倒数第一个台阶还没有到顶，想要达到第i个台阶的条件是先要到达第i-1或者i-2个台阶，所以遍历顺序还是从前往后，这个位置取值为从前面两个台阶中选一个小的花费</p><h3 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h3><p><a href="https://leetcode.cn/problems/unique-paths/description/">62. 不同路径 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>||m == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; m;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; m;j++)&#123;</span><br><span class="line">                dp[j][i] = dp[j - <span class="number">1</span>][i] + dp[j][i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显这道题是根据横纵两个方向进行路径的统计，所以dp是一个二维数组，由于这道题只能向下或者向右走，所以要想走到某一个点，必须先到达到他的左边的点或者上边的点，所以递推公式就是上边点的路径总和加上左边点的总和，从而推出递推公式，然后对于数组的初始化，由于递推公式是基于左边和上边的点，所以二维数组的最上边和最左边需要进行初始化，很显然最上面和最下面只有一种走法，不管多长都初始化为1即可，因为结果基于左边和上边，遍历顺序也很自然的从左向右从上向下</p><h3 id="不同路径Ⅱ"><a href="#不同路径Ⅱ" class="headerlink" title="不同路径Ⅱ"></a>不同路径Ⅱ</h3><p><a href="https://leetcode.cn/problems/unique-paths-ii/description/">63. 不同路径 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>||obstacleGrid[m - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>] != <span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i] != <span class="number">1</span>)&#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j] != <span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题就是在前一题的基础上加了障碍，所以递推公式和遍历顺序是不变的，所以只需要调整dp数组的初始化，也就是在初始化最上边和最左边的时候在遇到障碍之前还是1，在遇到障碍之后直接跳出循环即可，因为障碍和障碍后面的位置一定是到达不了的，注意，别忘了判断起始位置和终点位置是不是有障碍，如果有障碍那么一定到达不了终点</p><h3 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h3><p><a href="https://leetcode.cn/problems/integer-break/description/">343. 整数拆分 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;i &lt; n + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; i;j++)&#123;</span><br><span class="line">                dp[i] = Math.max(j * (i - j),Math.max(j * dp[i - j],dp[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由均值不等式可知，当和一定的时候，拆分的数大小越相近，相乘的结果越大，所以定义dp数组为第i个数拆分的最大值是dp[i]，当一个数拆分为i，j两个数时，乘积就是j * (i - j),当拆分的个数大于两个的时候，这时就需要用到dp数组中以前的结果了，j固定不动，j * dp[i - j]即可表示拆分后大于两个的情况，遍历顺序和初始化很简单，关键在于为什么j * dp[i - j]这个地方能代表全部的可能，是因为dp数组的任何一个数都是在经过全部遍历以后取得的最大值，然后固定一个j不动，乘上dp得到的一定是全部结果，最后注意取最大值的时候Math.max(j * (i - j),Math.max(j * dp[i - j],dp[i]))不要忘了dp[i]本身，因为之前记录的dp[i]可能比j * (i - j)和j * dp[i - j]z这两个都大，以防后面遍历的可能结果把之前记录的最大值覆盖掉</p><h3 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h3><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/description/">96. 不同的二叉搜索树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> dp[] = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt; dp.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; i;j++)&#123;</span><br><span class="line">                dp[i] += dp[j] * dp[i - <span class="number">1</span> -j]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一棵二叉树的所有放置方式，无非就是不断更新根节点，然后变动左右子节点数量，所以明确dp[]数组的意义，即有i个节点的时候有dp[i]中不同的节点放置方式，拿n &#x3D; 3(二叉树共三个节点)举例，无非三种情况：</p><ol><li>根节点为1，左子树节点个数为0，右子树节点个数为2，这时就是0个节点对应的放置方式 乘上 2个节点对应的放置方式</li><li>跟节点为2，左子树节点个数为1，右子树节点个数为1，这时就是1个节点对应的放置方式 乘上 1个节点对应的放置方式</li><li>跟节点为3，左子树节点个数为2，右子树节点个数为0，这时就是2个节点对应的放置方式 乘上 0个节点对应的放置方式</li></ol><p>把以上三种情况相加就是3个节点所有的放置方式，由此可以得出递推公式dp[i] +&#x3D; dp[j] * dp[i - 1 -j],其中i表示节点总数，j可以看成左节点的个数，由于根节点也要占一个节点，所以右节点的个数要在减去左节点个数的前提下额外减一，即i - j -1，然后遍历累加，关于数组的初始化，1个节点肯定是一种排列方式，0个也是1种方式，因为0个节点一定是二叉搜索树，这个很关键，遍历顺序很简单了，后面要依赖前面的所以是从前向后遍历</p><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>之所以使用一维数组进行求解的时候，先遍历物品然后遍历背包的时候，背包大小要从大到小进行遍历，是因为往背包里面放这件物品的计算规则是该物品的价值 + 减去该物品剩下的质量对应的最大价值，所以保证减去该物品的质量的那个背包里面没有放该物品，因为每个物品只有一个，使用二维数组的时候都是往左上角进行相加查找这个物品，所以这个时候一定没有放置该物品</p><ul><li>二维数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BagProblem</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划获得结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight  物品的重量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value   物品的价值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bagSize 背包的容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testWeightBagProblem</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] value, <span class="type">int</span> bagSize)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建dp数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">goods</span> <span class="operator">=</span> weight.length;  <span class="comment">// 获取物品的数量</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[goods][bagSize + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化dp数组</span></span><br><span class="line">        <span class="comment">// 创建数组后，其中默认的值就是0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> weight[<span class="number">0</span>]; j &lt;= bagSize; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充dp数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; weight.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= bagSize; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; weight[i]) &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 当前背包的容量都没有当前物品i大的时候，是不放物品i的</span></span><br><span class="line"><span class="comment">                     * 那么前i-1个物品能放下的最大价值就是当前情况的最大价值</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 当前背包的容量可以放下物品i</span></span><br><span class="line"><span class="comment">                     * 那么此时分两种情况：</span></span><br><span class="line"><span class="comment">                     *    1、不放物品i</span></span><br><span class="line"><span class="comment">                     *    2、放物品i</span></span><br><span class="line"><span class="comment">                     * 比较这两种情况下，哪种背包中物品的最大价值最大</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j] , dp[i-<span class="number">1</span>][j-weight[i]] + value[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>一维数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testWeightBagProblem</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] value, <span class="type">int</span> bagWeight)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">wLen</span> <span class="operator">=</span> weight.length;</span><br><span class="line">    <span class="comment">//定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[bagWeight + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//遍历顺序：先遍历物品，再遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; wLen; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagWeight; j &gt;= weight[i]; j--)&#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h3><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">416. 分割等和子集 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target;j &gt;= nums[i];j--)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j],dp[j - nums[i]] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[target] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个思路又很牛逼，要把一个数组完全分成两个等和的数组，那么就是每个数组是原数组之和的一半，然后拿一个最大容量就是原数组之和一半的背包，如果这个背包最大能装的价值就是原数组之和的一半的话(原数组的数值表示其价值)，那么就正好可以分成两个数组，这样就可以把这个问题抽象成01背包，然后每次往背包里放东西的时候都校验一遍是不是达到了原数组的一半，可以起到剪枝的作用</p><h3 id="最后一块石头的重量-II"><a href="#最后一块石头的重量-II" class="headerlink" title="最后一块石头的重量 II"></a>最后一块石头的重量 II</h3><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/description/">1049. 最后一块石头的重量 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; stones.length;i++)&#123;</span><br><span class="line">            sum += stones[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; stones.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> maxSize;j &gt;= stones[i];j--)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j],dp[j - stones[i]] + stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">other</span> <span class="operator">=</span> sum - dp[maxSize];</span><br><span class="line">        <span class="keyword">return</span> other - <span class="number">2</span>*dp[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上一题的牛逼思路一样，这一题要想让碰撞以后剩余石头尽可能小，就把所有的石头分成两堆，让两堆的石头尽量等于总重量的一半，这样两堆碰撞的之后就是最小的，所以就又转化为了01背包</p><h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h3><p><a href="https://leetcode.cn/problems/target-sum/description/">494. 目标和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((sum - target) % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> (sum - target)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[tmp + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> tmp;j &gt;= nums[i];j--)&#123;</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[tmp];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题的思路很简单，无非就是在数组中挑出来几个数，给这几个数加上负号，然后让其数组的数相加得零，计算这些数总和的方式是，原数组的总和减去目标值再除二(如果原数组的和减去目标值为奇数直接返回零即可)，记录这个值为tmp，这道题就转换为装满一个大小为tmp的背包有几种方法，所以难点到了求这个递推公式，举个例子，如果tmp &#x3D; 3，先遍历物品，如果物品的大小是3，这时就要加上dp[3 - 3]，如果物品的大小是2，那就加上dp[3 - 2]，以此类推，所以这样我们就可以得到递推公式，然后注意数组的初始化，dp[0]为什么等于一，因为需要用到dp[0]的地方是当我们遇到了和背包一样大的物品，这时只要把这一个物品直接放到背包中就可以装满，所以初始化dp[0]的时候要为1</p><h3 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h3><p><a href="https://leetcode.cn/problems/ones-and-zeroes/description/">474. 一和零 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; strs.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span>[] count = getCount(strs[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m;j &gt;= count[<span class="number">0</span>];j--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n;k &gt;= count[<span class="number">1</span>];k--)&#123;</span><br><span class="line">                    dp[j][k] = Math.max(dp[j][k],dp[j - count[<span class="number">0</span>]][k - count[<span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getCount(String s)&#123;</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                count[<span class="number">0</span>]++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count[<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>典型的01背包，要找的是装满背包最多可以装多少个物品，但是原来的01背包只需要考虑一个维度，也就是最大容量，但是这个背包需要考虑两个维度，这两个维度都不能超过上限，然后就是经典遍历，先遍历物品，物品无非两种情况，一个是装，就是背包的容量减去物品的容量剩余的容量最多可以装几个物品，然后加一，另一种就是不装，就是直接使用上一轮所装的物品个数，两种情况取最大值即可</p><h3 id="零钱兑换Ⅱ"><a href="#零钱兑换Ⅱ" class="headerlink" title="零钱兑换Ⅱ"></a>零钱兑换Ⅱ</h3><p><a href="https://leetcode.cn/problems/coin-change-ii/description/">518. 零钱兑换 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; coins.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coins[i];j &lt;= amount;j++)&#123;</span><br><span class="line">                dp[j] += dp[j - coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题和目标和的思路是一样的，就是装满背包大小为i的方式有几种，只不过这道题的物品都可以取多次，所以如果先遍历物品在遍历背包，在遍历背包的时候要正序遍历，这样就能保证每个物品取到多次，最关键的点在于物品和背包的遍历顺序，是不能颠倒的，因为本题中，先放2再放1和先放1再放2，这俩结果是一样的，也就是说<strong>先物品后背包得到的是组合，先背包后物品得到的是排列</strong>，本题要求的是组合，所以先物品后背包，加入背包的顺序严格按照物品遍历的顺序</p><h3 id="组合总和Ⅳ"><a href="#组合总和Ⅳ" class="headerlink" title="组合总和Ⅳ"></a>组合总和Ⅳ</h3><p><a href="https://leetcode.cn/problems/combination-sum-iv/description/">377. 组合总和 Ⅳ - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; dp.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i - nums[j] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i] += dp[i - nums[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题和上一题是一样一样的，都是问装满背包有几种方式，但是这道题求的是排列，也就是说拿元素的不同顺序也算不同的方式，所以要先遍历背包后遍历物品，再强调一遍，<strong>先物品后背包得到的是组合，先背包后物品得到的是排列，求装满背包的最大价值的时候遍历顺序无所谓</strong></p><h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h3><p><a href="https://leetcode.cn/problems/coin-change/description/">322. 零钱兑换 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length;i++)&#123;</span><br><span class="line">            dp[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; coins.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coins[i];j &lt;= amount;j++)&#123;</span><br><span class="line">                    dp[j] = Math.min(dp[j - coins[i]] + <span class="number">1</span>,dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == max ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题其实和前面的题是一样的，但是转了一个小弯，前面的题问的都是装满背包最多如何如何，但是本题要求的是装满背包最少需要多少件物品，所以初始化dp数组就要变一下，以前把dp数组都初始化为0，为的是防止使用max方法求最大值的时候，把正确的值覆盖掉，这道题要求最小物品数量，所以为了防止把正确的结果覆盖掉，所以dp初始化的值应该尽可能大（例如Integer.MAX_VALUE - 1），最后对数组本身和减去当前物品容量加一取最小值，即dp[j] &#x3D; Math.min(dp[j - coins[i]] + 1,dp[j]);</p><h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h3><p><a href="https://leetcode.cn/problems/perfect-squares/description/">279. 完全平方数 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[j] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i * i; j &lt;= n; j++) &#123;</span><br><span class="line">                    dp[j] = Math.min(dp[j], dp[j - i * i] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上一题很像，只不过这道题的物品全是完全平方数，所以和上一题唯一的差别就是本题不需要考虑背包装不满的情况，因为1也是一个完全平方数，所以最差的情况也是可以用1完全装满的</p><h3 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h3><p><a href="https://leetcode.cn/problems/word-break/description/">139. 单词拆分 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; dp.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(String word : wordDict)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> word.length();</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= len&amp;&amp;dp[i - len]&amp;&amp;word.equals(s.substring(i - len,i)))&#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题是通过s字符串不断的截取作为不同大小的背包，然后看字典中是否有这个单词，进行推导，dp数组的初始化中，dp[0]应该初始化为true，因为后面的所有单词一开始都是基于dp[0]推到出来的，进行dp数组推导的时候，截取的字符串长度必须大于等于当前字典中遍历的单词的长度，而且截取的长度减去当前字典遍历的单词长度之后的长度在dp中一定是要为true的，最后才看截取出来的单词和字典中遍历相不相同</p><h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><p><a href="https://leetcode.cn/problems/house-robber/description/">198. 打家劫舍 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i],dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，要先明确dp数组的含义，第i家及以前的所有家全都考虑进去，所能偷的最大值，第i家无非就两种情况，偷与不偷：</p><ul><li>如果偷：那么就是当前家的钱加上前前家及以前的所有家的最大值，dp[i - 2] + nums[i]</li><li>如果不偷：那么就是前一家及以前所有家的最大值，dp[i - 1]</li></ul><p>对以上两种情况取最大值即可，由于dp数组的推导是基于前面两个的值的，所以遍历顺序一定是从前往后，dp[0]初始化为nums[0]，dp[1]初始化为nums[0]和nums[1]的最大值，这样才是</p><h3 id="打家劫舍Ⅱ"><a href="#打家劫舍Ⅱ" class="headerlink" title="打家劫舍Ⅱ"></a>打家劫舍Ⅱ</h3><p><a href="https://leetcode.cn/problems/house-robber-ii/description/">213. 打家劫舍 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(robSum(nums,<span class="number">0</span>,nums.length - <span class="number">2</span>),robSum(nums,<span class="number">1</span>,nums.length - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">robSum</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end == start) <span class="keyword">return</span> nums[start];</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[start] = nums[start];</span><br><span class="line">        dp[start + <span class="number">1</span>] = Math.max(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + <span class="number">2</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>房子连成环了，也就是说头尾房子不能同时偷了，那么就是两种情况，考虑第一房子不考虑最后一个房子或者考虑最后一个房子不考虑第一个房子，最后取一个最大的</p><h3 id="打家劫舍Ⅲ"><a href="#打家劫舍Ⅲ" class="headerlink" title="打家劫舍Ⅲ"></a>打家劫舍Ⅲ</h3><p><a href="https://leetcode.cn/problems/house-robber-iii/description/">337. 打家劫舍 III - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] res = robDp(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(res[<span class="number">0</span>],res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] robDp(TreeNode cur)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] leftDp = robDp(cur.left);</span><br><span class="line">        <span class="type">int</span>[] rightDp = robDp(cur.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">val0</span> <span class="operator">=</span> Math.max(leftDp[<span class="number">0</span>],leftDp[<span class="number">1</span>]) + Math.max(rightDp[<span class="number">0</span>],rightDp[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">val1</span> <span class="operator">=</span> leftDp[<span class="number">0</span>] + rightDp[<span class="number">0</span>] + cur.val;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;val0,val1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个节点只有两个状态，偷与不偷，而且在递归遍历二叉树的时候，每调用一次递归方法的时候，线程栈帧中都会记录每次调用时候的局部变量，也就是每个节点的状态会被记录，所以dp数组就可以初始化为一个长度为2的数组，dp[0]表示不偷当前节点可以得到的最大值，dp[1]表示偷当前节点可以得到最大值，由于每个节点偷与不偷的情况取决于它的左右孩子的情况，所以采用后续遍历，得到左右孩子偷与不偷的最大值，来计算当前节点如何能够最大</p><ul><li>如果当前节点不偷，那么就是左孩子偷与不偷的最大值加上右孩子偷与不偷的最大值就是当前节点的不偷的最大值Math.max(leftDp[0],leftDp[1]) + Math.max(rightDp[0],rightDp[1]);</li><li>如果当前节点要偷，这时左右孩子一定不能偷，所以这时的最大值就是当前节点的值加上左右孩子都不偷的值</li></ul><p>遍历到最后得到根节点偷与不偷的值，然后取最大就是最终可以偷到的最大值</p><h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121. 买卖股票的最佳时机 - 力扣（LeetCode）</a></p><ul><li>贪心</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="comment">// 找到一个最小的购入点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// res不断更新，直到数组循环完毕</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            low = Math.min(prices[i], low);</span><br><span class="line">            res = Math.max(prices[i] - low, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贪心的思路就是找到数组左边最小的数和右边最大的数，这样这两个数一减肯定是最大利润</p><ul><li>动态规划</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//dp[i][j]其中i表示第几天，j的长度为2，只有0和1，0表示第i天不持有股票，1表示第i持有股票</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>],-prices[i]);<span class="comment">//如果第i天持有的两种情况</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>],dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);<span class="comment">//如果第i天不持有的两种情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态规划最难的点在于明确dp数组的含义，由于对于任何一天的股票只有两种状态，就是持有和不持有，所以需要一个二维数组，dp[i][j]其中i表示第几天，j的长度为2，只有0和1，0表示第i天不持有股票，1表示第i持有股票，然后dp数组的含义是第i天持有或不持有分别获得的最大利润，如果当天不持有，是两种情况，延续前一天不持有的状态，或者前一天在这一天卖出；如果当天持有，也是两种情况，延续前一天持有的状态，或者在这一天卖出</p><h3 id="买卖股票的最佳时机Ⅱ-1"><a href="#买卖股票的最佳时机Ⅱ-1" class="headerlink" title="买卖股票的最佳时机Ⅱ"></a>买卖股票的最佳时机Ⅱ</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122. 买卖股票的最佳时机 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>],dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>],dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和买卖股票Ⅰ的区别在于这次的股票可以买卖多次，所以在求持有股票的时候，可能是延续之前持有的状态，或者在之前的钱的基础上减去今天买股票的钱，上一题买股票的时候我们钱一定是0，因为只能买一次，而在求不持有股票的时候就直接和上一题一样，要么延续之前不持有的状态，或者在今天卖出</p><h3 id="买卖股票的最佳时机Ⅲ"><a href="#买卖股票的最佳时机Ⅲ" class="headerlink" title="买卖股票的最佳时机Ⅲ"></a>买卖股票的最佳时机Ⅲ</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">123. 买卖股票的最佳时机 III - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">5</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>],-prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>],dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">3</span>],dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">4</span>],dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为最多只能买卖两次限制了买卖次数，所以dp数组在初始化的时候不能单纯只记录买入和卖出，还要知道这是第几次买入和第几次卖出，所以分别定义以下几个状态</p><ul><li>0表示当天没有任何操作</li><li>1表示第一次持有股票</li><li>2表示第一次卖出股票</li><li>3表示第二次持有股票</li><li>4表示第二次卖出股票</li></ul><p>所有的状态都是在延续前一天相同状态或者当天操作中取最大值，所以第0天的股票需要初始化出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//第零天，不做任何操作，所以钱数是零</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];<span class="comment">//第零天就买入，所以就是-prices[0]</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;<span class="comment">//第零天买入就卖出，所以是0</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>];<span class="comment">//第零天买入卖出后又买入，所以就是-prices[0]</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">4</span>] = <span class="number">0</span>;<span class="comment">//第零天买入卖出买入后又卖出，所以是-prices[0]</span></span><br></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机Ⅳ"><a href="#买卖股票的最佳时机Ⅳ" class="headerlink" title="买卖股票的最佳时机Ⅳ"></a>买卖股票的最佳时机Ⅳ</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">188. 买卖股票的最佳时机 IV - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>*k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; <span class="number">2</span>*k + <span class="number">1</span>;i += <span class="number">2</span>)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; <span class="number">2</span>*k + <span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j],dp[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j],dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + prices[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>][<span class="number">2</span>*k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上一题是一模一样的，上一题最多买卖两个，状态最多到了4，即第二次不持有这个状态，对于至多买k次也就是说状态最多到2*k，也就是第k次不持有的状态，然后在进行状态遍历的时候，奇数表示持有，那么可能是延续之前持有的状态或者当天买入即在前一天的基础上减去股票的钱，偶数表示不持有，那么可能是延续之前不持有的状态或者在前一天持有的基础上卖出</p><h3 id="买卖股票的最佳时机含冷冻期"><a href="#买卖股票的最佳时机含冷冻期" class="headerlink" title="买卖股票的最佳时机含冷冻期"></a>买卖股票的最佳时机含冷冻期</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">309. 买卖股票的最佳时机含冷冻期 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = Math.max(dp[<span class="number">0</span>][<span class="number">0</span>],dp[<span class="number">0</span>][<span class="number">1</span>] + prices[<span class="number">1</span>]);</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = Math.max(dp[<span class="number">0</span>][<span class="number">1</span>],dp[<span class="number">0</span>][<span class="number">0</span>] - prices[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt; prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>],dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>],dp[i - <span class="number">2</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在买卖股票2的基础上加了冷冻期，所以可以直接在买卖股票2的基础上多考虑买入时的情况(即持有股票)即可，因为冷冻期只影响了你能否买入，持有股票分为延续前一天就持有的状态和在前前天卖出的状态的基础上今天买入取最大值，所以初始化dp数组的时候要出事前两天的</p><h3 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a>买卖股票的最佳时机含手续费</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">714. 买卖股票的最佳时机含手续费 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>],dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i] - fee);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>],dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题就是在买卖股票Ⅱ的基础上考虑手续费，所以统一在卖出计算利润的时候减去手续费</p><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">300. 最长递增子序列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[j] + <span class="number">1</span>,dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dp数组的含义是以索引为i的元素为结尾的最长子序列长度是dp[i]（注意这个子序列一定要包含dp[i]这个数字）,由于每个数组最少的递增序列长度一定是1，所以初始化dp[]数组的时候全部初始化为1就可以，从前向后遍历的过程中，由于nums[i]是一定要放在子序列中的，所以nums[i]要和nums[0]—-nums[i - 1]都要进行比较，只有当nums[i]大于nums[0]—-nums[i - 1]中的值的时候，才对dp[i]和对应位置的dp数组的值加一取最大值，注意最终的结果不是dp[dp.length - 1]，因为nums[dp.length - 1]这个数字不一定会在最长子序列中</p><h3 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a>最长连续递增子序列</h3><p><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/">674. 最长连续递增序列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; dp.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求连续的子序列，那么此时只需要把当前遍历到的值和前一个值进行比较即可，所以dp数组仍要全部初始化为1，然后遇到的数比前一个大就加一，dp数组的含义仍是以第i个数为结尾的最大长度(第i个数必须在序列中)</p><h3 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h3><p><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">718. 最长重复子数组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= nums2.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res = Math.max(res,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dp数组的i和j分别表示，以nums1[i - 1],nums2[j - 1]这两个数相不相等，因为这样初始化的时候方便一些，下图可以很好的说明这道题的递推公式，以及为什么要以i - 1和j - 1说明</p><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231223140856012.png" class title="image-20231223140856012"><p>最长重复数组对应在二维数组里面是斜向的，所以递推公式i，j同时减一，dp数组的最左边和最上边是也是表示该位置的左上角元素的状态，但是左上角没有元素所以直接初始化为0即可</p><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p><a href="https://leetcode.cn/problems/longest-common-subsequence/description/">1143. 最长公共子序列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] c1 = text1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] c2 = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[c1.length + <span class="number">1</span>][c2.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= c1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= c2.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c1[i - <span class="number">1</span>] == c2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j],dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[c1.length][c2.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题和上一题的唯一区别就是本题是要求子序列，所以可以不连续，所以dp数组的i和j还是表示，以nums1[i - 1],nums2[j - 1]这两个数，当遇到两个元素相等的时候直接在两字符串前一个状态基础上加一，当遇到两个元素不相等的时候参考某一个字符串的前一个状态的最大值</p><h3 id="不相交的线"><a href="#不相交的线" class="headerlink" title="不相交的线"></a>不相交的线</h3><p><a href="https://leetcode.cn/problems/uncrossed-lines/description/">1035. 不相交的线 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxUncrossedLines</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= nums2.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j],dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums1.length][nums2.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上一题一模一样，因为要想连出最多的不相交的线，就是最长的公共子序列，如果两个数组不是公共子序列，那么连完以后一定会出现相交</p><h3 id="最大子数组和-1"><a href="#最大子数组和-1" class="headerlink" title="最大子数组和"></a>最大子数组和</h3><p><a href="https://leetcode.cn/problems/maximum-subarray/description/">53. 最大子数组和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i],nums[i]);</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最难的点在于想明白dp数组的含义，就是dp[i]以nums[i]这个数作为子数组的最后一个数的最大和，这样就可以在前面dp数组的基础上加上这个数，或者和这个数本身取最大值，就是当前的最大和</p><h3 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h3><p><a href="https://leetcode.cn/problems/is-subsequence/description/">392. 判断子序列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &gt; t.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[t.length()];</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) == t.charAt(<span class="number">0</span>))&#123;</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; dp.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(dp[i - <span class="number">1</span>]) == t.charAt(i))&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == s.length())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一维dp数组，dp数组的含义是以t.charAt(i)为结尾的字符串包含s中的dp[i]个字符，所以dp[i]的大小和s的长度相等的时候，表示s是t的子序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> s.length(); <span class="type">int</span> <span class="variable">length2</span> <span class="operator">=</span> t.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[length1+<span class="number">1</span>][length2+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= length1; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= length2; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) == t.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[length1][length2] == length1)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和最长公共子序列一样的思路，因为如果s是t的子序列的话，那么s和t的最长公共子序列的长度一定是s字符串的长度，唯一不同的是当遍历到的两个字符不相同的时候，只需令当前的<code>dp[i][j] = dp[i][j-1]</code>,不需要<code>dp[i][j] = Math.max(dp[i - 1][j],dp[i][j - 1]);</code>因为i表示的是s的索引位置，<code>dp[i][j - 1]</code>一定比<code>dp[i - 1][j]</code>大</p><h3 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h3><p><a href="https://leetcode.cn/problems/distinct-subsequences/solutions/">115. 不同的子序列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>][t.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; t.length() + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[s.length()][t.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]</code>不是很理解，总之就是选择用遍历到的s的字符的时候就是<code>dp[i - 1][j - 1]</code>,不选择用遍历到s的字符就是<code>dp[i - 1][j]</code></p><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231227114550068.png" class title="image-20231227114550068"><h3 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h3><p><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= word1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= word2.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j],dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> word1.length() + word2.length() - <span class="number">2</span> * dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很巧妙的一个思路，要求最少删除几个能相同，删除后的两个字符串一定是最长公共子序列，所以可以使用之前的求最长公共子序列的思路，然后两个字符换的长度减去二倍的最长公共子序列的长度，就是最少要删除的次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= word1.length();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= word2.length();j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= word1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= word2.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>,dp[i][j - <span class="number">1</span>] + <span class="number">1</span>),dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题比上一题好理解多了，就是在遍历的时候遇到的两个字符如果相同，那么说明不用删，直接延续不考虑这两个字符时的状态，如果遇到的两个字符不相等，那么三种删法，保留word1删除word2计数加一，保留word2删除word1计数加一，两个字符都删除计数加二，取最小值就是最小需要删除的次数，注意dp数组初始化的时候，由于数组是根据左右上三个方向推出来的，所以第一行和第一列需要初始化，第一行&#x2F;列表示其中一个字符串为空，那么初始化的数值就是另外不为空的字符串的长度</p><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><p><a href="https://leetcode.cn/problems/edit-distance/description/">72. 编辑距离 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> word1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= m;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>,Math.min(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>,dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题和上题很像，虽然相对于上题只能删除，多了添加和修改操作，但是对于删除和添加互为逆操作，例如word1：ab，word2：a，不管是给word1删除还是给word2添加，所需要的操作次数是相同的，所以只考虑删除即可，对于修改操作，是遇到两个不同的字符，这时修改是基于这两个字符的前一个字符，所以得出递推公式<code>dp[i][j] = Math.min(dp[i - 1][j] + 1,Math.min(dp[i][j - 1] + 1,dp[i - 1][j - 1] + 1))</code>,如果遇到的两个字符相同说明不需要任何操作，直接延续之前的状态即可</p><h3 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h3><p><a href="https://leetcode.cn/problems/palindromic-substrings/description/">647. 回文子串 - 力扣（LeetCode）</a></p><ul><li>dp法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;j &lt; len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j - i &lt;= <span class="number">1</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>])&#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                        res++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很巧妙的dp，使用一个boolean类型的二维dp数组，表示在闭区间[i,j]这个字符串是不是回文子串，因为一个字符如果是回文串，那么必须满足首尾的字符相同，并且去掉首尾字符之后里面的字符也是一个回文子串，所以使用这样一个数组表示前一个状态的串是不是回文串，从而得到递推公式，然后再说遍历顺序，遍历顺序一定是基于递推公式的，递推公式是基于<code>dp[i + 1][j - 1]</code>得到的，所以i要倒序遍历，j要正序遍历</p><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231230111754803.png" class title="image-20231230111754803"><ul><li>双指针</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> <span class="number">0</span>; center &lt; <span class="number">2</span> * s.length() - <span class="number">1</span>; center++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> center / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + center % <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个比较巧妙的方法，实质的思路和动态规划的思路类似。</p><p>比如对一个字符串 ababa，选择最中间的 a 作为中心点，往两边扩散，第一次扩散发现 left 指向的是 b，right 指向的也是 b，所以是回文串，继续扩散，同理 ababa 也是回文串。只要寻找到所有的中心点，问题就解决了。</p><p>中心点一共有多少个呢？看起来像是和字符串长度相等，但如果是这样，上面的例子永远也搜不到 abab，想象一下单个字符的哪个中心点扩展可以得到这个子串？似乎不可能。所以中心点不能只有单个字符构成，还要包括两个字符，比如上面这个子串 abab，就可以有中心点 ba 扩展一次得到，所以最终的中心点由 2 * len - 1 个，分别是 len 个单字符和 len - 1 个双字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> center / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + center % <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>最巧妙的是中心点的赋值，如果是偶数那么就是单字符中心点，如果是奇数那么就是双字符中心点</p><h3 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h3><p><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/description/">516. 最长回文子序列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;j &lt; len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>],dp[i + <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dp数组表示以i开始，j结尾的字符串的最长回文子序列的长度，增长的思路和上题很类似，如果遇到的两个字符相等，那么就在不包含这两个字符的基础上加二，如果遇到的两个字符不相等，那么就需要单独考虑每一个字符，由于遍历顺序的原因，单独考虑一个字符的情况已经计算过了，所以直接在这两个里面取最大值即可，<code>Math.max(dp[i][j - 1],dp[i + 1][j])</code></p><h3 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h3><p><a href="https://leetcode.cn/problems/daily-temperatures/description/">739. 每日温度 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="type">int</span> lens=temperatures.length;</span><br><span class="line">        <span class="type">int</span>[] res=<span class="keyword">new</span> <span class="title class_">int</span>[lens];</span><br><span class="line">        Deque&lt;Integer&gt; stack=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lens;i++)&#123;</span><br><span class="line">           <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;temperatures[i]&gt;temperatures[stack.peek()])&#123;</span><br><span class="line">                    res[stack.peek()]=i-stack.peek();</span><br><span class="line">                    stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典的使用单调栈解决的题目，单调栈解决的就是求一个元素左右第一个比该元素大或小的元素，本题要求的是元素右边第一个比该元素大的元素，那么栈从栈顶到栈底的元素大小就是递增的，所以遍历到的元素比栈顶的元素小，就直接加入栈中，如果遍历到的元素比栈顶大，那么就循环取出栈顶元素，保证栈中的元素是递增的，由于要求的是找出第一个比该元素大的，所以就是求两个位置的距离，所以为了方便期间，栈中直接存放索引，用于计算距离，然后通过索引映射数组元素进行大小的比较</p><h3 id="下一个更大元素Ⅰ"><a href="#下一个更大元素Ⅰ" class="headerlink" title="下一个更大元素Ⅰ"></a>下一个更大元素Ⅰ</h3><p><a href="https://leetcode.cn/problems/next-greater-element-i/description/">496. 下一个更大元素 I - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            map.put(nums1[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">        Arrays.fill(res, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums2[stack.peek()] &lt; nums2[i]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(nums2[index])) &#123;</span><br><span class="line">                    res[map.get(nums2[index])] = nums2[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上一题相同，寻找更大的，所以单调栈里面维护的元素是升序的，所以遇到比栈顶的元素小的直接入栈，如果遇到比栈顶大的循环弹出栈顶元素，但是这道题最要判断弹出的元素在nums1中存不存在，如果不存在，那就直接弹出不做处理，如果nums1中存在，那么往栈顶加入的这个元素就是对于这个弹出的元素来说下一个更大元素</p><h3 id="下一个更大元素Ⅱ"><a href="#下一个更大元素Ⅱ" class="headerlink" title="下一个更大元素Ⅱ"></a>下一个更大元素Ⅱ</h3><p><a href="https://leetcode.cn/problems/next-greater-element-ii/description/">503. 下一个更大元素 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElements(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        Arrays.fill(res,-<span class="number">1</span>);</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">2</span> * len;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[i % len] &gt; nums[stack.peek()])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                res[index] = nums[i % len];</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i % len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和每日温度的唯一区别就是本题的数组循环起来了，虽然是循环次数无限，但是其实只要两次就可以知道哪些数字有下一个最大的元素，所以循环的次数应为数组长度的二倍，然后往栈中存的时候很关键，不能直接存遍历到的索引，因为两倍的长度一定超过了数组的上限，而且为了能够通过存入的内容找到元素值，所以存入的内容是遍历到的索引和数组的长度取模，这样就可以循环找到数组中的值，剩下的思路就和每日温度完全相同了</p><h3 id="柱状图中最大矩形"><a href="#柱状图中最大矩形" class="headerlink" title="柱状图中最大矩形"></a>柱状图中最大矩形</h3><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形 - 力扣（LeetCode）</a></p><ul><li>双指针</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        left[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; heights.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(tmp &gt;= <span class="number">0</span> &amp;&amp; heights[tmp] &gt;= heights[i])&#123;</span><br><span class="line">                tmp = left[tmp];</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        right[len - <span class="number">1</span>] = len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(tmp &lt; len &amp;&amp; heights[tmp] &gt;= heights[i])&#123;</span><br><span class="line">                tmp = right[tmp];</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> heights[i] * (right[i] - left[i] - <span class="number">1</span>);</span><br><span class="line">            res = Math.max(res,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和接雨水中双指针解法很像，但是难很多，因为接雨水只需要存入左右边第一个比当前值大的柱子的高度即可，但是这道题需要存入的是左右边第一个比当前值小的值对应的索引，这样才可以以每一个柱子的高度为基准进行面积的计算，因为记录的计算的是索引，所以在计算面积的时候别忘了右边索引减去右边索引再减去一，即<code>right[i] - left[i] - 1</code>才是宽度</p><ul><li>单调栈</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] newHeights = <span class="keyword">new</span> <span class="title class_">int</span>[heights.length + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; heights.length;i++)&#123;</span><br><span class="line">            newHeights[i + <span class="number">1</span>] = heights[i]; </span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; newHeights.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(newHeights[i] &lt; newHeights[stack.peek()])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> newHeights[mid];</span><br><span class="line">                <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> i - stack.peek() - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> w * h;</span><br><span class="line">                res = Math.max(res,tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和接雨水就很像了，加入时当前值比栈顶的值小的时候，直接以栈顶的高度为基准计算面积，宽度是要加入元素的索引和栈中第二个元素索引之差减一，往数组首尾加0的原因是，往尾部加0是为了防止数组的值单调递增，往首部加0是为了防止数组中第二个元素比第一个元素小的时候进行计算需要用到三个值，即当前值和该值左右的索引，这样可以防止stack.peek()出现空指针异常</p><h2 id="hot100"><a href="#hot100" class="headerlink" title="hot100"></a>hot100</h2><h3 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h3><p><a href="https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked">49. 字母异位词分组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        ArrayList&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Map&lt;String,List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; strs.length;i++)&#123;</span><br><span class="line">            <span class="type">char</span>[] ch = strs[i].toCharArray();</span><br><span class="line">            Arrays.sort(ch);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">                map.get(key).add(strs[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ArrayList&lt;String&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                tmp.add(strs[i]);</span><br><span class="line">                map.put(key,tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; list : map.values())&#123;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键点在于字母异位词的特点，就是这些单词在排序以后是一模一样的，那么我们就可以把每一个词排序后的样子作为key放到map中，然后如果这个map中有key，直接就往这个key对应的集合中存放这个字符串即可</p><h3 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h3><p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked">128. 最长连续序列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : set)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> num;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(num - <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">while</span>(set.contains(cur + <span class="number">1</span>))&#123;</span><br><span class="line">                    cur++;</span><br><span class="line">                &#125;</span><br><span class="line">                res = Math.max(res,cur - num + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为要求的是连续序列，所以数组中的相同元素对我来说一定是没用的，所以可以直接使用set集合进行去重，然后遍历set集合中的元素，只有当遍历到的元素num，在集合中不存在num-1这么大的元素，才开始计数，因为这样才有可能最大</p><h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h3><p><a href="https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked">283. 移动零 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[index] = nums[i];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; nums.length;i++)&#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要被题目的名字迷惑，题目说移动零，但是如果真的去移动零，需要操作的次数就比较多，所以我们可以先移动非零元素，然后根据数组的长度进行补零操作即可</p><p>如果真的想要移动零，不要一位一位的动，只有当当前元素不为零的时候才进行移动，如下代码,j指针始终指向的零，当i指针指向不是零时候进行交换即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(nums==<span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两个指针i和j</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line"><span class="comment">//当前元素!=0，就把其交换到左边，等于0的交换到右边</span></span><br><span class="line"><span class="keyword">if</span>(nums[i]!=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">nums[i] = nums[j];</span><br><span class="line">nums[j++] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="盛水最多的容器"><a href="#盛水最多的容器" class="headerlink" title="盛水最多的容器"></a>盛水最多的容器</h3><p><a href="https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-100-liked">11. 盛最多水的容器 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            max = Math.max(max,(right - left) * Math.min(height[left],height[right]));</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用两块板从外向里移动的思路，这样移动不管是移动哪块板，长度一定是减小的，然后如果移动长板此时容量一定减小，因为长度一定减小高度可能不变或者减小，只有移动短板才可能让容量增大，所以每次只移动短板即可，如果两块板相同移动任何一块板都行，因为如果移动以后变短了还会继续移动，如果移动后变大了那么就会保留并移动另一块</p><h3 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h3><p><a href="https://leetcode.cn/problems/trapping-rain-water/description/?envType=study-plan-v2&envId=top-100-liked">42. 接雨水 - 力扣（LeetCode）</a></p><ul><li>单调栈</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        LinkedList&lt;Data&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; height.length;i++)&#123;</span><br><span class="line">            <span class="type">Data</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>(height[i],i);</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;stack.peek().height &lt; right.height)&#123;</span><br><span class="line">                <span class="type">Data</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">Data</span> <span class="variable">left</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">                <span class="keyword">if</span>(left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> right.index - left.index - <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> Math.min(right.height,left.height) - pop.height;</span><br><span class="line">                    sum += width * high; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">        <span class="type">int</span> height;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Data</span><span class="params">(<span class="type">int</span> height,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.height = height;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助栈这个数据结构来帮助解题，但是这个栈是单调的，就是在往栈里面加入柱子的时候，柱子的高度必须是逐渐递减的，因为这样一定接不住水，只有当加入的柱子是比前一个高的时候才可以存住水，所以在每次向栈里面加柱子的时候如果前面的柱子比要加的柱子矮，要全部弹出直到找到第一个比要加的柱子高或者一样高柱子，才把这个柱子加进去，然后就计算接水就是算面积</p><ul><li>双指针</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(height.length &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] leftMax = <span class="keyword">new</span> <span class="title class_">int</span>[height.length];</span><br><span class="line">        <span class="type">int</span>[] rightMax = <span class="keyword">new</span> <span class="title class_">int</span>[height.length];</span><br><span class="line">        leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        rightMax[rightMax.length - <span class="number">1</span>] = height[height.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; leftMax.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            leftMax[i] = Math.max(height[i], leftMax[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> rightMax.length - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            rightMax[i] = Math.max(height[i], rightMax[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= height.length - <span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> Math.min(leftMax[i],rightMax[i]) - height[i];</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sum += tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双指针的思路是遍历统计每一列柱子可以存放的水(第一列和最后一列除外)，他的方法就是找到这个柱子左边的最高柱子和右边的最高的柱子，然后减去自身的高度，就是该列可以存放的水，但是如果每列都分别向右和向左遍历寻找最高的柱子，那么在力扣上面是超时的，所以需要对找最高柱子进行优化，也就是维护两个数组，一个数组记录每个柱子右边的最高高度，一个数组记录每个柱子左边的最高高度，通过自身高度和左&#x2F;右柱子最高高度，进行比较，如果比左&#x2F;右边的最高高度高，那么这个柱子自身就是自己左&#x2F;右边的最高高高度，如果比左&#x2F;右边的最高高度矮，那就沿用左&#x2F;右边的的最高高度，然后进行求解时候直接拿到每列柱子的左右边最高高度，然后拿到这两个高度的最小值，减去自身高度，如果大于零那么就是说明自身不是最高高度，可以存水，直接相加</p><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-100-liked">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                left = Math.max(left,map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i),i);</span><br><span class="line">            max = Math.max(max,i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>滑动窗口的思路，通过不断移动左右边界来获取最大长度，通过一个map帮助我们判断是否含有重复的值，刚开始遍历的时候左右边界都是索引为0，然后右边界开始移动，在移动的过程中如果遇到的值和map中的key都不相同，则以值key索引为value放到map中，通过记录此时的最大边界，如果右边界移动过程中出现和map中的key相同的元素，这时要更新左边界，左边界的值是自身和map中记录的位置的最大值，这是为了防止有其他的元素更新了左边界，然后出现左边界左移的情况</p><h3 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h3><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked">438. 找到字符串中所有字母异位词 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] sArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] pArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; p.length();i++)&#123;</span><br><span class="line">            pArr[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;right &lt; s.length();right++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rigCur</span> <span class="operator">=</span> s.charAt(right) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            sArr[rigCur]++;</span><br><span class="line">            <span class="keyword">while</span>(sArr[rigCur] &gt; pArr[rigCur])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">leftCur</span> <span class="operator">=</span> s.charAt(left) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                sArr[leftCur]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right - left + <span class="number">1</span> == p.length())&#123;</span><br><span class="line">                res.add(left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用两个数组进行是不是异位词进行判断，如果s数组某一个元素对应的值大于p数组对应的值，说明左右指针内的字符串一定不能成为p的异位词，所以此时要移动左指针，直到s数组的值不大于p数组的值，只有这样才有可能成为异位词，然后当左右指针相差3的时候收集即可</p><h3 id="和为k的子数组"><a href="#和为k的子数组" class="headerlink" title="和为k的子数组"></a>和为k的子数组</h3><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked">560. 和为 K 的子数组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] presum = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; presum.length;i++)&#123;</span><br><span class="line">            presum[i] = presum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; presum.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(presum[i] - k))&#123;</span><br><span class="line">                res += map.get(presum[i] - k);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(presum[i],map.getOrDefault(presum[i],<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前缀和 + hashmap的妙用，当求数组连续子序列的时候可以考虑前缀和，前缀和说白了就是高中数列里面的Sn，Sn是数列前n个数的和，当我们要数列中某几个连续数的和的时候，可以让两个Sn相减，比如求第2，3，4个数的和，就是S4 - S1，明白这个道理之后，这道题就变成了两数之和，维护一个presum数组，每个位置表示nums数组第i个数以前的所有数之和(包括i)，这样如果map中数组存在presum[i] - k这个key，那么就在res上进行累加即可，最关键的点在于别忘了map初始化的时候要map.put(0,1),这是为了如果某个前缀和正好是k的时候，说明从nums数组第一个数开始进行累加就能加到k，如果此时map中没有put(0,1)，这时就会少算一种情况</p><h3 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h3><p><a href="https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-100-liked">76.  最小覆盖子串- 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] sa = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">60</span>];</span><br><span class="line">        <span class="type">int</span>[] ta = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">60</span>];</span><br><span class="line">        <span class="type">char</span>[] ch = t.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">tot</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ch.length;i++)&#123;</span><br><span class="line">            ta[getIndex(ch[i])]++;</span><br><span class="line">            <span class="keyword">if</span>(ta[getIndex(ch[i])] == <span class="number">1</span>)&#123;</span><br><span class="line">                tot++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;right &lt; s.length();right++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">indexRight</span> <span class="operator">=</span> getIndex(s.charAt(right));</span><br><span class="line">            sa[indexRight]++;</span><br><span class="line">            <span class="keyword">if</span>(sa[indexRight] == ta[indexRight])&#123;</span><br><span class="line">                tot--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">indexLeft</span> <span class="operator">=</span> getIndex(s.charAt(left));</span><br><span class="line">                <span class="keyword">if</span>(sa[indexLeft] &gt; ta[indexLeft])&#123;</span><br><span class="line">                    sa[indexLeft]--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tot == <span class="number">0</span> &amp;&amp; (ans.length() == <span class="number">0</span>||ans.length() &gt; right - left + <span class="number">1</span>))&#123;</span><br><span class="line">                ans = s.substring(left,right + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span> ? c - <span class="string">&#x27;A&#x27;</span> + <span class="number">26</span> : c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典使用两个数组保存字符串对应字符出现的次数，使用ta数组用来存储目标字符串，使用sa数组用来大字符串，使用tot表示目标字符串不同字符的种类，然后使用左右指针，遍历大字符串，右指针往数组里面添加，如果右指针指向的字符对应的个数大于等于ta数组右指针对应的个数，那么tot的值减一，然后看左指针，如果左指针指针指向的字符对应的个数比ta数组对应位置的值大，这时左指针向右移动，注意不要忘了把sa数组对应左指针的值减一，然后只有当tot &#x3D;&#x3D; 0，并且ans &#x3D;&#x3D; 0或者ans字符串比左右指针包含的字符串长的时候，才对ans的值进行更新</p><h3 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a>轮转数组</h3><p><a href="https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&envId=top-100-liked">189. 轮转数组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">        reverse(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>);</span><br><span class="line">        reverse(nums,<span class="number">0</span>,k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums,k,nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[left];</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            nums[right] = tmp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 nums &#x3D; [1，2，3，4，5，6，7]，k &#x3D; 3，来说，从我们的直观感受来看，就是要把 [5，6，7]这块砍下来挪到数组头部，可是这显然不是原地交换。那有没有什么办法让[5，6，7]这3个元素跑到数组头部呢？那就是将整个数组翻转一次，数组翻转是可以原地实现的，这样 [7，6，5]这3个元素就跑到头部了，我们以下标为k的元素将nums在逻辑上分隔为2个数组，分别是[7，6，5]和[4，3，2，1]，然后分别再进行一次翻转，就可以得到[5，6，7，1，2，3，4]了</p><ol><li>反转整个数组</li></ol><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231207120032469.png" class title="image-20231207120032469"><ol start="2"><li>以k为分界点分别反转</li></ol><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231207120101088.png" class title="image-20231207120101088"><h3 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h3><p><a href="https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-100-liked">238. 除自身以外数组的乘积 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">          ans[i] = j;</span><br><span class="line">          j *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>,j = <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">          ans[i] = ans[i] * j;</span><br><span class="line">          j *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前有一道利用前缀和进行求解，而这道题的思路是前缀积，就是两个for循环，第一for循环先将小于i前半部分的nums[i]相乘，第二个for循环将后半部分nums[i]接着相乘，本题看不懂代码的时候可以举个例子带入帮助理解</p><h3 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h3><p><a href="https://leetcode.cn/problems/first-missing-positive/description/?envType=study-plan-v2&envId=top-100-liked">41. 缺失的第一个正数 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] &gt;= <span class="number">1</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">                 <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[nums[i] - <span class="number">1</span>];</span><br><span class="line">                 nums[nums[i] - <span class="number">1</span>] = nums[i];</span><br><span class="line">                 nums[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n ; i++)</span><br><span class="line">            <span class="keyword">if</span>( nums[i] != i + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题，对于一个长度为n的数组，要返回的答案一定在[1，n+1]之间，数组中的数都满足nums[i] &#x3D; nums[nums[i] - 1]的时候，说明此时结果是n + 1,所以需要对原数组的元素的进行重新排序，也就是尽可能保证nums[i] &#x3D; nums[nums[i] - 1]成立，所以这个地方的思路是如果nums[i] &#x3D; nums[nums[i] - 1]不成立，就对nums[i] 和nums[nums[i] - 1]进行交换，直到交换到成立或者交换来的数不在范围内，才交换下一个数</p><h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h3><p><a href="https://leetcode.cn/problems/palindrome-linked-list/description/?envType=study-plan-v2&envId=top-100-liked">234. 回文链表 - 力扣（LeetCode）</a></p><ul><li>利用集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">            list.add(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list.get(left) != list.get(right))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个思路很简单，就是遍链表，然后把遍历到的链表的值放入一个集合中，然后使用双指针，一个从前向后遍历，一个从后向前遍历，看数值是否相同</p><ul><li>快慢指针+反转链表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(head == <span class="literal">null</span>||head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> tmp;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> tmp;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span>&amp;&amp;fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        slow.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newCur</span> <span class="operator">=</span> pre;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span>(newCur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newCur.val != slow.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            newCur = newCur.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个虚拟头节点，然后快慢指针同时指向这个虚拟头节点，然后遍历的时候快指针以两步的速度向前走，慢指针以一步的速度向前走，这样快指针走到最后一个节点时候，慢指针刚好走到中间节点，然后把中间节点后面的链表进行一个反转链表的操作，这样得两个链表，只需判断这两个链表是不是都相同即可(如果链表节点个数是奇数的时候不用管长链表的最后一个节点即可)</p><h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p><a href="https://leetcode.cn/problems/linked-list-cycle/description/?envType=study-plan-v2&envId=top-100-liked">141. 环形链表 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是使用快慢指针，如果快指针走两步，慢指针走一步，这样如果快慢指针能相遇说明有环</p><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/?envType=study-plan-v2&envId=top-100-liked">21. 合并两个有序链表 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dum;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = list1 != <span class="literal">null</span> ? list1 : list2;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于新合并的链表第一个无处安放，所以使用一个虚拟头节点，把所有合并的节点放到虚拟头节点的后面，使用双指针遍历原始两个链表，cur指针表示当前操作到新链表哪个节点，直到有一个链表为空，由于链表默认升序，所以直接链表节点的val值进行比较，优先放入小的，然后不断更新双指针和cur的指向，最后别忘了，但有一个链表为空的时候，把另外一个链表剩余的节点放到cur节点的后面</p><h3 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h3><p><a href="https://leetcode.cn/problems/add-two-numbers/description/?envType=study-plan-v2&envId=top-100-liked">2. 两数相加 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> l1 == <span class="literal">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> l2 == <span class="literal">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x + y + carry;</span><br><span class="line">            </span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            sum = sum % <span class="number">10</span>;</span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum);</span><br><span class="line"></span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="literal">null</span>)</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">null</span>)</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>) &#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给相同索引位置的两数进行相加，相加结果的个位数部分作为新节点的val，十位数部分用于下两个数的加和，如果两个链表不一样长，那么就给短的链表进行补零，如果链表加完以后，别忘了看看十位是不是还是1，如果是1，还需要创建一个新节点</p><h3 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h3><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&envId=top-100-liked">25. K 个一组翻转链表 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head; cur != <span class="literal">null</span>; cur = cur.next)</span><br><span class="line">            n++; </span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p0</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">        <span class="keyword">for</span>(;n - k &gt;= <span class="number">0</span>;n -= k)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; ++i) &#123; <span class="comment">// 同 92 题</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">nxt</span> <span class="operator">=</span> cur.next;</span><br><span class="line">                cur.next = pre; <span class="comment">// 每次循环只修改一个 next，方便大家理解</span></span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = nxt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">nxt</span> <span class="operator">=</span> p0.next;</span><br><span class="line">            p0.next.next = cur;</span><br><span class="line">            p0.next = pre;</span><br><span class="line">            p0 = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接看<a href="https://www.bilibili.com/video/BV1sd4y1x7KN/?spm_id_from=333.337.search-card.all.click&vd_source=62304e716ad825965bf0000c5383ffbc">反转链表【基础算法精讲 06】_哔哩哔哩_bilibili</a>对于反转链表，反转链表Ⅱ，和本题做了总结，讲的很好反复看</p><h3 id="随机链表复制"><a href="#随机链表复制" class="headerlink" title="随机链表复制"></a>随机链表复制</h3><p><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/description/?envType=study-plan-v2&envId=top-100-liked">138. 随机链表的复制 - 力扣（LeetCode）</a></p><ul><li>使用map</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        Map&lt;Node,Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val);</span><br><span class="line">            map.put(cur,node);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> map.get(cur);</span><br><span class="line">            <span class="keyword">if</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                tmp.next = map.get(cur.next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.random != <span class="literal">null</span>)&#123;</span><br><span class="line">                tmp.random = map.get(cur.random);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用map集合帮助我们保存新链表和旧链表的对应关系，然后第一次遍历原链表的时候，创建新节点，然后把原链表的节点作为key，新创建的节点作为value放入map中，这时的新创建的节点没有next和random关系，所以再次遍历原链表，这样就可以把节点之间对应进行连接</p><ul><li>不使用map</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//第一步，在每个原节点后面创建一个新节点</span></span><br><span class="line">        <span class="comment">//1-&gt;1&#x27;-&gt;2-&gt;2&#x27;-&gt;3-&gt;3&#x27;</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(p.val);</span><br><span class="line">            newNode.next = p.next;</span><br><span class="line">            p.next = newNode;</span><br><span class="line">            p = newNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="comment">//第二步，设置新节点的随机节点</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.random!=<span class="literal">null</span>) &#123;</span><br><span class="line">                p.next.random = p.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>);</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">//第三步，将两个链表分离</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">null</span>) &#123;</span><br><span class="line">            cur.next = p.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            p.next = cur.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231216124622131.png" class title="image-20231216124622131"><p>最后把两个链表分离</p><h3 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h3><p><a href="https://leetcode.cn/problems/sort-list/description/?envType=study-plan-v2&envId=top-100-liked">148. 排序链表 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head; <span class="comment">//慢指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next; <span class="comment">//快指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">null</span> &amp;&amp; fast.next!=<span class="literal">null</span>)&#123; <span class="comment">//快慢指针找到链表中点</span></span><br><span class="line">            slow = slow.next; <span class="comment">//慢指针走一步</span></span><br><span class="line">            fast = fast.next.next; <span class="comment">//快指针走两步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">rightHead</span> <span class="operator">=</span> slow.next; <span class="comment">//链表第二部分的头节点</span></span><br><span class="line">        slow.next = <span class="literal">null</span>; <span class="comment">//cut 链表</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> sortList(head); <span class="comment">//递归排序前一段链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> sortList(rightHead); <span class="comment">//递归排序后一段链表</span></span><br><span class="line">        <span class="keyword">return</span> merge(left,right);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode h1,ListNode h2)</span>&#123; <span class="comment">//合并两个有序链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(h1!=<span class="literal">null</span> &amp;&amp; h2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(h1.val &lt; h2.val)&#123;</span><br><span class="line">                p.next = h1;</span><br><span class="line">                h1 = h1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p.next = h2;</span><br><span class="line">                h2 = h2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(h1!=<span class="literal">null</span>)&#123;</span><br><span class="line">            p.next = h1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p.next = h2;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归，不断把链表从中间拆开，直到只剩下一个节点，然后最后一次拆开的两个节点进行大小排序然后连接，这样不断向上返回每一段的头节点，做最终的合并</p><h3 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表</h3><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/?envType=study-plan-v2&envId=top-100-liked">23. 合并 K 个升序链表 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merge(lists,<span class="number">0</span>,lists.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode[] lists, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lo == hi)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists[lo];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> merge(lists,lo,mid);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> merge(lists,mid + <span class="number">1</span>,hi);</span><br><span class="line">        <span class="keyword">return</span> merge2Lists(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">merge2Lists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">                tail.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail.next = l1 == <span class="literal">null</span>? l2: l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路就是从链表数组中取出每一段，然后两两合并，如下图</p><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231218130430347.png" class title="image-20231218130430347"><h3 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h3><p><a href="https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&envId=top-100-liked">146. LRU 缓存 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        ListNode pre;</span><br><span class="line">        ListNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> key,<span class="type">int</span> value)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    ListNode head;</span><br><span class="line">    ListNode tail;</span><br><span class="line">    Map&lt;Integer,ListNode&gt; map;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>,-<span class="number">1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>,-<span class="number">1</span>);</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            refush(node);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            node = map.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.size() == capacity)&#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> tail.pre;</span><br><span class="line">                del(last);</span><br><span class="line">                map.remove(last.key);</span><br><span class="line">            &#125;</span><br><span class="line">            node = <span class="keyword">new</span> <span class="title class_">ListNode</span>(key,value);</span><br><span class="line">            map.put(key,node);</span><br><span class="line">        &#125;</span><br><span class="line">        refush(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">refush</span><span class="params">(ListNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.pre != head)&#123;</span><br><span class="line">            del(node);</span><br><span class="line">            node.pre = head;</span><br><span class="line">            head.next.pre = node;</span><br><span class="line">            node.next = head.next;</span><br><span class="line">            head.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(ListNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.pre != <span class="literal">null</span>)&#123;</span><br><span class="line">            node.pre.next = node.next;</span><br><span class="line">            node.next.pre = node.pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较简单，就是别忘了在调用get方法的时候需要把节点放到链表头部，调用put方法不管是新来的节点还是修改原来节点值都需要把该节点放到链表头部</p><h3 id="二叉树直径"><a href="#二叉树直径" class="headerlink" title="二叉树直径"></a>二叉树直径</h3><p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked">543. 二叉树的直径 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        getHight(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHight</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getHight(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getHight(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> Math.max(left,right) + <span class="number">1</span>;</span><br><span class="line">        ans = Math.max(ans,left + right);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉树的直径对于每个节点来说，就是左子树的高度加上右子树的高度，但是需要注意的是，最大的直径不一定经过根节点，例如形如下图的二叉树，所以需要维护一个ans遍历实时记录以当前节点为根的最大直径</p><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231221115318910.png" class title="image-20231221115318910"><h3 id="二叉树遍历总结"><a href="#二叉树遍历总结" class="headerlink" title="二叉树遍历总结"></a>二叉树遍历总结</h3><p>二叉树的前中后序迭代遍历：都是使用Stack，然后前后序遍历先把中节点放到栈中，然后再分别放入右左&#x2F;左右节点，而中序遍历是一路向左把节点放入栈中</p><p>二叉树的层序遍历：使用Deque，加入和弹出的方法是addLast和pollFirst，每次在队列头拿出一个节点，都要从队列尾加入该节点的左右孩子</p><h3 id="二叉树中第k小的元素"><a href="#二叉树中第k小的元素" class="headerlink" title="二叉树中第k小的元素"></a>二叉树中第k小的元素</h3><p><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/?envType=study-plan-v2&envId=top-100-liked">230. 二叉搜索树中第K小的元素 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> count,res;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = k;</span><br><span class="line">        find(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        find(cur.left);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(--count == <span class="number">0</span>)&#123;</span><br><span class="line">            res = cur.val;</span><br><span class="line">        &#125;</span><br><span class="line">        find(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>维护两个变量，一个res用来记录结果，一个count用来计数，由于二叉搜索树的中序遍历特点，当计数器减为0的时候记录此时节点的val，就是第k小的元素，后面的节点就不需要遍历了</p><h3 id="二叉树右视图"><a href="#二叉树右视图" class="headerlink" title="二叉树右视图"></a>二叉树右视图</h3><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/description/">199. 二叉树的右视图 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        find(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(TreeNode cur,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(depth == res.size())&#123;</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">        find(cur.right,depth);</span><br><span class="line">        find(cur.left,depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个解法很神奇，二叉树前序遍历<strong>中左右</strong>的时候，就总是优先访问最左边的节点，所以要求右视图的时候，就可以使用中右左的顺序，这样能保证优先访问的是最右边的节点，然后根节点的左子树也有可能在右视图中看见(左子树的深度比右子树深)，所以维护一个深度变量，只有深度和集合的大小相等时候才往集合里面进行添加</p><h3 id="二叉树转链表"><a href="#二叉树转链表" class="headerlink" title="二叉树转链表"></a>二叉树转链表</h3><p><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&envId=top-100-liked">114. 二叉树展开为链表 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;TreeNode&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;TreeNode&gt;();</span><br><span class="line">dfs(root,res);</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> res.get(<span class="number">0</span>);</span><br><span class="line">head.left = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; res.size();i++) &#123;</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> res.get(i);</span><br><span class="line">tmp.left = <span class="literal">null</span>;</span><br><span class="line">head.right = tmp;</span><br><span class="line">head = head.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, List&lt;TreeNode&gt; res)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">res.add(root);</span><br><span class="line">dfs(root.left,res);</span><br><span class="line">dfs(root.right,res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用前序遍历把树里面的所有节点放到一个集合中，然后遍历集合中的节点，重新构造父子节点关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line">                <span class="keyword">while</span>(tmp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    tmp = tmp.right;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp.right = root.right;</span><br><span class="line">                root.right = root.left;</span><br><span class="line">                root.left = <span class="literal">null</span>;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上代码过程如下</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将 1 的左子树插入到右子树的地方</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>         <span class="number">5</span></span><br><span class="line">     / \         \</span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>         <span class="number">6</span>        </span><br><span class="line"><span class="comment">//将原来的右子树接到左子树的最右边节点</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">     / \          </span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>  </span><br><span class="line">         \</span><br><span class="line">          <span class="number">5</span></span><br><span class="line">           \</span><br><span class="line">            <span class="number">6</span></span><br><span class="line">            </span><br><span class="line"> <span class="comment">//将 2 的左子树插入到右子树的地方</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       \          </span><br><span class="line">        <span class="number">3</span>       <span class="number">4</span>  </span><br><span class="line">                 \</span><br><span class="line">                  <span class="number">5</span></span><br><span class="line">                   \</span><br><span class="line">                    <span class="number">6</span>   </span><br><span class="line">        </span><br><span class="line"> <span class="comment">//将原来的右子树接到左子树的最右边节点</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       \          </span><br><span class="line">        <span class="number">3</span>      </span><br><span class="line">         \</span><br><span class="line">          <span class="number">4</span>  </span><br><span class="line">           \</span><br><span class="line">            <span class="number">5</span></span><br><span class="line">             \</span><br><span class="line">              <span class="number">6</span>         </span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="路径总和Ⅲ"><a href="#路径总和Ⅲ" class="headerlink" title="路径总和Ⅲ"></a>路径总和Ⅲ</h3><p><a href="https://leetcode.cn/problems/path-sum-iii/description/?envType=study-plan-v2&envId=top-100-liked">437. 路径总和 III - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="type">int</span> target;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        target = targetSum;</span><br><span class="line">        dfs1(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs1</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs2(cur,cur.val);</span><br><span class="line">        dfs1(cur.left);</span><br><span class="line">        dfs1(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs2</span><span class="params">(TreeNode cur,<span class="type">long</span> curVal)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curVal == target)&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            dfs2(cur.left,curVal + cur.left.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            dfs2(cur.right,curVal + cur.right.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力递归，dfs1递归找到二叉树的所有节点，然后dfs2递归找到以每一个节点为根加上其子节点的所有值，注意计算值的时候使用long这个数据类型，因为有的测试用例超过了int的范围</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Long, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> res, t;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> _t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(<span class="number">0L</span>,<span class="number">1</span>);</span><br><span class="line">        t = _t;</span><br><span class="line">        dfs(root,root.val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode cur,<span class="type">long</span> curVal)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(curVal - t))&#123;</span><br><span class="line">            res += map.get(curVal - t);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(curVal,map.getOrDefault(curVal,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            dfs(cur.left,curVal + cur.left.val);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            dfs(cur.right,curVal + cur.right.val);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(curVal,map.getOrDefault(curVal,<span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用前缀和的思路，因为这是二叉树所以不会成环(也就是一路向下不会回头)，前缀和就是在遍历的过程中把所有的节点的前缀和作为key，该前缀和的总数作为value存到map中，这样当遍历到每一个节点的时候只需要判断当前节点的前缀和减去目标值的结果是否存在于map中，最后别忘了当前节点回退的时候要把map中对应的值减一，也别忘了初始化map的时候，0要提前初始化为1，为了当前节点的前缀和就是目标值的时候使用</p><h3 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h3><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?envType=study-plan-v2&envId=top-100-liked">124. 二叉树中的最大路径和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> dfs(cur.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> dfs(cur.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.val;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            tmp += left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            tmp += right;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res,tmp);</span><br><span class="line">        <span class="keyword">return</span> Math.max(cur.val,Math.max(left,right) + cur.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用后序遍历，自底向上，递归得到每一个节点，然后以这个节点为跟，看他的左右孩子是否大于零，如果大于零说明路径的值有促进作用，可以和当前的最大值进行比较，然后不断更新最大值，注意向上返回的时候不能左右孩子都选，只能选一个最大的加上当前值，和当前值作比较</p><h3 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h3><p><a href="https://leetcode.cn/problems/generate-parentheses/description/?envType=study-plan-v2&envId=top-100-liked">22. 括号生成 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();     <span class="comment">// 结果集合</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();     <span class="comment">// 括号组合字符串，初始为空</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        backtracking(n, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> lbs, <span class="type">int</span> rbs)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rbs == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 右括号数量也为0时，左括号数量一定是不多于右括号的也为0，即生成一个括号组合</span></span><br><span class="line">            res.add(s.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 仅当右括号多于左括号的时候，可以填入一个右括号；</span></span><br><span class="line">        <span class="keyword">if</span>(lbs &lt; rbs)&#123;</span><br><span class="line">            s.append(<span class="string">&#x27;)&#x27;</span>);     <span class="comment">// 追加一个右括号</span></span><br><span class="line">            backtracking(lbs, rbs - <span class="number">1</span>);   <span class="comment">// 右括号剩余数目-1，然后递归组合剩余的括号</span></span><br><span class="line">            s.deleteCharAt(s.length() - <span class="number">1</span>);         <span class="comment">// 状态回退，看看这个位置还能不能填一个左括号</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 仅当左括号剩余数量不为0时，可以填入一个左括号；</span></span><br><span class="line">        <span class="keyword">if</span>(lbs != <span class="number">0</span>)&#123;</span><br><span class="line">            s.append(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            backtracking(lbs - <span class="number">1</span>, rbs);</span><br><span class="line">            s.deleteCharAt(s.length() - <span class="number">1</span>);    <span class="comment">// 状态回退，将这个位置空出来再其他情况下填入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>严格控制右括号的数量少于左括号即可</p><h3 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h3><p><a href="https://leetcode.cn/problems/word-search/description/?envType=study-plan-v2&envId=top-100-liked">79. 单词搜索 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">0</span>;i &lt; board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board,ch,i,j,<span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board,<span class="type">char</span>[] ch,<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span>||i &gt;= board.length||j &lt; <span class="number">0</span>||j &gt;= board[<span class="number">0</span>].length||board[i][j] != ch[index])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index == ch.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> dfs(board,ch,i + <span class="number">1</span>,j,index + <span class="number">1</span>) || dfs(board,ch,i - <span class="number">1</span>,j,index + <span class="number">1</span>) ||</span><br><span class="line">                        dfs(board,ch,i,j + <span class="number">1</span>,index + <span class="number">1</span>) || dfs(board,ch,i,j - <span class="number">1</span>,index + <span class="number">1</span>);</span><br><span class="line">        board[i][j] = ch[index];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以board中每一个字母为单词的开始，分别向上下左右分别寻找单词的下一个字母，寻找的过程中如果超过了board的范围或者字母与规定的字母不相同，那么直接返回false，也就是说，如果代码执行到了这里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(index == ch.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> dfs(board,ch,i + <span class="number">1</span>,j,index + <span class="number">1</span>) || dfs(board,ch,i - <span class="number">1</span>,j,index + <span class="number">1</span>) ||</span><br><span class="line">                        dfs(board,ch,i,j + <span class="number">1</span>,index + <span class="number">1</span>) || dfs(board,ch,i,j - <span class="number">1</span>,index + <span class="number">1</span>);</span><br><span class="line">        board[i][j] = ch[index];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><p>那么至少能说明，当前遍历到的字母，和单词指定的字母是一致的，然后再次上下左右寻找即可，别忘了遍历到的单词要使用其他字符占用，表示已经使用过了</p><h3 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h3><p><a href="https://leetcode.cn/problems/search-insert-position/description/?envType=study-plan-v2&envId=top-100-liked">35. 搜索插入位置 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[tmp] &gt; target)&#123;</span><br><span class="line">                right = tmp - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[tmp] &lt; target)&#123;</span><br><span class="line">                left = tmp + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和二分查找的思路一样，难点在于在区间减小的过程中，如果没有找到和target相等的位置，该如何返回？</p><p>这种情况可以通过逆推帮助理解：</p><p>因为此时的left一定在right的右边一位，构成了不合法的区间导致循环退出，导致区间不合法的原因无非两个，一个是right &#x3D; tmp - 1，一个是left &#x3D; tmp + 1，导致right &#x3D; tmp - 1的是nums[tmp] &gt; target，说明target正好比nums[right - 1]大一位，导致left &#x3D; tmp + 1的是nums[tmp] &lt; target，说明target比nums[tmp]大一位，除二是向下取整得到的tmp，所以left + 1就是要插入的索引位置</p><h3 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a>搜索二维矩阵</h3><p><a href="https://leetcode.cn/problems/search-a-2d-matrix/description/?envType=study-plan-v2&envId=top-100-liked">74. 搜索二维矩阵 - 力扣（LeetCode）</a></p><ul><li>大数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] mat, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> mat.length, n = mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = m * n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mat[mid / n][mid % n] &lt; t) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(mat[mid / n][mid % n] &gt; t)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把一个二维数组抽象成一个整体单调递增的大一维数组，元素在一维数组中的索引除以二维数组单行长度就是该元素在二维数组的行，元素在一维数组中的索引模上二维数组单行的长度就是该元素在二维数组的列，然后使用传统二分查找即可</p><ul><li>两次二分</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] mat, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> mat.length, n = mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (mat[mid][<span class="number">0</span>] &lt; t) &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(mat[mid][<span class="number">0</span>] &gt; t)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> r;</span><br><span class="line">        <span class="keyword">if</span> (mat[row][<span class="number">0</span>] == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mat[row][<span class="number">0</span>] &gt; t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        l = <span class="number">0</span>; r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (mat[row][mid] &lt; t) &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(mat[row][mid] &gt; t)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mat[row][col] == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次二分找到target对应的行，第二次二分找到target对应的列</p><h3 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h3><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> lowerBound(nums,target);</span><br><span class="line">        <span class="keyword">if</span>(start == nums.length || nums[start] != target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> lowerBound(nums,target + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start,end&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowerBound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后写二分查找就认定闭区间的写法，记住return left 或者 right + 1 就是要找的元素的索引位置</p><p>对于本题来说，如果存在第一个位置，那么一定存在最后一个位置，所以两次二分查找，第一次传入要找的target，这样找到的就是第一个元素，然后第二次二分查找，传入target + 1，然后对返回的索引位置减一就是最后一个的位置</p><h3 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h3><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked">33. 搜索旋转排序数组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isWhere(nums,target,mid))&#123;</span><br><span class="line">                right = mid  - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = left + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left &lt; nums.length &amp;&amp; nums[left] == target ? left : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isWhere</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target,<span class="type">int</span> mid)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; nums[end])&#123;</span><br><span class="line">            <span class="keyword">return</span> target &gt; nums[end] &amp;&amp; target &lt; nums[mid];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> target &gt; nums[end] || target &lt; nums[mid];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思想就是找到两端数组的分界点，分别二分查找这两段而递增数组，但是这样时间是高于O(logn)的，所以改进版思路就是用数组最后一个数字和中间值进行比较，最后一个值的特点是：它在第二段递增数组中是最大的，但是它不可能比第一段递增数组中任何一个数字大，所以当中间值大于最后一个值得时候，说明前半段更长，再比较target和中间值得大小当target大于数组最后一个值但是小于中间值得时候动右指针，反之则动左指针</p><h3 id="寻找旋转排序数组中的最小值"><a href="#寻找旋转排序数组中的最小值" class="headerlink" title="寻找旋转排序数组中的最小值"></a>寻找旋转排序数组中的最小值</h3><p><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked">153. 寻找旋转排序数组中的最小值 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[len - <span class="number">1</span>] &lt; nums[len - <span class="number">2</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[len  - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) /<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[len - <span class="number">1</span>])&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于上一题得简化版，因为最小值就在两端递增数组的分界点，所以还是上一题的思路，用中间值和最后一个值比较，如果中间值比最后一个值大，那么说明分界点在中间值的右边，所以左指针需要移动，如果中间值比最后一个值小，说明分界点在中间值左边，所以需要移动右指针，注意单独处理最小值在数组开头和结尾的情况，因为那两个地方会出现数组越界</p><h3 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h3><p><a href="https://leetcode.cn/problems/decode-string/description/?envType=study-plan-v2&envId=top-100-liked">394. 字符串解码 - 力扣（LeetCode）</a></p><ul><li>栈</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">multi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        Deque&lt;Integer&gt; stack_multi = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;String&gt; stack_res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Character c : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; c &gt;= <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                multi = multi * <span class="number">10</span> + Integer.parseInt(c + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                stack_multi.addLast(multi);</span><br><span class="line">                stack_res.addLast(res.toString());</span><br><span class="line">                multi = <span class="number">0</span>;</span><br><span class="line">                res = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmpMulti</span> <span class="operator">=</span> stack_multi.removeLast();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; tmpMulti;i++)&#123;</span><br><span class="line">                    tmp.append(res);</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stack_res.removeLast() + tmp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于存在括号中套括号的情况，所以可以使用栈来解决：</p><ul><li>当遍历到的字符是数字的时候，直接计算该乘数，后面会放到stack_multi这个栈中，用于循环</li><li>当遍历到是字母的时候，直接在res后面追加字符，用于后面的循环操作</li><li>当遍历到的是’[‘的时候，需要先把乘数和字符串都放到各自栈中，因为’[‘里面可能还会有’]’</li><li>当遍历到的是’]’的时候，就是真正计算循环结果的时候，从stack_multi拿到当前需要重复的次数，把当前的res进行重复，然后栈顶的字符拼接用于下一次重复</li></ul><hr><ul><li>递归</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, <span class="number">0</span>)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String[] dfs(String s, <span class="type">int</span> i) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">multi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">                multi = multi * <span class="number">10</span> + Integer.parseInt(String.valueOf(s.charAt(i))); </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                String[] tmp = dfs(s, i + <span class="number">1</span>);</span><br><span class="line">                i = Integer.parseInt(tmp[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">while</span>(multi &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res.append(tmp[<span class="number">1</span>]);</span><br><span class="line">                    multi--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;]&#x27;</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; String.valueOf(i), res.toString() &#125;;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                res.append(String.valueOf(s.charAt(i)));</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; res.toString() &#125;;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h3><p><a href="https://leetcode.cn/problems/min-stack/description/?envType=study-plan-v2&envId=top-100-liked">155. 最小栈 - 力扣（LeetCode）</a></p><ul><li>两个栈</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack stack;</span><br><span class="line">    <span class="keyword">private</span> Stack min_stack;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        min_stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        stack.push(val);</span><br><span class="line">        <span class="keyword">if</span>(min_stack.isEmpty() || val &lt;= (<span class="type">int</span>)min_stack.peek())&#123;</span><br><span class="line">            min_stack.push(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> (<span class="type">int</span>)stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(tmp == (<span class="type">int</span>)min_stack.peek())&#123;</span><br><span class="line">            min_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)min_stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过两个栈来实现，一个栈存放所有数据，另一个栈的栈顶存放的是当前栈的最小值</p><ul><li>一个链表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="type">int</span> min;</span><br><span class="line">        Node next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value,<span class="type">int</span> min)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.min = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            head = <span class="keyword">new</span> <span class="title class_">Node</span>(x,x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(x,Math.min(x,head.min));</span><br><span class="line">            node.next = head;</span><br><span class="line">            head = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        head = head.next;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head.min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>维护的每一个链表节点，都存放当前最小值</p><ul><li>一个栈</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= min)&#123;</span><br><span class="line">            stack.push(min);</span><br><span class="line">            min = x;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.pop() == min)&#123;</span><br><span class="line">            min = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个int类型的变量才存放当前的最小值，当向栈中放入一个比最小值更小或者和最小值相等的值的时候，这时候需要先把最小值放入栈中，然后更新最小值，再把要放入的值放入栈中，弹出的时候要判断弹出的值是否和最小值相等，如果相等再弹出一个并更新最小值</p><h3 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h3><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/?envType=study-plan-v2&envId=top-100-liked">215. 数组中的第K个最大元素 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &lt; k || x &gt; pq.peek())&#123;</span><br><span class="line">                pq.add(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &gt; k)&#123;</span><br><span class="line">                pq.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个升序排列的优先队列，帮助排序数组中的元素，这时如果队列的大小正好是k的话，那么在遍历完一遍数组的时候，优先队列的顶部就是第k大元素</p><h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><p><a href="https://leetcode.cn/problems/pascals-triangle/description/?envType=study-plan-v2&envId=top-100-liked">118. 杨辉三角 - 力扣（LeetCode）</a></p><ul><li>动态规划</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"><span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[numRows][numRows];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; numRows; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;=i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">0</span>)dp[i][j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+dp[i-<span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">List&lt;Integer&gt; tmp=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; dp.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(dp[i][j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">tmp.add(dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmp));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>递归</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> numRows)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(numRows == <span class="number">1</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            res.get(<span class="number">0</span>).add(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        res = generate(numRows - <span class="number">1</span>);</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; numRows - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            list.add(res.get(numRows - <span class="number">2</span>).get(i - <span class="number">1</span>) + res.get(numRows - <span class="number">2</span>).get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        res.add(list);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>numRows - 1表示上一次递归时杨辉三角对应层的元素个数，numRows - 2表示对应其在res中的索引位置</p><h3 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h3><p><a href="https://leetcode.cn/problems/maximum-product-subarray/?envType=study-plan-v2&envId=top-100-liked">152. 乘积最大子数组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmpMax</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmpMin</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> tmpMax;</span><br><span class="line">                tmpMax = tmpMin;</span><br><span class="line">                tmpMin = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            tmpMax = Math.max(nums[i],nums[i] * tmpMax);</span><br><span class="line">            tmpMin = Math.min(nums[i],nums[i] * tmpMin);</span><br><span class="line">            res = Math.max(res,tmpMax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为数组中存在负数，所以计算的当前最大值很可能回一下子就变成最小值，而最小值一下变成最大值，所以<strong>不但要实时记录当前的最大值还要实时记录最小值</strong>，这个值的变更是根据遍历到的数组中的值与该值乘上当前最大值的乘积，如果遍历到的值是负数，那么当前的最大最小值交换就可以保证乘完之后大小关系一定不变</p><h3 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h3><p><a href="https://leetcode.cn/problems/single-number/?envType=study-plan-v2&envId=top-100-liked">136. 只出现一次的数字 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">                res = res ^ nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想找到只出现一次的数字要想到异或(1 ^ 1 &#x3D; 0,0 ^ 0 &#x3D; 0,1 ^ 0 &#x3D; 1,0 ^ 1 &#x3D; 1)</p><h3 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h3><p><a href="https://leetcode.cn/problems/majority-element/description/?envType=study-plan-v2&envId=top-100-liked">169. 多数元素 - 力扣（LeetCode）</a></p><ul><li>投票法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == res)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(--count == <span class="number">0</span>)&#123;</span><br><span class="line">                res = nums[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先假设数组第一个元素就是多数元素，然后此时票数是一，向后遍历数组，如果遍历到元素是假设的值，那么票数加一，否则减一，如果票数减为零了，就更新假设元素为当前值，最后剩下的就是多数元素</p><ul><li>排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多数元素在数组排序以后中间位置一定是多数元素</p><h3 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a>颜色分类</h3><p><a href="https://leetcode.cn/problems/sort-colors/description/?envType=study-plan-v2&envId=top-100-liked">75. 颜色分类 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n0</span> <span class="operator">=</span> <span class="number">0</span>, n1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(num &lt; <span class="number">2</span>)&#123;</span><br><span class="line">                nums[n1++] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &lt; <span class="number">1</span>)&#123;</span><br><span class="line">                nums[n0++] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先把数组中所有的数都先备份一个，然后赋值为2，当备份的数小于2的时候，赋值为1，当备份的数小于1的时候，赋值为0。也就是先保证2的位置都正确，再保证1的位置都正确，最后是零的位置都正确，n0和n1分别表示要写入0的索引位置和要写入1的索引位置</p><h2 id="排序数组"><a href="#排序数组" class="headerlink" title="排序数组"></a>排序数组</h2><p><a href="https://leetcode.cn/problems/sort-an-array/description/">912. 排序数组 - 力扣（LeetCode）</a></p><ul><li>选择排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] chooseSort(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;j &lt; nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[minIndex])&#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = nums[minIndex];</span><br><span class="line">            nums[minIndex] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先从0到n - 1的范围内找到最小的值然后和范围内索引最小位置的值交换，然后是1到n - 1的范围，以此类推</p><ul><li>冒泡排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maopaoSort(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[j - <span class="number">1</span>])&#123;</span><br><span class="line">                swap(nums,j,j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从头开始两两比较，较大的数往后靠，这样就保证了最大数一直在最后面</p><ul><li>插入排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] insertSort(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span>(index &gt; <span class="number">0</span> &amp;&amp; nums[index] &lt; nums[index - <span class="number">1</span>])&#123;</span><br><span class="line">                swap(nums,index,index - <span class="number">1</span>);</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先保证0到0的位置有序，然后1位置的从后向前比较排序，然后就保证了0到1范围内的数字有序，然后2位置的数字从后向前比较排序</p><ul><li>归并排序(递归版)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">50001</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[MAX];</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort1</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">       mergeSort1(nums,left,mid);</span><br><span class="line">       mergeSort1(nums,mid + <span class="number">1</span>,right);</span><br><span class="line">       merge(nums,left,mid,right);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left;</span><br><span class="line">       <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> left;</span><br><span class="line">       <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(a &lt;= mid &amp;&amp; b &lt;= right)&#123;</span><br><span class="line">           help[index++] = nums[a] &lt;= nums[b] ? nums[a++] : nums[b++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(a &lt;= mid)&#123;</span><br><span class="line">           help[index++] = nums[a++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(b &lt;= right)&#123;</span><br><span class="line">           help[index++] = nums[b++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;i &lt;= right;i++)&#123;</span><br><span class="line">           nums[i] = help[i];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>思路是把一个数组从中间分开，然后保证左右两边都有序，然后合并这两段有序数组，合并的时候需要用到一个辅助数组，在辅助数组中排好序后，在拷贝到原始的nums数组中</p><ul><li>归并排序(非递归版)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort2</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> left,mid,right, step = <span class="number">1</span>;step &lt; nums.length;step *= <span class="number">2</span>)&#123;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; nums.length)&#123;</span><br><span class="line">            mid = left + step - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid &gt;= nums.length)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            right = Math.min(left + (step &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>,nums.length - <span class="number">1</span>);</span><br><span class="line">            merge(nums,left,mid,right);</span><br><span class="line">            left = right + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用步长的方式控制每次合并的两个数组的长度，步长每次扩大二倍，中间位置就是左数组的开始加上步长再减一，右数组的开始就是中间位置加一，右数组的结束要在数组的最大索引长度和左数组开始加二倍步长减一这两个位置取最小值，防止右数组的长度越界</p><h2 id="左神"><a href="#左神" class="headerlink" title="左神"></a>左神</h2><h3 id="二叉树的锯齿形层序遍历"><a href="#二叉树的锯齿形层序遍历" class="headerlink" title="二叉树的锯齿形层序遍历"></a>二叉树的锯齿形层序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        TreeNode[] queue = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[<span class="number">2001</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">state</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            queue[right++] = root;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> right - left;</span><br><span class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> state ? right - <span class="number">1</span> : left,j = state ? -<span class="number">1</span> : <span class="number">1</span>,k = <span class="number">0</span>;k &lt; size;i += j,k++)&#123;</span><br><span class="line">                    list.add(queue[i].val);</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(list);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue[left++];</span><br><span class="line">                    <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                        queue[right++] = node.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                        queue[right++] = node.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                state = !state;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用数组加双指针的形式来模仿一个队列，刚开始左右指针都指向零位置，往里加数组的时候，right++，需要取数字的时候left++，这样就形成了一个链表，使用state标志来判断是正序添加还是倒序添加，如果state为false则从l —- r - 1收集，否则从r - 1 —— l收集，然后处理完该层以后，该层的节点有左加左，有右加右，并调整左指针的位置</p><h3 id="二叉树最大宽度"><a href="#二叉树最大宽度" class="headerlink" title="二叉树最大宽度"></a>二叉树最大宽度</h3><p><a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/description/">662. 二叉树最大宽度 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        TreeNode[] tq = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[<span class="number">3001</span>];</span><br><span class="line">        <span class="type">int</span>[] iq = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3001</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            tq[right] = root;</span><br><span class="line">            iq[right++] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                ans = Math.max(ans,iq[right - <span class="number">1</span>] - iq[left] + <span class="number">1</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> right - left;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> tq[left];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> iq[left++];</span><br><span class="line">                    <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                        tq[right] = node.left;</span><br><span class="line">                        iq[right++] = index * <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                        tq[right] = node.right;</span><br><span class="line">                        iq[right++] = (index * <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求宽度说明是在每一层中求，所以还是先使用层序遍历的方式来处理每一层，但是还需要额外维护一个数组用来记录每个加入数组的节点的下标，一层中最右边的下标大小减去最左边的下标大小再加一就是对应的宽度，对于一个节点，其左孩子的下标就是其父节点的二倍，右孩子是其父节点的二倍加一</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程笔记</title>
      <link href="/2023/07/23/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/23/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="并发编程笔记"><a href="#并发编程笔记" class="headerlink" title="并发编程笔记"></a>并发编程笔记</h2><h4 id="wait-amp-notify"><a href="#wait-amp-notify" class="headerlink" title="wait&amp;notify"></a>wait&amp;notify</h4><ul><li>原理</li></ul><p>已经获得锁的线程发现后续的运行不满足条件时，会调用wait方法，线程状态变成waiting，此时和等待锁的线程一样处于阻塞状态，不会占用CPU的时间片，只有当其他线获取到锁并且满足此线程运行的条件后，调用**notify(挑一个线程唤醒)或者notifyAll(唤醒所有线程)**方法唤醒该线程，使得该线程重新进入到队列中重新争抢锁</p><img src="/2023/07/23/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20230723173807210.png" class title="image-20230723173807210"><ul><li>wait&amp;sleep</li></ul><ol><li>区别</li></ol><p>①wait是Object的方法，sleep是Thread的方法</p><p>②调用wait会释放掉锁，而sleep还会占用着锁</p><p>③sleep不需要配合synchronized使用，wait必须要获得到锁才能调用，所以必须配合synchronized使用</p><ol start="2"><li>相同点：</li></ol><p>调用wait和sleep都会使线程进入到TIMED_WAITING状态</p><ul><li>wait&amp;notify的正确使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可能不满足条件的线程部分</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    <span class="keyword">while</span>(!条件不成立)&#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//干活代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改条件使以上线程继续运行的线程部分</span></span><br><span class="line">lock.notifyAll();</span><br></pre></td></tr></table></figure><p><strong>wait一般和notifyAll配合使用，如果使用的是notify，且该锁对象中有多个调用了wait方法的线程，此时因为随机唤醒线程的原因，会导致虚假唤醒的发生</strong></p><h4 id="同步模式-保护性暂停"><a href="#同步模式-保护性暂停" class="headerlink" title="同步模式-保护性暂停"></a>同步模式-保护性暂停</h4><p><em>一个线程需要等待另一个线程的执行结果</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">protectStop</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;等待获取&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> guardedObject.get(<span class="number">2000</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;结果为：&#123;&#125;&quot;</span>,o);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行任务&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                guardedObject.complete(res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">        <span class="comment">//记录开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//记录经历时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">passTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (timeout - passTime &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.wait(timeout - passTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                passTime = System.currentTimeMillis() - begin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.response = obj;</span><br><span class="line">            <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="join原理"><a href="#join原理" class="headerlink" title="join原理"></a>join原理</h4><p><em>与保护性暂停的原理相同，都是根据开始时间和经过时间进行判断</em></p><ul><li>源码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校长书籍推荐</title>
      <link href="/2023/07/03/%E6%A0%A1%E9%95%BF%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"/>
      <url>/2023/07/03/%E6%A0%A1%E9%95%BF%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<img src="/2023/07/03/%E6%A0%A1%E9%95%BF%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/image-20230703172235266.png" class title="image-20230703172235266"><p>MySQL性能优化指南（提高实操性）</p><p>MySQL技术内幕：innodb存储引擎</p><p>深入理解Java虚拟机：看2，3，7，8，12章</p><p>并发编程的艺术</p><p>netty redis zk</p><p>redis设计与实战：5，9，<strong>10</strong>，11，15，16，17</p><p>设计模式：（等校长的书）</p><p>spring源码：先不看了</p><p>springboot技术内幕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二篇博客</title>
      <link href="/2023/07/02/javaweb/"/>
      <url>/2023/07/02/javaweb/</url>
      
        <content type="html"><![CDATA[<h2 id="IDEA工具开发Servlet程序"><a href="#IDEA工具开发Servlet程序" class="headerlink" title="IDEA工具开发Servlet程序"></a>IDEA工具开发Servlet程序</h2><ol><li>第一步：New Project 创建一个空项目，然后在空工程下新建Module模块（这不是必须的，只是一个习惯），可以直接创建一个非空的Project,起名为javaweb（不是必须的）</li><li>第二步：新建模块(File–&gt;new–&gt;Module..)</li></ol><ul><li>这里新建的是一个普通的JavaSE模块(这里先不要新建Java Enterprise模块)</li><li>这个Module自动会被放在Javaweb的project下面</li><li>Module起名：servlet01</li></ul><ol start="3"><li>第三步：让Module变成JavaEE模块(让Module变成javaweb的模块)</li></ol><ul><li>在Module上右键点击:Add Framework Support(添加框架支持)</li><li>在弹出的窗口，选择Web Application(选择的是webapp的支持)</li><li>选择了这个webapp支持后，idea会自动生成一个符合servlet规范的webapp目录结构</li><li><strong>重点，需要注意：在idea工具中根据Web Application模块生成的目录中有一个web目录，这个目录就代表webapp的根</strong></li></ul><ol start="4"><li>第四步（非必须）：根据Web Application生成的资源中有index.jsp文件，这里可以选择删除这个index.jsp文件</li><li>第五步：编写servlet</li></ol><ul><li>class studentServlet implements Servlet</li><li>这个时候发现Servlet.class文件没有，怎么办？将CATALINA_HOME&#x2F;lib&#x2F;servlet-api.jar添加到class.path当中(File–&gt;Project Structrue–&gt;Modules–&gt;+加号–Add jars…)</li><li>实现jakarta.servlet.Servlet接口中的五个方法</li></ul><ol start="6"><li>第六步：在Servlet当中的servlet方法中编写业务代码并连接数据库。</li><li>第七步：在WEB-INF目录下新增了一个子目录：lib(这个目录名不能随意，必须全部小写),并且将连接数据库驱动的jar包放到lib目录下。</li><li>第八步：在web.xml文件中完成StudentServlet类的注册（请求路径和servlet对应起来）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>studentServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.javaweb.servlet.StudentServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>studentServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet/student<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="9"><li>第九步：写一个html页面写一个超链接，用户点击这个超链接，发送请求。Tomcat执行后台的studentServer</li></ol><ul><li>student.html</li><li>这个文件不能放到WEB-INF目录中,只能放到WEB-INF目录外面</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>student list<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/xmm/servlet/student&quot;</span>&gt;</span>第一个servlet<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="10"><li>第十步：让idea工具去关联Tomcat，关联的过程中将webapp部署到Tocmat服务器中。</li></ol><ul><li>idea工具右上角，绿色锤子旁边有一个：Add Configuration</li><li>点击加号，点击Tomcat Server–&gt;local</li><li>在弹出的界面中设置服务器Server的参数(基本不用动)</li><li>在当前窗口中有一个Deployment(点击这个用来部署webapp),继续点击加号，部署即可</li><li>修改Application context为：html页面中的项目名&#x2F;xmm</li></ul><ol start="11"><li>第十一步：启动Tomcat服务器</li></ol><ul><li>点击右上角的小虫子，可以采用debug的模式启动Tomcat服务器</li><li>我们在开发中建议使用debug的方法启动Tomcat</li></ul><ol start="12"><li>打开浏览器在地址栏输入：http:localhost:8080&#x2F;xmm&#x2F;student.html</li></ol><h2 id="servlet的生命周期"><a href="#servlet的生命周期" class="headerlink" title="servlet的生命周期"></a>servlet的生命周期</h2><ol><li>servlet对象是由谁来维护</li></ol><ul><li>servlet对象的创建，对象的方法调用和对象的销毁，java程序员无权干预</li><li>servlet对象的生命周期是由Tomcat服务器负责的</li><li>Tomcat服务器通常称为WEB容器，WEB容器管理Servlet对象的死活</li></ul><ol start="2"><li><p>自己new的servlet的对象不归WEB容器管理(WEB容器创建的Servlet对象，这些对象会被放到一个集合中管理，自己new的对象不在容器当中)</p></li><li><p>Tomcat服务器在默认情况下Servlet对象不会被实例化，这个设计是合理的，如果提前创建出来所有的Servlet对象，必然是耗费内存的，并且如果创建出来的Servlet如果一直没有用户访问，显然这个Servlet是一个废物，没有必要先创建</p></li><li><p>servlet对象生命周期</p></li></ol><ul><li>用户发送第一次请求的时候，servlet对象实例化，并且执行无参构造方法</li><li>对象创建之后，Tomcat立马调用init方法(init方法执行的时候，servlet对象已经存在，已经被创建出来了)</li><li>init方法执行后，Tomcat立马调用了servlet的service方法</li><li>用户第二、三、四……次请求的时候，servlet对象不会新建，还是使用之前新建的servlet对象，此时直接调用service方法，这说明：<ul><li>第一：servlet对象是单例的（单实例的，需要注意：servlet对象是单实例的，但是servlet类并不符合单例模式，我们称之为假单例。之所以单例是因为servlet对象的创建java程序员不管，对象的创建是由Tomcat说了算的，Tomcat只创建了一个，所以导致了单例，但是属于假单例，真单例模式构造方法是私有化的）</li><li>第二：无参数构造方法，init得到只在第一次用户发送请求的时候执行，也就是说无参数构造方法只执行一次，init方法只调用一次</li><li>第三：用户发一次请求service方法必然会被Tomcat服务器调用一次</li></ul></li></ul><ol start="5"><li>关闭服务器</li></ol><ul><li>servlet的destroy方法会被Tomcat调用一次</li><li>destroy方法是在服务器关闭的时候调用的，因为要销毁对象的内存</li><li>销毁对象内存之前，Tomcat服务器会自动调用destroy方法，destroy方法调用之前，对象还在没有销毁，方法执行结束后，对象内存才被Tomcat释放</li></ul><ol start="6"><li>当我们在Servlet类中编写一个有参构造方法，没有手动编写无参构造方法会出现什么问题？</li></ol><ul><li>报500错误，是一个HTTP协议的错误状态码</li><li>500一般情况下是因为服务器端的Java程序出了问题，没有无参构造方法，会导致出现500错误，无法实例化Servlet对象</li><li>所以一般情况下不建议程序员定于构造方法</li></ul><ol start="7"><li>构造方法和init都是在对象创建的时候执行一次，能不能用无参构造方法代替init方法？</li></ol><ul><li>不能，因为作为Java程序员，编写Serclet类的时候，不建议手动编写构造方法，很容易让无参构造方法消失，这个操作很可能使Servlet无法实例化</li></ul><ol start="8"><li>init，destroy，service方法什么时候使用</li></ol><ul><li>使用最多的是service方法，service一定要实现，service方法是处理用户请求的核心方法</li><li>init方法很少用，通常在init方法中做初始化操作，并且这个初始化操作只执行一次，比如初始化数据库连接池，初始化线程池</li><li>destroy方法也很少用，进行资源的关闭，马上对象被销毁，还有什么没有关闭的抓紧时间关闭，还有什么资源没保存的抓紧保存。</li></ul><h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><ul><li><p>servlet是一个接口，是servlet规范中的一员</p></li><li><p>由Tomcat(WEB服务器)实现servletContext接口</p></li><li><p>ServletContext对象由WEB服务器在启动的时候创建的</p></li><li><p>对于一个webapp只有一个ServletContext对象，对象在服务器关闭的时候销毁</p></li><li><p>ServletContext对应的其实是web.xml文件，Tomcat是一个容器，一个webapp中可以放多个webapp，一个webapp对应一个ServletContext对象</p></li><li><p>ServletContext接口中常用的方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getInitParameter</span><span class="params">(String name)</span>;<span class="comment">//通过初始化参数name获取value</span></span><br><span class="line"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title function_">getInitParameterNames</span><span class="params">()</span>;<span class="comment">//获得所有初始化参数的name</span></span><br><span class="line"><span class="comment">//通过ServletContext对象记录日志</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message , Throwable t)</span></span><br><span class="line"><span class="comment">//这些日志记录到C:\Users\ZDKJ\AppData\Local\JetBrains\IntelliJIdea2020.2\tomcat\Unnamed_servlet02</span></span><br><span class="line"><span class="comment">//Tomcat服务器logs目录下的日志文件</span></span><br><span class="line"><span class="comment">//catalina.2022-11-03.log 服务器端的Java程序运行的控制台信息</span></span><br><span class="line"><span class="comment">//localhost.2022-11-03.log ServletContext对象的log方法记录的日志信息存储到这个文件中    </span></span><br><span class="line"><span class="comment">//   localhost_access_log.2022-11-03.txt 访问日志 </span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--以上两方法是获得以下配置信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>pageSize<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>10<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--以上配置信息属于应用级的配置信息，一般一个项目中共享的信息会放到以上的标签中--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果配置信息只是想给某个servlet作为参考，那么你配置到servlet标签中即可，使用ServletConfig获取即可--&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>ServletContext对象还有另一个名字：应用域（后面还有请求域，会话域等）</p></li><li><p>如果所有的用户共享一份数据，并且这个数据很少被修改，数据量很小，可以将这些数据放到ServletContext这个应用域中</p><ul><li>如果不是共享数据没有意义，因为Servlet对象只有一个，只有共享的数据放进去才有意义</li><li>数据量太大的话，太占用内存，并且这个对象的生命周期比较长，服务器关闭的时候才会被销毁，大量数据会影响服务器性能，占用内存较小的时候可以考虑放进去</li><li>所有用户共享的数据，如果涉及到频繁的修改的操作，必然会存在线程并发所带来的安全问题，为了解决线程安全问题只能使用锁机制,锁一旦使用最终会导致性能降低，所有在ServletContext对象中的数据一般都是只读的</li></ul></li><li><p>数据量小，所有用户共享，又不修改，这样放到ServletContext中，会大大提升效率，因为应用域相当于一个缓存，当道缓存中的数据，下次用的时候，不需要再次从数据库中获取，大大提升执行效率</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAttribute</span><span class="params">(String name,Object value)</span>;<span class="comment">//存</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getAtttibute</span><span class="params">(String name)</span>;<span class="comment">//取</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeAttribute</span><span class="params">(String name)</span>;<span class="comment">//删除</span></span><br></pre></td></tr></table></figure><ul><li><strong>注：以后编写Servlet方法的时候，实际上不会直接继承GenericServlet类的，因为我们是B&#x2F;S结构的系统，这种系统是基于HTTP找文本传输协议的，在Servlet规范中，提供了一个类叫做HttpServlet，它是专门为HTTP协议准备的一个Servlet类，我们编写的Servlet要继承HttpServlet。（HttpServlet是HTTP协议专用的）使用HttpServlet处理HTTP的时候更加便捷</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以上内容的继承结构</span></span><br><span class="line">jakarta.servlet.Servlet(接口)【爷爷】</span><br><span class="line">jakarta.servlet.GenericServlet <span class="keyword">implements</span> <span class="title class_">Servlet</span>(抽象类)【儿子】</span><br><span class="line">jakarta.servlet.HttpServlet <span class="keyword">extends</span> <span class="title class_">GenericServlet</span>(抽象类)【孙子】   </span><br></pre></td></tr></table></figure><ul><li><p>连接池</p><ul><li>这里所说的连接池的连接时Java语言连接数据库的连接对象：java.sql.Connection对象</li><li>JVM是一个进程，mysql是一个进程，进程和进程之间建立连接，打开通道是十分费劲的，很消耗资源，可以提前创建好N个Connection对象，将连接对象放到一个集合中，我们把这个放有Connection对象的集合称为连接池。每一次用户连接的时候不需要在新建连接对象，直接从连接池中获取连接对象，大大提升访问效率</li><li>连接池<ul><li>最小连接数</li><li>最大连接数</li><li>连接池可以提高用户访问效率，当然也可以保证数据库的安全性</li></ul></li></ul></li><li><p>线程池</p><ul><li>Tomcat服务器本身就是支持多线程</li><li>Tomcat服务器不是在用户发送一次请求，就新建一个Thread线程对象，会先创建好N个多线程Thread对象，然后将线程对象放到集合当中，称为线程池，用户发送请求过来后，需要有一个对应的线程来处理这个请求，这个时候线程对象会直接从线程池中拿，效率比较高</li><li>所有的WEB服务器，或者应用服务器，都是支持多线程的，都有线程池机制</li></ul></li></ul><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><ul><li>HTTP的响应协议(S–&gt;B)<ul><li>HTTP的响应协议包括四部分<ul><li>状态行</li><li>响应头</li><li>空白行</li><li>响应体</li></ul></li><li>HTTP的请求报文</li><li>状态行<ul><li>第一部分：版本协议号（HTTP&#x2F;1.11）</li><li>第二部分：状态码（HTTP协议中规定的响应状态号，不同的响应结果对应不同的号码）<ul><li>200表示响应成功，正常结束</li><li>404表示访问的资源不存在，通常是因为要么路径写错了，要么是路径写对了，但是服务器中对应的资源并没有启动成功，总之404错误是前端错误</li><li>405表示前端发送的请求方式与后端请求处理方式不一致时发生：<ul><li>比如：前端是POST请求，后端的处理方式按照get方式进行处理时，发生405</li><li>比如：前端是GET请求，后端的处理方式按照post方式进行处理时，发生405</li></ul></li><li>500表示服务器端的程序出现异常，一般会认为都武器端的错误导致的</li><li>以4开始的，一般是浏览器端错误导致的</li><li>以5开始的，一般是服务器端错误导致的</li></ul></li><li>第三部分：状态的描述信息<ul><li>ok表示正常成功结束</li><li>not found表示资源找不到</li></ul></li></ul></li><li>响应头<ul><li>响应的内容类型</li><li>相应的内容长度</li><li>响应的时间</li><li>….</li></ul></li><li>空白行<ul><li>用来分隔响应头和响应体</li></ul></li><li>响应体<ul><li>响应体是响应的正文，这些内容是一个长的字符串，这个字符串被浏览器渲染，解释并执行，最终展示出效果</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 ok                         状态行</span><br><span class="line">Content-Type:text/html;charset=UTF-8    响应头</span><br><span class="line">Content-Length:160</span><br><span class="line">Date:Mon,08 Nov 2021 13:19:36 GMT</span><br><span class="line">Keep-Alive:timeout=20</span><br><span class="line">Connection:keep-alive</span><br><span class="line">                                        空白行</span><br><span class="line">&lt;!doctype html&gt;                         响应体 </span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">       &lt;title&gt;from get servlet&lt;/title&gt;</span><br><span class="line">   &lt;/head&gt;</span><br><span class="line">   &lt;body&gt;</span><br><span class="line">       &lt;h1&gt;from get servlet&lt;/h1&gt;</span><br><span class="line">   &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;    </span><br></pre></td></tr></table></figure><ul><li>HTTP的请求协(B–&gt;S)<ul><li>请求行<ul><li>第一部分：请求方式（七种）<ul><li>get（常用的）</li><li>post（常用的）</li><li>delete</li><li>put</li><li>head</li><li>options</li><li>trace</li></ul></li><li>第二部分：URI<ul><li>URI是统一资源标识符，代表网络中某个资源的名字，但是通过URI是无法定位资源</li><li>URL是统一资源定位符。代表网络中某个资源，同时，通过URL是可以定位到该资源的</li><li>URL包括URI<ul><li><a href="http://localhost:8080/servlet/index.html%E8%BF%99%E6%98%AFURL">http://localhost:8080/servlet/index.html这是URL</a></li><li>&#x2F;servlet&#x2F;index.html这是URI</li></ul></li></ul></li><li>第三部分：HTTP协议版本号</li></ul></li><li>请求头<ul><li>请求的主机</li><li>主机的端口号</li><li>浏览器信息</li><li>平台信息</li><li>cookie</li><li>….</li></ul></li><li>空白行<ul><li>用来区分请求头和请求体</li></ul></li><li>请求体<ul><li>向服务器发送的具体数据</li></ul></li></ul></li><li>使用Chrome浏览器:F12，然后找到network，通过这个面板可以查看协议的具体内容</li><li>怎么向服务器发送GET请求，怎么向服务器发送的POST请求<ul><li>到目前为止，只有一种情况可以发送POST请求：使用form表单，并且在form标签中的method属性值为method&#x3D;”post”</li><li>其他情况一律是get请求：<ul><li>在浏览器地址栏直接输入的URL，敲回车，属于get请求</li><li>在浏览器上直接点击超链接，属于get请求</li><li>使用form表单提交数据时，form标签中没有method属性，默认是get</li><li>使用form的时候，form标签中的method属性值为method&#x3D;”get”</li><li>….</li></ul></li></ul></li><li>GET和POST请求的区别<ul><li>get请求发送数据的时候，数据会挂在URI的后面，并且在URI后面添加一个”?”，”?”后面是数据，这样会导致发送的数据显示在浏览器的地址栏中（get请求在请求行上发送数据）<ul><li><a href="http://localhost:8080/servlet/getServlet?username=dehua&password=666">http://localhost:8080/servlet/getServlet?username=dehua&amp;password=666</a></li></ul></li><li>post请求发送数据的时候，在请求体当中发送，不会回显到浏览器地址栏上，也就是说post发送的数据，在浏览器地址上看不到</li><li>get请求只能发送普通的字符串，并且发送的字符串长度有限制，不同的浏览器限制不同，没有明确规定</li><li>get请求无法发送大数据量</li><li>post请求可以发送任何类型的数据，包括普通字符串，流媒体等信息：视频、声音、图片</li><li>post请求可以发送大数据量，理论上没有长度限制</li><li>get请求在W3C中是这样说的：get请求比较适合从服务器端获取数据</li><li>post请求在W3C中是这样说的：post请求比较适合从浏览器向服务器端传送数据</li><li>get请求是安全的，get请求时绝对安全的，因为get请求只是为了从服务器上获取数据，不会对服务器造成威胁。（get请求本身是安全的，你不要用错了，用错了还冤枉人家get不安全，这好吗，这不好，那是你自己问题，不是get请求的问题）</li><li>post请求是危险的，因为post请求是向服务器提交数据，如果这些数据通过后门的方式进入到服务器当中，服务器是很危险的，另外post是为了提交数据，所以一般情况下拦截请求的时候，大部分会拦截（监听）post请求</li><li>get支持缓存<ul><li><a href="https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg">https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg</a></li><li>任何一个get请求最终的响应结果都会被浏览器存起来，在浏览器当中：<ul><li>一个get请求的路径a对应一个资源</li><li>一个get请求的路径b对应一个资源</li><li>一个get请求的路径c对应一个资源</li><li>…</li></ul></li><li>实际上只要发送了一个get请求，浏览器第一件事就是先从本地浏览器缓存中找，找不到的时候才会去服务器上获取，这种缓存机制目的是为了提高用户体验</li><li>如果有一个需求：不希望get请求走缓存，而是每次请求都去服务器上找资源，不去本地浏览器的缓存中获取<ul><li><a href="https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=948491511">https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=948491511</a></li><li><a href="https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=5661662">https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=5661662</a></li><li><a href="https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=%E7%B3%BB%E7%BB%9F%E6%AF%AB%E7%A7%92%E6%95%B0">https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=系统毫秒数</a></li><li>解决方案：在每个路径的后面加一个时刻都在变化的时间戳，这样每次的路径都不一样，浏览器就不会走缓存了</li></ul></li></ul></li><li>post不支持缓存<ul><li>post请求之后，服务器的响应结果不会被浏览器缓存起来，因为这个缓存没有意义</li></ul></li></ul></li><li>如何选择get请求和post请求<ul><li>如果请求是想获取服务器的数据，建议使用get请求，如果这个给是为了向服务器提交数据，建议使用post请求</li><li>大部分的form表单是向服务器提交用户手机的大量数据，服务器将这些数据保存，使用post请求</li><li>如果表中敏感信息，建议使用post请求，因为get请求会把敏感信息显示到浏览器地址栏上（例如：密码信息）</li><li>做文件上传一定是post请求，因为这不是普通的文本</li><li>其他情况都可以使用get请求</li></ul></li><li>不管使用get请求还是使用post请求，发送数据的格式是完全相同的，只不过位置不同，格式是统一的：<ul><li>name&#x3D;value&amp;name&#x3D;value&amp;name&#x3D;value</li><li>以form表单为例，name是form表单中input标签的name</li><li>以form表单为例，value是form表单中input标签的value</li></ul></li></ul><h2 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">        <span class="type">long</span> lastModified;</span><br><span class="line">        <span class="keyword">if</span> (method.equals(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">            lastModified = <span class="built_in">this</span>.getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span> (lastModified == -<span class="number">1L</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">long</span> ifModifiedSince;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ifModifiedSince = req.getDateHeader(<span class="string">&quot;If-Modified-Since&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">                    ifModifiedSince = -<span class="number">1L</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ifModifiedSince &lt; lastModified / <span class="number">1000L</span> * <span class="number">1000L</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">                    <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp.setStatus(<span class="number">304</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line">            lastModified = <span class="built_in">this</span>.getLastModified(req);</span><br><span class="line">            <span class="built_in">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">            <span class="built_in">this</span>.doHead(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doPost(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;PUT&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doPut(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;DELETE&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doDelete(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;OPTIONS&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doOptions(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;TRACE&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doTrace(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;method&#125;;</span><br><span class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">            resp.sendError(<span class="number">501</span>, errMsg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过源码的分析，</span></span><br><span class="line"><span class="comment">/*假设前端发送的是get请求，后端程序员重写的是doPost方法，或者前端程序员发送的是post请求，后端程序员重写的是doPost方法，会发生405这样一个错误</span></span><br><span class="line"><span class="comment">405表示的是前端的错误，发送请求方式不对，和服务器不一致，不是服务器需要的请求方式，所以可以看出只要HttpServlet类中的doPost或者doGte方法执行了必然会导致405错误</span></span><br><span class="line"><span class="comment">所以只有后端重写了哪个方法，前端发送对应请求才能避免405错误</span></span><br><span class="line"><span class="comment">但是，不能为了避免405错误把doPost方法和doGet方法都重写，这样虽然能避免405错误，因为405错误还是有用的。该报错的时候就让他报错，而且如果你doGet和doPost方法都重写还不如直接重写servlet方法，这样代码量还少一些*/</span></span><br></pre></td></tr></table></figure><h2 id="web欢迎页"><a href="#web欢迎页" class="headerlink" title="web欢迎页"></a>web欢迎页</h2><ul><li><p>访问方式</p><ul><li>如果访问的是<a href="http://localhost:8080/servlet/index.html%E5%B0%B1%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E6%8C%87%E5%AE%9A%E7%9A%84%E8%B5%84%E6%BA%90">http://localhost:8080/servlet/index.html就直接访问指定的资源</a></li><li>如果访问的是<a href="http://localhost:8080/servlet%E6%B2%A1%E6%9C%89%E6%8C%87%E5%AE%9A%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%EF%BC%8C%E4%BC%9A%E8%AE%BF%E9%97%AE%E8%AE%BE%E7%BD%AE%E7%9A%84%E6%AC%A2%E8%BF%8E%E9%A1%B5">http://localhost:8080/servlet没有指定资源路径，会访问设置的欢迎页</a></li></ul></li><li><p>设置欢迎页步骤</p><ul><li><p>第一步：在idea工具的web目录下新建一个login.html</p></li><li><p>第二步：在web.xml文件中进行以下配置</p><ul><li><pre><code class="xml">    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;welcome/login.html&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - **注：设置欢迎页面的时候路径不需要以&quot;/&quot;开始，并且这个路径默认是从webapp的根下开始查找**</span><br><span class="line"></span><br><span class="line">  - 第三步：开启服务器，浏览器地址栏输入地址</span><br><span class="line"></span><br><span class="line">* 一个webapp可以设置多个欢迎页面</span><br><span class="line"></span><br><span class="line">  - ```xml</span><br><span class="line">        &lt;welcome-file-list&gt;</span><br><span class="line">            &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;</span><br><span class="line">            &lt;welcome-file&gt;welcome/login.html&lt;/welcome-file&gt;</span><br><span class="line">        &lt;/welcome-file-list&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>越靠上的优先级越高</p></li></ul></li><li><p>当文件名设置为index.html的时候，不需要再web.xml文件中进行欢迎页面的设置，因为在Tomcat服务器已经设置好了</p><ul><li><p>实际上设置欢迎页面的地方有两个</p><ul><li><p>一个在webapp内部的web.xml文件中(这个地方属于局部配置)</p></li><li><p>一个在CATALINA_HOME&#x2F;conf&#x2F;web.xml文件中进行配置(这个地方的配置属于全局配置)</p><ul><li><pre><code class="xml">    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      - Tomcat服务器的全局观影页面是：index.html,index.htm,index.jsp，如果一个web站点没有设置局部欢迎页面，Tomcat服务器会以index.html,index.htm,index.jsp作为一个web站点的欢迎页面</span><br><span class="line"></span><br><span class="line">      - 注意原则：局部优先原则（就近原则）</span><br><span class="line"></span><br><span class="line">- 欢迎页面也可以是一个Servlet</span><br><span class="line"></span><br><span class="line">## 关于WEB-INF目录</span><br><span class="line"></span><br><span class="line">* 在WEB-INF目录下新建一个welcome.html</span><br><span class="line">* 打开浏览器访问：http:localhost:8080/WEB-INF/welcome.html出现404错误</span><br><span class="line">* 注意：放在WEB-INF目录下的资源是受保护的，在浏览器上不能够通过路径直接访问，所以像html,css,javascrip,image等静态资源一定要放到WEB-INF之外</span><br><span class="line"></span><br><span class="line">## HttpServletRequest接口详解</span><br><span class="line"></span><br><span class="line">* request和response对象生命周期</span><br><span class="line">  - request对象和response对象，一个是请求对象，一个是响应对象。这两个对象只在当前请求中有效</span><br><span class="line">  - 一次请求对应一个request</span><br><span class="line">  - 两次请求对应两个request</span><br><span class="line"></span><br><span class="line">* HttpServletRequest接口常用方法</span><br><span class="line"></span><br><span class="line">  - ````java</span><br><span class="line">    Map&lt;String,String[]&gt; getParameterMap() //这个是获取整个Map</span><br><span class="line">    Enumeration&lt;String&gt; getParameterNames()//这个是获取Map集合中所以的key</span><br><span class="line">    String[] getParamterValues(String name)//根据key获取Map的value</span><br><span class="line">    String getParamter(String name)//获取value这个一维数组的第一个元素，这个方法最常用    </span><br><span class="line">    ````</span><br><span class="line"></span><br><span class="line">  - 前端提交的数据格式：username=kun&amp;password=999&amp;interest=sing&amp;interest=dance&amp;interest=basketBall&amp;interest=Rap</span><br><span class="line"></span><br><span class="line">**请求域对象**</span><br><span class="line"></span><br><span class="line">* 请求域对象的作用范围比应用域小很多，声明周期短很多，请求域只在一次请求内有效</span><br><span class="line"></span><br><span class="line">* 一个请求对象request对应一个请求域对象，一次请求结束之后请求域就销毁了</span><br><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  //请求域也有ServletContext中的三个方法</span><br><span class="line">  void setAttribute(String name,Object obj);</span><br><span class="line">  Object getAttribute(String name);</span><br><span class="line">  void removeAttribute(String name);</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul></li><li><p>请求域和应用域选择的原则一般是，选择内存占用较小的</p></li><li><p>跳转</p><ul><li><p>转发</p><ul><li><pre><code class="java">req.getRequestDispatcher(&quot;/test.html&quot;).forward(req,resp);//获取请求转发器对象，并调用转发器对象的forward方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 两个Servlet共享数据的方法</span><br><span class="line"></span><br><span class="line">  - 直接将数据放到ServletContext应用域当中，虽然可以，但是作用域的范围太大，占用资源太多，不建议使用</span><br><span class="line">  - 可以将数据放到request域当中，然后AServlet转发到BServlet，保证AServlet和BServlet在一次请求当中，这样可以做到两个servlet共享同一份数据</span><br><span class="line"></span><br><span class="line">* 转发的下一个资源不一定是一个servlet，只要是Tomcat服务器当中合法的资源都可以转发，例如：html....</span><br><span class="line"></span><br><span class="line">* **注：转发的时候路径写法要注意，转发的路径以&quot;/&quot;开始，不要加i项目名**</span><br><span class="line"></span><br><span class="line">* 关于两个容易混淆的方法</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  String username = request.getParameter(&quot;username&quot;);</span><br><span class="line">  //这个获取的是用户在浏览器中提交的数据，数据形式为 uri?username=zhangsan&amp;userpwd=123&amp;sex=1</span><br><span class="line">  Object obj = request.getAttribute(&quot;name&quot;);</span><br><span class="line">  //这个获取的是请求域中绑定的数据，在此之前肯定执行过，request.setAttribute(&quot;name&quot;,new Object());</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li><li><p>HttpServletRequest</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">remoteAddr</span> <span class="operator">=</span> request.getRemoteAddr();</span><br><span class="line"><span class="comment">//获取客户端的ip地址</span></span><br><span class="line">request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//设置请求字体字符集，显然这个方法处理的是Post请求乱码问题，不适用于Get请求</span></span><br><span class="line"><span class="comment">//Tomcat10之后，request请求体当中的字符集默认是UTF-8，不需要设置字符集，不会出现乱码问题</span></span><br><span class="line"><span class="comment">//Tomcat9之前，包括Tomcat9，如果前端请求体提交的是中文，后端获取后会出现乱码，要用这个方法解决</span></span><br><span class="line">request.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//在Tomcat9之前，包括Tomcat9,响应中文即输出在控制台的中文也是有乱码的，使用以上方法解决</span></span><br><span class="line"><span class="comment">//在Tomcat10之后，包括Tomcat10，响应中文的时候就不在出现乱码问题，以上代码不需要设置UTF-8</span></span><br><span class="line"><span class="comment">/*    &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span></span><br><span class="line"><span class="comment">               connectionTimeout=&quot;20000&quot;</span></span><br><span class="line"><span class="comment">               redirectPort=&quot;8443&quot; </span></span><br><span class="line"><span class="comment">               URIEncoding=&quot;UTF-8&quot;/&gt;          */</span></span><br><span class="line"><span class="comment">//修改CATALINA_HOME/conf/server.sml配置文件，为以上内容，可以解决get请求乱码问题，get请求发送的时候，数据是在请求行上提交的，不是在请求体上提交的</span></span><br><span class="line"><span class="comment">//从Tomcat8之后，URIEncoding的默认值就是UTF-8，所以get请求也不会有乱码了</span></span><br><span class="line"><span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> request.getContextPath();</span><br><span class="line"><span class="comment">//获取应用的根路径 输出/servlet05即项目名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line"><span class="comment">//获取请求方式 输出get/post....</span></span><br><span class="line"><span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI(); </span><br><span class="line"><span class="comment">//获取请求的URI 输出/servlet05/B这样的URI</span></span><br><span class="line"><span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> request.getServletPath();</span><br><span class="line"><span class="comment">//获取servlet path 输出/B这样的Servlet路径</span></span><br></pre></td></tr></table></figure><h2 id="纯Servlet增删改查项目的一个bug的解决"><a href="#纯Servlet增删改查项目的一个bug的解决" class="headerlink" title="纯Servlet增删改查项目的一个bug的解决"></a>纯Servlet增删改查项目的一个bug的解决</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type = <span class="string">&#x27;text/javascript&#x27;</span>&gt;</span><br><span class="line">         <span class="keyword">function</span> <span class="title function_">del</span> (deptno)&#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&#x27;删除后不可恢复，请慎重选择&#x27;</span>))&#123;</span><br><span class="line">             <span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;&quot;+contextPath+&quot;/dept/delete?deptno=&#x27;</span>+deptno</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;javascript:void(0)&#x27;</span> <span class="attr">onclick</span> = <span class="string">&#x27;del(&quot;+deptno+&quot;)&#x27;</span> &gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>这样写，当鼠标单击删除的时候，会报del方法未定义的错误</li><li>正确写法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type = <span class="string">&#x27;text/javascript&#x27;</span>&gt;</span><br><span class="line">         del = <span class="keyword">function</span> (<span class="params">deptno</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&#x27;删除后不可恢复，请慎重选择&#x27;</span>))&#123;</span><br><span class="line">             <span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;&quot;+contextPath+&quot;/dept/delete?deptno=&#x27;</span>+deptno</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>如果函数写在$(functiong{ })或者$().ready(function () {});内部，那么 οnclick&#x3D;”del(“+deptno+”)”; 时 ,不能写成  function del(){}，也不能写成var del&#x3D; function(){}，只能写成del &#x3D; function(){}。</strong></p><h2 id="在一个web应用中如何完成资源跳转"><a href="#在一个web应用中如何完成资源跳转" class="headerlink" title="在一个web应用中如何完成资源跳转"></a>在一个web应用中如何完成资源跳转</h2><ul><li><p>两种完成跳转的方式</p><ul><li>转发</li><li>重定向</li></ul></li><li><p>两种方式的区别</p></li><li><p>代码上的区别</p><p>​    转发</p><ul><li><pre><code class="java">RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;/dept/list&quot;);dispatcher.forward(&quot;request,response&quot;);//转发的时候是一次请求，不管转发了多少次，都是一次请求//AServlet转发到BServlet，再转发到CServlet不管转发了多少次都是一次request//这就是为什么调用forward方法的时候会将当前的request和response对象传给下一次Sevlet<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  重定向</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  response.sendRedirect(req.getContextPath()+&quot;/dept/list&quot;);</span><br><span class="line">  //注意：路径上要加上项目名，因为相当于浏览器发送请求</span><br><span class="line">  //以上代码会将请求路径：/oa/dept/list发送给浏览器，浏览器向服务器发一次全新的请求</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>形式上的区别</p><ul><li>转发（一次请求）<ul><li>在浏览器地址栏上的请求是<a href="http://localhost:8080/Servlet/a,%E6%9C%80%E7%BB%88%E8%AF%B7%E6%B1%82%E7%BB%93%E6%9D%9F%E5%90%8E%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BF%98%E6%98%AF%E8%BF%99%E4%B8%AA">http://localhost:8080/Servlet/a,最终请求结束后，浏览器地址栏还是这个</a></li></ul></li><li>重定向（两次请求）<ul><li>在浏览器地址栏上发送的请求是：<a href="http://localhost:8080/Servlet/a,%E6%9C%80%E7%BB%88%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E4%B8%8A%E6%98%BE%E7%A4%BA%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%AF%EF%BC%9Ahttp://localhost:8080/Servlet/b">http://localhost:8080/Servlet/a,最终在浏览器地址栏上显示的地址是：http://localhost:8080/Servlet/b</a></li></ul></li></ul></li><li><p>转发和重定向的本质区别</p><ul><li>转发：是由WEB服务器控制的，A资源跳转到B资源，这个跳转动作是Tomcat服务器内部完成的</li><li>重定向：是浏览器完成的，具体跳转到哪个资源，浏览器说了算</li></ul></li><li><p>转发和重定向如何选择</p><ul><li>如果在上一个Servlet中向request域中绑定了数据，希望在下一个Servlet当中把request域的数据取出来，使用转发机制</li><li>剩下所有的请求均使用重定向</li></ul></li><li><p>跳转的下一个资源没有要求，可以是Servlet，jsp，html…..</p></li></ul><h2 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h2><ul><li><p>在web.xml文件中进行Servlet信息的配置，显然效率开发比较低，而且对于一个大项目来说，最终的web.xml可能会达到几十兆</p></li><li><p>而且web.xml文件中的配置信息是很少修改的，所有在Servlet3.0版本之后推出注解开发，将配置信息写到Java类</p><ul><li>并不是不需要写配置文件了，一般是注释+配置文件的开发模式</li><li>一些不常修改的配置信息建议使用注解，一些可能会修改的信息建议写到配置文件中</li></ul></li><li><p>第一个注解</p><ul><li><pre><code class="java">import jakarta.servlet.annotation.WebServlet;@WebServlet(&quot;/wel&quot;)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 在Servlet类上使用：</span><br><span class="line"></span><br><span class="line">    - name：用来指定Servlet的名字，相当于&lt;servlet-name&gt;</span><br><span class="line">    - urlPatterns：用来指定Servlet的映射路径，可以指定多个字符串，相当于&lt;url-pattern&gt;</span><br><span class="line">    - loadOnStartUp：用来指定在服务器启动阶段是否加载该Servlet,相当于&lt;load-on-startup&gt;</span><br><span class="line">    - value：同样用来映射路径，可以指定多个字符串，注解属性名为value的时候，使用注解的时候，value属性名是可以忽略的</span><br><span class="line">    - 注意：不是必须将所有属性都写上，只需要提供需要的，属性是一个数组的时候，如果数组中只有一个元素，使用该注解的时候，属性值的大括号可以省略</span><br><span class="line"></span><br><span class="line">* 注解对象的使用格式</span><br><span class="line"></span><br><span class="line">  - @注解名称(属性名=属性值，属性名=属性值.....)</span><br><span class="line"></span><br><span class="line">## jsp</span><br><span class="line"></span><br><span class="line">* jsp的基本语法</span><br><span class="line"></span><br><span class="line">  - 在jsp文件中直接编写文字，会被翻译到Servlet类的service方法的out.write(&quot;&quot;)的双引号中，被Java程序当作普通字符串输出到浏览器</span><br><span class="line">- 在jsp文件中编写html，css，js代码，这些代码对于jsp来说也是一个普通字符串，但是把这些普通字符串一旦输出浏览器，浏览器会对这些html，css，js代码进行解释执行，呈现出对应效果</span><br><span class="line">  - 乱码问题的解决</span><br><span class="line"></span><br><span class="line">    - 通过page指令设置相应的内容类型，在内容类型的后面添加：charset=UTF-8</span><br><span class="line">    - &lt;%@page contentType=&quot;text/html;charset=UTF-8&quot;%&gt;,表示响应的内容是text/html采用的字符集是UTF-8</span><br><span class="line">  - 在jsp中编写Java代码</span><br><span class="line">  </span><br><span class="line">  - &lt;% Java语句 %&gt;</span><br><span class="line">      - 在这个符号中编写的被视为Java程序，被编译到Servlet类的service方法内部</span><br><span class="line">    - 时刻记住此时此刻，你正在一个方法体的内部编写代码，想清楚什么能写，什么不能写，例如：不能写静态代码块，不能写方法，不能定义成员变量</span><br><span class="line">      - 在service方法中编写的的代码是有顺序的，方法体当中的代码遵循自上而下顺序进行执行</span><br><span class="line">      - 一个jsp文件中可以出现多个&lt;%%&gt;符号</span><br><span class="line">    - &lt;!%%&gt;</span><br><span class="line">      - 在这个符号中编写的Java程序会自动翻译到service方法之外</span><br><span class="line">      - 这个语法很少用，因为在service方法编写静态变量和实例变量，都会存在线程安全问题，jsp就是servlet，servlet是单例的，多线程并发的环境下，这个静态的变量和实例变量一旦有修改操作，必然会存在线程安全问题</span><br><span class="line">    - jsp输出语句</span><br><span class="line">      - 输出语句是像浏览器输出一个Java变量</span><br><span class="line">      - 语法&lt;% String name = &quot;dehau&quot;; out.write(&quot;name=&quot; + name) %&gt;</span><br><span class="line">      - 注意：以上代码中out是jsp的九大内置对象之一，可以直接拿来调用，必须在service方法内部</span><br><span class="line">  - &lt;%= %&gt;，等号后面写上输出的内容，会被翻译到service方法中，翻译成out.print();（输出的内容含有Java变量，输出的内容是一个动态内容，而输出一个死的字符串就直接在jsp中写就能输出）</span><br><span class="line">  </span><br><span class="line">* JSP指令</span><br><span class="line"></span><br><span class="line">  - 指令的作用：指导JSP的翻译引擎，如何工作(指导当前jsp翻译引擎如何翻译jsp文件)</span><br><span class="line"></span><br><span class="line">  - 指令包括：</span><br><span class="line"></span><br><span class="line">    - include：包含指令，在jsp中完成静态包含，很少用了</span><br><span class="line">    - taglib：引入标签库的指令，先不管</span><br><span class="line">    - page：重点</span><br><span class="line"></span><br><span class="line">  - 指令语法：</span><br><span class="line"></span><br><span class="line">    - &lt;%@指令名 属性名=属性值 属性名=属性值 属性名=属性值....%&gt;</span><br><span class="line"></span><br><span class="line">  - page指令中常用属性</span><br><span class="line"></span><br><span class="line">    - ```jsp</span><br><span class="line">      &lt;%@page session=&quot;true/false&quot;%&gt;</span><br><span class="line">      true表示启用jsp内置对象session，表示一定启动session对象，没有会创建，如果没有设置，默认值是session=&quot;true&quot;</span><br><span class="line">      session=&quot;false&quot;表示不启动内置对象session，当前jsp页面无法使用内置对象</span><br></pre></td></tr></table></figure>- ```jsp  &lt;%@page contentType=&quot;text/json&quot;%&gt;  contentType属性用来设置响应内容的类型  同样可以设置字符集  &lt;%@page contentType=&quot;text/json;charset=&quot;UTF-8&quot;%&gt;  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```jsp</span><br><span class="line">  &lt;%@page pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">  pageEncoding=&quot;UTF-8&quot;表示设置响应时采用的字符集</span><br></pre></td></tr></table></figure>- ```jsp  &lt;%@page import=&quot;java.util.*&quot;%&gt;  import语句，导包  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```jsp</span><br><span class="line">  &lt;%@page errorPage=&quot;/error.jsp&quot;%&gt;</span><br><span class="line">  当页面出现错误的时候，跳转到error.jsp页面</span><br><span class="line">  errorPage属性用来指定出错之后跳转的错误位置</span><br></pre></td></tr></table></figure>- ```jsp  &lt;%@page isErrorPage=&quot;true&quot;%&gt;  表示启用jsp九大内置对象之一：exception  默认值是false  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">  - jsp九大内置对象</span><br><span class="line"></span><br><span class="line">    - jakarta.servlet.jsp.PageContext  pageContext 页面作用域</span><br><span class="line">    - jakarta.servlet.http.HttpServletRequest  request 请求作用域</span><br><span class="line">    - jakarta.servlet.http.HttpSession  session 会话作用域</span><br><span class="line">    - jakarta.servlet.ServletContext  application 应用作用域</span><br><span class="line">      - pagecontext&lt;request&lt;session&lt;application</span><br><span class="line">      - 以上四个作用域都有：setAttribute,getAttribute,removeAttribute方法</span><br><span class="line">      - 以上作用域尽可能使用最小的</span><br><span class="line">    - jakarta.lang.Throwable  expection</span><br><span class="line">    - jakarta.servlet.ServletConfig  config</span><br><span class="line">    - jakarta.lang.Object  page(其实是this，当前的servlet对象)</span><br><span class="line">    - jakarta.servlet.jsp.jspWriter out(输出语句)</span><br><span class="line">    - jakarta.servlet.http.HttpServletResponse  response(负责响应)</span><br><span class="line"></span><br><span class="line">* jsp本质是一个servlet，和servlet到底有什么区别</span><br><span class="line">  - servlet的职责：擅长收集数据(强项是逻辑处理，然后连接数据库，获取/收集数据)</span><br><span class="line">  - jsp的职责：展示数据(强项是做数据的展示)</span><br><span class="line"></span><br><span class="line">## session 会话机制</span><br><span class="line"></span><br><span class="line">* 什么是会话</span><br><span class="line"></span><br><span class="line">  - 打开浏览器，进行一系列操作，然后最终将浏览器关闭，这个整个过程叫做一个会话，会话在服务器端也有一个Java对象，这个Java对象叫做session</span><br><span class="line">  - 在浏览器点击了一下，然后到页面停下来，可以粗略认为是一次请求，请求对应的服务器对象是request</span><br><span class="line">  - 一个会话中包含多次请求</span><br><span class="line"></span><br><span class="line">* session对象最主要的作用是：保存会话状态。（用户登录成功了，这是一种登陆成功的状态，使用session对象可以保留会话状态，把登陆状态一直保存住）</span><br><span class="line"></span><br><span class="line">* 为什么需要session对象保存会话状态</span><br><span class="line"></span><br><span class="line">  - 因为HTTP协议是一种无状态协议(请求的时候，B和S是连接的，但请求结束之后连接就断了，这样服务器压力小)</span><br><span class="line">  - 只要B和S断开了，关闭浏览器的动作，服务器是不知道的</span><br><span class="line"></span><br><span class="line">* 为什么不使用request对象保存会话状态，为什么不用ServletContext对象保存状态</span><br><span class="line"></span><br><span class="line">  - request是一次请求一个对象，作用域太小</span><br><span class="line">  - ServletContext对象是服务器启动的时候创建，服务器关闭的时候销毁，而且这个ServletContext对象只要一个，作用域太大</span><br><span class="line">  - request请求域(HttpServletRequest)&lt;session会话域(HttpSession)&lt;application域(ServletContext)</span><br><span class="line"></span><br><span class="line">* session对象</span><br><span class="line"></span><br><span class="line">  - session对象是存储在服务器中的</span><br><span class="line"></span><br><span class="line">  - 一个session对象对应一个会话，一次会话对应多个请求</span><br><span class="line"></span><br><span class="line">  - 获取方式：</span><br><span class="line"></span><br><span class="line">    - HttpSession session = request.getSession();从服务器中获取当前的session对象，如果没有则新建一个session对象</span><br><span class="line">    - HttpSession session  =  request.getSession(false);从服务器中获取当前session对象，如果没有不新建返回一个null</span><br><span class="line"></span><br><span class="line">  - 实现原理：</span><br><span class="line"></span><br><span class="line">    - 在web服务器中有一个session列表，类似于map集合，这个map集合的key存储的是sessionid，value存储的是session对象</span><br><span class="line">    - 用户第一次发送请求的时候，服务器会创建一个新的session对象，同时给session对象生成一个id，然后web服务器会将session对象的id发送给浏览器，浏览器将session的id保存在浏览器的缓存中</span><br><span class="line">    - 用户第二次发送请求的时候，会自动将浏览器缓存中的session对象的id自动发送给服务器，服务器获取到id，然后根据id查找对应的session对象</span><br><span class="line"></span><br><span class="line">  - session的两种销毁</span><br><span class="line"></span><br><span class="line">    - 超时销毁</span><br><span class="line"></span><br><span class="line">      - ```xml</span><br><span class="line">            &lt;session-config&gt;</span><br><span class="line">                &lt;session-timeout&gt;30&lt;/session-timeout&gt;</span><br><span class="line">            &lt;/session-config&gt;</span><br></pre></td></tr></table></figure>  - 在web.xml文件中的配置信息写上以上内容即可，表示超过三十分钟后session对象销毁- 手动销毁  - 例如，网银的安全退出的操作，就是手动销毁session对象</code></pre></li><li><p><strong>注：关闭浏览器后，浏览器中保存的sessionid消失，下次重新打开浏览器的时候，浏览器的缓存中没有这个sessionid，自然找不到对应的session对象，等同于会话结束</strong></p></li></ul></li><li><p>jsessionid &#x3D; xxxxxxxxx 是以Cookie的形式存在保存在浏览器中的</p></li><li><p>Cookie禁用了，每次请求都会新建一个session对象，此时服务器会正常发送cookie给浏览器，但是浏览器拒收</p><ul><li><p>为了实现session机制，需要使用URL重写机制</p></li><li><p><a href="http://localhost:8080/servlet08/dehua/tuji;JSESSIONID=A532F1125D878307C726D025E547492E">http://localhost:8080/servlet08/dehua/tuji;JSESSIONID=A532F1125D878307C726D025E547492E</a></p></li><li><p>URL重写机制会提高开发成本，开发人员在编写任何请求路径的时候，后面都添加一个sessionid，给开发提高难度，所以，大部分网站的设计是，如果你禁用了cookie就别用了</p></li></ul></li></ul><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul><li><p>session的实现原理中，每一个session对象都会关联一个对应的sessionid，例如：</p><ul><li>JSESSIONID&#x3D;A532F1125D878307C726D025E547492E</li><li>以上这个键值对数据其实就是cookie数据</li><li>对于session关联的cookie来说，这个cookie是被保存在浏览器的运行内存中</li><li>只要浏览器不关闭，用户再次发送请求的时候，会自动将运行内存中的cookie数据发送给服务器</li><li>服务器通过键值对的值A532F1125D878307C726D025E547492E来找到对应的session对象</li></ul></li><li><p>cookie最终是保存在浏览器客户端上的</p><ul><li>可以保存在运行内存中(浏览器只要关闭cookie就消失了)</li><li>也可以保存在硬盘文件中(永久保存)</li></ul></li><li><p>cookie的作用</p><ul><li>cookie和session机制其实都是为了保存会话状态</li><li>cookie是将会话的状态保存在浏览器客户端上(cookie将数据存储在浏览器客户端上)</li><li>session是将会话的状态保存在服务器端(session对象是存储在服务器上)</li></ul></li><li><p>在Java的servlet中，对cookie提供了哪些支持</p><ul><li>提供了一个cookie类专门表示cookie数据：jakarta.servlet.http.Cookie</li><li>java程序把cookie数据发送给浏览器:request.addCookie(cookis)</li></ul></li><li><p>在Http协议中是这样规定的：当浏览器发送请求时，会自动携带path下的cookie数据给服务器(通过URL)</p></li><li><p>关于cookie的有效时间</p><ul><li>用Java设置有效时间：cookie.setMaxAge(60*60)设置cookie在一小时之后失效，所以数字的单位是秒</li><li>没有设置有效时间，，默认保存在浏览器的运行内存中，浏览器关闭则cookie消失</li><li>设置时间大于零，cookie一定会存储在硬盘文件当中</li><li>设置时间等于零，cookie会被删除，同名cookie被删除</li><li>设置时间小于零，保存在浏览器的运行内存中，和没写cookie.setMaxAge(-1)这行代码效果相同</li></ul></li><li><p>关于cookie的path，cookie的相关路径</p><ul><li>假设现在发送的请求是<a href="http://localhost:8080/servlet/cookie/generate%E7%94%9F%E6%88%90%E7%9A%84cookie%EF%BC%8C%E5%A6%82%E6%9E%9Ccookie%E6%B2%A1%E6%9C%89%E8%AE%BE%E7%BD%AEpath%EF%BC%8C%E9%BB%98%E8%AE%A4%E7%9A%84path%E6%98%AF%EF%BC%9Ahttp://localhost:8080/servlet/cookie/%E4%BB%A5%E5%8F%8A%E5%AE%83%E7%9A%84%E5%AD%90%E8%B7%AF%E5%BE%84%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%AA%E8%A6%81%E5%8F%91%E9%80%81%E8%BF%99%E4%B8%AA%E8%B7%AF%E5%BE%84%E5%8F%8A%E5%85%B6%E5%AD%90%E8%B7%AF%E5%BE%84%EF%BC%8Ccookie%E9%83%BD%E4%BC%9A%E8%A2%AB%E5%8F%91%E9%80%81%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8">http://localhost:8080/servlet/cookie/generate生成的cookie，如果cookie没有设置path，默认的path是：http://localhost:8080/servlet/cookie/以及它的子路径，也就是说浏览器只要发送这个路径及其子路径，cookie都会被发送到服务器</a></li><li>手动设置cookie的path：cookie.serPath(“&#x2F;servlet13”),表示只要是servlet13项目的请求路径都会提交这个cookie</li></ul></li><li><p>浏览器发送cookie给服务器，服务器中Java程序接收</p><ul><li><pre><code class="java">Cookie[] cookies = request.getCookie();//如果没有则返回nullif(cookies != null)&#123;        for(Cookie cookie : cookies)&#123;        String name = cookie.getName();        String value = cookie.getValue();    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">## EL表达式</span><br><span class="line"></span><br><span class="line">* EL表达式出现在jsp的作用</span><br><span class="line"></span><br><span class="line">  - 从某个域中取数据，然后将其转换为字符串，然后输出到浏览器，这就是EL浏览器的三大功效</span><br><span class="line"></span><br><span class="line">* 语法  $&#123;key&#125;</span><br><span class="line"></span><br><span class="line">* EL表达式使用：</span><br><span class="line"></span><br><span class="line">  - ```jsp</span><br><span class="line">    &lt;%</span><br><span class="line">      User user = new user();</span><br><span class="line">      user.setName(&quot;jack&quot;);</span><br><span class="line">      user.setAge(66)</span><br><span class="line">      request.setAttribute(&quot;userdetial&quot;,user);</span><br><span class="line">    %&gt;</span><br><span class="line">    $&#123;userdetial&#125;//大括号里面必须写存储到域对象中name，不能写成$&#123;&quot;userdetial&quot;&#125;,这样是直接输出&quot;userdetial&quot;这个字符串</span><br><span class="line">    $&#123;userdetial&#125;的底层是先从域中取数据，即user对象，然后调用user的toString方法，转换成字符串，输出到浏览器</span><br><span class="line">    //直接输出对象的某一个属性</span><br><span class="line">    $&#123;user.name&#125;</span><br><span class="line">    $&#123;user.age&#125;</span><br><span class="line">    //使用这个两个语法的前提是，userd对象有getName()和getAge()这两个方法，这样写底层其实调用了get方法</span><br><span class="line">    //如果在不同的域中，存上相同名字的key，然后使用$&#123;&#125;调用的时候，在没有指定范围的情况下，取出的顺序是先从小的域中取，然后再是大的域</span><br><span class="line">    //指定域的语法,key相同时，优先从哪个域取数据的语法</span><br><span class="line">    $&#123;pageScopr.userdetial&#125;</span><br><span class="line">    $&#123;requestScope.userdetial&#125;</span><br><span class="line">    $&#123;session.userdetial&#125;</span><br><span class="line">    $&#123;applicationScope.userdetial&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>EL表达式对null进行了预处理，如果是null，则输出一个空字符串到浏览器</p></li><li><p>EL表达式取数据的时候有两种形式：</p><ul><li>第一种：${user.userdetial}(大部分是使用这种形式)</li><li>第二种：${user[“userdetial”]}(如果存储到域中的key含有特殊字符，可以使用[]),例如：<ul><li>request.setAttribute(“abc.def”,”fhaishdu”)</li><li>${requestScope.abc.def}这样是无法取值的</li><li>应该写成这样：${requestScope[“abc.def”]}</li><li><strong>注意：中括号里面必须加双引号</strong></li></ul></li></ul></li><li><p>使用EL表达式从Map中取数据</p><ul><li>${map.key}</li></ul></li><li><p>使用EL表达式从List和数组中取数据</p><ul><li>${list[索引]}</li><li>${数组[索引]}</li></ul></li><li><p>page指令忽略EL表达式</p><ul><li><pre><code class="jsp">&lt;%@page contentType=&quot;html/text;charset=UTF-8&quot; isELIgnored=&quot;true&quot;%&gt;isELIgnored=&quot;true&quot;表示忽略EL表达式isELIgnored=&quot;false&quot;表示不忽略EL表示式（这是默认值）//以上指令是忽略所有的EL表达式可以使用反斜杠局部控制：\$&#123;username&#125;，这样也可以忽略EL表达式，只忽略这一行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- EL中的隐式对象</span><br><span class="line"></span><br><span class="line">  - ```jsp</span><br><span class="line">    //pageContext</span><br><span class="line">    //EL表示式中没有request这个隐式对象，EL表达式中有一个隐式对象：pageContext，EL表达式中的pageContext和jsp中的九大内置对象pageContext是同一个对象</span><br><span class="line">    $&#123;pageContext.request.contextPath&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="jsp">//param//如果用户提交的请求是：http://localhost:8080/jsp?aihao=smoke&amp;aihao=drink&amp;aihao=tangtou$&#123;param.aihao&#125;这样可以获取请求参数一维数组当中的第一个元素$&#123;paramValues.aihao[索引]&#125;可以获得数组中指定的元素//在web.xml文件中配置以下数据    &lt;context-param&gt;        &lt;param-name&gt;pageSize&lt;/param-name&gt;        &lt;param-value&gt;20&lt;/param-value&gt;    &lt;/context-param&gt;$&#123;initParam.pageSize&#125;相当于&lt;%application.getInitParameter(&quot;pageSize&quot;)%&gt;获取上下文对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - EL表达式的运算符</span><br><span class="line">    - 算数运算符(+ - * /)只能做数值运算，不能做字符串的运算，如果是“123”这样的字符串，先把字符串转成数字，然后进行数值的运算，其他字符串直接报错</span><br><span class="line">    - 比较运算符(= , !=  , eq)都会调用equal方法</span><br><span class="line">    - empty 判断后面的内容是否为空</span><br><span class="line"></span><br><span class="line">## JSTL标签库</span><br><span class="line"></span><br><span class="line">* 在jsp中引入JSTL标签库(使用taglib指令)</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    &lt;%@taglib prefix=&quot;这里随便起一个名字即可，一般是c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line">    //这个就是核心标签库</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li><li><p>JSTL标签的原理</p><ul><li><pre><code>&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;//以上uri后面的路径实际上指向了一个xxx.tld文件，tld文件其实是一个xml文件，在tld文件中描述了标签和java类的关系//以上核心标签库对应tld文件是：c.tld文件，在jakarta.servlet.jsp.jstl-2.0.0.jar里面META-INF目录下有一个c.tld文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 源码解析</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">      &lt;tag&gt;</span><br><span class="line">        &lt;description&gt;对标签的描述&lt;/description&gt;</span><br><span class="line">        &lt;name&gt;catch&lt;/name&gt;标签的名字</span><br><span class="line">        &lt;tag-class&gt;org.apache.taglibs.standard.tag.common.core.CatchTag&lt;/tag-class&gt;标签对应的Java类</span><br><span class="line">        &lt;body-content&gt;JSP&lt;/body-content&gt;标签体当中可以出现的内容，如果是jsp就表示，就表示标签体中可以出现符合jsp所有语法的代码，例如EL表达式</span><br><span class="line">        &lt;attribute&gt;//属性</span><br><span class="line">            &lt;description&gt;对属性的描述&lt;/description&gt;</span><br><span class="line">            &lt;name&gt;var&lt;/name&gt;属性名</span><br><span class="line">            &lt;required&gt;false&lt;/required&gt;false表示该属性不是必须的，true表示该属性是必须的</span><br><span class="line">            &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt;这个描述说明了该属性是否支持EL表达式，false表示不支持，true表示支持</span><br><span class="line">        &lt;/attribute&gt;</span><br><span class="line">      &lt;/tag&gt;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>jstl中的核心标签库core中的常用标签</p><ul><li><p>c:if</p><ul><li>&lt;c:if test&#x3D;”boolean类型，支持EL表达式”&gt;&lt;&gt;</li></ul></li><li><p>c:forEach</p><ul><li>&lt;c:forEach items&#x3D;”集合，支持EL表达式” var&#x3D;”集合中的元素” varStatus&#x3D;”元素状态对象”&gt;${元素状态对象.count}&lt;&gt;</li><li>count可以实现自增，常用于编号</li><li>&lt;c:forEach var&#x3D;”i” begin &#x3D;”1” end&#x3D;”10” step&#x3D;”1”&gt;${i}&lt;&gt;</li></ul></li><li><p>c:choose c:when c:otherwise</p><ul><li><pre><code>&lt;c:choose&gt;  &lt;c:when test=&quot;$&#123;age&lt;18&#125;&quot;&gt;  未成年  &lt;/c:when&gt;  &lt;c:otherwise&gt;  成年  &lt;/c:otherwise&gt;&lt;/c:choose&gt;  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## Filter过滤器</span><br><span class="line"></span><br><span class="line">* Filter是过滤器，可以在Servlet这个目标程序执行之前添加代码，也可以在目标Servlet程序执行之后添加代码，一般情况下将公共代码编写到过滤器当中</span><br><span class="line"></span><br><span class="line">* 过滤器写法</span><br><span class="line"></span><br><span class="line">  - 第一步：编写一个Java类实现一个接口：jakarta.servlet.Filter并实现这个接口所有方法</span><br><span class="line"></span><br><span class="line">    - init方法：在Filter对象第一次被创建的时候调用，并且只调用一次</span><br><span class="line">    - doFilter方法：只要用户发送一次请求，则执行一次，发送n次请求则执行n次</span><br><span class="line">    - destroy方法：在Filter对象被释放销毁之前被调用，并且只调用一次</span><br><span class="line"></span><br><span class="line">  - 第二步：在类上写注解@WebFilter(&quot;路径&quot;)，或者在web.xml文件中配置和Servlet类似</span><br><span class="line"></span><br><span class="line">    - ```xml</span><br><span class="line">          &lt;filter&gt;</span><br><span class="line">              &lt;filter-name&gt;filter1&lt;/filter-name&gt;</span><br><span class="line">              &lt;filter-class&gt;com.nipowenode.servlet.Filter.Filter1&lt;/filter-class&gt;</span><br><span class="line">          &lt;/filter&gt;</span><br><span class="line">          &lt;filter-mapping&gt;</span><br><span class="line">              &lt;filter-name&gt;filter1&lt;/filter-name&gt;</span><br><span class="line">              &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">          &lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul></li><li><p><strong>注意</strong></p><ul><li>Servlet对象默认情况下，在服务启动的时候不会新建对象</li><li>Filter对象默认情况下，在服务器启动的时候会新建对象</li><li>Servlet是单例的，Filter也是单例的</li></ul></li><li><p>目标Servlet是否执行取决于两个条件</p><ul><li>第一：在过滤器中是否编写了chain.doFilter(request,response);代码(这行代码表示执行下一个过滤器，如果没有下一个过滤器则执行最终的Servlet)</li><li>第二：用户发送的请求是否和Servlet请求路径一致</li></ul></li><li><p>注意：Filter的优先级，天生就比Servlet的优先级高</p><ul><li>&#x2F;a.do对应一个Filter，也对应一个Servlet，那么一定是先执行Filter，然后执行Servlet</li></ul></li><li><p>Filter的配置路径</p><ul><li>&#x2F;a.do,&#x2F;b.do,&#x2F;dept&#x2F;save 这些配置方式都是精确配置</li><li>&#x2F;* 匹配所有路径</li><li>*.do 后缀匹配，不要以&#x2F;开始</li><li>&#x2F;dept&#x2F;* 前缀匹配</li></ul></li><li><p>在web.xml文件中进行配置的时候，Filter的执行顺序是<filter-mapping>标签越靠前的，执行优先级越高</filter-mapping></p></li><li><p>过滤器的调用顺序，遵行栈的数据结构，先进后出</p></li><li><p>使用注,Filter的执行顺序</p><ul><li>比较Filter这个类名</li><li>比如：FilterA和FilterB，先执行FilterA</li><li>比如：Filter1和Filter2，先执行Filter1</li></ul></li><li><p>Filter的生命周期</p><ul><li>和Servlet生命周期相同</li><li>唯一的区别：Filter默认情况下，在服务器启动的情况下就会实例化，Servlet不会</li></ul></li><li><p>责任链设计模式</p><ul><li>过滤器的优点：在程序编译阶段不会确定调用对象，因为Filter的调用顺序是配置到web.xml文件中的，只要修改web.xml配置文件中的filter-mapping的顺序就可以调整Filter的执行顺序，显然Filter的执行顺序是在程序运行阶段动态组合的，这种设计模式被称为责任链设计模式</li><li>责任链模式的最大核心思想：在程序运行阶段，动态的组合程序的调用顺序</li></ul></li></ul><h2 id="Listener-监听器"><a href="#Listener-监听器" class="headerlink" title="Listener 监听器"></a>Listener 监听器</h2><ul><li><p>监听器有什么用</p><ul><li>监听器实际上是Servlet规范留给我们javaweb程序员的特殊时机</li><li>特殊时刻如果想执行这段代码，你需要想到使用对应的监听器</li></ul></li><li><p>Servlet规范中提供的监听器：</p><ul><li>jakarta.servlet包下：<ul><li>ServletContextListener</li><li>ServletContextAttributeListener</li><li>ServletRequestListener</li><li>ServletRequestAttributeListener</li></ul></li><li>jakarta.servlet.http包下：<ul><li>HttpSessionListener</li><li>HttpSessionAttributeListener<ul><li>该监听器需要使用@WebListener注解进行标注</li><li>主要在session中存入数据都会出发该监听器并执行方法</li></ul></li><li>HttpSessionBindingListener<ul><li>该监听器不需要@WebListener注解标注</li><li>只要某个类实现了HttpSessionBindingListener这个监听器，然后这个类对象放入到session的时候触发bind事件，类对象从session中删除的时候，会触发unbind事件</li></ul></li><li>HttpSessionIdListener(不重要)<ul><li>session的id发生改变的时候，监听器中的唯一一个方法就会被调用</li></ul></li><li>HttpSessionActivationListener<ul><li>监听session对象的钝化和活化</li><li>钝化：session对象从内存存到硬盘文件</li><li>活化：session对象从硬盘存到内存</li></ul></li></ul></li></ul></li><li><p>实现一个监听器的步骤：</p><ul><li><p>第一步：编写一个类实现ServletContextListener接口，并实现里面方法</p><ul><li><pre><code class="java">void contextInitialized(ServletContextEvent sce)&#123;&#125;void contextDestroyed(ServletContextEvent sce)</code></pre></li></ul></li><li><p>第二步：在web.xml文件中配置，或者在类上面加上注解@WebListener</p></li></ul></li><li><p>注意：所有监听器中的方法都是不需要javaweb程序员调用的，当某个特殊的事件发生之后，被web服务器自动调用</p></li></ul><h2 id="MVC架构模式"><a href="#MVC架构模式" class="headerlink" title="MVC架构模式"></a>MVC架构模式</h2><p><img src="/2023/07/02/javaweb/Users\ZDKJ\AppData\Roaming\Typora\typora-user-images\image-20221130193806151.png" alt="image-20221130193806151"></p><ul><li>表示层：web包<ul><li>写servlet</li></ul></li><li>业务逻辑层：service包<ul><li>写业务逻辑代码</li></ul></li><li>持久层：dao包<ul><li>做数据库的增删改查</li></ul></li><li>pojo包：封装数据</li><li>utils包：放工具的</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
