<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/07/02/javaweb/"/>
      <url>/2023/07/02/javaweb/</url>
      
        <content type="html"><![CDATA[<h2 id="IDEA工具开发Servlet程序"><a href="#IDEA工具开发Servlet程序" class="headerlink" title="IDEA工具开发Servlet程序"></a>IDEA工具开发Servlet程序</h2><ol><li>第一步：New Project 创建一个空项目，然后在空工程下新建Module模块（这不是必须的，只是一个习惯），可以直接创建一个非空的Project,起名为javaweb（不是必须的）</li><li>第二步：新建模块(File–&gt;new–&gt;Module..)</li></ol><ul><li>这里新建的是一个普通的JavaSE模块(这里先不要新建Java Enterprise模块)</li><li>这个Module自动会被放在Javaweb的project下面</li><li>Module起名：servlet01</li></ul><ol start="3"><li>第三步：让Module变成JavaEE模块(让Module变成javaweb的模块)</li></ol><ul><li>在Module上右键点击:Add Framework Support(添加框架支持)</li><li>在弹出的窗口，选择Web Application(选择的是webapp的支持)</li><li>选择了这个webapp支持后，idea会自动生成一个符合servlet规范的webapp目录结构</li><li><strong>重点，需要注意：在idea工具中根据Web Application模块生成的目录中有一个web目录，这个目录就代表webapp的根</strong></li></ul><ol start="4"><li>第四步（非必须）：根据Web Application生成的资源中有index.jsp文件，这里可以选择删除这个index.jsp文件</li><li>第五步：编写servlet</li></ol><ul><li>class studentServlet implements Servlet</li><li>这个时候发现Servlet.class文件没有，怎么办？将CATALINA_HOME&#x2F;lib&#x2F;servlet-api.jar添加到class.path当中(File–&gt;Project Structrue–&gt;Modules–&gt;+加号–Add jars…)</li><li>实现jakarta.servlet.Servlet接口中的五个方法</li></ul><ol start="6"><li>第六步：在Servlet当中的servlet方法中编写业务代码并连接数据库。</li><li>第七步：在WEB-INF目录下新增了一个子目录：lib(这个目录名不能随意，必须全部小写),并且将连接数据库驱动的jar包放到lib目录下。</li><li>第八步：在web.xml文件中完成StudentServlet类的注册（请求路径和servlet对应起来）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>studentServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.javaweb.servlet.StudentServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>studentServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet/student<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="9"><li>第九步：写一个html页面写一个超链接，用户点击这个超链接，发送请求。Tomcat执行后台的studentServer</li></ol><ul><li>student.html</li><li>这个文件不能放到WEB-INF目录中,只能放到WEB-INF目录外面</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>student list<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/xmm/servlet/student&quot;</span>&gt;</span>第一个servlet<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="10"><li>第十步：让idea工具去关联Tomcat，关联的过程中将webapp部署到Tocmat服务器中。</li></ol><ul><li>idea工具右上角，绿色锤子旁边有一个：Add Configuration</li><li>点击加号，点击Tomcat Server–&gt;local</li><li>在弹出的界面中设置服务器Server的参数(基本不用动)</li><li>在当前窗口中有一个Deployment(点击这个用来部署webapp),继续点击加号，部署即可</li><li>修改Application context为：html页面中的项目名&#x2F;xmm</li></ul><ol start="11"><li>第十一步：启动Tomcat服务器</li></ol><ul><li>点击右上角的小虫子，可以采用debug的模式启动Tomcat服务器</li><li>我们在开发中建议使用debug的方法启动Tomcat</li></ul><ol start="12"><li>打开浏览器在地址栏输入：http:localhost:8080&#x2F;xmm&#x2F;student.html</li></ol><h2 id="servlet的生命周期"><a href="#servlet的生命周期" class="headerlink" title="servlet的生命周期"></a>servlet的生命周期</h2><ol><li>servlet对象是由谁来维护</li></ol><ul><li>servlet对象的创建，对象的方法调用和对象的销毁，java程序员无权干预</li><li>servlet对象的生命周期是由Tomcat服务器负责的</li><li>Tomcat服务器通常称为WEB容器，WEB容器管理Servlet对象的死活</li></ul><ol start="2"><li><p>自己new的servlet的对象不归WEB容器管理(WEB容器创建的Servlet对象，这些对象会被放到一个集合中管理，自己new的对象不在容器当中)</p></li><li><p>Tomcat服务器在默认情况下Servlet对象不会被实例化，这个设计是合理的，如果提前创建出来所有的Servlet对象，必然是耗费内存的，并且如果创建出来的Servlet如果一直没有用户访问，显然这个Servlet是一个废物，没有必要先创建</p></li><li><p>servlet对象生命周期</p></li></ol><ul><li>用户发送第一次请求的时候，servlet对象实例化，并且执行无参构造方法</li><li>对象创建之后，Tomcat立马调用init方法(init方法执行的时候，servlet对象已经存在，已经被创建出来了)</li><li>init方法执行后，Tomcat立马调用了servlet的service方法</li><li>用户第二、三、四……次请求的时候，servlet对象不会新建，还是使用之前新建的servlet对象，此时直接调用service方法，这说明：<ul><li>第一：servlet对象是单例的（单实例的，需要注意：servlet对象是单实例的，但是servlet类并不符合单例模式，我们称之为假单例。之所以单例是因为servlet对象的创建java程序员不管，对象的创建是由Tomcat说了算的，Tomcat只创建了一个，所以导致了单例，但是属于假单例，真单例模式构造方法是私有化的）</li><li>第二：无参数构造方法，init得到只在第一次用户发送请求的时候执行，也就是说无参数构造方法只执行一次，init方法只调用一次</li><li>第三：用户发一次请求service方法必然会被Tomcat服务器调用一次</li></ul></li></ul><ol start="5"><li>关闭服务器</li></ol><ul><li>servlet的destroy方法会被Tomcat调用一次</li><li>destroy方法是在服务器关闭的时候调用的，因为要销毁对象的内存</li><li>销毁对象内存之前，Tomcat服务器会自动调用destroy方法，destroy方法调用之前，对象还在没有销毁，方法执行结束后，对象内存才被Tomcat释放</li></ul><ol start="6"><li>当我们在Servlet类中编写一个有参构造方法，没有手动编写无参构造方法会出现什么问题？</li></ol><ul><li>报500错误，是一个HTTP协议的错误状态码</li><li>500一般情况下是因为服务器端的Java程序出了问题，没有无参构造方法，会导致出现500错误，无法实例化Servlet对象</li><li>所以一般情况下不建议程序员定于构造方法</li></ul><ol start="7"><li>构造方法和init都是在对象创建的时候执行一次，能不能用无参构造方法代替init方法？</li></ol><ul><li>不能，因为作为Java程序员，编写Serclet类的时候，不建议手动编写构造方法，很容易让无参构造方法消失，这个操作很可能使Servlet无法实例化</li></ul><ol start="8"><li>init，destroy，service方法什么时候使用</li></ol><ul><li>使用最多的是service方法，service一定要实现，service方法是处理用户请求的核心方法</li><li>init方法很少用，通常在init方法中做初始化操作，并且这个初始化操作只执行一次，比如初始化数据库连接池，初始化线程池</li><li>destroy方法也很少用，进行资源的关闭，马上对象被销毁，还有什么没有关闭的抓紧时间关闭，还有什么资源没保存的抓紧保存。</li></ul><h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><ul><li><p>servlet是一个接口，是servlet规范中的一员</p></li><li><p>由Tomcat(WEB服务器)实现servletContext接口</p></li><li><p>ServletContext对象由WEB服务器在启动的时候创建的</p></li><li><p>对于一个webapp只有一个ServletContext对象，对象在服务器关闭的时候销毁</p></li><li><p>ServletContext对应的其实是web.xml文件，Tomcat是一个容器，一个webapp中可以放多个webapp，一个webapp对应一个ServletContext对象</p></li><li><p>ServletContext接口中常用的方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getInitParameter</span><span class="params">(String name)</span>;<span class="comment">//通过初始化参数name获取value</span></span><br><span class="line"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title function_">getInitParameterNames</span><span class="params">()</span>;<span class="comment">//获得所有初始化参数的name</span></span><br><span class="line"><span class="comment">//通过ServletContext对象记录日志</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message , Throwable t)</span></span><br><span class="line"><span class="comment">//这些日志记录到C:\Users\ZDKJ\AppData\Local\JetBrains\IntelliJIdea2020.2\tomcat\Unnamed_servlet02</span></span><br><span class="line"><span class="comment">//Tomcat服务器logs目录下的日志文件</span></span><br><span class="line"><span class="comment">//catalina.2022-11-03.log 服务器端的Java程序运行的控制台信息</span></span><br><span class="line"><span class="comment">//localhost.2022-11-03.log ServletContext对象的log方法记录的日志信息存储到这个文件中    </span></span><br><span class="line"><span class="comment">//   localhost_access_log.2022-11-03.txt 访问日志 </span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--以上两方法是获得以下配置信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>pageSize<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>10<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--以上配置信息属于应用级的配置信息，一般一个项目中共享的信息会放到以上的标签中--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果配置信息只是想给某个servlet作为参考，那么你配置到servlet标签中即可，使用ServletConfig获取即可--&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>ServletContext对象还有另一个名字：应用域（后面还有请求域，会话域等）</p></li><li><p>如果所有的用户共享一份数据，并且这个数据很少被修改，数据量很小，可以将这些数据放到ServletContext这个应用域中</p><ul><li>如果不是共享数据没有意义，因为Servlet对象只有一个，只有共享的数据放进去才有意义</li><li>数据量太大的话，太占用内存，并且这个对象的生命周期比较长，服务器关闭的时候才会被销毁，大量数据会影响服务器性能，占用内存较小的时候可以考虑放进去</li><li>所有用户共享的数据，如果涉及到频繁的修改的操作，必然会存在线程并发所带来的安全问题，为了解决线程安全问题只能使用锁机制,锁一旦使用最终会导致性能降低，所有在ServletContext对象中的数据一般都是只读的</li></ul></li><li><p>数据量小，所有用户共享，又不修改，这样放到ServletContext中，会大大提升效率，因为应用域相当于一个缓存，当道缓存中的数据，下次用的时候，不需要再次从数据库中获取，大大提升执行效率</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAttribute</span><span class="params">(String name,Object value)</span>;<span class="comment">//存</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getAtttibute</span><span class="params">(String name)</span>;<span class="comment">//取</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeAttribute</span><span class="params">(String name)</span>;<span class="comment">//删除</span></span><br></pre></td></tr></table></figure><ul><li><strong>注：以后编写Servlet方法的时候，实际上不会直接继承GenericServlet类的，因为我们是B&#x2F;S结构的系统，这种系统是基于HTTP找文本传输协议的，在Servlet规范中，提供了一个类叫做HttpServlet，它是专门为HTTP协议准备的一个Servlet类，我们编写的Servlet要继承HttpServlet。（HttpServlet是HTTP协议专用的）使用HttpServlet处理HTTP的时候更加便捷</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以上内容的继承结构</span></span><br><span class="line">jakarta.servlet.Servlet(接口)【爷爷】</span><br><span class="line">jakarta.servlet.GenericServlet <span class="keyword">implements</span> <span class="title class_">Servlet</span>(抽象类)【儿子】</span><br><span class="line">jakarta.servlet.HttpServlet <span class="keyword">extends</span> <span class="title class_">GenericServlet</span>(抽象类)【孙子】   </span><br></pre></td></tr></table></figure><ul><li><p>连接池</p><ul><li>这里所说的连接池的连接时Java语言连接数据库的连接对象：java.sql.Connection对象</li><li>JVM是一个进程，mysql是一个进程，进程和进程之间建立连接，打开通道是十分费劲的，很消耗资源，可以提前创建好N个Connection对象，将连接对象放到一个集合中，我们把这个放有Connection对象的集合称为连接池。每一次用户连接的时候不需要在新建连接对象，直接从连接池中获取连接对象，大大提升访问效率</li><li>连接池<ul><li>最小连接数</li><li>最大连接数</li><li>连接池可以提高用户访问效率，当然也可以保证数据库的安全性</li></ul></li></ul></li><li><p>线程池</p><ul><li>Tomcat服务器本身就是支持多线程</li><li>Tomcat服务器不是在用户发送一次请求，就新建一个Thread线程对象，会先创建好N个多线程Thread对象，然后将线程对象放到集合当中，称为线程池，用户发送请求过来后，需要有一个对应的线程来处理这个请求，这个时候线程对象会直接从线程池中拿，效率比较高</li><li>所有的WEB服务器，或者应用服务器，都是支持多线程的，都有线程池机制</li></ul></li></ul><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><ul><li>HTTP的响应协议(S–&gt;B)<ul><li>HTTP的响应协议包括四部分<ul><li>状态行</li><li>响应头</li><li>空白行</li><li>响应体</li></ul></li><li>HTTP的请求报文</li><li>状态行<ul><li>第一部分：版本协议号（HTTP&#x2F;1.11）</li><li>第二部分：状态码（HTTP协议中规定的响应状态号，不同的响应结果对应不同的号码）<ul><li>200表示响应成功，正常结束</li><li>404表示访问的资源不存在，通常是因为要么路径写错了，要么是路径写对了，但是服务器中对应的资源并没有启动成功，总之404错误是前端错误</li><li>405表示前端发送的请求方式与后端请求处理方式不一致时发生：<ul><li>比如：前端是POST请求，后端的处理方式按照get方式进行处理时，发生405</li><li>比如：前端是GET请求，后端的处理方式按照post方式进行处理时，发生405</li></ul></li><li>500表示服务器端的程序出现异常，一般会认为都武器端的错误导致的</li><li>以4开始的，一般是浏览器端错误导致的</li><li>以5开始的，一般是服务器端错误导致的</li></ul></li><li>第三部分：状态的描述信息<ul><li>ok表示正常成功结束</li><li>not found表示资源找不到</li></ul></li></ul></li><li>响应头<ul><li>响应的内容类型</li><li>相应的内容长度</li><li>响应的时间</li><li>….</li></ul></li><li>空白行<ul><li>用来分隔响应头和响应体</li></ul></li><li>响应体<ul><li>响应体是响应的正文，这些内容是一个长的字符串，这个字符串被浏览器渲染，解释并执行，最终展示出效果</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 ok                         状态行</span><br><span class="line">Content-Type:text/html;charset=UTF-8    响应头</span><br><span class="line">Content-Length:160</span><br><span class="line">Date:Mon,08 Nov 2021 13:19:36 GMT</span><br><span class="line">Keep-Alive:timeout=20</span><br><span class="line">Connection:keep-alive</span><br><span class="line">                                        空白行</span><br><span class="line">&lt;!doctype html&gt;                         响应体 </span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">       &lt;title&gt;from get servlet&lt;/title&gt;</span><br><span class="line">   &lt;/head&gt;</span><br><span class="line">   &lt;body&gt;</span><br><span class="line">       &lt;h1&gt;from get servlet&lt;/h1&gt;</span><br><span class="line">   &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;    </span><br></pre></td></tr></table></figure><ul><li>HTTP的请求协(B–&gt;S)<ul><li>请求行<ul><li>第一部分：请求方式（七种）<ul><li>get（常用的）</li><li>post（常用的）</li><li>delete</li><li>put</li><li>head</li><li>options</li><li>trace</li></ul></li><li>第二部分：URI<ul><li>URI是统一资源标识符，代表网络中某个资源的名字，但是通过URI是无法定位资源</li><li>URL是统一资源定位符。代表网络中某个资源，同时，通过URL是可以定位到该资源的</li><li>URL包括URI<ul><li><a href="http://localhost:8080/servlet/index.html%E8%BF%99%E6%98%AFURL">http://localhost:8080/servlet/index.html这是URL</a></li><li>&#x2F;servlet&#x2F;index.html这是URI</li></ul></li></ul></li><li>第三部分：HTTP协议版本号</li></ul></li><li>请求头<ul><li>请求的主机</li><li>主机的端口号</li><li>浏览器信息</li><li>平台信息</li><li>cookie</li><li>….</li></ul></li><li>空白行<ul><li>用来区分请求头和请求体</li></ul></li><li>请求体<ul><li>向服务器发送的具体数据</li></ul></li></ul></li><li>使用Chrome浏览器:F12，然后找到network，通过这个面板可以查看协议的具体内容</li><li>怎么向服务器发送GET请求，怎么向服务器发送的POST请求<ul><li>到目前为止，只有一种情况可以发送POST请求：使用form表单，并且在form标签中的method属性值为method&#x3D;”post”</li><li>其他情况一律是get请求：<ul><li>在浏览器地址栏直接输入的URL，敲回车，属于get请求</li><li>在浏览器上直接点击超链接，属于get请求</li><li>使用form表单提交数据时，form标签中没有method属性，默认是get</li><li>使用form的时候，form标签中的method属性值为method&#x3D;”get”</li><li>….</li></ul></li></ul></li><li>GET和POST请求的区别<ul><li>get请求发送数据的时候，数据会挂在URI的后面，并且在URI后面添加一个”?”，”?”后面是数据，这样会导致发送的数据显示在浏览器的地址栏中（get请求在请求行上发送数据）<ul><li><a href="http://localhost:8080/servlet/getServlet?username=dehua&password=666">http://localhost:8080/servlet/getServlet?username=dehua&amp;password=666</a></li></ul></li><li>post请求发送数据的时候，在请求体当中发送，不会回显到浏览器地址栏上，也就是说post发送的数据，在浏览器地址上看不到</li><li>get请求只能发送普通的字符串，并且发送的字符串长度有限制，不同的浏览器限制不同，没有明确规定</li><li>get请求无法发送大数据量</li><li>post请求可以发送任何类型的数据，包括普通字符串，流媒体等信息：视频、声音、图片</li><li>post请求可以发送大数据量，理论上没有长度限制</li><li>get请求在W3C中是这样说的：get请求比较适合从服务器端获取数据</li><li>post请求在W3C中是这样说的：post请求比较适合从浏览器向服务器端传送数据</li><li>get请求是安全的，get请求时绝对安全的，因为get请求只是为了从服务器上获取数据，不会对服务器造成威胁。（get请求本身是安全的，你不要用错了，用错了还冤枉人家get不安全，这好吗，这不好，那是你自己问题，不是get请求的问题）</li><li>post请求是危险的，因为post请求是向服务器提交数据，如果这些数据通过后门的方式进入到服务器当中，服务器是很危险的，另外post是为了提交数据，所以一般情况下拦截请求的时候，大部分会拦截（监听）post请求</li><li>get支持缓存<ul><li><a href="https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg">https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg</a></li><li>任何一个get请求最终的响应结果都会被浏览器存起来，在浏览器当中：<ul><li>一个get请求的路径a对应一个资源</li><li>一个get请求的路径b对应一个资源</li><li>一个get请求的路径c对应一个资源</li><li>…</li></ul></li><li>实际上只要发送了一个get请求，浏览器第一件事就是先从本地浏览器缓存中找，找不到的时候才会去服务器上获取，这种缓存机制目的是为了提高用户体验</li><li>如果有一个需求：不希望get请求走缓存，而是每次请求都去服务器上找资源，不去本地浏览器的缓存中获取<ul><li><a href="https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=948491511">https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=948491511</a></li><li><a href="https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=5661662">https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=5661662</a></li><li><a href="https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=%E7%B3%BB%E7%BB%9F%E6%AF%AB%E7%A7%92%E6%95%B0">https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=系统毫秒数</a></li><li>解决方案：在每个路径的后面加一个时刻都在变化的时间戳，这样每次的路径都不一样，浏览器就不会走缓存了</li></ul></li></ul></li><li>post不支持缓存<ul><li>post请求之后，服务器的响应结果不会被浏览器缓存起来，因为这个缓存没有意义</li></ul></li></ul></li><li>如何选择get请求和post请求<ul><li>如果请求是想获取服务器的数据，建议使用get请求，如果这个给是为了向服务器提交数据，建议使用post请求</li><li>大部分的form表单是向服务器提交用户手机的大量数据，服务器将这些数据保存，使用post请求</li><li>如果表中敏感信息，建议使用post请求，因为get请求会把敏感信息显示到浏览器地址栏上（例如：密码信息）</li><li>做文件上传一定是post请求，因为这不是普通的文本</li><li>其他情况都可以使用get请求</li></ul></li><li>不管使用get请求还是使用post请求，发送数据的格式是完全相同的，只不过位置不同，格式是统一的：<ul><li>name&#x3D;value&amp;name&#x3D;value&amp;name&#x3D;value</li><li>以form表单为例，name是form表单中input标签的name</li><li>以form表单为例，value是form表单中input标签的value</li></ul></li></ul><h2 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">        <span class="type">long</span> lastModified;</span><br><span class="line">        <span class="keyword">if</span> (method.equals(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">            lastModified = <span class="built_in">this</span>.getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span> (lastModified == -<span class="number">1L</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">long</span> ifModifiedSince;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ifModifiedSince = req.getDateHeader(<span class="string">&quot;If-Modified-Since&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">                    ifModifiedSince = -<span class="number">1L</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ifModifiedSince &lt; lastModified / <span class="number">1000L</span> * <span class="number">1000L</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">                    <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp.setStatus(<span class="number">304</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line">            lastModified = <span class="built_in">this</span>.getLastModified(req);</span><br><span class="line">            <span class="built_in">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">            <span class="built_in">this</span>.doHead(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doPost(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;PUT&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doPut(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;DELETE&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doDelete(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;OPTIONS&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doOptions(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;TRACE&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doTrace(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;method&#125;;</span><br><span class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">            resp.sendError(<span class="number">501</span>, errMsg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过源码的分析，</span></span><br><span class="line"><span class="comment">/*假设前端发送的是get请求，后端程序员重写的是doPost方法，或者前端程序员发送的是post请求，后端程序员重写的是doPost方法，会发生405这样一个错误</span></span><br><span class="line"><span class="comment">405表示的是前端的错误，发送请求方式不对，和服务器不一致，不是服务器需要的请求方式，所以可以看出只要HttpServlet类中的doPost或者doGte方法执行了必然会导致405错误</span></span><br><span class="line"><span class="comment">所以只有后端重写了哪个方法，前端发送对应请求才能避免405错误</span></span><br><span class="line"><span class="comment">但是，不能为了避免405错误把doPost方法和doGet方法都重写，这样虽然能避免405错误，因为405错误还是有用的。该报错的时候就让他报错，而且如果你doGet和doPost方法都重写还不如直接重写servlet方法，这样代码量还少一些*/</span></span><br></pre></td></tr></table></figure><h2 id="web欢迎页"><a href="#web欢迎页" class="headerlink" title="web欢迎页"></a>web欢迎页</h2><ul><li><p>访问方式</p><ul><li>如果访问的是<a href="http://localhost:8080/servlet/index.html%E5%B0%B1%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E6%8C%87%E5%AE%9A%E7%9A%84%E8%B5%84%E6%BA%90">http://localhost:8080/servlet/index.html就直接访问指定的资源</a></li><li>如果访问的是<a href="http://localhost:8080/servlet%E6%B2%A1%E6%9C%89%E6%8C%87%E5%AE%9A%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%EF%BC%8C%E4%BC%9A%E8%AE%BF%E9%97%AE%E8%AE%BE%E7%BD%AE%E7%9A%84%E6%AC%A2%E8%BF%8E%E9%A1%B5">http://localhost:8080/servlet没有指定资源路径，会访问设置的欢迎页</a></li></ul></li><li><p>设置欢迎页步骤</p><ul><li><p>第一步：在idea工具的web目录下新建一个login.html</p></li><li><p>第二步：在web.xml文件中进行以下配置</p><ul><li><pre><code class="xml">    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;welcome/login.html&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - **注：设置欢迎页面的时候路径不需要以&quot;/&quot;开始，并且这个路径默认是从webapp的根下开始查找**</span><br><span class="line"></span><br><span class="line">  - 第三步：开启服务器，浏览器地址栏输入地址</span><br><span class="line"></span><br><span class="line">* 一个webapp可以设置多个欢迎页面</span><br><span class="line"></span><br><span class="line">  - ```xml</span><br><span class="line">        &lt;welcome-file-list&gt;</span><br><span class="line">            &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;</span><br><span class="line">            &lt;welcome-file&gt;welcome/login.html&lt;/welcome-file&gt;</span><br><span class="line">        &lt;/welcome-file-list&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>越靠上的优先级越高</p></li></ul></li><li><p>当文件名设置为index.html的时候，不需要再web.xml文件中进行欢迎页面的设置，因为在Tomcat服务器已经设置好了</p><ul><li><p>实际上设置欢迎页面的地方有两个</p><ul><li><p>一个在webapp内部的web.xml文件中(这个地方属于局部配置)</p></li><li><p>一个在CATALINA_HOME&#x2F;conf&#x2F;web.xml文件中进行配置(这个地方的配置属于全局配置)</p><ul><li><pre><code class="xml">    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      - Tomcat服务器的全局观影页面是：index.html,index.htm,index.jsp，如果一个web站点没有设置局部欢迎页面，Tomcat服务器会以index.html,index.htm,index.jsp作为一个web站点的欢迎页面</span><br><span class="line"></span><br><span class="line">      - 注意原则：局部优先原则（就近原则）</span><br><span class="line"></span><br><span class="line">- 欢迎页面也可以是一个Servlet</span><br><span class="line"></span><br><span class="line">## 关于WEB-INF目录</span><br><span class="line"></span><br><span class="line">* 在WEB-INF目录下新建一个welcome.html</span><br><span class="line">* 打开浏览器访问：http:localhost:8080/WEB-INF/welcome.html出现404错误</span><br><span class="line">* 注意：放在WEB-INF目录下的资源是受保护的，在浏览器上不能够通过路径直接访问，所以像html,css,javascrip,image等静态资源一定要放到WEB-INF之外</span><br><span class="line"></span><br><span class="line">## HttpServletRequest接口详解</span><br><span class="line"></span><br><span class="line">* request和response对象生命周期</span><br><span class="line">  - request对象和response对象，一个是请求对象，一个是响应对象。这两个对象只在当前请求中有效</span><br><span class="line">  - 一次请求对应一个request</span><br><span class="line">  - 两次请求对应两个request</span><br><span class="line"></span><br><span class="line">* HttpServletRequest接口常用方法</span><br><span class="line"></span><br><span class="line">  - ````java</span><br><span class="line">    Map&lt;String,String[]&gt; getParameterMap() //这个是获取整个Map</span><br><span class="line">    Enumeration&lt;String&gt; getParameterNames()//这个是获取Map集合中所以的key</span><br><span class="line">    String[] getParamterValues(String name)//根据key获取Map的value</span><br><span class="line">    String getParamter(String name)//获取value这个一维数组的第一个元素，这个方法最常用    </span><br><span class="line">    ````</span><br><span class="line"></span><br><span class="line">  - 前端提交的数据格式：username=kun&amp;password=999&amp;interest=sing&amp;interest=dance&amp;interest=basketBall&amp;interest=Rap</span><br><span class="line"></span><br><span class="line">**请求域对象**</span><br><span class="line"></span><br><span class="line">* 请求域对象的作用范围比应用域小很多，声明周期短很多，请求域只在一次请求内有效</span><br><span class="line"></span><br><span class="line">* 一个请求对象request对应一个请求域对象，一次请求结束之后请求域就销毁了</span><br><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  //请求域也有ServletContext中的三个方法</span><br><span class="line">  void setAttribute(String name,Object obj);</span><br><span class="line">  Object getAttribute(String name);</span><br><span class="line">  void removeAttribute(String name);</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul></li><li><p>请求域和应用域选择的原则一般是，选择内存占用较小的</p></li><li><p>跳转</p><ul><li><p>转发</p><ul><li><pre><code class="java">req.getRequestDispatcher(&quot;/test.html&quot;).forward(req,resp);//获取请求转发器对象，并调用转发器对象的forward方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 两个Servlet共享数据的方法</span><br><span class="line"></span><br><span class="line">  - 直接将数据放到ServletContext应用域当中，虽然可以，但是作用域的范围太大，占用资源太多，不建议使用</span><br><span class="line">  - 可以将数据放到request域当中，然后AServlet转发到BServlet，保证AServlet和BServlet在一次请求当中，这样可以做到两个servlet共享同一份数据</span><br><span class="line"></span><br><span class="line">* 转发的下一个资源不一定是一个servlet，只要是Tomcat服务器当中合法的资源都可以转发，例如：html....</span><br><span class="line"></span><br><span class="line">* **注：转发的时候路径写法要注意，转发的路径以&quot;/&quot;开始，不要加i项目名**</span><br><span class="line"></span><br><span class="line">* 关于两个容易混淆的方法</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  String username = request.getParameter(&quot;username&quot;);</span><br><span class="line">  //这个获取的是用户在浏览器中提交的数据，数据形式为 uri?username=zhangsan&amp;userpwd=123&amp;sex=1</span><br><span class="line">  Object obj = request.getAttribute(&quot;name&quot;);</span><br><span class="line">  //这个获取的是请求域中绑定的数据，在此之前肯定执行过，request.setAttribute(&quot;name&quot;,new Object());</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li><li><p>HttpServletRequest</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">remoteAddr</span> <span class="operator">=</span> request.getRemoteAddr();</span><br><span class="line"><span class="comment">//获取客户端的ip地址</span></span><br><span class="line">request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//设置请求字体字符集，显然这个方法处理的是Post请求乱码问题，不适用于Get请求</span></span><br><span class="line"><span class="comment">//Tomcat10之后，request请求体当中的字符集默认是UTF-8，不需要设置字符集，不会出现乱码问题</span></span><br><span class="line"><span class="comment">//Tomcat9之前，包括Tomcat9，如果前端请求体提交的是中文，后端获取后会出现乱码，要用这个方法解决</span></span><br><span class="line">request.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//在Tomcat9之前，包括Tomcat9,响应中文即输出在控制台的中文也是有乱码的，使用以上方法解决</span></span><br><span class="line"><span class="comment">//在Tomcat10之后，包括Tomcat10，响应中文的时候就不在出现乱码问题，以上代码不需要设置UTF-8</span></span><br><span class="line"><span class="comment">/*    &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span></span><br><span class="line"><span class="comment">               connectionTimeout=&quot;20000&quot;</span></span><br><span class="line"><span class="comment">               redirectPort=&quot;8443&quot; </span></span><br><span class="line"><span class="comment">               URIEncoding=&quot;UTF-8&quot;/&gt;          */</span></span><br><span class="line"><span class="comment">//修改CATALINA_HOME/conf/server.sml配置文件，为以上内容，可以解决get请求乱码问题，get请求发送的时候，数据是在请求行上提交的，不是在请求体上提交的</span></span><br><span class="line"><span class="comment">//从Tomcat8之后，URIEncoding的默认值就是UTF-8，所以get请求也不会有乱码了</span></span><br><span class="line"><span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> request.getContextPath();</span><br><span class="line"><span class="comment">//获取应用的根路径 输出/servlet05即项目名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line"><span class="comment">//获取请求方式 输出get/post....</span></span><br><span class="line"><span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI(); </span><br><span class="line"><span class="comment">//获取请求的URI 输出/servlet05/B这样的URI</span></span><br><span class="line"><span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> request.getServletPath();</span><br><span class="line"><span class="comment">//获取servlet path 输出/B这样的Servlet路径</span></span><br></pre></td></tr></table></figure><h2 id="纯Servlet增删改查项目的一个bug的解决"><a href="#纯Servlet增删改查项目的一个bug的解决" class="headerlink" title="纯Servlet增删改查项目的一个bug的解决"></a>纯Servlet增删改查项目的一个bug的解决</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type = <span class="string">&#x27;text/javascript&#x27;</span>&gt;</span><br><span class="line">         <span class="keyword">function</span> <span class="title function_">del</span> (deptno)&#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&#x27;删除后不可恢复，请慎重选择&#x27;</span>))&#123;</span><br><span class="line">             <span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;&quot;+contextPath+&quot;/dept/delete?deptno=&#x27;</span>+deptno</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;javascript:void(0)&#x27;</span> <span class="attr">onclick</span> = <span class="string">&#x27;del(&quot;+deptno+&quot;)&#x27;</span> &gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>这样写，当鼠标单击删除的时候，会报del方法未定义的错误</li><li>正确写法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type = <span class="string">&#x27;text/javascript&#x27;</span>&gt;</span><br><span class="line">         del = <span class="keyword">function</span> (<span class="params">deptno</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&#x27;删除后不可恢复，请慎重选择&#x27;</span>))&#123;</span><br><span class="line">             <span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;&quot;+contextPath+&quot;/dept/delete?deptno=&#x27;</span>+deptno</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>如果函数写在$(functiong{ })或者$().ready(function () {});内部，那么 οnclick&#x3D;”del(“+deptno+”)”; 时 ,不能写成  function del(){}，也不能写成var del&#x3D; function(){}，只能写成del &#x3D; function(){}。</strong></p><h2 id="在一个web应用中如何完成资源跳转"><a href="#在一个web应用中如何完成资源跳转" class="headerlink" title="在一个web应用中如何完成资源跳转"></a>在一个web应用中如何完成资源跳转</h2><ul><li><p>两种完成跳转的方式</p><ul><li>转发</li><li>重定向</li></ul></li><li><p>两种方式的区别</p></li><li><p>代码上的区别</p><p>​    转发</p><ul><li><pre><code class="java">RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;/dept/list&quot;);dispatcher.forward(&quot;request,response&quot;);//转发的时候是一次请求，不管转发了多少次，都是一次请求//AServlet转发到BServlet，再转发到CServlet不管转发了多少次都是一次request//这就是为什么调用forward方法的时候会将当前的request和response对象传给下一次Sevlet<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  重定向</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  response.sendRedirect(req.getContextPath()+&quot;/dept/list&quot;);</span><br><span class="line">  //注意：路径上要加上项目名，因为相当于浏览器发送请求</span><br><span class="line">  //以上代码会将请求路径：/oa/dept/list发送给浏览器，浏览器向服务器发一次全新的请求</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>形式上的区别</p><ul><li>转发（一次请求）<ul><li>在浏览器地址栏上的请求是<a href="http://localhost:8080/Servlet/a,%E6%9C%80%E7%BB%88%E8%AF%B7%E6%B1%82%E7%BB%93%E6%9D%9F%E5%90%8E%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BF%98%E6%98%AF%E8%BF%99%E4%B8%AA">http://localhost:8080/Servlet/a,最终请求结束后，浏览器地址栏还是这个</a></li></ul></li><li>重定向（两次请求）<ul><li>在浏览器地址栏上发送的请求是：<a href="http://localhost:8080/Servlet/a,%E6%9C%80%E7%BB%88%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E4%B8%8A%E6%98%BE%E7%A4%BA%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%AF%EF%BC%9Ahttp://localhost:8080/Servlet/b">http://localhost:8080/Servlet/a,最终在浏览器地址栏上显示的地址是：http://localhost:8080/Servlet/b</a></li></ul></li></ul></li><li><p>转发和重定向的本质区别</p><ul><li>转发：是由WEB服务器控制的，A资源跳转到B资源，这个跳转动作是Tomcat服务器内部完成的</li><li>重定向：是浏览器完成的，具体跳转到哪个资源，浏览器说了算</li></ul></li><li><p>转发和重定向如何选择</p><ul><li>如果在上一个Servlet中向request域中绑定了数据，希望在下一个Servlet当中把request域的数据取出来，使用转发机制</li><li>剩下所有的请求均使用重定向</li></ul></li><li><p>跳转的下一个资源没有要求，可以是Servlet，jsp，html…..</p></li></ul><h2 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h2><ul><li><p>在web.xml文件中进行Servlet信息的配置，显然效率开发比较低，而且对于一个大项目来说，最终的web.xml可能会达到几十兆</p></li><li><p>而且web.xml文件中的配置信息是很少修改的，所有在Servlet3.0版本之后推出注解开发，将配置信息写到Java类</p><ul><li>并不是不需要写配置文件了，一般是注释+配置文件的开发模式</li><li>一些不常修改的配置信息建议使用注解，一些可能会修改的信息建议写到配置文件中</li></ul></li><li><p>第一个注解</p><ul><li><pre><code class="java">import jakarta.servlet.annotation.WebServlet;@WebServlet(&quot;/wel&quot;)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 在Servlet类上使用：</span><br><span class="line"></span><br><span class="line">    - name：用来指定Servlet的名字，相当于&lt;servlet-name&gt;</span><br><span class="line">    - urlPatterns：用来指定Servlet的映射路径，可以指定多个字符串，相当于&lt;url-pattern&gt;</span><br><span class="line">    - loadOnStartUp：用来指定在服务器启动阶段是否加载该Servlet,相当于&lt;load-on-startup&gt;</span><br><span class="line">    - value：同样用来映射路径，可以指定多个字符串，注解属性名为value的时候，使用注解的时候，value属性名是可以忽略的</span><br><span class="line">    - 注意：不是必须将所有属性都写上，只需要提供需要的，属性是一个数组的时候，如果数组中只有一个元素，使用该注解的时候，属性值的大括号可以省略</span><br><span class="line"></span><br><span class="line">* 注解对象的使用格式</span><br><span class="line"></span><br><span class="line">  - @注解名称(属性名=属性值，属性名=属性值.....)</span><br><span class="line"></span><br><span class="line">## jsp</span><br><span class="line"></span><br><span class="line">* jsp的基本语法</span><br><span class="line"></span><br><span class="line">  - 在jsp文件中直接编写文字，会被翻译到Servlet类的service方法的out.write(&quot;&quot;)的双引号中，被Java程序当作普通字符串输出到浏览器</span><br><span class="line">- 在jsp文件中编写html，css，js代码，这些代码对于jsp来说也是一个普通字符串，但是把这些普通字符串一旦输出浏览器，浏览器会对这些html，css，js代码进行解释执行，呈现出对应效果</span><br><span class="line">  - 乱码问题的解决</span><br><span class="line"></span><br><span class="line">    - 通过page指令设置相应的内容类型，在内容类型的后面添加：charset=UTF-8</span><br><span class="line">    - &lt;%@page contentType=&quot;text/html;charset=UTF-8&quot;%&gt;,表示响应的内容是text/html采用的字符集是UTF-8</span><br><span class="line">  - 在jsp中编写Java代码</span><br><span class="line">  </span><br><span class="line">  - &lt;% Java语句 %&gt;</span><br><span class="line">      - 在这个符号中编写的被视为Java程序，被编译到Servlet类的service方法内部</span><br><span class="line">    - 时刻记住此时此刻，你正在一个方法体的内部编写代码，想清楚什么能写，什么不能写，例如：不能写静态代码块，不能写方法，不能定义成员变量</span><br><span class="line">      - 在service方法中编写的的代码是有顺序的，方法体当中的代码遵循自上而下顺序进行执行</span><br><span class="line">      - 一个jsp文件中可以出现多个&lt;%%&gt;符号</span><br><span class="line">    - &lt;!%%&gt;</span><br><span class="line">      - 在这个符号中编写的Java程序会自动翻译到service方法之外</span><br><span class="line">      - 这个语法很少用，因为在service方法编写静态变量和实例变量，都会存在线程安全问题，jsp就是servlet，servlet是单例的，多线程并发的环境下，这个静态的变量和实例变量一旦有修改操作，必然会存在线程安全问题</span><br><span class="line">    - jsp输出语句</span><br><span class="line">      - 输出语句是像浏览器输出一个Java变量</span><br><span class="line">      - 语法&lt;% String name = &quot;dehau&quot;; out.write(&quot;name=&quot; + name) %&gt;</span><br><span class="line">      - 注意：以上代码中out是jsp的九大内置对象之一，可以直接拿来调用，必须在service方法内部</span><br><span class="line">  - &lt;%= %&gt;，等号后面写上输出的内容，会被翻译到service方法中，翻译成out.print();（输出的内容含有Java变量，输出的内容是一个动态内容，而输出一个死的字符串就直接在jsp中写就能输出）</span><br><span class="line">  </span><br><span class="line">* JSP指令</span><br><span class="line"></span><br><span class="line">  - 指令的作用：指导JSP的翻译引擎，如何工作(指导当前jsp翻译引擎如何翻译jsp文件)</span><br><span class="line"></span><br><span class="line">  - 指令包括：</span><br><span class="line"></span><br><span class="line">    - include：包含指令，在jsp中完成静态包含，很少用了</span><br><span class="line">    - taglib：引入标签库的指令，先不管</span><br><span class="line">    - page：重点</span><br><span class="line"></span><br><span class="line">  - 指令语法：</span><br><span class="line"></span><br><span class="line">    - &lt;%@指令名 属性名=属性值 属性名=属性值 属性名=属性值....%&gt;</span><br><span class="line"></span><br><span class="line">  - page指令中常用属性</span><br><span class="line"></span><br><span class="line">    - ```jsp</span><br><span class="line">      &lt;%@page session=&quot;true/false&quot;%&gt;</span><br><span class="line">      true表示启用jsp内置对象session，表示一定启动session对象，没有会创建，如果没有设置，默认值是session=&quot;true&quot;</span><br><span class="line">      session=&quot;false&quot;表示不启动内置对象session，当前jsp页面无法使用内置对象</span><br></pre></td></tr></table></figure>- ```jsp  &lt;%@page contentType=&quot;text/json&quot;%&gt;  contentType属性用来设置响应内容的类型  同样可以设置字符集  &lt;%@page contentType=&quot;text/json;charset=&quot;UTF-8&quot;%&gt;  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```jsp</span><br><span class="line">  &lt;%@page pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">  pageEncoding=&quot;UTF-8&quot;表示设置响应时采用的字符集</span><br></pre></td></tr></table></figure>- ```jsp  &lt;%@page import=&quot;java.util.*&quot;%&gt;  import语句，导包  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```jsp</span><br><span class="line">  &lt;%@page errorPage=&quot;/error.jsp&quot;%&gt;</span><br><span class="line">  当页面出现错误的时候，跳转到error.jsp页面</span><br><span class="line">  errorPage属性用来指定出错之后跳转的错误位置</span><br></pre></td></tr></table></figure>- ```jsp  &lt;%@page isErrorPage=&quot;true&quot;%&gt;  表示启用jsp九大内置对象之一：exception  默认值是false  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">  - jsp九大内置对象</span><br><span class="line"></span><br><span class="line">    - jakarta.servlet.jsp.PageContext  pageContext 页面作用域</span><br><span class="line">    - jakarta.servlet.http.HttpServletRequest  request 请求作用域</span><br><span class="line">    - jakarta.servlet.http.HttpSession  session 会话作用域</span><br><span class="line">    - jakarta.servlet.ServletContext  application 应用作用域</span><br><span class="line">      - pagecontext&lt;request&lt;session&lt;application</span><br><span class="line">      - 以上四个作用域都有：setAttribute,getAttribute,removeAttribute方法</span><br><span class="line">      - 以上作用域尽可能使用最小的</span><br><span class="line">    - jakarta.lang.Throwable  expection</span><br><span class="line">    - jakarta.servlet.ServletConfig  config</span><br><span class="line">    - jakarta.lang.Object  page(其实是this，当前的servlet对象)</span><br><span class="line">    - jakarta.servlet.jsp.jspWriter out(输出语句)</span><br><span class="line">    - jakarta.servlet.http.HttpServletResponse  response(负责响应)</span><br><span class="line"></span><br><span class="line">* jsp本质是一个servlet，和servlet到底有什么区别</span><br><span class="line">  - servlet的职责：擅长收集数据(强项是逻辑处理，然后连接数据库，获取/收集数据)</span><br><span class="line">  - jsp的职责：展示数据(强项是做数据的展示)</span><br><span class="line"></span><br><span class="line">## session 会话机制</span><br><span class="line"></span><br><span class="line">* 什么是会话</span><br><span class="line"></span><br><span class="line">  - 打开浏览器，进行一系列操作，然后最终将浏览器关闭，这个整个过程叫做一个会话，会话在服务器端也有一个Java对象，这个Java对象叫做session</span><br><span class="line">  - 在浏览器点击了一下，然后到页面停下来，可以粗略认为是一次请求，请求对应的服务器对象是request</span><br><span class="line">  - 一个会话中包含多次请求</span><br><span class="line"></span><br><span class="line">* session对象最主要的作用是：保存会话状态。（用户登录成功了，这是一种登陆成功的状态，使用session对象可以保留会话状态，把登陆状态一直保存住）</span><br><span class="line"></span><br><span class="line">* 为什么需要session对象保存会话状态</span><br><span class="line"></span><br><span class="line">  - 因为HTTP协议是一种无状态协议(请求的时候，B和S是连接的，但请求结束之后连接就断了，这样服务器压力小)</span><br><span class="line">  - 只要B和S断开了，关闭浏览器的动作，服务器是不知道的</span><br><span class="line"></span><br><span class="line">* 为什么不使用request对象保存会话状态，为什么不用ServletContext对象保存状态</span><br><span class="line"></span><br><span class="line">  - request是一次请求一个对象，作用域太小</span><br><span class="line">  - ServletContext对象是服务器启动的时候创建，服务器关闭的时候销毁，而且这个ServletContext对象只要一个，作用域太大</span><br><span class="line">  - request请求域(HttpServletRequest)&lt;session会话域(HttpSession)&lt;application域(ServletContext)</span><br><span class="line"></span><br><span class="line">* session对象</span><br><span class="line"></span><br><span class="line">  - session对象是存储在服务器中的</span><br><span class="line"></span><br><span class="line">  - 一个session对象对应一个会话，一次会话对应多个请求</span><br><span class="line"></span><br><span class="line">  - 获取方式：</span><br><span class="line"></span><br><span class="line">    - HttpSession session = request.getSession();从服务器中获取当前的session对象，如果没有则新建一个session对象</span><br><span class="line">    - HttpSession session  =  request.getSession(false);从服务器中获取当前session对象，如果没有不新建返回一个null</span><br><span class="line"></span><br><span class="line">  - 实现原理：</span><br><span class="line"></span><br><span class="line">    - 在web服务器中有一个session列表，类似于map集合，这个map集合的key存储的是sessionid，value存储的是session对象</span><br><span class="line">    - 用户第一次发送请求的时候，服务器会创建一个新的session对象，同时给session对象生成一个id，然后web服务器会将session对象的id发送给浏览器，浏览器将session的id保存在浏览器的缓存中</span><br><span class="line">    - 用户第二次发送请求的时候，会自动将浏览器缓存中的session对象的id自动发送给服务器，服务器获取到id，然后根据id查找对应的session对象</span><br><span class="line"></span><br><span class="line">  - session的两种销毁</span><br><span class="line"></span><br><span class="line">    - 超时销毁</span><br><span class="line"></span><br><span class="line">      - ```xml</span><br><span class="line">            &lt;session-config&gt;</span><br><span class="line">                &lt;session-timeout&gt;30&lt;/session-timeout&gt;</span><br><span class="line">            &lt;/session-config&gt;</span><br></pre></td></tr></table></figure>  - 在web.xml文件中的配置信息写上以上内容即可，表示超过三十分钟后session对象销毁- 手动销毁  - 例如，网银的安全退出的操作，就是手动销毁session对象</code></pre></li><li><p><strong>注：关闭浏览器后，浏览器中保存的sessionid消失，下次重新打开浏览器的时候，浏览器的缓存中没有这个sessionid，自然找不到对应的session对象，等同于会话结束</strong></p></li></ul></li><li><p>jsessionid &#x3D; xxxxxxxxx 是以Cookie的形式存在保存在浏览器中的</p></li><li><p>Cookie禁用了，每次请求都会新建一个session对象，此时服务器会正常发送cookie给浏览器，但是浏览器拒收</p><ul><li><p>为了实现session机制，需要使用URL重写机制</p></li><li><p><a href="http://localhost:8080/servlet08/dehua/tuji;JSESSIONID=A532F1125D878307C726D025E547492E">http://localhost:8080/servlet08/dehua/tuji;JSESSIONID=A532F1125D878307C726D025E547492E</a></p></li><li><p>URL重写机制会提高开发成本，开发人员在编写任何请求路径的时候，后面都添加一个sessionid，给开发提高难度，所以，大部分网站的设计是，如果你禁用了cookie就别用了</p></li></ul></li></ul><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul><li><p>session的实现原理中，每一个session对象都会关联一个对应的sessionid，例如：</p><ul><li>JSESSIONID&#x3D;A532F1125D878307C726D025E547492E</li><li>以上这个键值对数据其实就是cookie数据</li><li>对于session关联的cookie来说，这个cookie是被保存在浏览器的运行内存中</li><li>只要浏览器不关闭，用户再次发送请求的时候，会自动将运行内存中的cookie数据发送给服务器</li><li>服务器通过键值对的值A532F1125D878307C726D025E547492E来找到对应的session对象</li></ul></li><li><p>cookie最终是保存在浏览器客户端上的</p><ul><li>可以保存在运行内存中(浏览器只要关闭cookie就消失了)</li><li>也可以保存在硬盘文件中(永久保存)</li></ul></li><li><p>cookie的作用</p><ul><li>cookie和session机制其实都是为了保存会话状态</li><li>cookie是将会话的状态保存在浏览器客户端上(cookie将数据存储在浏览器客户端上)</li><li>session是将会话的状态保存在服务器端(session对象是存储在服务器上)</li></ul></li><li><p>在Java的servlet中，对cookie提供了哪些支持</p><ul><li>提供了一个cookie类专门表示cookie数据：jakarta.servlet.http.Cookie</li><li>java程序把cookie数据发送给浏览器:request.addCookie(cookis)</li></ul></li><li><p>在Http协议中是这样规定的：当浏览器发送请求时，会自动携带path下的cookie数据给服务器(通过URL)</p></li><li><p>关于cookie的有效时间</p><ul><li>用Java设置有效时间：cookie.setMaxAge(60*60)设置cookie在一小时之后失效，所以数字的单位是秒</li><li>没有设置有效时间，，默认保存在浏览器的运行内存中，浏览器关闭则cookie消失</li><li>设置时间大于零，cookie一定会存储在硬盘文件当中</li><li>设置时间等于零，cookie会被删除，同名cookie被删除</li><li>设置时间小于零，保存在浏览器的运行内存中，和没写cookie.setMaxAge(-1)这行代码效果相同</li></ul></li><li><p>关于cookie的path，cookie的相关路径</p><ul><li>假设现在发送的请求是<a href="http://localhost:8080/servlet/cookie/generate%E7%94%9F%E6%88%90%E7%9A%84cookie%EF%BC%8C%E5%A6%82%E6%9E%9Ccookie%E6%B2%A1%E6%9C%89%E8%AE%BE%E7%BD%AEpath%EF%BC%8C%E9%BB%98%E8%AE%A4%E7%9A%84path%E6%98%AF%EF%BC%9Ahttp://localhost:8080/servlet/cookie/%E4%BB%A5%E5%8F%8A%E5%AE%83%E7%9A%84%E5%AD%90%E8%B7%AF%E5%BE%84%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%AA%E8%A6%81%E5%8F%91%E9%80%81%E8%BF%99%E4%B8%AA%E8%B7%AF%E5%BE%84%E5%8F%8A%E5%85%B6%E5%AD%90%E8%B7%AF%E5%BE%84%EF%BC%8Ccookie%E9%83%BD%E4%BC%9A%E8%A2%AB%E5%8F%91%E9%80%81%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8">http://localhost:8080/servlet/cookie/generate生成的cookie，如果cookie没有设置path，默认的path是：http://localhost:8080/servlet/cookie/以及它的子路径，也就是说浏览器只要发送这个路径及其子路径，cookie都会被发送到服务器</a></li><li>手动设置cookie的path：cookie.serPath(“&#x2F;servlet13”),表示只要是servlet13项目的请求路径都会提交这个cookie</li></ul></li><li><p>浏览器发送cookie给服务器，服务器中Java程序接收</p><ul><li><pre><code class="java">Cookie[] cookies = request.getCookie();//如果没有则返回nullif(cookies != null)&#123;        for(Cookie cookie : cookies)&#123;        String name = cookie.getName();        String value = cookie.getValue();    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">## EL表达式</span><br><span class="line"></span><br><span class="line">* EL表达式出现在jsp的作用</span><br><span class="line"></span><br><span class="line">  - 从某个域中取数据，然后将其转换为字符串，然后输出到浏览器，这就是EL浏览器的三大功效</span><br><span class="line"></span><br><span class="line">* 语法  $&#123;key&#125;</span><br><span class="line"></span><br><span class="line">* EL表达式使用：</span><br><span class="line"></span><br><span class="line">  - ```jsp</span><br><span class="line">    &lt;%</span><br><span class="line">      User user = new user();</span><br><span class="line">      user.setName(&quot;jack&quot;);</span><br><span class="line">      user.setAge(66)</span><br><span class="line">      request.setAttribute(&quot;userdetial&quot;,user);</span><br><span class="line">    %&gt;</span><br><span class="line">    $&#123;userdetial&#125;//大括号里面必须写存储到域对象中name，不能写成$&#123;&quot;userdetial&quot;&#125;,这样是直接输出&quot;userdetial&quot;这个字符串</span><br><span class="line">    $&#123;userdetial&#125;的底层是先从域中取数据，即user对象，然后调用user的toString方法，转换成字符串，输出到浏览器</span><br><span class="line">    //直接输出对象的某一个属性</span><br><span class="line">    $&#123;user.name&#125;</span><br><span class="line">    $&#123;user.age&#125;</span><br><span class="line">    //使用这个两个语法的前提是，userd对象有getName()和getAge()这两个方法，这样写底层其实调用了get方法</span><br><span class="line">    //如果在不同的域中，存上相同名字的key，然后使用$&#123;&#125;调用的时候，在没有指定范围的情况下，取出的顺序是先从小的域中取，然后再是大的域</span><br><span class="line">    //指定域的语法,key相同时，优先从哪个域取数据的语法</span><br><span class="line">    $&#123;pageScopr.userdetial&#125;</span><br><span class="line">    $&#123;requestScope.userdetial&#125;</span><br><span class="line">    $&#123;session.userdetial&#125;</span><br><span class="line">    $&#123;applicationScope.userdetial&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>EL表达式对null进行了预处理，如果是null，则输出一个空字符串到浏览器</p></li><li><p>EL表达式取数据的时候有两种形式：</p><ul><li>第一种：${user.userdetial}(大部分是使用这种形式)</li><li>第二种：${user[“userdetial”]}(如果存储到域中的key含有特殊字符，可以使用[]),例如：<ul><li>request.setAttribute(“abc.def”,”fhaishdu”)</li><li>${requestScope.abc.def}这样是无法取值的</li><li>应该写成这样：${requestScope[“abc.def”]}</li><li><strong>注意：中括号里面必须加双引号</strong></li></ul></li></ul></li><li><p>使用EL表达式从Map中取数据</p><ul><li>${map.key}</li></ul></li><li><p>使用EL表达式从List和数组中取数据</p><ul><li>${list[索引]}</li><li>${数组[索引]}</li></ul></li><li><p>page指令忽略EL表达式</p><ul><li><pre><code class="jsp">&lt;%@page contentType=&quot;html/text;charset=UTF-8&quot; isELIgnored=&quot;true&quot;%&gt;isELIgnored=&quot;true&quot;表示忽略EL表达式isELIgnored=&quot;false&quot;表示不忽略EL表示式（这是默认值）//以上指令是忽略所有的EL表达式可以使用反斜杠局部控制：\$&#123;username&#125;，这样也可以忽略EL表达式，只忽略这一行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- EL中的隐式对象</span><br><span class="line"></span><br><span class="line">  - ```jsp</span><br><span class="line">    //pageContext</span><br><span class="line">    //EL表示式中没有request这个隐式对象，EL表达式中有一个隐式对象：pageContext，EL表达式中的pageContext和jsp中的九大内置对象pageContext是同一个对象</span><br><span class="line">    $&#123;pageContext.request.contextPath&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="jsp">//param//如果用户提交的请求是：http://localhost:8080/jsp?aihao=smoke&amp;aihao=drink&amp;aihao=tangtou$&#123;param.aihao&#125;这样可以获取请求参数一维数组当中的第一个元素$&#123;paramValues.aihao[索引]&#125;可以获得数组中指定的元素//在web.xml文件中配置以下数据    &lt;context-param&gt;        &lt;param-name&gt;pageSize&lt;/param-name&gt;        &lt;param-value&gt;20&lt;/param-value&gt;    &lt;/context-param&gt;$&#123;initParam.pageSize&#125;相当于&lt;%application.getInitParameter(&quot;pageSize&quot;)%&gt;获取上下文对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - EL表达式的运算符</span><br><span class="line">    - 算数运算符(+ - * /)只能做数值运算，不能做字符串的运算，如果是“123”这样的字符串，先把字符串转成数字，然后进行数值的运算，其他字符串直接报错</span><br><span class="line">    - 比较运算符(= , !=  , eq)都会调用equal方法</span><br><span class="line">    - empty 判断后面的内容是否为空</span><br><span class="line"></span><br><span class="line">## JSTL标签库</span><br><span class="line"></span><br><span class="line">* 在jsp中引入JSTL标签库(使用taglib指令)</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    &lt;%@taglib prefix=&quot;这里随便起一个名字即可，一般是c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line">    //这个就是核心标签库</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li><li><p>JSTL标签的原理</p><ul><li><pre><code>&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;//以上uri后面的路径实际上指向了一个xxx.tld文件，tld文件其实是一个xml文件，在tld文件中描述了标签和java类的关系//以上核心标签库对应tld文件是：c.tld文件，在jakarta.servlet.jsp.jstl-2.0.0.jar里面META-INF目录下有一个c.tld文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 源码解析</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">      &lt;tag&gt;</span><br><span class="line">        &lt;description&gt;对标签的描述&lt;/description&gt;</span><br><span class="line">        &lt;name&gt;catch&lt;/name&gt;标签的名字</span><br><span class="line">        &lt;tag-class&gt;org.apache.taglibs.standard.tag.common.core.CatchTag&lt;/tag-class&gt;标签对应的Java类</span><br><span class="line">        &lt;body-content&gt;JSP&lt;/body-content&gt;标签体当中可以出现的内容，如果是jsp就表示，就表示标签体中可以出现符合jsp所有语法的代码，例如EL表达式</span><br><span class="line">        &lt;attribute&gt;//属性</span><br><span class="line">            &lt;description&gt;对属性的描述&lt;/description&gt;</span><br><span class="line">            &lt;name&gt;var&lt;/name&gt;属性名</span><br><span class="line">            &lt;required&gt;false&lt;/required&gt;false表示该属性不是必须的，true表示该属性是必须的</span><br><span class="line">            &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt;这个描述说明了该属性是否支持EL表达式，false表示不支持，true表示支持</span><br><span class="line">        &lt;/attribute&gt;</span><br><span class="line">      &lt;/tag&gt;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>jstl中的核心标签库core中的常用标签</p><ul><li><p>c:if</p><ul><li>&lt;c:if test&#x3D;”boolean类型，支持EL表达式”&gt;&lt;</c:if>&gt;</li></ul></li><li><p>c:forEach</p><ul><li>&lt;c:forEach items&#x3D;”集合，支持EL表达式” var&#x3D;”集合中的元素” varStatus&#x3D;”元素状态对象”&gt;${元素状态对象.count}&lt;</c:forEach>&gt;</li><li>count可以实现自增，常用于编号</li><li>&lt;c:forEach var&#x3D;”i” begin &#x3D;”1” end&#x3D;”10” step&#x3D;”1”&gt;${i}&lt;</c:forEach>&gt;</li></ul></li><li><p>c:choose c:when c:otherwise</p><ul><li><pre><code>&lt;c:choose&gt;  &lt;c:when test=&quot;$&#123;age&lt;18&#125;&quot;&gt;  未成年  &lt;/c:when&gt;  &lt;c:otherwise&gt;  成年  &lt;/c:otherwise&gt;&lt;/c:choose&gt;  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## Filter过滤器</span><br><span class="line"></span><br><span class="line">* Filter是过滤器，可以在Servlet这个目标程序执行之前添加代码，也可以在目标Servlet程序执行之后添加代码，一般情况下将公共代码编写到过滤器当中</span><br><span class="line"></span><br><span class="line">* 过滤器写法</span><br><span class="line"></span><br><span class="line">  - 第一步：编写一个Java类实现一个接口：jakarta.servlet.Filter并实现这个接口所有方法</span><br><span class="line"></span><br><span class="line">    - init方法：在Filter对象第一次被创建的时候调用，并且只调用一次</span><br><span class="line">    - doFilter方法：只要用户发送一次请求，则执行一次，发送n次请求则执行n次</span><br><span class="line">    - destroy方法：在Filter对象被释放销毁之前被调用，并且只调用一次</span><br><span class="line"></span><br><span class="line">  - 第二步：在类上写注解@WebFilter(&quot;路径&quot;)，或者在web.xml文件中配置和Servlet类似</span><br><span class="line"></span><br><span class="line">    - ```xml</span><br><span class="line">          &lt;filter&gt;</span><br><span class="line">              &lt;filter-name&gt;filter1&lt;/filter-name&gt;</span><br><span class="line">              &lt;filter-class&gt;com.nipowenode.servlet.Filter.Filter1&lt;/filter-class&gt;</span><br><span class="line">          &lt;/filter&gt;</span><br><span class="line">          &lt;filter-mapping&gt;</span><br><span class="line">              &lt;filter-name&gt;filter1&lt;/filter-name&gt;</span><br><span class="line">              &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">          &lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul></li><li><p><strong>注意</strong></p><ul><li>Servlet对象默认情况下，在服务启动的时候不会新建对象</li><li>Filter对象默认情况下，在服务器启动的时候会新建对象</li><li>Servlet是单例的，Filter也是单例的</li></ul></li><li><p>目标Servlet是否执行取决于两个条件</p><ul><li>第一：在过滤器中是否编写了chain.doFilter(request,response);代码(这行代码表示执行下一个过滤器，如果没有下一个过滤器则执行最终的Servlet)</li><li>第二：用户发送的请求是否和Servlet请求路径一致</li></ul></li><li><p>注意：Filter的优先级，天生就比Servlet的优先级高</p><ul><li>&#x2F;a.do对应一个Filter，也对应一个Servlet，那么一定是先执行Filter，然后执行Servlet</li></ul></li><li><p>Filter的配置路径</p><ul><li>&#x2F;a.do,&#x2F;b.do,&#x2F;dept&#x2F;save 这些配置方式都是精确配置</li><li>&#x2F;* 匹配所有路径</li><li>*.do 后缀匹配，不要以&#x2F;开始</li><li>&#x2F;dept&#x2F;* 前缀匹配</li></ul></li><li><p>在web.xml文件中进行配置的时候，Filter的执行顺序是<filter-mapping>标签越靠前的，执行优先级越高</p></li><li><p>过滤器的调用顺序，遵行栈的数据结构，先进后出</p></li><li><p>使用注,Filter的执行顺序</p><ul><li>比较Filter这个类名</li><li>比如：FilterA和FilterB，先执行FilterA</li><li>比如：Filter1和Filter2，先执行Filter1</li></ul></li><li><p>Filter的生命周期</p><ul><li>和Servlet生命周期相同</li><li>唯一的区别：Filter默认情况下，在服务器启动的情况下就会实例化，Servlet不会</li></ul></li><li><p>责任链设计模式</p><ul><li>过滤器的优点：在程序编译阶段不会确定调用对象，因为Filter的调用顺序是配置到web.xml文件中的，只要修改web.xml配置文件中的filter-mapping的顺序就可以调整Filter的执行顺序，显然Filter的执行顺序是在程序运行阶段动态组合的，这种设计模式被称为责任链设计模式</li><li>责任链模式的最大核心思想：在程序运行阶段，动态的组合程序的调用顺序</li></ul></li></ul><h2 id="Listener-监听器"><a href="#Listener-监听器" class="headerlink" title="Listener 监听器"></a>Listener 监听器</h2><ul><li><p>监听器有什么用</p><ul><li>监听器实际上是Servlet规范留给我们javaweb程序员的特殊时机</li><li>特殊时刻如果想执行这段代码，你需要想到使用对应的监听器</li></ul></li><li><p>Servlet规范中提供的监听器：</p><ul><li>jakarta.servlet包下：<ul><li>ServletContextListener</li><li>ServletContextAttributeListener</li><li>ServletRequestListener</li><li>ServletRequestAttributeListener</li></ul></li><li>jakarta.servlet.http包下：<ul><li>HttpSessionListener</li><li>HttpSessionAttributeListener<ul><li>该监听器需要使用@WebListener注解进行标注</li><li>主要在session中存入数据都会出发该监听器并执行方法</li></ul></li><li>HttpSessionBindingListener<ul><li>该监听器不需要@WebListener注解标注</li><li>只要某个类实现了HttpSessionBindingListener这个监听器，然后这个类对象放入到session的时候触发bind事件，类对象从session中删除的时候，会触发unbind事件</li></ul></li><li>HttpSessionIdListener(不重要)<ul><li>session的id发生改变的时候，监听器中的唯一一个方法就会被调用</li></ul></li><li>HttpSessionActivationListener<ul><li>监听session对象的钝化和活化</li><li>钝化：session对象从内存存到硬盘文件</li><li>活化：session对象从硬盘存到内存</li></ul></li></ul></li></ul></li><li><p>实现一个监听器的步骤：</p><ul><li><p>第一步：编写一个类实现ServletContextListener接口，并实现里面方法</p><ul><li><pre><code class="java">void contextInitialized(ServletContextEvent sce)&#123;&#125;void contextDestroyed(ServletContextEvent sce)</code></pre></li></ul></li><li><p>第二步：在web.xml文件中配置，或者在类上面加上注解@WebListener</p></li></ul></li><li><p>注意：所有监听器中的方法都是不需要javaweb程序员调用的，当某个特殊的事件发生之后，被web服务器自动调用</p></li></ul><h2 id="MVC架构模式"><a href="#MVC架构模式" class="headerlink" title="MVC架构模式"></a>MVC架构模式</h2><p><img src="C:\Users\ZDKJ\AppData\Roaming\Typora\typora-user-images\image-20221130193806151.png" alt="image-20221130193806151"></p><ul><li>表示层：web包<ul><li>写servlet</li></ul></li><li>业务逻辑层：service包<ul><li>写业务逻辑代码</li></ul></li><li>持久层：dao包<ul><li>做数据库的增删改查</li></ul></li><li>pojo包：封装数据</li><li>utils包：放工具的</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2023/07/02/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/07/02/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="测试markdown"><a href="#测试markdown" class="headerlink" title="测试markdown"></a>测试markdown</h3><ul><li>要点</li></ul><ol><li>第一</li><li>2<br>2</li><li>3<br><strong>加粗</strong></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test代码块</title>
      <link href="/2023/07/02/test/"/>
      <url>/2023/07/02/test/</url>
      
        <content type="html"><![CDATA[<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<br>测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<br>测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<br>测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<br>测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<br>测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试</p><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<br>测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<br>测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<br>测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<br>测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<br>测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试</p><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p>测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<br>测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<br>测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<br>测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<br>测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<br>测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试</p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试   spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/07/02/hello-world/"/>
      <url>/2023/07/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
