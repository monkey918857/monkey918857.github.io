<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《Java并发编程的艺术》阅读笔记</title>
      <link href="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="并发编程初探"><a href="#并发编程初探" class="headerlink" title="并发编程初探"></a>并发编程初探</h3><h4 id="1-Java天生的多线程"><a href="#1-Java天生的多线程" class="headerlink" title="1.Java天生的多线程"></a>1.Java天生的多线程</h4><p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位</strong></p><p>在Java中仅仅运行一个main函数，在相当于启动了一个JVM进程，而且这个进程有六条线程，这些线程都拥有各自的<strong>计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量</strong>。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。</p><hr><p>main函数启动后开启的六条线程：</p><p>[6] Monitor Ctrl-Break （跟JVM 关系不大，他是 IDEA 通过反射的方式，开启一个随着我们运行的jvm进程开启与关闭的一个监听线程。）</p><p>[5] Attach Listener （附加监听器。 简单来说，他是jdk里边一个工具类提供的<strong>jvm</strong> <strong>进程之间通信</strong>的工具。 cmd – java -version; jvm – jstack、jmap、dump） 进程间的通信。</p><p>开启我们这个线程的两个方式： 1. 通过jvm参数开启。-XX: StartAttachListener</p><ol start="2"><li>延迟开启： cmd – java -version –&gt; JVM 适时开启A L 线程</li></ol><p>[4] Signal Dispatcher （信号分发器。 我们通过cmd 发送jstack，传到了jvm进程，这时候信号分发器就要发挥作用了。）</p><p>[3] Finalizer （JVM 垃圾回收相关的内容。此处只做简单的介绍。 1. 只有当开始一轮垃圾收集的时候，才会开始调用finalize方法。 2. daemon prio&#x3D;10 高优先级的守护线程。  3. jvm在垃圾收集的时候，会将失去引用的对象封装到我们的 Fianlizer 对象（Reference）， 放入我们的 F-queue 队列中。由 Finalizer 线程执行inalize方法）</p><p>[2] Reference Handler （引用处理的线程。强，软，弱，虚。 -GC 有不同表现 - JVM深入分析）</p><p>[1] main 主线程</p><hr><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231119213444916.png" class title="image-20231119213444916"><h4 id="2-线程的优先级和守护线程"><a href="#2-线程的优先级和守护线程" class="headerlink" title="2.线程的优先级和守护线程"></a>2.线程的优先级和守护线程</h4><ul><li><p>优先级</p><ul><li>通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，setPriority(int)这个方法是 jvm 提供的一个方法，并且能够调用 本地方法 setPriority0. 但是设置以后发现没有作用，为什么？ <ul><li>1.我们现在的计算机都是多核的，t1，t2 会让哪个cpu处理不好说。由不同的cpu同时提供资源执行。 2.优先级不代表先后顺序。哪怕你的优先级低，也是有可能先拿到我们的cpu时间片的，只不过这个时间片比高优先级的线程的时间片短。 <strong>优先级针对的是 cpu时间片的长短问题。</strong>这个 setPriority方法很少使用，很难控制。实际的运行环境太复杂。</li></ul></li></ul></li><li><p>守护线程</p><ul><li><p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这 意味着，<strong>当一个Java虚拟机中不存在非Daemon线程的时候，守护线程也会立即终止(这也是finally块中代码不一定执行的一个原因)，</strong>Java虚拟机将会退出。</p></li><li><p>可以通过调 用Thread.setDaemon(true)将线程设置为Daemon线程。但是注意设置守护线程的时候一定要在调用thread.start()之前设置，如果线程已经启动了在进行设置会抛出异常</p></li></ul><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231119220444532.png" class title="image-20231119220444532"></li></ul><h4 id="3-线程状态转换"><a href="#3-线程状态转换" class="headerlink" title="3.线程状态转换"></a>3.线程状态转换</h4><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231119223427696.png" class title="image-20231119223427696"><ul><li>注意：①上面图中有一个错误，就是红框里面的join方法是Thread的。②BLOCKED状态只针对sync锁。③通过调用join方法导致状态转为WAITING时，也是需要调用notify方法转为RUNNABLE状态，因为join方法底层就是调用了wait方法</li></ul><h4 id="4-init方法和start方法"><a href="#4-init方法和start方法" class="headerlink" title="4.init方法和start方法"></a>4.init方法和start方法</h4><ul><li>init方法<ul><li>当使用new关键词进行线程创建的时候，底层调用的是init方法，一个新构造的线程对象是由其parent线程来进行空间分配的，而child线程继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的ThreadLocal，同时还会分配一个唯一的（sync）ID来标识这个child线程(之所以能保证唯一是因为nextThreadID这个方法是被synchronized修饰的)。此时这个线程会被添加到Unstarted线程组，也就是NEW状态，因为还有调用start方法;至此，一个能够运行的线程对象就初始化好了，在堆内存中等待着运行。</li></ul></li><li>start方法<ul><li>start方法也是一个被synchronized修饰的方法，这样可以避免多线程同时启动一个线程，start方法底层调用的是用native修饰的start0方法，在start0方法完全执行完成之前，线程处于READY状态，在start0方法完全执行结束以后，线程就处于RUNNING状态，线程start()方法的含义是：当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程。</li></ul></li></ul><h4 id="5-sleep方法和wait方法"><a href="#5-sleep方法和wait方法" class="headerlink" title="5.sleep方法和wait方法"></a>5.sleep方法和wait方法</h4><ul><li>sleep方法<ul><li>是否释放锁？<ul><li>不释放</li><li>通过源码发现sleep方法是一个native方法，但是可以根据注释**The thread does not lose ownership of any monitors.**，说明他不会释放锁</li></ul></li><li>是否响应中断？<ul><li>响应，他会先清除中断标志然后抛出异常，所以调用Thread.isInterrupted()方法的时候会返回false</li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231121191452253.png" class title="image-20231121191452253"></li></ul></li><li>是否释放CPU<ul><li>释放，通过jstack命令可以查看到它没有占用任何CPU</li></ul></li></ul></li><li>wait方法<ul><li>是否释放锁？<ul><li>释放</li><li>wait方法也是一个native方法，使用上面的方法可以查看到，线程会释放锁</li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231121192241133.png" class title="image-20231121192241133"></li></ul></li><li>是否响应中断？<ul><li>响应</li></ul></li><li>是否释放CPU？<ul><li>释放，他会让出CPU时间片，然后进入到等待队列中</li></ul></li></ul></li></ul><h4 id="6-join方法"><a href="#6-join方法" class="headerlink" title="6.join方法"></a>6.join方法</h4><ul><li>是否释放锁？<ul><li>释放，但是它释放的是当前调用 join方法的那个对象的锁。</li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231121192631058.png" class title="image-20231121192631058"></li></ul></li><li>是否响应中断？<ul><li>响应</li></ul></li><li>是否释放CPU？<ul><li>释放，其底层调用的是wait方法</li></ul></li></ul><h4 id="7-线程间的通信方式"><a href="#7-线程间的通信方式" class="headerlink" title="7.线程间的通信方式"></a>7.线程间的通信方式</h4><ul><li>volitate 、synchronize、lock。（都保证可见性）</li><li>wait、notify、await() 、 signal</li><li>管道输入&#x2F;输出流和普通的文件输入&#x2F;输出流或者网络输入&#x2F;输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</li><li>Thread.join() ： 隐式唤醒。等待其他线程执行完成，其他线程会发送唤醒信号。</li><li>ThreadLocal() </li><li>线程中断</li></ul><h4 id="8-ThreadLocal"><a href="#8-ThreadLocal" class="headerlink" title="8.ThreadLocal"></a>8.ThreadLocal</h4><p>ThreadLocal之所以能够实现线程的隔离，主要是依靠线程自身有一个名叫threadLocals的ThreadLocalMap类型的变量，threadLocal底层是使用一个table数组进行数据的存放，存放的时候使用斐波那契散列法把对应不同的threadlocal进行散列，存放的数据是使用threadlocal和要set的值封装成的Entry对象，每次从map中获取信息的时候是通过thradLocal的get方法，当前线程拿到这个map，通过threadLocal散列得到存放的位置，最终得到数据，如果线程一直不终止，那么这个数据会一直存放在threadLocals，<strong>ThreadLocalMap中ThreadLocal是弱引用，</strong></p><p>如果在ThreadLocalMap中使用强引用来存储ThreadLocal对象，那么ThreadLocal对象会一直存在于内存中，即使在实际的应用中已经不再需要该ThreadLocal对象。这是因为ThreadLocalMap是与线程相关联的，保存在ThreadLocalMap的table数组中，ThreadLocalMap中的键值对不会被自动清理，而是会一直保留，从而造成内存泄漏。也就是说ThreadLocal永远不会被清理，除非手动清理，ThreadLocalMap调用set(),get()，remove()方法的时候会被清除value值。</p><p>为了解决这个问题，ThreadLocal存放的Entry对象被设计为弱引用。<strong>弱引用的特点是，当一个对象只被弱引用所引用时，在垃圾回收时会被自动回收。当ThreadLocal对象被垃圾回收时，对应的键值对也会被自动从ThreadLocalMap中移除。但是我们set的value是强引用的，当一个线程长时间运行，有可能不会及时清理导致内存泄漏，为了避免泄漏问题应做手动清理的动作</strong></p><h3 id="synchronized-全解读"><a href="#synchronized-全解读" class="headerlink" title="synchronized 全解读"></a>synchronized 全解读</h3><h4 id="1-Synchronized的使用方法"><a href="#1-Synchronized的使用方法" class="headerlink" title="1.Synchronized的使用方法"></a>1.Synchronized的使用方法</h4><ul><li><p>synchonized关键字的三种使用方式</p><ul><li>用在同步代码块上，此时锁是括号里面配置的对象</li><li>用在普通方法上，此时锁是当前调用该方法的实例对象</li><li>用在静态方法上，此时锁是当前类的Class对象</li></ul><p>当一个线程试图访问同步代码块的时候，必须要先获取到锁，在退出或者出现异常的时候必须释放锁</p></li><li><p>synchonized在JVM的实现原理</p><ul><li>JVM是基于进入和退出Monitor对象来实现同步方法和同步代码块，二者的实现细节略有不同<ul><li>对于同步代码块来说，在编译后会在进入同步代码块之前会加一个monitorenter指令，在同步代码块结束退出或者发生异常的地方monitorexit指令，任何一个对象都有一个monitor与之关联，当monitor被持有后将处于锁定状态，线程执行到monitorenter的时候会尝试获取对应monitor的所有权，即尝试获取对象的锁</li><li>对于同步方法和静态方法来说，通过反编译得到字节码后可以发现，在方法的flags中多了一个ACC_SYNCHONIZED标志，这会告诉JVM这是一个同步方法</li></ul></li></ul></li></ul><h4 id="2-Synchronized的特性"><a href="#2-Synchronized的特性" class="headerlink" title="2.Synchronized的特性"></a>2.Synchronized的特性</h4><ol><li>有序性 （读读、读写、写读、写写 互斥）</li><li>可见性 （可见性是指多个线程访问⼀个资源时，该资源的状态、值信息等对于其他线程都是可见的。 synchronized和volatile都具有可见性，其中synchronized对⼀个类或对象加锁时，⼀个线程如果要访问该类或对象必须先获得它的锁，⽽这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到共享内存当中，保证资源变量的可见性。）</li><li>原子性 (本质上是线程互斥保证的原子性)</li><li>可重入性 （一个线程获取到某个锁以后，再次请求该对象的锁的时候，还可以获取到执行权）</li></ol><h4 id="3-Synchronized锁–偏向锁"><a href="#3-Synchronized锁–偏向锁" class="headerlink" title="3.Synchronized锁–偏向锁"></a>3.Synchronized锁–偏向锁</h4><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231122222424235.png" class title="image-20231122222424235"><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231122222444063.png" class title="image-20231122222444063"><ul><li>偏向锁使用的前提<ul><li>在jdk1.6版本以后，并且开启了使用偏向锁这一配置，但是它默认情况下是延迟开启的，可以通过-     XX:BiasedLockingStartupDelay&#x3D;0这个配置关闭延迟，如果我们关闭了延迟开启这一配置，那么<strong>锁对象在创建出来的时候markword的状态就是偏向锁对应的状态</strong>，只不过现在没有任何的线程竞争，此时就是一个没有偏向任何线程的偏向锁</li><li>锁对象在被获取之前没有显式&#x2F;隐式的调用hashCode方法(隐式调用比如说以这个锁对象作为hashmap的key进行保存)，如果调用了hashcode方法，由于我们偏向锁的markword中没有地方存储这个hashcode，所以此时就会升级为轻量级锁</li></ul></li></ul><p>为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在<strong>锁的对象头中存储线程id并在线程的栈帧中的锁记录里(线程有自己的栈帧，LOCK RECORD) 存储当前线程id</strong>,存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里存储的id和线程栈帧里面锁记录的id是否匹配，如果匹配，表示线程已经获得了锁。如果不匹配，则需要再测试一下锁对象的Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程： 其实是cas竞争替换 线程id。</p><h4 id="4-偏向锁撤销"><a href="#4-偏向锁撤销" class="headerlink" title="4.偏向锁撤销"></a>4.偏向锁撤销</h4><p><em><strong>面试过程中，如果聊到偏向锁的撤销可以先通过一句简短的话来描述一下，然后通过面试官后续的发问逐步展开，即偏向锁使用了一种当出现线程竞争才撤销偏向锁的机制，一旦出现竞争偏向锁就会升级为轻量级锁</strong></em></p><ul><li>在竞争偏向锁的时候会出现以下可能性<ol><li>A线程获取偏向锁，并且A线程死亡退出。B线程争抢偏向锁，会直接升级当前对象的锁为轻量级锁。<strong>这只是针对我们争抢了一次。</strong></li><li>A线程获取偏向锁，并且A线程没有释放偏向锁，还在sync的代码块里边。B线程此时过来争抢偏向锁，会直接升级为重量级锁。</li><li>A线程获取偏向锁，并且A线程释放了锁，但是A线程并没有死亡还在活跃状态。此时锁处于无锁状态，B线程过来争抢，会直接升级为轻量级锁。</li><li>A线程获取偏向锁，并且A线程没有释放偏向锁，还在sync的代码块里边。B线程多次争抢锁，会在加锁过程中采用重量级锁；但是，一旦锁被释放，当前对象还是会以轻量级锁的初始状态执行。但是这里不能称之为锁降级，因为锁升级是在线程运行过程中和争抢过程中的一种升级。而现在是线程已经释放了锁，然后又重新获取锁的情况，不属于线程运行中。</li><li>A线程获取偏向锁，并且A线程释放了锁，但是A线程并没有死亡还在活跃状态。B线程过来争抢。部分争抢会升级为轻量级锁；部分争抢会依旧保持偏向锁。</li></ol></li></ul><p>所以，偏向锁的撤销过程很复杂，即使是锁升级的官方文档中对这一部分也没有特别细致的说明，所以面试过程中不要较真</p><p>以下面试过程中推荐说的：</p><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态(<strong>如上述情况1</strong>)；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向的线程对象的栈帧中的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程(<strong>如上述情况5</strong>)，要么恢复到无锁(<strong>如上述情况3</strong>)或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。 </p><ul><li>偏向锁的批量重偏向和批量撤销<ul><li>批量重偏向，一个已经偏向A线程Object类型的对象，在经过另外B线程争抢超过二十次的情况下，该类所创建出来的其他对象会直接重新偏向于B线程，此时jvm认为这个对象更适合偏向于B线程(20这个数字不是一定的，<strong>不同机器环境参数配置不一样</strong>)</li><li>批量撤销，如果基于批量重偏向的基础上，还在继续进行争抢达到40次，并且有第三条线程C也来争抢这个对象锁，这个时候会触发批量撤销。JVM会标记该对象不能使用偏向锁，以后新创建的对象，直接以轻量级锁开始。 这个时候，才是真正的完成了锁升级。</li></ul></li></ul><p><strong>注意，真正的锁升级，是依赖于 class 的，而并不是依赖于 某一个 new出来的对象（这句话适用于偏向锁升级为轻量级锁），这里更加可以说明锁可以升级，而不能降级，也就是说上面出现的线程争抢锁过程中升级的锁，在使用new关键字对该类进行重新创建的时候还是偏向锁这一现象不能称之为锁降级</strong></p><h4 id="5-轻量级锁的加锁和解锁"><a href="#5-轻量级锁的加锁和解锁" class="headerlink" title="5.轻量级锁的加锁和解锁"></a>5.轻量级锁的加锁和解锁</h4><ul><li>轻量级锁加锁</li></ul><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间（Lock Record记录），并将对象头中的Mark Word（前30位 （25位的hashcode，4位的分代年龄，1位是否为偏向锁））复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针（指向线程栈帧里边的Lock Record的指针）。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用<strong>自旋</strong>来获取锁。</p><ul><li>轻量级锁解锁</li></ul><p>轻量级锁解锁时，会使用原子的CAS操作将Displaced Mark Word（Lock Record记录）替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p><p><strong>注意，这里真正的锁升级依赖的是对象，对象升级为重量级锁，而对象对应的类再new一个的新对象锁，这时还是从轻量级锁开始(这句话适用于轻量级锁升级为重量级锁)</strong></p><h4 id="6-轻量级锁膨胀流程"><a href="#6-轻量级锁膨胀流程" class="headerlink" title="6.轻量级锁膨胀流程"></a>6.轻量级锁膨胀流程</h4><p>线程A在获取到锁以后，线程B也想要获得这个锁，通过CAS进行markword和指针的替换，如果替换失败，会自旋尝试十次，如果线程A一直没有释放锁那么十次自旋也失败，进入膨胀流程，此时线程B会用一个临时的指针指向重量级锁，当线程A执行完代码进行解锁的时候，发现有竞争要升级锁，线程A即会做以下五步：</p><ol><li><p>线程A 初始化monitor 对象；</p></li><li><p>将状态设置为膨胀中（inflating）；</p></li><li><p>将monitor里边的header属性，set称为对象的markword；（即将自己lock record里边的存放的mark word的hashcode，分代年龄，是否为偏向锁 set 到 objectmonitor对象的header属性里）</p></li><li><p>设置对象头为重量级锁状态（标记为改为00）；然后将前30位指向第1步他初始化的monitor 对象；（<strong>真正的锁升级是由线程A操控的</strong>）</p></li><li><p>唤醒线程B；</p></li></ol><p>线程B开始争抢重量级锁。（线程B就干了一件事儿，就是弄了一个临时的重量级锁指针吧？还不是最后的重量级锁指针。因为最后的重量级锁指针是线程A初始化的并且是线程A修改的。 而且，线程B被唤醒之后，还不一定能够抢到这个重量级锁。Sync是非公平锁。 线程B费力不讨好，但是线程B做了一件伟大的事情：他是锁升级的奠基者。）</p><h4 id="7-锁升级过程中markword的转移流程"><a href="#7-锁升级过程中markword的转移流程" class="headerlink" title="7.锁升级过程中markword的转移流程"></a>7.锁升级过程中markword的转移流程</h4><p>创建一个对象，此时对象里边没有hashcode，所以该对象可以使用我们的偏向锁，偏向锁不会考虑hashcode，</p><p>他会直接将自己的线程id放到我们的markword里边，不需要考虑后续的替换问题。 所以呢，一旦我们的对象主动调用了Object的hashcode方法，我们的偏向锁就自动不可用了。</p><p>如果我们的对象有了hashcode和分代年龄和是否为偏向锁（30位）。在轻量级锁的状态下，这30位会被复制到我们的轻量级锁线程持有者的栈帧里的lock record里边记录。与此同时，我们的对象的markword里边存放的是我们的指向轻量级锁线程持有者的栈帧的lock recod里的指针。如果一直存在轻量级锁竞争，在未发生锁膨胀的前提下，一直会保持轻量级锁，A线程释放的时候，会将markword替换回对象的markword里边，B线程下次再从新走一遍displace mark word；</p><p>一旦发生了轻量级膨胀为重量级锁。前提，A线程持有锁；B线程争抢。</p><p>B线程将marikword里边A线程的指针替换成一个临时的（过度的）重量级锁指针，为了让A线程在cas往回替换markword的时候失败。</p><p>A线程替换回markword失败后，会发起：1.初始化monitor对象；2. 将状态设置为膨胀中；3 将替换失败的 markword放到objectmonitro的head属性里； 4。改变markword的锁标志为10；将markword里的 30 位设置为指向自己第一步初始化的那个monitor对象；5唤醒B线程； 6以后这个对象只能作为重量级锁；</p><p>Markword从未丢失。</p><h4 id="8-死锁的避免方式"><a href="#8-死锁的避免方式" class="headerlink" title="8.死锁的避免方式"></a>8.死锁的避免方式</h4><p>概念：死锁是指两个或两个以上的线程在执行过程中，由于竞争资源而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p><p>避免死锁的几个常见方法：</p><ol><li><p>避免一个线程同时获取多个锁。</p></li><li><p>尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。</p></li><li><p>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</p></li></ol><h4 id="9-ObjectMonitor的属性"><a href="#9-ObjectMonitor的属性" class="headerlink" title="9.ObjectMonitor的属性"></a>9.<strong>ObjectMonitor</strong>的属性</h4><ol><li><p>header ： 重量级锁保存markword的地方；对象的markword里边也保存了指向monitor的指针；</p></li><li><p>own: 指向我们持有锁的线程；</p></li><li><p>_cxq 队列： 竞争队列。 A线程持有锁没有释放； B和C线程同时过来争抢锁，都被block了，此时会将B和C线程加入到 该队列。</p></li><li><p>EntryList队列：同步队列。A线程释放锁，B和C线程中会选定一个继承者（可以去争抢锁的这个线程），另外一个线程会被放入我们的EntryList队列里边。 </p></li><li><p>waitset：等待队列。Object wait的线程。</p></li></ol><ul><li>这个地方为什么要使用cxq和EntryList两个数据结构来存储被阻塞的线程<ul><li>这里主要是为了避免ABA问题，对于ABA问题的其中一个解决方式就是通过保证对一个数据结构只能执行相同的操作，在竞争失败后会进入cxq队列(<strong>这个队列只能新增线程，不能删除</strong>)，<strong>持锁线程</strong>释放锁时会唤醒阻塞在cxq队列里面的线程，并将其移动到EntryList队列，notify线程被唤醒的时候，<strong>持锁线程</strong>会把waitset的头节点放到cxq或EntryList的栈顶，从这个地方可以看出加锁失败的线程会往cxq中进行添加，所以会存在竞争，所以我们<strong>限制了cxq只能使用新增操作来避免ABA问题</strong>，而EntryList只能由持锁线程进行操作，所以不存在竞争不会出现ABA问题</li></ul></li></ul><p>A线程持有锁，BC线程过来竞争失败，进入cxq – 下轮竞争会把 cxq里的线程移动到EntrylIst中。假设B线程竞争到了锁，然后B线程调用了 Object.Wait方法，这时候B线程进入waitset，并释放锁。C线程拿到了锁，然后唤醒B线程。B线程会从waitset里边出来，直接竞争锁。如果竞争失败进入cxq，继续轮回，如果竞争成功，ok了。</p><h4 id="10-CPU的用户态与内核态"><a href="#10-CPU的用户态与内核态" class="headerlink" title="10.CPU的用户态与内核态"></a>10.CPU的用户态与内核态</h4><ul><li>内核态：</li></ul><ol><li><p>系统中既有操作系统的程序，也有普通用户程序。为了安全性和稳定性，操作系统的程序不能随便访问，这就是内核态。即需要执行操作系统的程序就必须转换到内核态才能执行！</p></li><li><p>内核态可以使用计算机所有的硬件资源！</p></li></ol><ul><li><p>用户态：不能直接使用系统资源，也不能改变 CPU 的工作状态，并且只能访问这个用户程序自己的存储空间！</p></li><li><p>用户态与内核态转换的条件</p><ul><li>用户态进程要使用操作系统资源主动申请状态转换</li><li>CPU出现没有预知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常。</li></ul></li></ul><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><h4 id="1-Java内存模型基础"><a href="#1-Java内存模型基础" class="headerlink" title="1. Java内存模型基础"></a>1. Java内存模型基础</h4><p>Java线程之间的通信由Java内存模型控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在<strong>主存</strong>中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读&#x2F;写共享变量的副本。</p><h4 id="2-指令重排序"><a href="#2-指令重排序" class="headerlink" title="2.指令重排序"></a>2.指令重排序</h4><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。</p><ol><li><p><strong>编译器优化的重排序</strong>。编译器在不改变<strong>单线程程序语义</strong>的前提下，可以重新安排语句的执行顺序。</p></li><li><p><strong>指令级并行的重排序</strong>。现代处理器采用了指令级并行技术来将多条指令<strong>重叠</strong>执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p></li><li><p><strong>内存系统的重排序</strong>。由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p></li></ol><p>举个例子解释上面三种重排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br></pre></td></tr></table></figure><p>例如上面三行代码，其中第一行和第二行在单线程的情况下，即使发生指令顺序的改变，但是也不会改变其语意，所以在编译阶段，编译器就可以对其进行重排序，这就是编译器优化的重排序；同时第一行和第二行不存在数据依赖性，所以在并行执行的时候，可以改变执行顺序，甚至两条指令重叠执行，这也可以提高程序执行效率，这就是指令集并行重排序；由于处理器是使用内存的，所以需要对数据进行加载(i load)和存储(i store)，在保证程序执行结果正确的前提下，这两个操作的顺序也可以被改变，这就是内存系统重排序</p><p>JMM的处理器重排序规则会要求 <strong>Java编译器在生成指令序列时，插入特定类型的内存屏障指令</strong>，通过内存屏障指令来禁止特定类型的处理器重排序。</p><h4 id="3-内存屏障"><a href="#3-内存屏障" class="headerlink" title="3.内存屏障"></a>3.内存屏障</h4><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231126212750679.png" class title="image-20231126212750679"><h4 id="4-as-if-serial语义和Happen-Before原则"><a href="#4-as-if-serial语义和Happen-Before原则" class="headerlink" title="4.as-if-serial语义和Happen-Before原则"></a>4.<strong>as-if-serial语义</strong>和<strong>Happen-Before</strong>原则</h4><p>as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（<strong>单线程</strong>）程序的执行结果不能被改变。</p><p><strong>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。</strong>但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p><p><strong>happens-before关系本质上和as-if-serial语义是一回事。</strong></p><p><strong>as-if-serial语义保证单线程</strong>内程序的执行结果不被改变，<strong>happens-before关系保证正确同步的多线程</strong>程序的执行结果不被改变。</p><p>as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。</p><p><strong>as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度</strong>。</p><h4 id="5-锁的内存语义"><a href="#5-锁的内存语义" class="headerlink" title="5.锁的内存语义"></a>5.锁的内存语义</h4><p>线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（<strong>线程A对共享变量进行修改</strong>）消息。</p><p>线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（<strong>在释放这个锁之前对共享变量所做修改的</strong>）消息。</p><p>线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过<strong>主存</strong>向线程B发送消息。（<strong>隐式通信</strong>）</p><h3 id="volatile全解读"><a href="#volatile全解读" class="headerlink" title="volatile全解读"></a>volatile全解读</h3><h4 id="1-volatile定义"><a href="#1-volatile定义" class="headerlink" title="1.volatile定义"></a>1.volatile定义</h4><p>Java语言规范第3版中对volatile的定义如下：Java编程语言允许线程访问共享变量，<strong>为了确保共享变量能被准确和一致地更新</strong>，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁要更加方便（读多写少）。<strong>如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。</strong></p><p>volatile主要做的三件事：1. 保证可见性 2. 禁止指令重排序 3. 双重检查锁</p><h4 id="2-volatile可见性"><a href="#2-volatile可见性" class="headerlink" title="2.volatile可见性"></a>2.volatile可见性</h4><p>在修改volatile修饰的变量时，Java转变成的<strong>汇编代码会多加一个lock前缀指令</strong>(这一步叫做声言lock信号)，lock前缀指令在多核处理器的条件下会引发两件事，1. 将当前处理器缓存行的数据过总线写回主存。2. 使在其他CPU里缓存了该内存地址的数据无效。</p><p>声言lock信号的期间，系统内存只有当前处理器可以访问也就是说锁总线，但是锁总线的开销太大了，所以最近的处理器如果发现要访问的数据缓存到了处理器内部，这时不会声言lock信号，而是锁定这块内存区域的缓存并回写到内存，并使用缓存一致性协议机制确保修改的原子性。(缓存一致性协议会阻止由多个处理器同时缓存的数据同时被修改)。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。如果通过嗅探一个处理器来检测其他处理器打算修改的内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行(缓存行是缓存可以分配的最小单位，所以缓存行中不一定只有这一条被修改的数据)无效，在下次访问相同内存地址时，强制执行缓存行填充(即从系统内存中重新读取最新数据)。</p><h4 id="3-volatile的使用优化"><a href="#3-volatile的使用优化" class="headerlink" title="3. volatile的使用优化"></a>3. volatile的使用优化</h4><p>先说问题：问题在于一个使用volatile修饰的队列，如果该队列的头尾节点都不足64位，那么他们就会被缓存到同一个缓存行，这时如果是多核处理器都对该数据进行了缓存，那么在缓存一致性的机制下，当一个处理器对头&#x2F;尾节点的修改会导致其他处理器不能访问这个队列的尾&#x2F;头节点，由于队列的入队和出队操作会频繁的修改头尾节点，这样会严重影响性能。</p><p>优化方法是基于缓存行是64位的处理器，处理器的高速缓存行一旦对数据进行缓存，那么就不支持进行部分填充，LinkedTransferQueue这个队列集合则使用追加字节的方式优化入队和出队的性能，它使用一个内部类类型来定义队列的头节点（head）和尾节点（tail），而这个内部类PaddedAtomicReference就是将共享变量追加到64字节。一个对象的引用占4个字节，它追加了15个变量（共占60个字节），再加上父类的value变量，一共64个字节。这样就能保证队列的首尾节点不在同一个缓存行中，</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231130220926320.png" class title="image-20231130220926320"><h4 id="4-volatile禁止指令重排序"><a href="#4-volatile禁止指令重排序" class="headerlink" title="4. volatile禁止指令重排序"></a>4. volatile禁止指令重排序</h4><p>Ø·在每个volatile<strong>写操作的前面</strong>插入一个<strong>StoreStore</strong>屏障，防止前面的写操作与当前的volatile写操作发生指令重排序。</p><p>Ø·在每个volatile<strong>写操作的后面</strong>插入一个<strong>StoreLoad</strong>屏障，防止当前的volatile写操作和后面的读操作发生指令重排序。</p><p>Ø·在每个<strong>volatile读操作的</strong>后面插入一个<strong>LoadLoad</strong>屏障。</p><p>Ø·在每个<strong>volatile读操作的</strong>后面插入一个<strong>LoadStore</strong>屏障。</p><ul><li>为什么volatile读前面没有屏障？<ul><li>JMM原本是在每个volatile写的后面，或者在每个volatile读的前面都插入一个StoreLoad屏障。从整体执行效率的角度考虑，JMM最终选择了只在每个volatile写的后面插入一个StoreLoad屏障。因为volatile写-读内存语义的常见使用模式是：一个写线程写volatile变量，多个读线程读同一个volatile变量。<strong>当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。</strong>因此可以看出JMM是<strong>先保证正确性然后才考虑的性能。</strong></li></ul></li></ul><p>由于JMM是<strong>先保证正确性然后才考虑的性能。</strong>所以在真正代码执行屏障插入的时候，编译器可以根据实际情况省略某些屏障！！</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231130223957979.png" class title="image-20231130223957979"><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231130224007219.png" class title="image-20231130224007219"><ul><li>为什么volatile写和普通写不能重排序？<ul><li>因为可能会引发以下问题<ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231130225009541.png" class title="image-20231130225009541"></li><li>当1和2之间没有数据依赖关系时，1和2之间就可能被重排序（3和4类似）。其结果就是：读线程B执行4时，不一定能看到写线程A在执行1时对共享变量的修改。</li></ul></li><li>所以在新的内存模型中进行了volatile的语意增强<ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231130225208019.png" class title="image-20231130225208019"></li></ul></li></ul></li></ul><h4 id="5-双重检查锁存在的问题"><a href="#5-双重检查锁存在的问题" class="headerlink" title="5.  双重检查锁存在的问题"></a>5.  双重检查锁存在的问题</h4><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231201164120235.png" class title="image-20231201164120235"><p>问题出现在第七行，因为创建对象的过程分为三个步骤，分别是1. 为创建的对象开辟一片内存空间 2. 对象的初始化 3. 把初始化好的对象指向开辟好的内存空间，这三步如果发生指令的重排序，比如第二行和第三行进行重排序，就会出现以下问题：</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231201164510079.png" class title="image-20231201164510079"><p>指令交换后，当其他线程发现instance不为空了，但是return回去对象可能还没有初始化</p><h4 id="6-基于volatile的解决方案"><a href="#6-基于volatile的解决方案" class="headerlink" title="6.基于volatile的解决方案"></a>6.基于volatile的解决方案</h4><p>在instance对象上加一个volatile修饰即可解决。</p><p>原理(大众式理解)：volatile禁止了 new 对象里边三行代码的重排序，所以初始化对象的操作一定在指向内存地址这一操作之前，所以不会发生问题。</p><p>个人理解：这个地方new instance对应的JVM指令也是new，所以这个地方可以看成一个volatile写，所以会在new这个操作前加一个storestore屏障，操作之后加一个storeload屏障，这时其他线程想要读取这个变量必须在storeload屏障以后进行读取，也就是说只有当new操作全部执行完时候才能读取，从而解决以上问题，但是new对象过程中的三个步骤还是有可能发生重排序</p><h4 id="7-基于类初始化的解决方案"><a href="#7-基于类初始化的解决方案" class="headerlink" title="7.基于类初始化的解决方案"></a>7.基于类初始化的解决方案</h4><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231201170222111.png" class title="image-20231201170222111"><p>JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。<strong>在执行类的初始化期间，JVM会去获取一个锁。</strong>这个锁可以防止多个线程对同一个类的初始化。锁可以保证原子性可见性，所以在一个线程完成类的初始化之前，其他线程看不见这个类</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231201170333032.png" class title="image-20231201170333032"><h3 id="Lock全解读"><a href="#Lock全解读" class="headerlink" title="Lock全解读"></a>Lock全解读</h3><h4 id="1-Lock锁的由来及API"><a href="#1-Lock锁的由来及API" class="headerlink" title="1. Lock锁的由来及API"></a>1. Lock锁的由来及API</h4><p>Lock锁放弃了隐式获取和释放锁的便捷性，但是却拥有了<strong>锁获取与释放的可操作性、可中断的获取锁以及超时获取锁</strong>等多种synchronized关键字所不具备的同步特性</p><ul><li>特性</li></ul><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231204214927802.png" class title="image-20231204214927802"><ul><li>API</li></ul><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231204215022959.png" class title="image-20231204215022959"><h4 id="2-队列同步器AQS"><a href="#2-队列同步器AQS" class="headerlink" title="2.队列同步器AQS"></a>2.队列同步器AQS</h4><p>队列同步器AQS是用来构建锁和其他同步组件的基础框架，他提供了一个int类型变量来获取锁的状态，通过维护一个先进先出的双端队列管理来竞争的线程，同步器重写以下方法，然后调用同步器提供的模板方法，模板方法中会调用自己重写的方法，最终是实现自定义锁</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231204221226033.png" class title="image-20231204221226033"><p>当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。在线程获取锁失败，加入同步队列尾端的时候需要保证线程安全，使用CAS提供当前线程认为的头节点和尾节点进行判断，看看现在是否能加入尾节点***(设置尾节点需要使用CAS的原因)***。</p><p><strong>设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，</strong>因此设置头节点的方法并不需要使用CAS来保证，它只需要将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可***(设置头节点不需要CAS的原因)***。</p><h4 id="3-ReentrantLock-非公平-的lock方法"><a href="#3-ReentrantLock-非公平-的lock方法" class="headerlink" title="3.ReentrantLock(非公平)的lock方法"></a>3.ReentrantLock(非公平)的lock方法</h4><p>调用lock方法后，会先后执行AQS中的以下方法</p><ul><li>compareAndSetState</li><li>acquire</li><li>addWaiter</li><li>enq</li><li>acquireQueued</li><li>shouldParkAfterFailedAcquire</li><li>parkAndCheckInterrupt</li><li>cancelAcquire</li></ul><p>acquire 方法是 aqs提供的模板方法，是为了进行锁的获取；tryAcquire 方法是aqs提供的可以复写的方法，主要是完成了加锁状态变化的逻辑（state）；addWaiter将我们的获取失败的线程放到我们的同步队列里；enq 如果addwaiter第一次没有成功，就进行死循环添加；acquireQueued：这部分其实是通过<strong>循环的自我检查</strong>，如果当前节点的pred节点是头节点，那么就尝试获取锁；如果不是头节点，就调用 shouldParkAfterFailedAcquire 方法，判断pred节点是否为 SIGNAL 状态，如果是signal状态，自己就好好的等着；如果是 cancel状态，就移除cancel的节点。其他状态的节点，会通过cas操作替换为 SIGNAL状态。parkAndCheckInterrupt方法是为了清除中断标志把当前线程挂起。在循环自我检查的过程中发现任何异常，这时会调用finally块中的cancelAcquire方法，把出现异常的线程状态设置为Cancelled </p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231205160117700.png" class title="image-20231205160117700"><p>两个比较重要的状态：</p><ol><li>SIGNAL：等待被通知状态，如果pre节点是这个状态，那么当前节点就会进行park操作</li><li>Cancelled ： 一个取消的线程状态。这个状态的线程会被移除</li></ol><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231205162740351.png" class title="image-20231205162740351"><h4 id="4-ReentrantLock的tryLock方法"><a href="#4-ReentrantLock的tryLock方法" class="headerlink" title="4.ReentrantLock的tryLock方法"></a>4.ReentrantLock的tryLock方法</h4><ul><li>不含参数<ul><li>表示一次性获取锁，获取成功了就成功了，获取失败了就失败了，不会进行重试</li></ul></li><li>含参数<ul><li>含有一个时间参数，表示可以在获取锁失败以后，在规定的时间内进行重试，循环获取锁，循环获取锁的逻辑和lock方法一样，都是先把线程封装成一个Node节点，然后判断自己前节点是不是头节点，如果是头节点则开始尝试获取锁</li><li>含参数的这个方法是支持中断的</li></ul></li></ul><h4 id="5-ReentrantLock的lockInterruptibly方法"><a href="#5-ReentrantLock的lockInterruptibly方法" class="headerlink" title="5.ReentrantLock的lockInterruptibly方法"></a>5.ReentrantLock的lockInterruptibly方法</h4><ul><li>lockInterruptibly方法，是一个支持中断的加锁方式。他与 lock.tryLock(1,null) 这个有什么区别？<br>相同点：都支持中断<br>不同点： lockInterruptibly方法仅仅支持中断；不支持超时。lock.tryLock(1,null)即支持超时，也支持超时内的时间中断</li></ul><h4 id="6-ReentrantLock的isHeldByCurrentThread方法"><a href="#6-ReentrantLock的isHeldByCurrentThread方法" class="headerlink" title="6.ReentrantLock的isHeldByCurrentThread方法"></a>6.ReentrantLock的isHeldByCurrentThread方法</h4><p>直接判断getExclusiveOwnerThread() &#x3D;&#x3D; Thread.currentThread()直接返回锁的持有线程是不是当前线程</p><h4 id="7-ReentrantLock的unlock方法"><a href="#7-ReentrantLock的unlock方法" class="headerlink" title="7.ReentrantLock的unlock方法"></a>7.ReentrantLock的unlock方法</h4><p>调用了unlock方法以后，会直接调用AQS的release方法，这也是一个模板方法，会直接调用到ReentrantLock复写的tryRelease方法，还是对state的值进行修改，只有当state的值被修改为0的时候，才会把当前锁的线程置为null，只有线程释放了锁，才会通知后继节点对锁进行争抢，通知的方式是先把线程自己的状态置为0，然后判断当前节点的后继节点状态是不是1，如果是1或者线程为空说明线程等待超时，或者被中断，这时会从后向前遍历整个同步队列，找到队列中第一个可以对锁进行争抢的节点，使用unpark方法对锁进行唤醒</p><h4 id="8-ReentrantLock-公平"><a href="#8-ReentrantLock-公平" class="headerlink" title="8.ReentrantLock(公平)"></a>8.ReentrantLock(公平)</h4><ol><li><p>synchronized 他是一个非公平锁。</p></li><li><p>Lock分为非公平锁（默认） 还有公平锁。</p><ul><li>非公平锁： 当我们的线程在同步队列里排队完成之后，获取锁的时候，这个时间点上如果有其他新的线程来竞争锁，那么我当前的排队的锁可能会被插队（当前线程可能竞争不过新来的线程，导致自己竞争锁失败。）这是不公平的，我（当前线程） 已经在同步队列里排了好长时间了，你这新来的线程直接抢走了。</li><li>公平锁：获取锁的时候，这个时间点上如果有其他新的线程来竞争锁，那么新的线程会直接加入到同步队列里（使用CAS放入队列的尾端）。</li></ul></li><li><p>性能比较：肯定是非公平锁性能更高。（所有新来的线程都要同步队列里，都要进行我们源码中的一系列的操作，公平锁会有更多的上下文切换）</p></li><li><p>非公平锁容易造成线程饥饿。（<strong>会被插队，极限情况考虑，如果一直被插队，同步队列里的其他线程就一直等着</strong>）</p></li><li><p>很多情况我们在进行实战开发的时候，如果要限定我们的线程的访问先后顺序，就要使用公平锁了。</p></li></ol><ul><li>公平锁的实现主要执行tryAcquire方法的时候，在线程使用CAS对state变量进行修改的时候，多了一个hasQueuedPredecessors方法的判断条件，就是判断当前这个要获取锁的线程是不是在队列中，如果不在队列中直接进入队列的tail等待</li></ul><h4 id="9-ReentrantReadWriteLock原理"><a href="#9-ReentrantReadWriteLock原理" class="headerlink" title="9.ReentrantReadWriteLock原理"></a>9.<strong>ReentrantReadWriteLock</strong>原理</h4><p>读线程获取读锁，写线程获取写锁，所以支持多个线程同时读，但是对于读写和写写依然是排他的，一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231205224745413.png" class title="image-20231205224745413"><p><strong>注意：上面的锁降级的意思是，读锁和写锁相互可以相互转换，而不是synchronized中的那个锁降级</strong></p><ul><li><p>ReentrantReadWriteLock也是维护了一个FIFO队列实现线程同步，也是维护了一个int类型的state变量，表示获取锁的次数，那么一个int变量是如何对读写两种锁进行统计的呢？</p><ul><li>在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写</li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231205225236301.png" class title="image-20231205225236301"></li></ul></li><li><p>写锁的获取</p><ul><li>通过lock.writeLock().lock()的方式进行锁的获取，然后依然是调用AQS提供的模板方法acquire，acquire调用ReentrantReadWriteLock复写的tryAcquire方法，进入加锁逻辑，先获取到读写锁当前的状态，然后把这个状态和1 &lt;&lt; 16 - 1进行&amp;操作，得到的就是写锁的状态，然后进行判断<ul><li>如果读写锁的状态不为0，但是写锁的状态为0，说明此时有线程正在读，所以return false</li><li>如果读写锁的状态不为0，写锁的状态也不为0，这时要判断写锁的线程主人是否是当前线程，如果不是当前线程，仍然return false</li><li>如果读写锁的状态不为0，同时写锁的状态也不同于以上两种情况，说明此时是写锁的重入，这时在可重入范围(0 — 1 &lt;&lt; 16 - 1)以内都可以进行加锁</li><li>如果读写锁的状态为0，那就好办了，说明此时还没有任何线程获取到锁，只需要看当前这个线程是否是公平的，如果是非公平的直接加锁，如果是公平的那么只有在队列中的线程才可以加锁</li></ul></li></ul></li><li><p>读锁的获取</p><ul><li>通过lock.readLock().lock()的方式进行锁的获取，然后调用的是AQS中提供的acquireShared这个模板方法，然后模板方法调用ReentrantReadWriteLock复写的tryAcquireShared方法，进入获取锁的逻辑，先判断写锁有没有被获取，如果写锁被获取，且获取写锁的线程还不是自己，那么就直接获取读锁失败，如果写锁没有被获取，或者获取写锁的线程就是当前线程，那么就获取读锁，并且读状态加一(加的是 1 &lt;&lt; 16)</li><li>读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在ThreadLocal中（A 和 B 线程获取读锁，A线程重入了3次, B线程只有1次，那么对于我们读锁的读状态&#x3D; 3+1 &#x3D; 4；<strong>A线程的ThreadLoca保存了 3，B线程的ThreadLocal保存了1</strong>）<strong>，</strong>由线程自身维护，所以在释放锁的时候要对应减去自己ThreadLocal中保存的获取锁的状态。</li></ul></li></ul><h4 id="10-ReentrantReadWriteLock的锁降级"><a href="#10-ReentrantReadWriteLock的锁降级" class="headerlink" title="10.ReentrantReadWriteLock的锁降级"></a>10.ReentrantReadWriteLock的锁降级</h4><p><strong>锁降级指的是写锁降级成为读锁</strong>。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指<strong>把持住（当前拥有的）写锁</strong>，<strong>再获取到读锁</strong>，<strong>随后释放（先前拥有的）写锁的过程</strong>。</p><ul><li>锁降级中读锁的获取是否必要呢？<ul><li>必要。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻<strong>另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。</strong>如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会一直被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。</li></ul></li></ul><h4 id="11-LockSupport工具"><a href="#11-LockSupport工具" class="headerlink" title="11.LockSupport工具"></a>11.<strong>LockSupport</strong>工具</h4><p>LockSupport定义了一组的公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231206200046659.png" class title="image-20231206200046659"><p>上面的park和unpark方法都是直接调用的native方法，所以是直接和操作系统进行了交互，在Java 6中，LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos)和parkUntil(Object blocker,long deadline)3个方法，也就是在原方法的基础上加了一个参数，其中参数<strong>blocker是用来标识当前线程在等待的对象</strong>，调用这个方法会导致线程dump的日志中多出等待对象的信息(下图黄色部分)，从而方便问题排查和系统监控。</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231206200726045.png" class title="image-20231206200726045"><h4 id="12-Condition解读"><a href="#12-Condition解读" class="headerlink" title="12.Condition解读"></a>12.<strong>Condition</strong>解读</h4><ul><li><p>Condition介绍</p><ul><li>Condition接口提供了类似Object的监视器(wait&#x2F;notify)方法，与Lock配合可以实现等待&#x2F;通知模式，但是这两者在使用方式以及功能特性上还是有差别的。</li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231206215911098.png" class title="image-20231206215911098"></li></ul></li><li><p>Condition使用</p><ul><li>通过lock.newCondition()的形式进行队列的创建，Condition调用await方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的singal方法，通知当前线程，当前线程才从await方法返回，并且在返回前已经获取了锁。多用于生产者和消费者的形式中，例如当生产者的队列满了以后，调用await方法等待，然后唤醒消费者线程。当没东西可以消费的时候，消费者线程会调用await方法进入等待状态，然后通知生产者线程继续生产</li></ul></li><li><p>Condition的原理</p><ul><li>通过newCondition得到的队列也是一个FIFO队列，称为等待队列，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。事实上，节点的定义复用了同步器中节点的定义，也就是AbstractQueuedSynchronizer.Node，一个Condition包含一个等待队列，Condition拥有首节点（firstWaiter）和尾节点（lastWaiter）。上述节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。</li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207125211837.png" class title="image-20231207125211837"></li><li>并发包中的Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列，其对应关系如图所示。一个线程持有锁，调用了await方法之后加入了<strong>等待队列</strong>进行排队，当我们的这个线程被唤醒（需要执行await后边的代码），需要重新竞争锁（因为await方法将锁释放掉了）。如果竞争成功执行后续代码，如果竞争失败，就会加入到<strong>同步队列</strong>里进行排队。如果排到了同步队列的头部且争抢锁成功，就继续执行await方法后边的代码。如果在执行过程中又调用了await方法，就再次回到等待队列。依次循环下去。</li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207125453697.png" class title="image-20231207125453697"></li></ul></li><li><p>await和signal重点源码</p><ul><li><p>await</p><ul><li><pre><code class="java">if (Thread.interrupted())//先查看线程的中断标记，如果被中断则直接抛出异常    throw new InterruptedException();Node node = addConditionWaiter();//加入到等待队列的尾端int savedState = fullyRelease(node);//释放锁<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- signal</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    if (first != null)</span><br><span class="line">        doSignal(first);//唤醒等待队列的首节点</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul><h3 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h3><h4 id="1-什么是原子操作类"><a href="#1-什么是原子操作类" class="headerlink" title="1.什么是原子操作类"></a>1.什么是原子操作类</h4><p><strong>原子操作类：提供了可以保证我们线程安全的类。可以直接使用。</strong>Java从JDK 1.5开始提供了java.util.concurrent.atomic包，这个包中的原子操作类提供了一种用法简单、性能高效（使用CAS不会阻塞线程）、线程安全地更新一个变量的方式。</p><p>因为变量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是<strong>原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。</strong>Atomic包里的类基本都是使用Unsafe实现的包装类。</p><h4 id="2-原子更新基本类型类"><a href="#2-原子更新基本类型类" class="headerlink" title="2.原子更新基本类型类"></a>2.<strong>原子更新基本类型类</strong></h4><p>使用原子的方式更新基本类型，Atomic包提供了以下3个类。</p><p>·AtomicBoolean：原子更新布尔类型。</p><p>·AtomicInteger：原子更新整型。</p><p>·AtomicLong：原子更新长整型。</p><p>以原子更新整型为例，可以调用其incrementAndGet方法，先对初始化的值进行加一，然后返回相加后的值</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207220113917.png" class title="image-20231207220113917"><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207220241440.png" class title="image-20231207220241440"><p>底层直接调用了native方法，使用CAS保证了原子性</p><h4 id="3-原子更新数组型类"><a href="#3-原子更新数组型类" class="headerlink" title="3.原子更新数组型类"></a>3.原子更新数组型类</h4><p>通过原子的方式更新数组里的某个元素，Atomic包提供了以下3个类。</p><p>·AtomicIntegerArray：原子更新整型数组里的元素。</p><p>·AtomicLongArray：原子更新长整型数组里的元素。</p><p>·AtomicReferenceArray：原子更新引用类型数组里的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayAtomicTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        array[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">        array[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">        <span class="type">AtomicIntegerArray</span> <span class="variable">aia</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(array);</span><br><span class="line">        aia.compareAndSet(<span class="number">0</span>, <span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line">        System.out.println(aia.get(<span class="number">0</span>)); <span class="comment">// 11</span></span><br><span class="line">        System.out.println(array[<span class="number">0</span>]);<span class="comment">// 10</span></span><br><span class="line">        <span class="comment">//我们的数组的原子操作类，只是复制了我们之前的array的对象，并不会</span></span><br><span class="line">        <span class="comment">//在操作中改变原有array的值。</span></span><br><span class="line">        <span class="comment">//原始的array只作为一个入参。真正保障我们的原子性的还是我们的AtomicIntegerArray</span></span><br><span class="line">        <span class="comment">//备份的这个一份儿数据。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>AtomicIntegerArray的备份操作，克隆了一份原数组，而不是对原数组直接进行修改<ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207221600191.png" class title="image-20231207221600191"></li></ul></li></ul><p>里面的方法基本都见名知意，而底层基本也都是使用Unsafe类的CAS方法来保证原子性</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207221058981.png" class title="image-20231207221058981"><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207221116257.png" class title="image-20231207221116257"><h4 id="4-原子更新引用类"><a href="#4-原子更新引用类" class="headerlink" title="4.原子更新引用类"></a>4.<strong>原子更新引用类</strong></h4><p>原子更新引用类型提供的类中常用的两个类：</p><p>·AtomicReference：原子更新引用类型。</p><p>·AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</p><p>底层依然是CAS</p><ul><li><p>对于原子更新数组和引用的总结：</p><ul><li><p><strong>对于原子更新数组类和原子更新对象引用类，他们实质上就是将我们的数组和对象的外层进行了一次 Atomic</strong> <strong>的封装。所以，在进行替换的时候，其实是外层的这个封装保证了原子性。</strong></p><p><strong>想想我们的原子更新基本类型如：Integer，也是在他的外层进行了一次封装。</strong></p></li></ul></li></ul><h4 id="5-原子更新字段类"><a href="#5-原子更新字段类" class="headerlink" title="5.原子更新字段类"></a>5.<strong>原子更新字段类</strong></h4><p>如果需要原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新。</p><p>·AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</p><p>·AtomicLongFieldUpdater：原子更新长整型字段的更新器。</p><p>·AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的ABA问题。</p><p>要想原子地更新字段类需要两步。<strong>第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新类的字段（属性）必须使用public volatile修饰符。</strong></p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207223857004.png" class title="image-20231207223857004"><p>底层依然是CAS</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231207224000538.png" class title="image-20231207224000538"><h3 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h3><h4 id="1-CountDownLatch介绍"><a href="#1-CountDownLatch介绍" class="headerlink" title="1. CountDownLatch介绍"></a>1. <strong>CountDownLatch</strong>介绍</h4><p>CountDownLatch 中 count down 是倒数的意思，latch 则是门闩的含义。整体含义可以理解为<strong>倒数完成后，门栓打开。倒数没有完成，门栓紧闭。</strong>CountDownLatch 类似于join方法，等待其他线程执行完成后，才会统一继续执行下边的代码。但是它比join的功能更多。</p><p>常用方法说明：</p><p>Ø<strong>CountDownLatch(int count)</strong>; &#x2F;&#x2F;构造方法，创建一个值为count 的计数器。</p><p>Ø<strong>await()</strong>;&#x2F;&#x2F;阻塞当前线程，将当前线程加入阻塞队列。</p><p>Ø<strong>await(long timeout, TimeUnit unit)</strong>;&#x2F;&#x2F;在timeout的时间之内阻塞当前线程,时间一过则当前线程可以执行，</p><p>Ø<strong>countDown()</strong>;&#x2F;&#x2F;对计数器进行递减1操作，当计数器递减至0时，当前线程会去唤醒阻塞队列里的所有线程。</p><ul><li><p>使用示例：每条线程执行完之后，倒数的计数器都会减一，直到减为0，才能执行await后面的代码</p><ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208173827228.png" class title="image-20231208173827228"></li></ul></li><li><p>CountDownLatch 的源码也是一个实现类AQS的Sync，调用await方法相当于是获取锁，调用countDown方法相当于是对锁的状态不断减一，直到减到零，才能释放锁</p></li></ul><h4 id="2-CyclicBarrier介绍"><a href="#2-CyclicBarrier介绍" class="headerlink" title="2.CyclicBarrier介绍"></a>2.<strong>CyclicBarrier</strong>介绍</h4><p>CyclicBarrier的字面意思是<strong>可循环使用（Cyclic）的屏障（Barrier</strong>）。它要做的事情是，让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p><p>CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p><p><strong>CountDownLatch的计数器只能使用一次</strong>，<strong>而CyclicBarrier的计数器可以使用reset()方法重置</strong>。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。CyclicBarrier在初始化时候的传参，除了设置屏障个数以外，能够支持传入一个 Runnable的 action去做后续的数据的操作。能够适用于更加复杂的场景。</p><p>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。</p><ul><li><p>CyclicBarrier和CountDownLatch 的使用区别(需求：A线程完成3+5，B线程完成10+2，然后主线程对结果进行相加)</p><ul><li>使用CountDownLatch完成<ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208182601180.png" class title="image-20231208182601180"></li></ul></li><li>使用CyclicBarrier完成<ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208182813315.png" class title="image-20231208182813315"></li></ul></li><li>总结：CountdownLatch里边的参数直接写的是2，就是进行2次倒计时，我们的main函数调用的await。就是告诉我们main线程在等待其他两个线程执行完毕。 然而，对于 CyclicBarrier 这种实现形式，main函数和其他两个线程都被阻塞到了一个地方。此处main函数到达了屏障之后挂起自己，等待其他两个线程达到屏障之后才开始执行。<strong>CountdownLatch 针对业务完成之后放行；CyclicBarrier 针对的是所有的线程在统一的屏障集合之后开始执行后续代码</strong></li></ul><ul><li>使用CyclicBarrier传入的Runnable的 action完成<ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208183829168.png" class title="image-20231208183829168"></li></ul></li></ul></li></ul><h4 id="3-Semaphore介绍"><a href="#3-Semaphore介绍" class="headerlink" title="3.Semaphore介绍"></a>3.<strong>Semaphore</strong>介绍</h4><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p><p>Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制。</p><ul><li>示例代码<ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208185046260.png" class title="image-20231208185046260"></li><li>这样就可以保证同一时间数据库最多只有十条线程对其进行连接</li></ul></li></ul><h4 id="4-Exchanger介绍"><a href="#4-Exchanger介绍" class="headerlink" title="4.Exchanger介绍"></a>4.<strong>Exchanger</strong>介绍</h4><p>Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果<strong>第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</strong></p><p>下面来看一下Exchanger的应用场景。Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作，比如我们需要将<strong>纸制银行流水通过人工的方式录入成电子银行流水</strong>，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致。</p><h3 id="Java阻塞与非阻塞队列"><a href="#Java阻塞与非阻塞队列" class="headerlink" title="Java阻塞与非阻塞队列"></a>Java阻塞与非阻塞队列</h3><h4 id="1-ConcurrentLinkedQueue非阻塞队列"><a href="#1-ConcurrentLinkedQueue非阻塞队列" class="headerlink" title="1.ConcurrentLinkedQueue非阻塞队列"></a>1.<strong>ConcurrentLinkedQueue</strong>非阻塞队列</h4><p>在多线程并发环境下，如果想要实现一个线程安全的队列，无非两种方式</p><ol><li>加锁</li><li>使用CAS</li></ol><p>ConcurrentLinkedQueue是一个基于<strong>链接节点的无界线程安全队列</strong>，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元素时，它会返回队列头部的元素，底层使用CAS保证线程安全。</p><p>ConcurrentLinkedQueue在节点入队的时候，先会检查tail的next节点是不是为空，如果tail的next节点为空，那么新来的节点直接放到tail的next的位置，如果tail的next节点不为空，那么新来的节点直接放到tail的next节点的next节点，同时把tail指向新来的节点，所以tail指向的不一定是尾节点</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208220706859.png" class title="image-20231208220706859"><p>ConcurrentLinkedQueue在节点出队的时候，当head节点里有元素时，直接弹出head节点里的元素，而不会更新head节点。只有当head节点里没有元素时，出队操作才会更新head节点(head指向弹出节点的next节点)。所以，并不是每次出队时都更新head节点，也就是说head并不一定一直指向头节点</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208220848350.png" class title="image-20231208220848350"><h4 id="2-阻塞队列介绍"><a href="#2-阻塞队列介绍" class="headerlink" title="2.阻塞队列介绍"></a>2.阻塞队列介绍</h4><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列：</p><p>1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。</p><p>2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。</p><p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231208221559308.png" class title="image-20231208221559308"><p><em>注：返回特殊值例如true或者false</em></p><ul><li>JDK7提供的阻塞队列：<ul><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ul></li></ul><h4 id="3-有界阻塞队列"><a href="#3-有界阻塞队列" class="headerlink" title="3.有界阻塞队列"></a>3.有界阻塞队列</h4><p>ArrayBlockingQueue是一个用<strong>数组</strong>实现的<strong>有界阻塞队列</strong>。此队列按照<strong>先进先出（FIFO）</strong>的原则对元素进行排序。</p><p>LinkedBlockingQueue是一个用<strong>链表</strong>实现的<strong>有界阻塞队列</strong>。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照<strong>先进先出</strong>的原则对元素进行。</p><ul><li><p>相同点：</p><ul><li>都是阻塞队列，且有界；</li><li>都是先进先出</li></ul></li><li><p>不同点：</p><ul><li>锁使用的不同，ArrayBlockingQueue元素入队和出队使用的是一把ReentrantLock，所以进出会相互影响，LinkedBlockingQueue使用的是两把ReentrantLock，一个take锁，一个put锁，入队出队只需要获取对应的锁即可，所以进出互不影响。所以从这一方面来看LinkedBlockingQueue更适合高并发场景，具有更高的吞吐量(单位时间处理更多请求)</li><li>ArrayBlockingQueue使用的是object的数组存储的元素，而LinkedBlockingQueue使用的是Node节点进行的元素存储，而且有next节点。如果数据量非常大的情况下，随着数据量的增长，我们需要构建的Node节点的数量就越多，Node节点数量代表的是对象的数量，一旦有这么多对象的产生，就会有产生对象的jvm的消耗;使用完成需要进行垃圾回收; 而且还存在next指针问题。反观我们的 array，就是一个数组,内存空间连续,不需要额外构造node节点了。直接object定义的我们的底层数组，可以存放任何类型的对象，不需要构造 node。</li><li>队列长度问题。如果我们要创建ArrayBlockingQueue,需要严格指定queue的大小，也就是说，我们在使用这个queue之前就开辟好了内存空间。而LinkedBlockingQueue不强制指定大小。因为每次插入一个新的节点，都会new 一个Node对象，都会开辟一块新的内存空间。如果我们能够确定定长的队列，建议使用arrayqueue。</li></ul></li></ul><p>总结：至于谁的效率更好，真的没有办法界定。因为你永远无法知道，创建节点开辟内存空间的消耗，创建Node对象的消耗，回收Node对象的消耗，和ArrayBlockingQueue 的单锁的消耗谁大谁小。所以有条件一定进行压测然后再选取</p><h4 id="4-优先级队列和延时队列"><a href="#4-优先级队列和延时队列" class="headerlink" title="4.优先级队列和延时队列"></a>4.优先级队列和延时队列</h4><ul><li>PriorityBlockingQueue优先级队列的介绍：</li></ul><p>PriorityBlockingQueue是一个支持优先级的无界阻塞队列。底层是使用数组来进行元素的保存,如果达到数组的大小会进行扩容，默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PriorityBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityBlockingQueue</span>&lt;&gt;(<span class="number">10</span>,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                    <span class="comment">// 降序排列，如果o1小于o2，返回-1，如果o1等于o2，返回0，如果o1大于o2，返回1</span></span><br><span class="line">                    <span class="keyword">return</span> o2 - o1;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>DelayQueue延时队列介绍</li></ul><p>DelayQueue是一个<strong>支持延时</strong>获取元素的<strong>无界阻塞队列</strong>。队列使用<strong>PriorityQueue</strong>来实现。队列中的元素必须实现<strong>Delayed接口</strong>，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。</p><p><strong>DelayQueue非常有用，可以将DelayQueue运用在以下应用场景。</strong></p><p><strong>缓存系统的设计</strong>(很少有公司自己设计大型缓存：Redis，ehcache)：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</p><p><strong>定时任务调度</strong>：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。</p><p>由于它底层的队列是由PriorityQueue实现的，所以它可以实现优先级排序，可以根据加入任务的时间进行升序排列，剩余时间越小的越靠前，当从队列中取数据的时候，会先调用peek方法，看看第一个任务是不是空，看看第一个任务是不是到期可以执行了，然后才会取出任务，其中poll方法在取任务的时候发现任务不能取出，会直接返回null，而take方法在取数据的时候如果第一个任务不能取出，那么这时会死循环返回获取</p><ul><li>signal和await在这个地方的配合<ul><li>如果取任务的线程发现队列中第一个任务不可取，或者第一个去取得线程(leader)不为空，那么说明这个取线程一定取不到任务，这时会调用await进入等待队列，当放任务的线程把一个任务放到空队列的时候，会调用signal方法唤醒正在等待队列中等待的取线程</li></ul></li></ul><h4 id="5-SynchronousQueue介绍"><a href="#5-SynchronousQueue介绍" class="headerlink" title="5.SynchronousQueue介绍"></a>5.<strong>SynchronousQueue</strong>介绍</h4><p>SynchronousQueue<strong>是一个不存储元素的阻塞队列</strong>。每一个put操作必须等待一个take操作，否则不能继续添加元素。</p><p>它支持公平访问队列。<strong>默认情况下线程采用非公平性策略访问队列</strong>。如果设置为true，则等待的线程会采用先进先出的顺序访问队列。</p><ul><li><p>使用场景</p><ul><li><p>不存储数据的队列，阻塞队列。适合短期的小并发场景，且数据处理相当快速。</p><p>硬说点好处：首先他没有缓冲容量，那么他可以避免在服务器宕机的情况下，从queue的角度来说，没有数据丢失这么一说。 他类似于一个<strong>传球手</strong>，中间没有任何介质阻碍。如果单纯的进行数据的传递且生产的线程与消费的线程生产时间和消费时间比较同步的话，他的性能能够很高。</p></li><li><p>CachedThreadPool 里边使用的就是SynchronousQueue。CachedThreadPool 的使用场景就是处理<strong>快速的短期的小并发场景。</strong>CachedThreadPool 是没有核心线程数，完全依赖max线程数，直接依赖操作系统创建线程，如果是短期的小并发，在线程达到 keep live 时间以后，可以自行销毁。</p></li></ul></li></ul><h4 id="6-LinkedTransferQueue介绍（无界、传球手、阻塞）"><a href="#6-LinkedTransferQueue介绍（无界、传球手、阻塞）" class="headerlink" title="6.LinkedTransferQueue介绍（无界、传球手、阻塞）"></a>6.<strong>LinkedTransferQueue</strong>介绍（无界、传球手、阻塞）</h4><p>LinkedTransferQueue是一个由<strong>链表结构</strong>组成的<strong>无界阻塞TransferQueue队列</strong>。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。</p><p>LinkedTransferQueue是一个高效阻塞无界链表队列(被称为综合性的阻塞队列) 。和 SynchronousQueue.TransferQueue (<strong>公平模式</strong>) 相比，它是可以统计长度(使用getWaitingConsumerCount方法查询有多少个正在等待获取的线程，没有获取到的线程会被封装成Node节点)；和 LinkedBlockingQueue 相比，它拥有更高的性能（使用 CAS 自旋，LinkedBlockingQueue使用的是lock锁）；和 ConcurrentLinkedQueue 相比，它拥有阻塞功能（因为它实现了TransferQueue，TransferQueue继承了BlockingQueue）。</p><p><strong>（1）transfer方法</strong></p><p>如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者（与SynchronousQueue相似<strong>）。如果没有消费者在等待接收元素，transfer方法会将元素</strong>存放在队列的tail节点，并等到该元素被消费者消费了才返回。</p><p><strong>（2）tryTransfer方法</strong> </p><p>tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。</p><p>对于带有时间限制的tryTransfer（E e，long timeout，TimeUnit unit）方法，试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</p><h4 id="7-LinkedBlockingDeque介绍"><a href="#7-LinkedBlockingDeque介绍" class="headerlink" title="7.LinkedBlockingDeque介绍"></a>7.<strong>LinkedBlockingDeque</strong>介绍</h4><p>LinkedBlockingDeque是一个由<strong>链表结构</strong>组成的<strong>双向阻塞队列</strong>。所谓双向队列指的是可以从队列的两端插入和移出元素（LinkedBlockingDeque产生的原因是什么？1.首先它是对LinkedBlockingQueue的一个补充，能支持双向存取； 2.对阻塞队列的补充支持双向存取）。</p><p>双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法</p><p>在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“**工作窃取(Fork&#x2F;Join框架中细说)**”模式中。</p><ul><li>既然有双向队列，还那么方便，为什么不直接把单向队列移除? <ul><li>功能越多，向 越多，Node节点越复杂，添加，移除越复杂，维护起来更加麻烦；虽然是减小了竞争压力，但是对于一些不是很大竞争压力下的场景，我们的单向的队列还是非常好用的</li></ul></li></ul><h4 id="8-Fork-x2F-Join框架"><a href="#8-Fork-x2F-Join框架" class="headerlink" title="8.Fork&#x2F;Join框架"></a>8.<strong>Fork&#x2F;Join框架</strong></h4><ul><li><p>Fork&#x2F;Join框架介绍</p><ul><li>Fork&#x2F;Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务(调用compute方法)，最终汇总每个小任务结果后得到大任务结果的框架。再通过Fork和Join这两个单词来理解一下Fork&#x2F;Join框架。Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。</li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231209221211915.png" class title="image-20231209221211915"></li></ul></li><li><p>工作窃取算法</p><ul><li>介绍<ul><li>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。那么，为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，<strong>把这些子任务分别放到不同的队列里</strong>，并为每个队列<strong>创建一个单独的线程来执行队列里的任务</strong>，线程和队列一一对应。比如A线程负责处理A队列里的任务。但是，有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。</li></ul></li><li>与双端队列的配合<ul><li>窃取其他队列中的任务时，它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。工作窃取算法的缺点：如果队列中只剩一个任务，还是会出现竞争，<strong>并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</strong></li></ul></li></ul></li><li><p>Fork&#x2F;Join框架使用</p><ul><li><p>Fork&#x2F;Join使用两个类来完成以上两件事情。</p><p>①<strong>ForkJoinTask</strong>：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中<strong>执行fork()<strong>和</strong>join()<strong>操作的机制。通常情况下，我们</strong>不需要直接继承ForkJoinTask类</strong>，只需<strong>要继承它的子类</strong>，Fork&#x2F;Join框架提供了以下两个子类。</p><p>·<strong>RecursiveAction</strong>：用于没有返回结果的任务。</p><p>·<strong>RecursiveTask</strong>：用于有返回结果的任务。</p><p>②<strong>ForkJoinPool</strong>：ForkJoinTask需要通过ForkJoinPool来执行。</p></li><li><pre><code class="java">//使用fork/join计算从一加到一百public class ForkJoinTest extends RecursiveTask&lt;Integer&gt; &#123; //需要返回结果    private static final int THRESHOLD = 2; // 最多几个数字做子任务    private int start; //从那块相加    private int end;// 加到几    public ForkJoinTest(int start, int end) &#123;        this.start = start;        this.end = end;    &#125;    @Override    protected Integer compute() &#123; //拆分任务，获取结果        int sum = 0;        // 如果任务足够小就计算任务        boolean canCompute = (end - start) &lt; THRESHOLD;        if (canCompute) &#123;            for (int i = start; i &lt;= end; i++) &#123;                sum += i;            &#125;        &#125; else &#123;            // 如果任务大于阈值，就分裂成两个子任务计算            int middle = (start + end) / 2;            ForkJoinTest leftTask = new ForkJoinTest(start, middle);            ForkJoinTest rightTask = new ForkJoinTest(middle + 1, end);            // 执行子任务            leftTask.fork();            rightTask.fork();            // 等待子任务执行完，并得到其结果            int leftResult = leftTask.join();            int rightResult = rightTask.join();            // 合并子任务            sum = leftResult + rightResult;        &#125;        return sum;    &#125;    public static void main(String[] args) &#123;        ForkJoinPool forkJoinPool = new ForkJoinPool();        // 生成一个计算任务，负责计算1+2+3+4        ForkJoinTest task = new ForkJoinTest(1, 100);        // 执行一个任务        Future&lt;Integer&gt; result = forkJoinPool.submit(task);        try &#123;            System.out.println(result.get());        &#125; catch (InterruptedException e) &#123;        &#125; catch (ExecutionException e) &#123;        &#125;    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 线程池与Executor框架</span><br><span class="line"></span><br><span class="line">#### 1.**线程池的原理**</span><br><span class="line"></span><br><span class="line">* 线程池运行步骤：</span><br><span class="line"></span><br><span class="line">1）使用者提交任务以后，如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</span><br><span class="line"></span><br><span class="line">2）如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue队列。</span><br><span class="line"></span><br><span class="line">3）如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。</span><br><span class="line"></span><br><span class="line">4）如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231209225302725.png image-20231209225302725 %&#125;</span><br><span class="line"></span><br><span class="line">* ThreadPoolExecutor为什么采取上述步骤的总体设计思路？(或者问：线程池为什么要有一个核心线程数和最大线程数的区分呢？)</span><br><span class="line"></span><br><span class="line">**是为了在执行execute()方法时，尽可能地避免获取全局锁**</span><br><span class="line"></span><br><span class="line">1. 核心线程数和最大线程数中间还有一个queue，向queue里添加任务不需要获取全局锁。如果核心线程数够用，不一定先要去创建其他的线程，因为需要看queue是否还能够继续容纳新的请求； 如果没有所谓的最大的线程数，只有一个核心线程数，那么当我们线程池的核心线程数配置小了的话，那么很多任务都会添加到queue里。如果queue满了，我们就没有其他的办法创建新的额外的线程了。</span><br><span class="line"></span><br><span class="line">2. 如果仅仅依靠核心线程数，比如说我们将核心线程数的值设置的非常大，每次有新任务过来，都有可能在核心线程数里边创建新的线程，可能会造成全局锁的获取，导致性能一个瓶颈。</span><br><span class="line"></span><br><span class="line">* 全局锁？在那块儿有这个逻辑？</span><br><span class="line"></span><br><span class="line">当我们的ThreadPoolExecutor进行execute方法执行的时候，如果当前的工作线程小于 Coresize，就会进行一个新的工作线程的添加，调用 addWorker 方法，这个方法里，当我们进行最终的worker.add的时候，是在一个ReentrantLock里执行的。也就是说，此处不允许并发添加新的worker。如果同时有多个线程进来，且都小于coresize，只能排队添加。</span><br><span class="line"></span><br><span class="line">#### 2.线程池参数</span><br><span class="line"></span><br><span class="line">1）**corePoolSize**（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</span><br><span class="line"></span><br><span class="line">2）**runnableTaskQueue**（任务队列）**建议选用有界队列**。1. 如果是无界队列，那么queue永远不会满，永远不会触发到maximumPoolSize，意味着maximumPoolSize这个参数就没有他的作用了； 2. 最重要的是无界队列无法控制队列最终包含的数据量，导致内存资源的极大的消耗甚至耗尽。3. 最好是选用有界队列并合理的配置maximumPoolSize。4 饱和策略的使用根据需求选择。一旦我们触发了饱和策略，就说明：要么是我们的线程池配置有问题，要么真的是并发量太高，任务太多，导致的问题。警醒我们进行深入的参数调查及合理分配。</span><br><span class="line"></span><br><span class="line">3）**maximumPoolSize**（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。</span><br><span class="line"></span><br><span class="line">4）ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线程设置有意义的名字</span><br><span class="line"></span><br><span class="line">5）**RejectedExecutionHandler**（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略。</span><br><span class="line"></span><br><span class="line">·**AbortPolicy**：直接抛出异常。相对多一些，因为我们会在异常处理的过程中进行各种手段：如果记录日志，存入数据库等待重试</span><br><span class="line"></span><br><span class="line">·**CallerRunsPolicy**：只用调用者所在线程来运行任务。用的也相对少一些。调用者线程也是系统资源，说明线程数量已经很多了，调用者线程的加入其实是变相增加了 maxsize</span><br><span class="line"></span><br><span class="line">·**DiscardOldestPolicy**：丢弃队列里最近的一个任务，并执行当前任务。几乎没有人使用。</span><br><span class="line"></span><br><span class="line">·**DiscardPolicy**：不处理，丢弃掉。 这种使用的也少</span><br><span class="line"></span><br><span class="line">当然，也可以根据应用场景需要来实现**RejectedExecutionHandler**接口**自定义策略**。（最推荐）</span><br><span class="line"></span><br><span class="line">6）keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率,如果是一个多线程一同执行的一个大任务，例如一个定时任务，一天执行一次，这时可以把keepAliveTime的时间调小一些。</span><br><span class="line"></span><br><span class="line">7）TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</span><br><span class="line"></span><br><span class="line">#### 3.如何合理的配置线程池</span><br><span class="line"></span><br><span class="line">1. 我们的线程池是生存在一个复杂的系统环境里，我们还有其他的接口需要使用我们的服务器资源，所以在进行线程池coresize的配置以及maxsize的配置的时候，我们需要明确我们当前的接口的重要性，如果当前接口占据了未来业务访问的50%，那么就可以分配50%的系统资源给当前接口。（我们一个服务，总有一些重要接口和非重要接口，在我们进行项目开发初期，需求就定好了。）</span><br><span class="line">2. 线程池参数的配置一定要基于压测。来评估线程池的参数是否合理。</span><br><span class="line">   - 初次压测的参数配置：</span><br><span class="line">     - 情况一：当前的服务器只为当前的线程池服务。这时可以站在前辈的肩膀，根据前辈的经验，看当前任务是CPU密集型任务还是IO密集型任务，如果是CPU密集型的，那么可以选与当前CPU核数差不多的线程数，或者稍微大一点点的，如果是IO密集型的，那么可以选择CPU核数的两倍或者稍微大一点点的</span><br><span class="line">     - 情况二：当前的服务器不是只为这一个线程池服务。举个场景，一个服务共有五个接口，其中两个重要接口，三个不重要接口(访问量大的时候可以做降级处理，保障另外两个接口可以尽可能多的使用服务器资源)，这两个重要接口都创建了线程池来提高单接口的并发处理速度，这时首先要做的是拿到线上高并发访问压力下该服务每个接口的访问比例，比如这五个接口的访问比例是4：3：1：1：1，那么对于第二个接口而言，它就有资格占用3/10的服务器资源，那么他的线程池的最大线程数可以粗略的设置为当前CPU核数的3/10，首次压测，把核心线程数也设置为和最大线程数相同的大小，然后开始压测，看当前线程池能否撑得住现在的并发访问量，如果撑得住慢慢调小核心线程数，如果撑不住这时queue就要登场了，至于队列大小的计算，需要根据接口访问峰值和持续时间，比如，双11，618等等活动，都会有一个高峰的访问持续时间，假如高峰情况下访问一个小时，打到该接口的请求一共有1000个，而当前接口正常情况下一个小时能处理的请求数量是800个，这时可以得到1000-800=200这个值，然后把200这个值稍微调高50%(为了避免访问不均匀的问题，当然如果访问量曲线比较平稳可以适当降低这个值，比如就调高10%-20%)，也就是300作为这个有界队列的初始大小，然后再次压测，这时如果可以达到要求，那么为了避免资源的浪费，再次降低核心线程数的数量 ，但是如果还没有达到预期要求，可以从以下几点进行解决，1.再次提高队列的长度(不要首先想提高线程数，而是先动队列的长度上限，因为这样一定不会影响到其他接口，属于空间换时间)2.如果由于调高了队列的长度，没有提高线程数导致接口性能下降，这时考虑对代码进行优化(比如可不可以把目前的接口做成异步的，对于消息的处理可不可进行服务的拆分，把他放到RabbitMQ里，由下游的服务从RabbitMQ里边，进行多线程的处理，提高当前接口的并发量)3.如果对代码优化之后还是不能达到预期，这时才可以考虑调高一下线程数，因为如此大的并发情况下，另外三个接口可能做出了服务的降级处理让出了一定服务器资源，但是并不建议这么做，因为虽然其他接口做了降级处理，还是有可能因为提高线程数而引起其他节点的一些问题4.增加节点数量。</span><br><span class="line">3. 我们要给线程池开后门，可以动态的调整线程池的参数。（我们现在很多大型项目都有自己的配置中心，appolo是一个非常好的配置组件，你可以将coresize和maxsize配置到配置中心，一旦发生不可控的高并发场景，可以随时修改配置中心的参数，我们的项目就会按照新的标准进行调整。）</span><br><span class="line"></span><br><span class="line">#### 4.**线程池的监控及关闭**</span><br><span class="line"></span><br><span class="line">* 线程池的监控</span><br><span class="line"></span><br><span class="line">  * 如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根据线程池的使用状况快速定位问题。可以通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性。</span><br><span class="line"></span><br><span class="line">    ·taskCount：线程池需要执行的任务数量。</span><br><span class="line"></span><br><span class="line">    ·completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。</span><br><span class="line"></span><br><span class="line">    ·largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。</span><br><span class="line"></span><br><span class="line">    ·getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。</span><br><span class="line"></span><br><span class="line">    ·getActiveCount：获取活动的线程数。</span><br><span class="line"></span><br><span class="line">    通过扩展线程池进行监控。可以**通过继承线程池来自定义线程池**，重写线程池的beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。</span><br><span class="line"></span><br><span class="line">* 关闭线程池：</span><br><span class="line">  </span><br><span class="line">  - 可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的**原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。**但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后**尝试停止所有的正在执行或暂停任务的线程**，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后**中断所有没有正在执行任务的线程。**</span><br><span class="line"></span><br><span class="line">#### 5.**Executor框架**</span><br><span class="line"></span><br><span class="line">Executor框架就是一个上层的用户级的调度器。</span><br><span class="line"></span><br><span class="line">在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231210145801348.png image-20231210145801348 %&#125;</span><br><span class="line"></span><br><span class="line">应用程序通过Executor框架控制上层的调度；而下层的调度由操作系统内核控制，下层的调度不受应用程序的控制。</span><br><span class="line"></span><br><span class="line">* Executor框架的组成</span><br><span class="line"></span><br><span class="line">  **·任务**。包括被执行任务需要实现的接口：Runnable接口(没有返回值)或Callable接口(有返回值)。</span><br><span class="line"></span><br><span class="line">  **·任务的执行**。包括任务执行机制的核心接口Executor，以及继承自Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口（ThreadPoolExecutor(用来执行被提交的任务)和ScheduledThreadPoolExecutor(在给定的延迟后运行命令，或者定期执行命令。)）。</span><br><span class="line"></span><br><span class="line">  **·异步计算的结果**。包括接口Future和实现Future接口的FutureTask类。</span><br><span class="line"></span><br><span class="line">  - &#123;% asset_img image-20231210150303335.png image-20231210150303335 %&#125;</span><br><span class="line"></span><br><span class="line">#### 6.**Executor框架**的使用</span><br><span class="line"></span><br><span class="line">主线程首先要创建实现Runnable或者Callable接口的任务对象。然后可以把Runnable对象直接交给ExecutorService调用execute或者submit来执行，如果执行ExecutorService.submit，ExecutorService将返回一个实现Future接口的对象（到目前为止的JDK中，返回的是FutureTask对象）。最后，主线程可以执行FutureTask.get()方法来等待任务执行完成。主线程也可以执行FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。</span><br><span class="line"></span><br><span class="line">* 示例代码</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public class ThreadPoolSimpleTest &#123;</span><br><span class="line">        public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">            ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10,</span><br><span class="line">                    200, TimeUnit.MILLISECONDS,</span><br><span class="line">                    new ArrayBlockingQueue&lt;Runnable&gt;(5));</span><br><span class="line">    </span><br><span class="line">            for(int i=0;i&lt;15;i++)&#123;</span><br><span class="line">                //创建任务对象</span><br><span class="line">                MyTask myTask = new MyTask(i);</span><br><span class="line">                //任务的执行</span><br><span class="line">    //            executor.execute(myTask);</span><br><span class="line">                //异步计算的结果</span><br><span class="line">                Future&lt;?&gt; submit = executor.submit(myTask);</span><br><span class="line">                System.out.println(&quot;线程池中线程数目：&quot;+executor.getPoolSize()+&quot;，队列中等待执行的任务数目：&quot;+</span><br><span class="line">                        executor.getQueue().size()+&quot;，已执行完的任务数目：&quot;+executor.getCompletedTaskCount());</span><br><span class="line">            &#125;</span><br><span class="line">            executor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    class MyTask implements Runnable &#123;</span><br><span class="line">        private int taskNum;</span><br><span class="line">    </span><br><span class="line">        public MyTask(int num) &#123;</span><br><span class="line">            this.taskNum = num;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;正在执行task &quot; + taskNum);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.currentThread().sleep(4000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;task &quot; + taskNum + &quot;执行完毕&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="7-FixedThreadPool详解"><a href="#7-FixedThreadPool详解" class="headerlink" title="7.FixedThreadPool详解"></a>7.<strong>FixedThreadPool详解</strong></h4><p>Executor框架最核心的类是ThreadPoolExecutor，通过Executor框架的工具类Executors，可以创建4种类型的ThreadPoolExecutor。</p><ol><li><p>最大的类型是自定义创建的类型(所有的参数自己输入)</p></li><li><p>FixedThreadPool。</p></li><li><p>SingleThreadExecutor。</p></li><li><p>CachedThreadPool。</p></li></ol><ul><li><p>为什么命名不同呢？ </p><ul><li><p>（不同的pool都是return new ThreadPoolExecutor）ThreadPoolExecutor参数不同导致的。</p></li><li><p>例如通过使用Executors的newFixedThreadPool创建的FixedThreadPool</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231210153132819.png" class title="image-20231210153132819"></li></ul></li><li><p>FixedThreadPool介绍</p><ul><li><p>FixedThreadPool被称为<strong>可重用固定线程数的线程池</strong>。FixedThreadPool的corePoolSize和maximumPoolSize都被设置为创建FixedThreadPool时指定的参数nThreads。<strong>当线程池中的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的最长时间</strong>，超过这个时间后多余的线程将被终止。这里把keepAliveTime设置为0L，意味着多余的空闲线程会被立即终止。</p></li><li><p>执行步骤</p><ul><li><p>1）如果当前运行的线程数少于corePoolSize，则创建新线程来执行任务。</p><p>2）在线程池完成预热之后（当前运行的线程数等于corePoolSize），将任务加入LinkedBlockingQueue。</p><p>3）线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue获取任务来执行。</p></li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231210154714279.png" class title="image-20231210154714279"></li></ul></li><li><p>FixedThreadPool使用无界队列LinkedBlockingQueue(<strong>这个地方的无界指的是有没有在创建队列的时候手动的限制队列大小，而不是说队列元素有上限就是无界队列</strong>)作为线程池的工作队列<strong>（</strong>队列的容量为Integer.MAX_VALUE）。使用无界队列作为工作队列会对线程池带来如下影响。</p><p>1）当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize。</p><p>2）由于1，使用无界队列时<strong>maximumPoolSize将是一个无效参数</strong>。</p><p>3）由于1和2，使用无界队列时keepAliveTime将是一个无效参数。</p><p>4）由于使用无界队列，运行中的FixedThreadPool（未执行方法shutdown()或shutdownNow()）不会拒绝任务</p></li></ul></li></ul><h4 id="8-SingleThreadExecutor详解"><a href="#8-SingleThreadExecutor详解" class="headerlink" title="8.SingleThreadExecutor详解"></a>8.<strong>SingleThreadExecutor详解</strong></h4><p>SingleThreadExecutor是使用单个worker线程的Executor。属于FixedThreadPool的一种特殊情况</p><p>SingleThreadExecutor的corePoolSize和maximumPoolSize被设置为1。其他参数与FixedThreadPool相同。SingleThreadExecutor使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）。</p><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231210155443356.png" class title="image-20231210155443356"><h4 id="9-CachedThreadPool详解"><a href="#9-CachedThreadPool详解" class="headerlink" title="9.CachedThreadPool详解"></a>9.<strong>CachedThreadPool详解</strong></h4><p>CachedThreadPool是一个会根据需要创建新线程的线程池。</p><p>CachedThreadPool的corePoolSize被设置为0，maximumPoolSize被设置为Integer.MAX_VALUE，即maximumPool是<strong>无界的</strong>。这里把keepAliveTime设置为60秒，CachedThreadPool使用没有容量的SynchronousQueue作为线程池的工作队列，但CachedThreadPool的maximumPool是无界的。这意味着，如果主线程提交任务的速度高于maximumPool中线程处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下，CachedThreadPool会因为创建过多线程而耗尽CPU和内存资源。</p><ul><li><p>总结：</p><ul><li><p>对于fixed，single和 cache，我们在实际的工作中最多使用到的是 single（相对于fixed和cache）。一般情况下，对于并发量不高的场景，并且需要单条异步线程进行处理的时候，会使用一下 single。 真正的业务处理中，如果使用线程池，99%的情况下，需要自定义线程池（自己传入参数）。只有1%的情况会使用fixed，single和 cache。在这1%里，single稍微多一些。</p><p>Fixed和 single 容易造成我们的queue的消息无限积压，还会导致无法触发拒绝策略。所以一般没人用</p><p>Cache可能高并发下无法控制最高的线程创建数量，造成cpu和内存资源的消耗甚至耗尽。所以没人用</p><p>这三个，仅仅是为了让我们创建线程池的时候方便一些，不代表他们很实用。</p></li></ul></li></ul><h4 id="10-ScheduledThreadPoolExecutor详解"><a href="#10-ScheduledThreadPoolExecutor详解" class="headerlink" title="10.ScheduledThreadPoolExecutor详解"></a>10.<strong>ScheduledThreadPoolExecutor详解</strong></h4><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的<strong>延迟</strong>之后运行任务，或者<strong>定期</strong>执行任务。ScheduledThreadPoolExecutor的功能与Timer类似，但ScheduledThreadPoolExecutor功能更强大、更灵活。Timer对应的是单个后台线程，而ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数（创建线程池）。</p><ul><li><p>ScheduledThreadPoolExecutor的创建</p><ul><li><p>ScheduledThreadPoolExecutor的创建一般有以下三种方法</p></li><li><pre><code class="java">ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(5);ScheduledExecutorService service = Executors.newScheduledThreadPool(5);ScheduledThreadPoolExecutor pool    = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(5);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 一般使用第三种方法，一方面使用Executors工具类便于new的创建，不许使用new这个关键词，另一方面，源码中就是直接new的ScheduledThreadPoolExecutor只不过返回值是ScheduledExecutorService，所以只需要对其强转，获取其子类就可以同时使用父类和子类的方法</span><br><span class="line"></span><br><span class="line">  - &#123;% asset_img image-20231210163550997.png image-20231210163550997 %&#125;</span><br><span class="line"></span><br><span class="line">* ScheduledThreadPoolExecutor常见方法</span><br><span class="line"></span><br><span class="line">  - schedule方法</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      pool.schedule(new STask(1), 5, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>- 第一次参数是要执行的任务，第二个参数是要延迟多少时间执行，第三个参数是时间的单位</code></pre></li><li><p>scheduleAtFixedRate方法</p><ul><li><pre><code class="java">pool.scheduleAtFixedRate(new STask(1), 5, 5, TimeUnit.SECONDS);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 第一次参数是要执行的任务，第二个参数是要延迟多少时间执行，第三个参数是执行的周期时间，第四个参数是时间的单位</span><br><span class="line"></span><br><span class="line">- scheduleWithFixedDelay方法</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    pool.scheduleWithFixedDelay(new STask(1), 5, 5, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></code></pre></li><li><p>参数含义和第二个方法完全一致</p></li></ul></li><li><p>scheduleAtFixedRate方法和scheduleWithFixedDelay方法的区别</p><ul><li>scheduleWithFixedDelay的周期执行是等待上一次任务执行完成后才开始计算下一次要执行任务的时间，例如第一次执行任务在0秒开始，然后耗时4秒，第二次执行就会在第9秒开始执行，而scheduleWithFixedDelay的周期执行不会管上一次任务是否执行完毕，严格按照在周期在第5秒，第10秒的时间进行执行(注意：如果第一次执行任务的耗时超过了周期时间，比如第一次耗时6秒，周期是5秒，那么第二次任务的开始时间就是第6秒，因为task是周期执行的，下一次执行的时间是在上一个任务执行完成后进行计算，并且 add 到我们的delayQueue里。现在如果是一个 while循环，那么永远不能执行结束我们的ScheduledThreadPoolExecutor就没有办法再次的重新计算时间，并且从新添加到我们的delayQueue中。)</li></ul></li><li><p>延时执行的实现方式就是把传入的任务，延迟时间，周期时间封装成一个ScheduledFutureTask，然后放入到延时队列中，获取任务并执行的逻辑和延迟队列相同(看队列中第一个任务是不是空，或者第一个任务是否到期可执行，如果可以则赶紧执行，否则继续等待)</p><ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231210165113464.png" class title="image-20231210165113464"></li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231210165709980.png" class title="image-20231210165709980"></li></ul></li></ul></li></ul><h4 id="11-FutureTask详解"><a href="#11-FutureTask详解" class="headerlink" title="11.FutureTask详解"></a>11.FutureTask详解</h4><p><strong>Future接口</strong>和<strong>实现Future接口的FutureTask类</strong>，代表异步计算的结果。</p><p>FutureTask除了实现Future接口外，还实现了Runnable接口。因此，FutureTask可以交给Executor执行，也可以由调用线程直接执行（FutureTask.run()）。根据FutureTask.run()方法被执行的时机，FutureTask可以处于下面3种状态。</p><p>1）未启动。FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态。当创建一个FutureTask，且没有执行FutureTask.run()方法之前，这个FutureTask处于未启动状态。</p><p>2）已启动。FutureTask.run()方法被执行的过程中，FutureTask处于已启动状态。</p><p>3）已完成。FutureTask.run()方法执行完后正常结束，或被取消（FutureTask.cancel（…）），或执行FutureTask.run()方法时抛出异常而异常结束，FutureTask处于已完成状态。</p><ul><li><p>使用FutureTask.get()方法的几种结果</p><ul><li>当FutureTask处于未启动或已启动状态时，执行FutureTask.get()方法将导致调用线程阻塞</li><li>当FutureTask处于已完成状态时，执行FutureTask.get()方法将导致调用线程立即返回结果或抛出异常。</li></ul></li><li><p>使用FutureTask.cancel()方法的几种结果</p><ul><li>当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将导致此任务永远不会被执行；</li><li>当FutureTask处于已启动状态时，执行FutureTask.cancel（true）方法将以中断执行此任务线程的方式来试图停止任务；</li><li>当FutureTask处于已启动状态时，执行FutureTask.cancel（false）方法将不会对正在执行此任务的线程产生影响（让正在执行的任务的线程正常运行完成）；</li><li>当FutureTask处于已完成状态时，执行FutureTask.cancel（…）方法将返回false。</li></ul></li><li><p>FutureTask的使用示例</p><ul><li><pre><code class="java">public class FutureTaskTest &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        TaskTest task = new TaskTest();        //方式一：放到线程池中执行        Future submit = Executors.newSingleThreadExecutor().submit(task);        System.out.println(submit.get());        //方式二：调用线程直接执行        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(task);        futureTask.run();        System.out.println(futureTask.get());    &#125;    private static class TaskTest implements Callable &#123;        @Override        public String call() throws Exception &#123;            Thread.sleep(5000);            return &quot;Hello world!&quot;;        &#125;    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 两个关键字</span><br><span class="line"></span><br><span class="line">* volatile </span><br><span class="line">  * 保证可见性</span><br><span class="line">    * 可见性是让其他线程可见，现在的处理器都是多核的处理器，多核处理器就有多核CPU，每个CPU理论上可以提供一条线程，多个线程共同修改一个volatile 修饰的共享变量的时候，一旦一个线程拿到修改权限并且修改完之后，会立即把修改后的值过**总线**推送到主存中，此时其他的CPU会一直嗅探总线的数据流通，在**缓存一致性协议**的保障下，他能够嗅探到这条数据的修改，如果自己的缓存行中有这条数据，就会把这条数据置为不可用，当该线程再次用到这条数据的时候，需要在主存中重新读取，并保存到自己缓存行中</span><br><span class="line">    * 关于CPU在嗅探总线的数据流通的时候，它这么知道这个数据就是volatile 修饰的呢？</span><br><span class="line">      * 当一个数据被volatile修饰后，被一个线程修改，并通过总线保存到主存时，它的汇编指令的码会在里面加一个lock关键词，lock指令有两层含义，第一，是将信息的修改推送到主存；第二，lock指令过总线的时候其他CPU会嗅探含有lock的指令，然后置其他缓存行为不可用</span><br><span class="line">  * 禁止指令重排序</span><br><span class="line">    * volatile写之前加入storestore屏障，表示上面的普通写和volatile写不能重排序</span><br><span class="line">    * volatile写之后加入storeload屏障，表示下面的volatile读写和volatile写不能重排序</span><br><span class="line">    * volatile读之后加入loadload屏障，表示下面的普通读和volatile读不能重排序</span><br><span class="line">    * volatile读之后加入loadstore屏障，表示下面的普通写和volatile读不能重排序</span><br><span class="line">  * 在特殊情况下还能保证原子性</span><br><span class="line">    * 比如volatile修饰的变量i，进行i++操作的时候，就不能保证原子性，因为i++有三条JVM指令字节码。第一条，i load读取i这个变量；第二条，i add进行加一的操作；第三条，i store然后把相加后结果写回。所以被volatile修饰的变量是单条JVM指令字节码的时候就可以保证原子性，而volatile修饰的变量是多条JVM指令字节码的时候就不能保证原子性</span><br><span class="line">* synchronized</span><br><span class="line">  * 三种使用方式</span><br><span class="line">    * 作用到代码块上(锁可以是Object类型的成员变量，也可以使用this作为锁)</span><br><span class="line">    * 多用在静态方法上(锁是当前的Class，因为静态方法在调用的时候是 类.方法 的形式进行调用，不需要创建对象，所以只能使用当前类的Class作为锁)</span><br><span class="line">    * 作用到普通方法上(锁是当前的类的对象)</span><br><span class="line">  * 有一个Student类，其中有一个int类型的成员变量，同时提供set和get方法。给int变量加上volatile修饰可以保证原子性，因为set和get都是对应单条JVM字节码指令；不给int变量加上volatile进行修饰，而是给get和set方法加上synchronized也可以保证原子性</span><br><span class="line">    * 如果此时get操作多，set操作少，即读多写少的场景，volatile的方法更快，因为如果不对volatile修饰的变量进行修改，那么每个线程可以直接从线程的缓存行里面直接拿到</span><br><span class="line">    * 如果此时get操作少，set操作多，即读少写多的场景，这个时候volatile就慢了，此时volatile修饰的变量一直修改，一直过总线写到主存中，其他的CPU一直在嗅探总线，一直把自己缓存行的数据置为不可用，每次都要透过总线从主存中拉取最新数据，严重损耗计算机的总线资源，synchronized这是就比较快了，因为写比较多，一个线程写的时候其他线程处于BLOCK状态，对于set方法来说处理器执行的是非常快的，也就是其他线程BLOCK的时间会非常短，*重量级锁可以提高程序的吞吐量*</span><br><span class="line"></span><br><span class="line">#### Lock</span><br><span class="line"></span><br><span class="line">*lock相关的问题比较繁杂，所以要找到一个好的切入点进行总结，先从lock和synchronized的区别切入*</span><br><span class="line"></span><br><span class="line">##### 区别</span><br><span class="line"></span><br><span class="line">* synchronized是一个关键字，lock是一个接口，使用lock的话需要new出其子类来</span><br><span class="line">  - lock接口中的方法</span><br><span class="line">    - lock()方法：加锁</span><br><span class="line">    - unlock()方法：锁释放</span><br><span class="line">    - tryLock()方法：可以非阻塞的进行加锁</span><br><span class="line">    - tryLock(long time , TimeUnit unit)方法：可以超时性的非阻塞式加锁</span><br><span class="line">    - lockInterruptibly()方法：可中断式加锁</span><br><span class="line">    - newCondition()方法：配合实现等待通知机制</span><br><span class="line">  - 常用的实现子类是ReentrantLock和ReentrantReadWriteLock</span><br><span class="line">* synchronized是隐式加锁，lock是显式加锁</span><br><span class="line">  - synchronized肉眼看不到加锁和解锁的过程，lock一定要在finally代码块中释放锁</span><br><span class="line">* synchronized可以作用到方法和代码块上，lock只能作用到代码块上</span><br><span class="line">  - synchronized三种加锁方式</span><br><span class="line">    - 加到静态方法上使用的当前类的Class</span><br><span class="line">    - 加到普通方法上使用的当前类的对象</span><br><span class="line">    - 加到代码块上可以用this关键字，也可以new一个Object对象</span><br><span class="line">    - lock加锁就不用多说了，只能加在代码块上，同时别忘了进行锁的释放</span><br><span class="line">  - synchronized作用到代码块上和作用到方法上，使用javap命令反编译成字节码指令有什么区别</span><br><span class="line">    - synchronized作用到代码块上反编译之后，在代码块进入的点有一个monitorenter指令，在代码块出的点有一个monitorexit指令，而且monitorexit这个指令最少要有两个，一个是正常出代码块释放锁，一个是发生异常释放锁</span><br><span class="line">    - synchronized作用到方法上会在方法的flag上加一个acc_synchronized，**后续学完JVM进行详细补充**</span><br><span class="line">* lock支持非阻塞式加锁</span><br><span class="line">  - lock接口中有两个关于非阻塞式加锁的方法，tryLock()方法和tryLock(long time , TimeUnit unit)方法，如果尝试获加锁失败直接返回，不会阻塞线程，那么线程就不会从用户态转为内核态，少一次线程上下文切换</span><br><span class="line">* lock支持可超时性加锁</span><br><span class="line">  - tryLock(long time , TimeUnit unit)方法可以超时性加锁，一定时间内尝试加锁失败了，直接返回，是一个避免发生死锁的好办法</span><br><span class="line">* lock支持可中断式加锁</span><br><span class="line">  - 可中断的意思是一个线程在运行的时候，另一个线程想要对这个线程进行中断，lock中的lockInterruptibly()方法可以接受这种中断，synchronized做不到这一点</span><br><span class="line">* synchronized采用对象监视器，lock采用AQS</span><br><span class="line">  - 两个线程竞争一个synchronized锁，一条线程竞争成功，另一条线程竞争失败进入到ObjectMonitor中的EntryList(同步队列)，等到当前执行线程释放锁，被唤醒以后才重新进入到锁的竞争，但是当前执行线程调用了wait方法释放锁以后，会进入到ObjectMonitor中的WaitSet(等待队列)中</span><br><span class="line">  - AQS根据一个int类型的state变量，来确定这个锁有没有被获取，如果被获取则会加入到AQS双端队列的尾部，这里注意此时有可能是大量的线程同时竞争锁失败，然后同时放到双端队列的尾部，此时就会有线程安全的问题，这里采用的CAS的方式来保证进入双端队列尾部的线程安全，当获取锁的线程执行完成释放锁的时候，会通知自己的后继节点进行锁的竞争</span><br><span class="line">* 在加锁和解锁时，synchronized有一个同步队列和一个等待队列，lock有一个同步队列和多个等待队列</span><br><span class="line">  - lock可以new出多个Condition，一个Condition就有一个等待队列</span><br><span class="line">* 锁竞争方面，synchronized只支持非公平锁，lock支持非公平锁和公平锁</span><br><span class="line">  - 到底什么叫公平，什么叫非公平(场景举例)</span><br><span class="line">    - 假设此时有A,B,C三条线程对lock锁进行竞争，A线程获取到锁了，B,C线程要依次进入到双端队列中进行等待，当A线程执行完成释放锁，唤醒B线程进行锁的竞争时，此时又来了另外十条线程竞争这个lock，如果B和这十条线程进行锁的竞争那么就是不公平，因为B线程已经在队列中排队等待了很久了，如果B不用和新来的线程竞争(新来的十条线程在CAS的保证下直接加入到双端队列的尾端)那么就是公平的</span><br><span class="line">  - 新来的十条线程怎么知道这是一个公平锁，并且加入到队列的？</span><br><span class="line">    - 新来的线程对于公平锁的竞争之前，会进行一个判断，就是判断自己是否有前置节点，如果没有就进入到队列排队，但是对于非公平锁的竞争就不会有这个判断</span><br><span class="line">  - 非公平锁的线程饥饿问题？</span><br><span class="line">    - 一条线程在竞争失败后进入到等待队列进行等待，下一次再次失败再次等待，如此反复线程一直处于等待状态，这就叫做线程饥饿</span><br><span class="line">* 对于等待唤醒机制，synchronized与Object进行配合，lock与Condition接口进行配合</span><br><span class="line">  * synchronized与Object的wait/notify进行配合</span><br><span class="line">  * lock与Condition接口await和signal进行配合</span><br><span class="line">    - 拿到lock锁的线程，调用await方法时，就会进入到Condition的等待队列的尾节点中，**不需要使用CAS直接加就行**，因为线程在调用await方法之前先回把自己加入到等待队列的尾部，正因为此时还没有调用await方法，线程还持有着锁，所以进入到尾节点的时候不用CAS</span><br><span class="line">  * 调用await方法之后，这个线程经历了什么？</span><br><span class="line">    - 拿到lock锁的线程，调用await方法时，就会进入到Condition的等待队列的尾节点中，当他达到队列的头部时会被唤醒，此时这条线程会重新竞争lock锁，一旦竞争失败会使用CAS加入到同步队列的尾端，排队到同步队列的头部，直到他的前置节点线程释放锁以后，根据是否是公平锁重新竞争，竞争失败继续等待，竞争成功继续执行完await后面的逻辑</span><br><span class="line">* lock锁可以根据需要进行个性化开发 </span><br><span class="line">* ReentrantReadWriteLock支持并发读</span><br><span class="line">  * 读-读可以并发执行，读-写，写-读，写-写 都不可以并发执行</span><br><span class="line">  * 通过一个int类型的state变量来控制读写权限，他把一个32位的int变量分成高16位和低16位，高16位负责控制读，低16位负责控制写。当一个读线程来的时候会检查低16，如果低16位为0说明没有写线程，直接对高16位加一，然后进行读取，如果有写线程那么就会被阻塞。当一个写线程来的时候会检查高16位和低16位，此时不管是有写还是有读直接被阻塞，这是ReadWriteLock的加锁细节。如果是ReentrantReadWriteLock(表示可重入读写锁)的话，加读锁的时候，如果低16位不为0，会先判断持有写锁的线程是不是当前线程，如果是也会在高16位加一，加写锁的时候，如果低16位和高16位都不为0，此时会先判断持有这些锁的线程是不是当前线程，如果是则会在低16位加一</span><br><span class="line"></span><br><span class="line">#### 锁升级</span><br><span class="line"></span><br><span class="line">*背景：32位JVM虚拟机*</span><br><span class="line"></span><br><span class="line">* 无锁状态</span><br><span class="line"></span><br><span class="line">  - 当我们新创建一个对象的时候，它的对象头MarkWord里有25位的HashCode，4位的对象分代年龄，1位的偏向锁标记位，2位的锁标记位</span><br><span class="line">  - **当我们仅仅只是用new关键字创建一个对象的时候，此时如果没有显式/隐式的调用Object里面的hashCode方法，那么hashCode的值不会存储在对象头中**，此时的占位是0</span><br><span class="line">    - 显示调用hashCode：比如在类的构造器中直接调用super.hashCode()方法，这样我们对象头的MarkWord中是有hashCode的</span><br><span class="line">    - 隐式调用hashCode：比如在构造函数中，对象创建完毕的一瞬间直接把该对象放入到了HashMap，HashSet这样的类Hash集合中，因为put方法的第一个参数就是哈希值，这个哈希值就是靠调用Object类的hashCode方法得到的</span><br><span class="line">    - 如果该类重写了hashCode方法，然后在对象的创建过程中调用了重写以后的hashCode方法，那么同样不会把hashCode的值存放到对象头的MarkWord中，**必须调用父类的hashCode方法才会把值存到对象头的MarkWord中**</span><br><span class="line">  - 对于分代年龄，此时由于对象刚刚创建，没有分代年龄，所以还是以0表示</span><br><span class="line">  - 对于锁标记位，无锁状态和偏向锁状态的锁标记位都是01，他们的区别在于偏向锁标记位，无锁的偏向锁标记位是0，偏向锁状态的偏向锁标记位是1</span><br><span class="line"></span><br><span class="line">* 无锁状态升级为偏向锁</span><br><span class="line"></span><br><span class="line">  - 无锁状态想要升级位偏向锁状态，此时**对象头的MarkWord中必须不能有hashCode值**，理论上hashCode这个位置要保存上23位的线程ID和2位的Epoch，但是如果这个位置有hashCode的值就会对这个值进行覆盖，因为hashCode值没有替换这个逻辑也无法对这个值进行保存，所以这个行为是不允许的，所以此时就不能成为偏向锁</span><br><span class="line">  - 如果想要成为偏向锁的对象的对象头的MarkWord没有存放hashCode值，此时就可以把线程ID放到前23位，Epoch的值放到后2位，偏向锁标记位从0变成1，锁标记位还是01不变</span><br><span class="line">  - 偏向锁的好处在于，当一个线程想要再次获取锁，可以直接检查一下MarkWord里面保存的线程ID是不是当前线程的ID，如果是那么直接加锁成功，性能会有所提升</span><br><span class="line"></span><br><span class="line">* 偏向锁升级为轻量级锁</span><br><span class="line"></span><br><span class="line">  - 发生线程竞争的时候偏向锁一定会升级为轻量级锁吗？</span><br><span class="line">  - 偏向锁升级为轻量级锁发生了线程的竞争这句话是对的，但是反过来说就不一定对了，例如下面加粗斜体的例子，虽然有线程的竞争但是锁的偏向发生了改变但是没有升级为轻量级锁</span><br><span class="line">  - 偏向锁升级为轻量级锁的过程：***加入A线程获取到了偏向锁把自己的线程ID存放到MarkWord中，此时又来了一个B线程也想要获取偏向锁，他会先检查锁标记状态是不是01，偏向锁标记位是不是1，如果锁标记位是01，且偏向锁标记位是1，那么线程B就知道此时这个锁已经有线程偏向了，这时线程B会检查线程A的线程存活状态，如果此时A线程没有在执行同步代码，那么B线程会直接把这个偏向锁置为无锁状态，然后去竞争这个偏向锁，如果竞争成功则把自己的线程ID放入到MarkWord当中，此时偏向锁就偏向B线程了***，但是如果线程B争抢失败了，线程C争抢成功了，把线程C的ID存放到了MarkWord中并执行线程C对应的代码，这是时候线程B就很烦，他会执行一个更加高级的操作，叫做**偏向锁的撤销**，线程B会等待线程C执行到JVM安全点，对线程C的栈进行遍历，遍历的是锁记录，遍历完成可能会有三种情况</span><br><span class="line">  - 可能会直接把锁的状态变为无锁状态，然后把锁标记位置为00，即轻量级锁</span><br><span class="line">    - 这个地方可以理解为锁从偏向锁直接升级为轻量级锁，所谓把锁的状态变为无锁状态就是把锁标记位置为00，并且把偏向线程ID和Epoch置为空，偏向锁标记位是0。之所以上面说把锁的状态变为无锁状态，是因为真正的轻量级锁的对象头应该除了2位的锁标记位之外，其余的30位都应该指向栈帧中锁记录的指针，但是此时的状态比较**游离**，暂且理解为无锁状态</span><br><span class="line">  - ***可能会把偏向锁重新偏向到线程B***</span><br><span class="line">    - JVM除了有开启偏向锁的配置之外，还有批量重偏向和批量撤销的操作。场景举例：比如有一个Student类，然后这个Student类创建了40个对象，线程A把这四十个对象进行偏向锁的加锁操作，然后线程A一直对这四十个对象保持代码的执行，此时来了个线程B，**线程B要对这四十个对象进行锁撤销的操作**，此时这1-19个对象直接升级为轻量级锁也就是上面所说的游离状态，当执行到第20个对象时，JVM就会反思自己是不是最开始的时候偏向错了，然后就把后面的20-39个对象批量重偏向到线程B，因为JVM里有配置批量偏向锁的阈值是20，但是当线程B撤销到第40个对象的时候，此时已经有20个对象偏向给线程B了，线程B还在继续要求偏向，JVM又不高兴了，既然这个对象的竞争这么激烈那么你就不适合作为偏向锁，然后直接把这个对象置为不可使用偏向锁</span><br><span class="line">    - 可能会把该锁直接置为不可使用偏向锁</span><br><span class="line">      - 书接上文，至于置为不可使用偏向锁体现在new出第41个student对象的时候，此时该对象的对象头的MarkWord的锁标记位直接就是00，其实JVM这个地方还有一个默认参数，也就是两万五千毫秒，如果25秒以内批量撤销没有达到40这个阈值，那么从20-39的这个重偏向可以重新计数，**也就是说25秒内批量撤销没有达到阈值，那么此时就不会发生置为不可使用偏向锁这一状态**</span><br><span class="line"></span><br><span class="line">* 轻量级锁record</span><br><span class="line"></span><br><span class="line">  - 竞争过程：假设此时多条线程竞争时，如果A线程竞争成功了，A线程会直接把锁对象头里的MarkWord里面的25位hashCode，4位的分代年龄和1位的偏向锁标记，这30位的内容复制到A线程的栈帧中的一个叫做lockRecord即锁记录中，然后把对象头的MarkWord中对应的30位的位置放上一个指向当前线程栈帧中lockRecord这块区域的一个指针，当B线程来竞争轻量级锁的时候，他会使用CAS的方式把锁对象头对应位置的内容放到自己栈帧的lockRecord中，此时肯定是失败的，因为锁对象头本来该存放的hashCode，分代年龄等内容已经被替换成了指针了，此时B线程会进行一个CAS的自旋，再次尝试替换，默认循环十次，如果这十次还没有成功，那么轻量级锁将会升级为重量级锁</span><br><span class="line">  - 轻量级锁升级为重量级锁： 自旋十次没有成功的B线程，会把原本指向A线程中栈帧的lockRecord的指针替换为指向重量级锁的指针即ObjectMonitor，此时线程A执行完对应代码要使用CAS进行锁的释放时，会发现此时锁对象头内的指针已经不是轻量级锁的指针了，已经变成了重量级锁的指针了，所以这个时候他就知道要进行重量级锁解锁的过程了</span><br><span class="line">  - 重量级锁解锁的过程：线程A会先把栈帧中lockRecord记录的hashcode，分代年龄等内容保存到ObjectMonitor的header属性中保证这些内容不丢失，然后把ObjectMonitor的owner属性保存成自己</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 双重检查锁</span><br><span class="line"></span><br><span class="line">*双重检查锁是基于单例模式的两次改造，第一次改造实是在synchronized同步代码块的外边，加一个判空处理，减少一些线程对于锁的竞争而变为阻塞状态，导致从用户态转化为内核态对于资源的消耗，这样会导致一些问题，因为在new对象的时候有三个步骤，第一，开辟一块内存空间，第二，初始化对象，第三，把instance指向这片内存空间，此时如果不用volatile修饰的话，可能会导致第二步和第三步发生指令重排序，在多线程的情况下其他线程访问到判空处理那一步时，他只会关心这个instance是否有指向，所以此时他会认为instance已经初始化好了，导致得到一个错误的结果*</span><br><span class="line"></span><br><span class="line">***加上volatile修饰的话会导致第二步和第三步不会发生重排序***，这句话是错误的！！！！！！！！！！！</span><br><span class="line"></span><br><span class="line">因为当我们new一个对象的时候，new是写在我们Java代码里面的，new这个关键词对应的JVM字节码指令也是new，volatile作为Java中的一个关键词，他做的添加屏障只能做到JVM字节码指令这个级别，它无法涉及到new这个关键词带来的更加底层的操作，也就是创建对象的那三步操作，这就像lock锁锁住了三行代码，在这三行代码执行结束前其他的线程进不来，而volatile就像是包住了new的这个过程保证了创建对象结束前其他线程进不来，从而保证线程安全</span><br><span class="line"></span><br><span class="line">#### 线程状态转化</span><br><span class="line"></span><br><span class="line">*new 一个线程出来进入new状态，然后调用start方法进入runnable状态，在runnable状态下调用join，wait，park方法会进入waiting状态，调用sleep，wait(long)等方法会进入到timed_waiting状态，加锁失败的话会进入到blocked状态，最后是线程的TERMINATED终止状态，在Java的Thread类中的state内部枚举类中只有这六种状态*</span><br><span class="line"></span><br><span class="line">**网上说的七种状态区别在于把runnable状态分成了running状态和ready状态，在running状态的线程调用了yield方法会进入到ready状态，此时放弃了CPU的执行权**</span><br><span class="line"></span><br><span class="line">* NEW状态</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">/**</span><br><span class="line"> * Thread state for a thread which has not yet started.</span><br><span class="line"> */</span><br><span class="line">NEW</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>线程还没有开始的状态，也就是说还没有调用start方法</p><ul><li>RUNNABLE状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment"> * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment"> * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment"> * such as processor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RUNNABLE</span><br></pre></td></tr></table></figure><p>在JVM中线程已经开始了，但会因为其他的一些调用进入到waiting状态</p><ul><li>WAITING状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment"> * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment"> * following methods:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment"> * perform a particular action.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WAITING</span><br></pre></td></tr></table></figure><p>在调用wait，join，park方法后会进入到waiting状态，调用notify，unpark等方法会使线程从waiting状态切换到runnable状态</p><ul><li>TIMED_WAITING状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment"> * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment"> * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TIMED_WAITING</span><br></pre></td></tr></table></figure><p>在调用sleep，wait(long)，join，parkNanos，parkUntil这些方法后会进入到TIMED_WAITING状态</p><ul><li>BLOCKED状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment"> * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment"> * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment"> * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BLOCKED</span><br></pre></td></tr></table></figure><p>只有在synchronized代码块或者synchronized修饰的方法的范围内才有可能进入到BLOCKED状态</p><ul><li>TERMINATED状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment"> * The thread has completed execution.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TERMINATED</span><br></pre></td></tr></table></figure><p>线程运行完毕，执行结束</p><ul><li>锁释放(使用join来说明)</li></ul><p>join方法底层也调用了wait方法，但是很多博客文章上说调用join方法不会释放锁，他会释放锁，但是他释放的是调用join方法的线程对应的对象的锁，举个例子，在synchronized(Object obj)代码块里面创建一个thread1线程，然后thread1线程调用join方法，此时释放的不是obj这个对象锁，而是thread1线程自身对象的Object Monitor锁</p><ul><li>waiting和timed_waiting的区别</li></ul><p>time_waiting状态不用唤醒，等时间到了以后自动执行后续代码，waiting状态需要显式或者隐式的唤醒，显式唤醒就是通过调用wait或者park方法进入waiting状态，通过调用notify或者unpark方法进行唤醒，隐式唤醒就是通过调用join方法，等到其他线程执行结束后会在线程内部接收到一条消息，然后执行后面的代码</p><ul><li>有了waiting和timed_waiting这两种状态为什么还要一个blocked状态</li></ul><p>线程在竞争锁失败后会进到EntryList同步队列，线程状态变为blocked状态，线程在调用wait方法进入到WaitSet等待队列，线程进入到waiting状态，当waiting状态被唤醒时会重新进行锁的竞争，此时如果竞争失败，那么会进入到EntryList同步队列，状态变位block，所以此时状态和队列进行了一个对应，为了把不同的线程状态进行一个更加细致的划分</p><h3 id="并发编程重点问题"><a href="#并发编程重点问题" class="headerlink" title="并发编程重点问题"></a>并发编程重点问题</h3><ul><li><p>进程和线程的区别</p><ul><li>进程是系统进行资源分配和调度的基本单位，线程是进程的一个执行路径，一个进程最少有一个线程，进程中的每个线程共享进程中的资源</li><li>操作系统分配资源的时候是分配给进程的，而CPU分配资源是分配给线程的，真正占用CPU的是线程，所以说线程是CPU分配的基本单位</li><li>一个进程中的多个线程共享进程的堆和方法区的资源，每个线程有自己的程序计数器和栈区域</li></ul></li><li><p>为什么将程序计数器设为线程私有的区域</p><ul><li>程序计数器记录线程当前要执行的指令地址，因为线程在用时间片轮转的方式的占用CPU，当前时间片用完后下次再次继续执行的时候，需要从线程私有的程序计数器这个内存区域拿到指定地址继续执行，如果要执行的是native方法那么程序计数器记录的undefined地址，只有要执行的是Java代码程序计数器记录的才是下一条指令的地址</li></ul></li><li><p>局部变量，对象实例，JVM加载的类，常量及静态常量都存在主存的哪个部分，是线程私有的吗？</p><ul><li>每个线程有自己的栈资源，该栈用于存储线程的局部变量，局部变量是线程私有的，除了局部变量，栈还可以用来存放线程的调用栈帧</li><li>new操作创建的实例对象存放在堆中，堆是进程在创建的时候分配的，是进程中最大的一块内存，所有线程可以共享</li><li>JVM加载的类，常量和静态常量放在方法区，也是线程共享的</li></ul></li><li><p>继承Thread类实现多线程的优劣</p><ul><li>好处：在run()方法中，想要获取当前线程的时候直接this就可以，不用Thread.currentThread()方法</li><li>坏处：Java不支持多继承，如果继承了Thread类就无法在继承其他的类了。</li></ul></li><li><p>IllegalMonitorStateException出现的原因</p><ul><li>调用wait()方法之前没有获得该对象的监视器锁</li></ul></li><li><p>什么是虚假唤醒，如何避免</p><ul><li><p>虚假唤醒指的是，一条线程在没有被其他线程调用notify(),notifyAll()方法进行通知，也没有被中断，也没有等待超时，这时如果还被唤醒那么就是虚假唤醒</p></li><li><p>可以在while循环中调用wait方法来防止虚假唤醒，只有满足while中条件才可以退出循环详见以下伪代码</p><ul><li><pre><code class="java">synchronized(obj)&#123;    while(条件不成立)&#123;        obj.wait();    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 调用共享对象的notify()方法后，会唤醒一个在该共享变量上调用wait的线程，这两个线程对于锁获取和释放的过程</span><br><span class="line"></span><br><span class="line">  - 首先一个线程一定是在拿到共享变量锁之后才能调用wait方法，调用wait方法后该线程会先释放锁，进入到WaitSet队列中进行等待，然后另外一条线程拿到该共享对象的锁，调用了notify方法唤醒了在队列中等待的线程，等到该线程释放了锁以后，被唤醒的线程会重新进行该共享对象的锁的竞争，只有竞争到锁后才能继续执行后序代码</span><br><span class="line"></span><br><span class="line">* join()方法和yeild()方法</span><br><span class="line"></span><br><span class="line">  - join方法的使用场景在需要多个线程同时完成某个事情的时候才继续向下执行，比如多个线程同时加载同一个资源，使用join方法可以等到所有线程完成后进行汇总处理，join方法底层就是使用了while循环和wait方法实习无限等待和带时间参数的等待</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      //join方法源码</span><br><span class="line">      public final synchronized void join(long millis)</span><br><span class="line">          throws InterruptedException &#123;</span><br><span class="line">              long base = System.currentTimeMillis();</span><br><span class="line">              long now = 0;</span><br><span class="line">      </span><br><span class="line">              if (millis &lt; 0) &#123;</span><br><span class="line">                  throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">      </span><br><span class="line">              if (millis == 0) &#123;</span><br><span class="line">                  while (isAlive()) &#123;</span><br><span class="line">                      wait(0);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  while (isAlive()) &#123;</span><br><span class="line">                      long delay = millis - now;</span><br><span class="line">                      if (delay &lt;= 0) &#123;</span><br><span class="line">                          break;</span><br><span class="line">                      &#125;</span><br><span class="line">                      wait(delay);</span><br><span class="line">                      now = System.currentTimeMillis() - base;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>线程的执行需要操作系统分配时间片来轮询占用CPU，正常情况下当时间片用完后，线程调度器会进行下一轮线程调度，而调用了yeild方法，表示线程告诉线程调度器虽然现在分配的时间片还没用完，但是此时可以进行下一轮的线程调度了，此时该线程让出CPU的使用权，线程计数器可以从就绪队列中找出一个优先级最高的线程执行</p></li></ul></li><li><p>sleep()方法和yeild()方法的区别</p><ul><li>调用了sleep方法的线程处于阻塞状态，且线程调度器在指定时间内不会调度该线程</li><li>调用了yeild方法的线程处于就绪状态，如果该线程的优先级较高线程调度器可能下一次调度仍然调度到当前线程执行</li></ul></li><li><p>interrupt(),isInterrupted()和interrupted()的特点和区别</p><ul><li>interrupt方法表示中断线程，例如线程A正在执行，线程B调用线程A的interrupt方法，会使线程A的线程中断标记为true，但是此时的线程不会真正中断，还需继续向下执行后面的代码，如果线程A调用了wait，sleep，join方法挂起阻塞，此时线程B还调用线程A的interrupt方法，就会在调用方法的地方抛出InterruptedExpection</li><li>isInterrupted方法用于判断某个线程是否被中断，如果被中断返回true，没有被中断返回false</li><li>interrupted方法也是用于判断某个线程是否被中断，如果被中断返回true，没有被中断返回false，与isInterrupted不同的是调用interrupted方法后发现线程已被中断，那么此时会清除中断标记，并且interrupted是static方法；interrupted调用的是currentThread()的native方法isInterrupted，而isInterrupted调用的是实例对象的native方法，其中native方法的传参如果是true表示清除中断标志，是false表示不清除中断标志</li></ul></li><li><p>什么是死锁</p><ul><li>死锁是两个或两个以上的线程在执行过程中，为了获取某一资源而相互等待的现象，在无外力帮助的情况下会一直等待下去无法继续运行，例如线程A持有资源1，想要资源2，线程B持有资源2，想要资源1，两个线程都在等待其他线程已经持有的资源就会一直等待下去处于死锁状态</li></ul></li><li><p>线程发生死锁的条件</p><ul><li><p>资源具有排他性，即资源在同一时刻只能由一条线程持有，另外的线程想要持有必须等待到当前线程释放该资源</p></li><li><p>持有某个资源的线程，想要获取其他被持有的资源的时候，进行等待，但此时该线程在阻塞期间不会释放原有的资源</p></li><li><p>持有的资源只能由自己使用完后释放，释放前其他线程不能抢占</p></li><li><p>发生死锁时，一定会有一条 线程 &#x3D;&gt; 资源的环形链，例如 T0线程 &#x3D;》T1线程占用的资源 &#x3D;》T2线程占有的资源。。。。&#x3D;》 Tn线程占有的资源 &#x3D;》 T0线程占有的资源</p><ul><li><p>类似伪代码</p></li><li><pre><code class="java">//线程A重写的run方法synchronized(A)&#123;    sleep(1000);    synchronized(B)&#123;        //do something    &#125;&#125;//线程B重写的run方法synchronized(B)&#123;    sleep(1000);    synchronized(A)&#123;        //do something    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 如何避免死锁</span><br><span class="line"></span><br><span class="line">  - 要想避免死锁，只需破环形成死锁的四个条件中的至少一个条件，我们人为能进行破坏的只有第二条和第四条，破环的方法都是调整资源的访问顺序，保证资源获取的有序性。*所谓有序性，就是假如线程A，B都需要1，2，3....n这些资源，那么获取到资源n条件是已经获取了n-1这个资源*</span><br><span class="line"></span><br><span class="line">    - 以上代码进行如下优化，就会谦让有序不会发生死锁</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      //线程A重写的run方法</span><br><span class="line">      synchronized(A)&#123;</span><br><span class="line">          sleep(1000);</span><br><span class="line">          synchronized(B)&#123;</span><br><span class="line">              //do something</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //线程B重写的run方法</span><br><span class="line">      synchronized(A)&#123;</span><br><span class="line">          sleep(1000);</span><br><span class="line">          synchronized(B)&#123;</span><br><span class="line">              //do something</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li><li><p>对ThreadLocal的了解</p><ul><li>ThreadLocal是JDK包提供的，它提供的是每个线程的本地变量，也就是创建一个ThreadLocal变量以后，当有线程访问这个变量的时候都会有这个变量的本地副本，当多个线程对同一个变量进行操作的时候其实操作的是自己本地内存中的变量，可以避免线程安全问题。即创建ThreadLocal变量后，每个线程都会复制一个变量到自己的本地内存中</li></ul></li><li><p>ThreadLocal的原理</p><ul><li>Thread类中维护了两个ThreadLocalMap类型的变量，一个叫做threadLocals，一个叫做inheritableThreadLocals(下图1)，默认情况下这两个的值都为null，只有当该线程第一次调用ThreadLocal的set或get方法的时候才会创建他们，其实每个线程的本地变量不是存在ThreadLocal中的，而是存在threadLocals这个变量中的，ThreadLocal其实就是一个工具壳，它通过set方法把值存放到调用方法线程的threadLocals变量中，调用get方法再从当前线程的threadLocals变量中拿出来使用(如图2)，如果调用线程一直不终止那么这个本地变量就只存在当前线程的threadLocals中，之所以threadLocals的类型是ThreadLocalMap类型，是因为一个线程可以关联多个ThreadLocal变量(如图3)<ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231010225027854.png" class title="image-20231010225027854"></li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231010225102302.png" class title="image-20231010225102302"></li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231010225251621.png" class title="image-20231010225251621"></li></ul></li></ul></li></ul><ul><li><p>关于ThreadLocal的set方法</p><ul><li>set方法先是获取到当前线程，通过当前线程得到threadLocals这个成员变量，如果这个threadLocals不为null，那么就以this作为key，this代表当前对象，要set的值作为value，放到threadLocals这个map中，如果threadLocals为空，那么就调用cteateMap方法以当前线程为key，要set的值为value新建一个threadLocals对象<ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231012224747251.png" class title="image-20231012224747251"></li><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231012224757298.png" class title="image-20231012224757298"></li></ul></li></ul></li><li><p>ThreadLocal支持继承吗</p><ul><li>对于同一个ThreadLocal变量，父线程set的值，子线程是get不到的，因为父线程在set时候村的key是父线程，而子线程在get的时候是以当前线程作为key来获取的threadLocals，所以自然获取不到</li></ul></li><li><p>如何让子线程访问到父线程的ThreadLocal中的值</p><ul><li>可以使用InheritableThreadLocal，InheritableThreadLocal继承自ThreadLocal，同时重写了getMap，createMap，childValue方法，这个类的作用就是为了让父线程设置的本地变量子线程可以访问到，主要就是在Thread类的init方法，父线程在构造子线程的时候，先判断出父类的inheritableThreadLocals这个成员变量是否为空，如果不为空就把父线程中的inheritableThreadLocals这个变量复制一份保存到子线程的inheritableThreadLocals这个成员变量中</li></ul></li><li><p>InheritableThreadLocal的使用场景</p><ul><li>例如子线程需要访问父线程存放到ThreadLocal中的用户登录信息，其实子线程想要获取到父线程的信息还有其他的方式，例如在创建子线程的时候传入父线程的变量复制到子线程中，或者在父线程中构造一个map作为参数传递给子线程，但是这些方法违背了我们使用的习惯，这时InheritableThreadLocal类就显得很关键</li></ul></li><li><p>程序CPU100%，内存和IO利用率都正常，是什么原因，如何排查</p><ul><li>有可能发生死锁，通过java程序的进程ID，使用jstack命令dump出线程文件，查看所有线程处于什么状态，看看是否存在处于BLOCKED状态的线程</li></ul></li><li><p>volatile如何保证可见性</p><ul><li>被volatile修饰的变量在进行写操作的时候，会多出一个lock汇编代码，有了lock前缀在多核处理器会发生两件事，第一件事是将当前处理器缓存行的数据写回到系统内存，第二件事是其他CPU缓存该内存地址的数据置为无效，在多核处理器下，为了保证每个处理器的缓存是一致的，会实现缓存一致性协议，每个处理器在嗅探总线上的传输的数据检查自己缓存的数据是不是过期了，当发现缓存行对应的内存地址发生的修改，那么就会置该缓存行的数据为无效，当处理器再次对该数据进行修改操作的时候会重新从系统内存中重新读取数据保存到处理器缓存行中</li></ul></li><li><p>synchonized关键字的三种使用方式</p><ul><li>用在同步代码块上，此时锁是括号里面配置的对象</li><li>用在普通方法上，此时锁是当前实例对象</li><li>用在静态方法上，此时锁是当前类的Class对象</li></ul><p>当一个线程试图访问同步代码块的时候，必须要先获取到锁，在退出或者出现异常的时候必须释放锁</p></li><li><p>synchonized在JVM的实现原理</p><ul><li>JVM是基于进入和退出Monitor对象来实现同步方法和同步代码块，二者的实现细节略有不同<ul><li>对于同步代码块来说，在编译后会在进入同步代码块之前会加一个monitorenter指令，在同步代码块结束退出或者发生异常的地方monitorexit指令，任何一个对象都有一个monitor与之关联，当monitor被持有后将处于锁定状态，线程执行到monitorenter的时候会尝试获取对应monitor的所有权，即尝试获取对象的锁</li><li>对于同步方法来说，通过反编译得到字节码后可以发现，在方法的flags中多了一个ACC_SYNCHONIZED标志，这会告诉JVM这是一个同步方法</li></ul></li></ul></li><li><p>synchonized锁信息在对象的存储位置</p><ul><li><p>无锁状态</p><ul><li><table><thead><tr><th>锁状态</th><th>25bit</th><th>4bit</th><th>1bit是否是偏向锁</th><th>2bit锁标志位</th></tr></thead><tbody><tr><td>无锁状态</td><td>对象的hashCode</td><td>对象分代年龄</td><td>0</td><td>01</td></tr></tbody></table></li></ul></li><li><p>不同的加锁状态</p><ul><li><img src="/2023/09/20/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20231027113647593.png" class title="image-20231027113647593"></li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构算法笔记</title>
      <link href="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><a href="https://leetcode.cn/problems/binary-search/submissions/">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &gt; target)&#123;</span><br><span class="line">                j = m - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[m] &lt; target)&#123;</span><br><span class="line">                i = m + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[m] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>区间开闭分析<ul><li>左闭右闭<ul><li>此时数组中所有的元素都在查找范围内，所以j的大小应该等于数组最后一个元素的索引大小，所以j &#x3D; nums.length - 1，然后判断while循环条件时，根据数组是否合法来判断是否有等于号。左闭右闭的情况下[1,1]这个数组是合法的所以需要等于号。然后进入循环，当nums[m] &gt; target时，此时要更新原数组的右边界，因为已经判断过nums[m] &gt; target了，所以nums[m]一定不是要查找的数，所以 j &#x3D; m - 1。nums[m] &lt; target的情况同理。</li></ul></li><li>左闭右开<ul><li>此时数组中最后一个元素不在查找范围内，所以j的大小应该等于数组最后一个元素的索引大小，所以j &#x3D; nums.length，然后判断while循环条件时，根据数组是否合法来判断是否有等于号。左闭右开的情况下[1,1)这个数组是不合法的所以不能加等于号。然后进入循环，当nums[m] &gt; target时，此时要更新原数组的右边界，由于右边界是开区间 j 还等于m - 1话，此时数组就少了一个元素，所以j应该等于m，如果nums[m] &lt; target的情况同理。</li></ul></li></ul></li></ul><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素 - 力扣（LeetCode）</a></p><ul><li>暴力解法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val == nums[i])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;j &lt; size;j++)&#123;</span><br><span class="line">                    nums[j-<span class="number">1</span>] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">                i --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接两层for循环，第一层for循环主要遍历整个数组，查找要删除的值，找到要删除的值以后，进入第二层for循环，把当前位置后面的所有元素向前移一位，即覆盖要删除的值，此时要把数组的长度减一，<strong>循环i的值减一</strong>,因为此时的数组相当于目标值之后元素都向前移了一位，如果循环的i不减一，那么就会少校验一个元素</p><ul><li>快慢指针法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="type">int</span> <span class="variable">slowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">quickIndex</span> <span class="operator">=</span> <span class="number">0</span>;quickIndex&lt;nums.length;quickIndex++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(val != nums[quickIndex])&#123;</span><br><span class="line">               nums[slowIndex] = nums[quickIndex];</span><br><span class="line">               slowIndex++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure><p><strong>核心思想</strong>：当快指针找到目标值的时候，快指针移向下一位，没有其他任何操作，当快指针指向的不是目标值的时候，把指向的值赋给慢指针所指的位置</p><p>快指针：要去寻找目标值</p><p>慢指针：始终指向的是当快指针找到目标元素后要覆盖的位置</p><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项 - 力扣（LeetCode）</a></p><p>同样使用快慢指针的思想</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">quickIndex</span> <span class="operator">=</span> <span class="number">1</span>;quickIndex&lt;nums.length;quickIndex++)&#123;</span><br><span class="line">            tmp = nums[slowIndex];</span><br><span class="line">            <span class="keyword">if</span>(tmp != nums[quickIndex])&#123;</span><br><span class="line">                nums[++slowIndex] = nums[quickIndex]; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h3><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            nums[i] *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> res.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[begin] &gt;= nums [end])&#123;</span><br><span class="line">                res[k] = nums[begin];</span><br><span class="line">                begin++;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[k] = nums[end];</span><br><span class="line">                end--;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思路：非递减的有序数组就是一个相等或者递增的数组，之所以平方之后会出现不递增的情况，是因为数组中可能含有负数，所以此时可以发现<strong>平方之后的数组的最大值一定出现的数组的两端</strong>，所以定义两个指针分别指向数组的第一个元素和数组的最后一个元素，遍历整个数组，向新的数组中赋值。</p><h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h3><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums.length + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">real</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">fast</span>  <span class="operator">=</span> <span class="number">0</span>;fast &lt; nums.length;fast++)&#123;</span><br><span class="line">            sum += nums[fast];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                real = fast - slow + <span class="number">1</span>;</span><br><span class="line">                res = Math.min(res,real);</span><br><span class="line">                sum -= nums[slow];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == nums.length + <span class="number">1</span> ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是双指针的思想，通过双指针来卡数组的长度，其中for循环中的fast一定指的是截取数组的末尾，类似于快指针，通过结尾和开始来判断中间的数的和是否大于target，当大于target的时候慢指针才开始移动，直到截取的数组之和小于target时，此时快指针继续向前移动。其中<strong>res的值在最开始定义的时候必须是一个比数组长度大的数字</strong>，如果定义数字小于等于数组的长度，此时如果原数组中所有的数字相加正好等于target的时候，就会出现问题。</p><h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h3><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II - 力扣（LeetCode）</a></p><ul><li>方法一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">startx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">starty</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i , j;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num &lt; n/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = starty;j &lt; n - offset;j++)&#123;</span><br><span class="line">                res[startx][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i = startx;i &lt; n - offset;i++)&#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;j &gt;= offset;j--)&#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;i &gt;= offset; i--)&#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            offset++;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            res[startx][starty] = n*n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遵循左闭右开或者左开右闭的原则，通过i和j循环递增和递减的方式，上边右边下边左边依次填充</p><p>这个方法的难点：为什么要转n&#x2F;2圈？因为n是正方形的边长，可以通过startx和starty发现每一圈起点的规律，每一圈的起点一定是从左上角开始向正方形的中心递进</p><ul><li>方法二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        res[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; n*n)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; n - <span class="number">1</span>&amp;&amp;res[i][j+<span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                res[i][++j] = ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n - <span class="number">1</span>&amp;&amp;res[i+<span class="number">1</span>][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                res[++i][j] = ++count;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span>&amp;&amp;res[i][j-<span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                res[i][--j] = ++count;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &gt; <span class="number">0</span>&amp;&amp;res[i - <span class="number">1</span>][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                res[--i][j] = ++count;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接螺旋写数字，关键在于要在写数字的时候知道什么时候要拐弯，这里的判断方法是判断下一个点的数是不是零和判断到没到边界的前一个点（判断是不是边界用于写第一圈，判断是不是零用于写第二圈），如果是零说明可以写数字，因为矩阵中不可能有零，如果到了边界的前一个点说明拐弯了。</p><h3 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h3><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素 - 力扣（LeetCode）</a></p><ul><li>不使用虚拟头节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; head.val == val) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val == val)&#123;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时要分情况讨论</p><ol><li>头节点的值等于要删除的值</li></ol><p>while (head !&#x3D; null &amp;&amp; head.val &#x3D;&#x3D; val)，此时要循环移动head所对应的节点</p><ol start="2"><li>头节点的值不等于要删除的值</li></ol><p>此时要用一个pre变量记录头节点，来完成接下来的一系列操作，因为最后要求返回的是链表的头节点，同时头节点的值不等于要删除的值，所以head的指向不能改变，用cur记录pre的下一个节点，相当于cur和pre两个指针遍历整个链表</p><ul><li>使用虚拟头节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val == val) &#123;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加虚拟头节点的好处是不需要单独判断头节点是否为要删除的val，核心思路就是把<strong>pre指向虚拟头节点！虚拟头节点！虚拟头节点！</strong>，cur指向头节点，然后让这俩个指针遍历整个链表即可</p><h3 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode()&#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//size存储链表元素的个数</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//虚拟头结点</span></span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取第index个节点的数值，注意index是从0开始的，第0个节点就是头结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//如果index非法，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//包含一个虚拟头节点，所以查找第 index+1 个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentNode.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表最前面插入一个节点，等价于在第0个元素前添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表的最后插入一个节点，等价于在(末尾+1)个元素前添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class="line">    <span class="comment">// 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// 如果 index 大于链表的长度，则返回空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">//找到要插入节点的前驱</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pred</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">toAdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        toAdd.next = pred.next;</span><br><span class="line">        pred.next = toAdd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除第index个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pred</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index ; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pred.next = pred.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典题目，基本包含了包含了链表的所有常见操作，主要想好<strong>在get节点的时候，指针要指向该节点，在增删节点的时候，指针指向的是要增删位置节点的前一个节点</strong></p><p>一个小坑：在增加节点的时候先把新增节点的next指向下一个节点，在将cur指向的节点的next指向新增节点，因为如果cur指向的节点先指向了新增节点，那么新增的节点就找不到next要指向谁了</p><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表 - 力扣（LeetCode）</a></p><ul><li>双指针法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个指针指向头节点的前一个即为null，第二个指针指向头节点，注意遍历到cur为null而不是cur的next为null，因为当cur的next为空的时候，此时cur指向的是原链表的最后一个，此时应该进入循环，tmp指针需要保存的是cur的next，因为如果不保存的话，cur的指向已经发生改变了，下一次循环就找不到cur.next了</p><ul><li>递归写法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reverseList(<span class="literal">null</span>,head);      </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode pre,ListNode cur)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        </span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">        <span class="keyword">return</span> reverseList(pre,cur);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路和双指针一摸一样，注意递归终止的条件是cur为空</p><h3 id="两两交换链表中节点"><a href="#两两交换链表中节点" class="headerlink" title="两两交换链表中节点"></a>两两交换链表中节点</h3><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp1</span> <span class="operator">=</span> cur.next.next;</span><br><span class="line">            cur.next = tmp1;</span><br><span class="line">            tmp.next = tmp1.next;</span><br><span class="line">            tmp1.next = tmp;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是使用虚拟头节点的方式，首先要判断什么时候循环结束，当前指向的后两个只要有null就停止循环，交换的顺序一定是要交换的两个节点的前一个节点的前一个节点指向要交换的后一个，要交换的前一个指向下一组的前一个，要交换的后一个节点指向要交换的前一个节点</p><h3 id="删除倒数第几个节点"><a href="#删除倒数第几个节点" class="headerlink" title="删除倒数第几个节点"></a>删除倒数第几个节点</h3><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一提到删除就要想到指针指向的是要删除节点的前一个节点，此时我们就要知道要删的节点的前一个在哪，这时有一个比较巧妙的方法，使用一种<strong>特殊的快慢指针</strong>，开始的时候，快慢指针同时指向虚拟头节点，然后快指针向前移动n个位置，然后快慢指针一起移动，直到快指针到达链表最后一个节点，此时慢指针刚好指向要删除的前一个节点，很巧妙，可以多画图理解</p><h3 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur1</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur2</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            size1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">            size2++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = headA;</span><br><span class="line">        cur2 = headB;</span><br><span class="line">        <span class="keyword">if</span>(size2 &gt; size1)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> size1;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmpList</span> <span class="operator">=</span> cur1;</span><br><span class="line">            size1 = size2;</span><br><span class="line">            size2 = tmp;</span><br><span class="line">            cur1 = cur2;</span><br><span class="line">            cur2 = tmpList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> size1 - size2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; count;i++)&#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1 == cur2)&#123;</span><br><span class="line">                <span class="keyword">return</span> cur1;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解题的关键是要想找到相交的链，这两个链表一定是尾部对齐的，然后短链的指针指向该链的第一个节点，长链的指针从头节点开始向后移动两链表长度之差，这样在链表尾部对齐的情况下，两指针就在同一个位置了，然后依次向后遍历判断是否有相同的节点</p><h3 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h3><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index1</span> <span class="operator">=</span> fast;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index2</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="keyword">while</span>(index1 != index2)&#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题可以分成两个部分，第一是判断是否有环，第二是找出环的入口</p><ol><li>判断是否有环</li></ol><p>使用快慢指针的方法，让快指针每次走两个节点，慢指针走一个节点，如果快慢指针能相遇，那么一定有环</p><ul><li>为什么快慢指针一定能相遇？不会跨过去吗？</li></ul><p>因为快指针的移动速度是2，慢指针的移动速度是1，快指针相对慢指针的速度是1，所以在慢指针看来，快指针是在一个节点一个节点的靠近自己，所以不会跨过去</p><ol start="2"><li>找出环的入口</li></ol><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230909145914203.png" class title="image-20230909145914203"><p>根据公式可以发现，环的入口位置一定等于z加上n倍的圈数，所以可以定两个指针，一个指向头节点位置，一个指向快慢指针相遇位置，两个指针同时以1的速度前进，相遇的位置就是入口位置。</p><h3 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h3><p><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            hash[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; t.length();i++)&#123;</span><br><span class="line">            hash[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; hash.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用一个数组来表示要存放26个字母，a是索引0的数据，z是索引25的数据，然后分别遍历s和t这两个字符串的每一个字母，s和t的每一个字母分别和’a’相减得到每个字母对应的索引，s得到索引后把对应位置的数字加一，t得到索引后把对应位置的数字减一，最后遍历数组的每个数字，如果每个位置的数字都等于0‘，那么每个位置加的次数和减的次数相同，说明是字母异位词</p><h3 id="两个数组元素交集-去重"><a href="#两个数组元素交集-去重" class="headerlink" title="两个数组元素交集(去重)"></a>两个数组元素交集(去重)</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1 == <span class="literal">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="literal">null</span> || nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; resSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历数组1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            set1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历数组2的过程中判断哈希表中是否存在该元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set1.contains(i)) &#123;</span><br><span class="line">                resSet.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[resSet.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : resSet)&#123;</span><br><span class="line">            arr[j++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数组内的元素大小不确定时，可以考虑使用set集合来找交集，思路很简单就是先把第一个数组中所有的元素放到set集合中，然后遍历第二个数组，看set集合中是否包含该元素，如果包含直接放到新的set集合中，因为set集合可以帮我们去重。重点记住相关api，判断是否包含的：set1.contains(i)，往集合中添加元素set1.add(i)，获得集合大小Set.size()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1 == <span class="literal">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="literal">null</span> || nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1001</span>];</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums1.length;i++)&#123;</span><br><span class="line">            hash[nums1[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i &lt; nums2.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[nums2[i]] == <span class="number">1</span>)&#123;</span><br><span class="line">                set.add(nums2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> set.stream().mapToInt(x -&gt; x).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在力扣改版之后，这道题新增了一个条件是元素的大小在0到1000中，此时元素的大小有了范围，所以可以考虑使用数组解决，思路和集合一样，第一个传入的数组直接放到新的，容量为1000的数组中，第二个传入的数组在这个容量为1000的数组中查询</p><h3 id="两个数组元素交集-不去重"><a href="#两个数组元素交集-不去重" class="headerlink" title="两个数组元素交集(不去重)"></a>两个数组元素交集(不去重)</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/submissions/">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[Math.min(nums1.length,nums2.length)];</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; nums1.length &amp;&amp; p2 &lt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[p1] &lt; nums2[p2])&#123;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums2[p2] &lt; nums1[p1])&#123;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                arr[index] = nums1[p1];</span><br><span class="line">                index++;</span><br><span class="line">                p1++;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(arr,<span class="number">0</span>,index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先对两个数组进行从小打到的排序，然后分别定义两个指针分别指向两个数组索引为0的位置，比大小让小的元素对应的指针向前进一个，然后如果相等那么就把该元素记录到新数组重，然后两个指针同时向后前进一位</p><h3 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h3><p><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span>&amp;&amp;!set.contains(n))&#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">            n = getNextNumber(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNumber</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">            res += tmp * tmp;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意获取一个数，每位之和的方法，循环模10的方法取到最后一位，然后除10一直循环到这个数除10为0。然后的关键点在于判断是不是快乐数的终止条件，如果平方和为1了，直接终止循环是快乐数，如果set集合中出现了这个数，说明这个数每位的平方和进入了循环且不等于1，此时一定不是快乐数</p><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和 - 力扣（LeetCode）</a></p><ul><li>暴力</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                    res[<span class="number">0</span>] = i;</span><br><span class="line">                    res[<span class="number">1</span>] = j;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两层循环直接找，时间复杂度O(n²)，不好</p><ul><li>哈希法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(tmp))&#123;</span><br><span class="line">                res[<span class="number">0</span>] = map.get(tmp);</span><br><span class="line">                res[<span class="number">1</span>] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们想到要通过数组的元素来判断是不是我们需要的下标，所以元素和下标我们都需要，所以考虑使用map，注意此时<strong>把元素的值作为map的key，元素的下标作为map的value</strong>，因为要通过元素的值来判断是否符合要求，把他作为key能迅速的查找他是否在map中出现过，一定要在判断的过程中往map里添加，<strong>千万不能把数组全部添加到map中再进行判断，这样可能重复的元素索引值会被覆盖</strong></p><h3 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加"></a>四数相加</h3><p><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums2.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> nums1[i] + nums2[j];</span><br><span class="line">                map.put(s,map.getOrDefault(s,<span class="number">0</span>) + <span class="number">1</span>);                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums3.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums4.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums3[i] + nums4[j];    </span><br><span class="line">                count += map.getOrDefault(-m,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路和两数之和很像，这道题为了降低时间复杂度，可以把四个数组两两分组，然后先遍历其中两个数组，得到他们的和放到map集合中，其中map的key是两元素之和，map的value是这个和出现的次数，然后遍历剩下两个数组，也是先得到两个数的和m，然后在map中找有没有和m相加等于0的key，即-m的key，如果有统计出现-m的次数即可</p><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(right &gt; left)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>])&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三数之和虽然可以考虑和两数之和一样使用哈希法来解决，但是要考虑去重，太麻烦，所以推荐使用双指针法(其实是三个指针，分别指向要想加的三个元素)，核心思路是，先对数组进行从小到大的排序，i先指向数组的第一个元素，left指向i的下一个元素，right指向数组的最后一个元素，然后三个数相加，如果等于大于零说明这三个数相加比目标值大了，让right向前移动，如果小于零则left向后移一位。</p><ul><li>去重细节<ul><li>i的去重，一定是i和i的前一个元素进行比较，即nums[i] &#x3D;&#x3D; nums[i - 1]，因为如果是nums[i] &#x3D;&#x3D; nums[i +1]这样进行比较去重的话，可能会漏掉一些结果，比如{-1，-1，2}，题目只要求数组与数组之间不能重复，没有说数组内的元素不能重复，这样i和i的前一个进行比较如果相等说明这个数已经用过了无需再次遍历直接coontinue</li><li>left和right的去重，一定要保证left&lt;right的情况之下，然后left和后一个进行比较，right和前一个进行计较即可</li></ul></li></ul><h3 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h3><p><a href="https://leetcode.cn/problems/4sum/">18. 四数之和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;k &lt; nums.length;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">0</span>&amp;&amp;nums[k] == nums[k - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; k + <span class="number">1</span>&amp;&amp;nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>)nums[k] + nums[i] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[k],nums[i],nums[left],nums[right]));</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right&amp;&amp;nums[left] == nums[left + <span class="number">1</span>])&#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span>(right &gt; left&amp;&amp;nums[right] == nums[right - <span class="number">1</span>])&#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑和三数之和一样，只是在三数之和的代码逻辑之上加上一层循环，注意去重细节，k指向数组第一个元素，然后去重的时候和前一个元素进行比较，如果相等向前移动，<strong>这里就不要考虑剪枝了，因为数组中可能有负数，有可能两个数越加越小导致直接return漏掉结果</strong></p><h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><p><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典双指针的思路，一个指针指向数组的头节点，另一个指针指向数组的尾节点，然后同时向中间移动</p><h3 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h3><p><a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] strChar = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; strChar.length;i += <span class="number">2</span>*k)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Math.min(strChar.length - <span class="number">1</span>,left + k -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> strChar[left];</span><br><span class="line">                strChar[left] = strChar[right];</span><br><span class="line">                strChar[right] = tmp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(strChar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反转过程和第一个反转字符串一样，但是注意这个遍历的时候需要以2k为单位向前移动for(int i &#x3D; 0;i &lt; strChar.length;i +&#x3D; 2*k)，反转的头节点就是每一次遍历的i，反转尾节点就是数组长度和i+k中较小的一个，这样正好可以满足题目的两个条件</p><h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格 - 力扣（LeetCode）</a></p><ul><li>复制元素直接求解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用StringBuilder追加字符串的方式，遍历原字符串，如果遇到’ ‘就替换成“%20”，思路简单，注意StringBuilde的API使用，另外还需要额外的内存空间</p><ul><li>双指针法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sb.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        s += sb.toString();</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[left] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                ch[right--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                ch[right--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                ch[right] = <span class="string">&#x27;%&#x27;</span>; </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ch[right] = ch[left];</span><br><span class="line">            &#125;</span><br><span class="line">            left--;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路就是遍历原字符串，如果遇到’ ‘的情况就直接在字符串的后面追加两个空位，然后一个指针指向原字符串的最后一个元素，另一个指针指向追加后字符串的最后一个空位，然后向前对新字符串进行填充</p><h3 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h3><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> ch.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch[left] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ch[right] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(index &gt;= left &amp;&amp; ch[index] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index+<span class="number">1</span>;i &lt;= right;i++)&#123;</span><br><span class="line">                sb.append(ch[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(index &gt; left)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(index &gt;= left &amp;&amp; ch[index] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">            right = index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>难点在于多出来的空格如何处理，使用双指针法，先去除字符串两端的空格，一个指针指向字符串的最前面，一个指针指向字符串的最后面，然后向前遍历，直到不是’ ‘，然后使用一个index指针，从后向前遍历每个单词(即等于空的时候停下)，此时有了单词的开始索引(index的指向)和单词结束的索引(right的指向)，这时可以使用StringBuilder拼接这个单词，如果此时index大于left再拼接一个空格表示不是最后一个单词，然后index继续向前走，直到不是空格的时候，让right指向该位置(下一个单词最后一个字母的位置)，此后一直循环即可</p><p>详细图解：<a href="https://leetcode.cn/problems/reverse-words-in-a-string/solutions/1153820/yi-ci-bian-li-shi-xian-fan-zhuan-zi-fu-c-cmos/">https://leetcode.cn/problems/reverse-words-in-a-string/solutions/1153820/yi-ci-bian-li-shi-xian-fan-zhuan-zi-fu-c-cmos/</a></p><h3 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h3><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &gt;= s.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] res = <span class="keyword">new</span> <span class="title class_">char</span>[ch.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n;i &lt; ch.length;i++)&#123;</span><br><span class="line">            res[index] = ch[i];</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            res[index] = ch[i];</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(res);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启一个新的数组，然后先遍历原数组的n到末尾的位置，放到新数组，再遍历原数组的首个元素到n的前一个位置，放到新数组中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &gt;= s.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        reverse(ch,<span class="number">0</span>,n - <span class="number">1</span>);</span><br><span class="line">        reverse(ch,n,ch.length - <span class="number">1</span>);</span><br><span class="line">        reverse(ch,<span class="number">0</span>,ch.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] ch,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> ch[start];</span><br><span class="line">            ch[start] = ch[end];</span><br><span class="line">            ch[end] = tmp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接在原字符串数组中操作，先把数组的首个元素到n的前一个进行反转，然后再把数组的第n个元素到最后一个元素进行反转，最后把数组整个反转，这样可以直接得到返转好的数组</p><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> haystack.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> needle.length();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; h)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>;right &lt; n;right++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &gt; <span class="number">0</span>&amp;&amp;needle.charAt(left) != needle.charAt(right))&#123;</span><br><span class="line">                left = next[left - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(needle.charAt(left) == needle.charAt(right))&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[right] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">0</span>;i &lt; h;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span>&amp;&amp;haystack.charAt(i) != needle.charAt(j))&#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(haystack.charAt(i) == needle.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == n)&#123;</span><br><span class="line">                <span class="keyword">return</span> i - n + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>haystack查询字符串，needle被查询字符串</p><p>暴力解法就是两层for循环遍历两个字符串，如果找不到从查找字符串的第二个字符再次遍历，KMP的核心思路就是找到字符串的最长前后缀长度，可以少遍历几个几个字符串</p><p>前缀：以第一个字符开头的任意长度的字符串</p><p>后缀：以最后一个字符结尾的任意长度字符串</p><p>其中，前缀表示的是被查询的字符串的前几个字符，后缀表示的是查询字符串中的几个字符</p><p>next数组存放的就是每个字符所对应的最长前后缀长度，这样我们遍历到不相符的字符的时候，直接找到该字符前一个字符对应的最长前后缀长度，指针直接指向最长前缀的后一个字符，从那个位置开始遍历，最长的前缀的东西一定在要查询的字符串出现了。。。。。。胡言乱语，刷算法的第一道坎，还是多练吧</p><p>详细分解：<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/1119642/duo-tu-yu-jing-xiang-jie-kmp-suan-fa-by-w3c9c/">https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/1119642/duo-tu-yu-jing-xiang-jie-kmp-suan-fa-by-w3c9c/</a></p><h3 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h3><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串 - 力扣（LeetCode）</a></p><ul><li>拼接法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> s + s;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(ss);</span><br><span class="line">        sb.deleteCharAt(ss.length() - <span class="number">1</span>);</span><br><span class="line">        sb.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">newString</span> <span class="operator">=</span> newStr.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[pre];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>;right &lt; pre;right++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &gt; <span class="number">0</span>&amp;&amp;s.charAt(left) != s.charAt(right))&#123;</span><br><span class="line">                left = next[left - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[right] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">0</span>;i &lt; newString;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span>&amp;&amp;newStr.charAt(i) != s.charAt(j))&#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(newStr.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == pre)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个字符串是ababab这样的由一个子字符串重复出现构成的，那么两个这样的字符串相加，并且掐头去尾后，一定会包含原本的字符串，即相加后abababababab，掐头去尾后bababababa，此时ababab一定在该字符串中，所以就可以使用kmp算法解决</p><ul><li>next数组妙用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[pre];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>;right &lt; pre;right++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &gt; <span class="number">0</span>&amp;&amp;s.charAt(left) != s.charAt(right))&#123;</span><br><span class="line">                left = next[left - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[right] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(next[pre - <span class="number">1</span>] &gt; <span class="number">0</span>&amp;&amp;pre%(pre - next[pre - <span class="number">1</span>]) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果s是一个重复的子字符串，那么他的最大前后缀长度一定是next数组的最后一个位置，此时数组的长度减去最长前后缀长度，得到就是一个子字符串的长度，所以如果原字符串长度%子字符串长度为0，那么它就是重复的子字符串</p><h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Stack stackIn;</span><br><span class="line">    Stack stackOut;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(stackOut.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stackIn.isEmpty())&#123;</span><br><span class="line">                stackOut.push(stackIn.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> (<span class="type">int</span>)stackOut.peek();</span><br><span class="line">        stackOut.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="built_in">this</span>.pop();</span><br><span class="line">        stackOut.push(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stackIn.isEmpty()&amp;&amp;stackOut.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理是使用两个栈来模拟队列，一个栈模拟队列的入口，一个栈模拟队列的出口，队列每次添加数据从入口栈添加，获取数据从出口栈获取，每当出口栈为空的时候，把入口栈的数据全部放到出口栈，因为栈是先进后出的，所以后进入入口栈的数据会先出来放到出口栈的最下面，先进入口栈的数据放到出口栈的最上面形成先进先出的效果</p><h3 id="使用队列实现栈"><a href="#使用队列实现栈" class="headerlink" title="使用队列实现栈"></a>使用队列实现栈</h3><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈 - 力扣（LeetCode）</a></p><ul><li>使用两个队列实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="comment">//q1作为主要的队列，其元素排列顺序和出栈顺序相同</span></span><br><span class="line">    Queue&lt;Integer&gt; q1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//q2仅作为临时放置</span></span><br><span class="line">    Queue&lt;Integer&gt; q2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在加入元素时先将q1中的元素依次出栈压入q2，然后将新加入的元素压入q1，再将q2中的元素依次出栈压入q1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(q1.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            q2.add(q1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        q1.add(x);</span><br><span class="line">        <span class="keyword">while</span>(q2.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            q1.add(q2.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个队列辅助另一个队列实现栈，每次新增元素的时候把第一个队列的所有元素放入第二个队列，然后在第一个队列放入新元素，然后把第二个队列的所有元素放入第一个队列中，实现先进后出</p><ul><li>一个队列实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">     <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        q.add(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        size = q.size();</span><br><span class="line">        <span class="keyword">while</span>(size &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            q.add(q.poll());</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> q.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思路就是在每次弹出元素的时候，根据队列的长度先弹出前n - 1个元素并放到队列尾端，这样再弹出的时候就是最后加入进来的元素，Deque 接口继承了 Queue 接口, 所以 Queue 中的 add、poll、peek等效于 Deque 中的 addLast、pollFirst、peekFirst，peekLast,这样在获取栈顶部元素的时候，直接调用peekLast获取队列的最后一个即可</p><h3 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h3><p><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">Stack</span> <span class="variable">sk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ch.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                sk.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch[i] == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                sk.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch[i] == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                sk.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sk.isEmpty() || !sk.peek().equals(ch[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sk.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无效的括号无非就三种情况，1. 左括号多了 2. 右括号多了 3. 左右括号不匹配，所以可以利用栈先进后出的特点，遍历字符串，如果遇到左括号那么就往栈里面加一个与之对应的右括号，如果遇到右括号看栈里面的peek元素是不是和遍历的右括号相符，如果相符就从栈中把该右括号取出，如果栈空了或者不相符直接返回false，最后整个遍历完根据栈里是否有元素判断是否为有效括号</p><h3 id="删除字符串的相邻重复项"><a href="#删除字符串的相邻重复项" class="headerlink" title="删除字符串的相邻重复项"></a>删除字符串的相邻重复项</h3><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ch.length;i++)&#123;</span><br><span class="line">            ch[slow] = ch[fast];</span><br><span class="line">            <span class="keyword">if</span>(slow &gt; <span class="number">0</span>&amp;&amp;ch[slow] == ch[slow - <span class="number">1</span>])&#123;</span><br><span class="line">                slow--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch,<span class="number">0</span>,slow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用经典的双指针解法就可以搞定，一个快指针遍历整个字符串，慢指针用来判断前后两个字符是不是相等，如果相等慢指针后退，不相等慢指针前进一个，注意最后返回的字符串是从零到慢指针指向的位置</p><h3 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h3><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; sk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; tokens.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;+&quot;</span>.equals(tokens[i])||<span class="string">&quot;-&quot;</span>.equals(tokens[i])||<span class="string">&quot;*&quot;</span>.equals(tokens[i])||<span class="string">&quot;/&quot;</span>.equals(tokens[i]))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> sk.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> sk.pop();</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;+&quot;</span>.equals(tokens[i]))&#123;</span><br><span class="line">                    sk.push(num1 + num2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;-&quot;</span>.equals(tokens[i]))&#123;</span><br><span class="line">                    sk.push(num2 - num1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;*&quot;</span>.equals(tokens[i]))&#123;</span><br><span class="line">                    sk.push(num1 * num2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;/&quot;</span>.equals(tokens[i]))&#123;</span><br><span class="line">                    sk.push(num2/num1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(tokens[i]);</span><br><span class="line">                sk.push(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带有”+-*&#x2F;“这种运算符的都可以考虑用栈来解决，这道题可以把传入的字符串数组看成一个二叉树，按照左右中的顺序进行计算，把整个字符串数组进行遍历放到栈里，然后如果遇到运算符号，从栈顶取出两个元素进行运算，把运算结果放到栈里，当字符换数组遍历完之后栈里剩的数就是最后的结果，很神奇</p><h3 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h3><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> nums.length - k + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[count];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!d.isEmpty()&amp;&amp;nums[d.peekLast()] &lt; nums[i])&#123;</span><br><span class="line">                d.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            d.addLast(i);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!d.isEmpty()&amp;&amp;d.peekFirst() &lt;= i - k)&#123;</span><br><span class="line">                    d.pollFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                res[i - k + <span class="number">1</span>] = nums[d.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法是维护一个单调队列，遍历整个数组，把数组的每一个元素的<strong>索引</strong>放到队列中，但是在每次加入前都要先进行判断，看看当前加入的索引对应的元素是不是比队列尾部索引对应的值大，如果大则队列中尾部索引就删除掉，判断到上一个索引元素大于要加入的或者队列为空为止，然后开始取元素，取元素的条件是遍历的次数要大于等于k-1，然后从头开始看这个队列，如果开头元素索引比i - k还小，说明此时的滑动窗口以及到了开头元素的后面，所以开头的不符合滑动窗口范围的也要进行删除，最后队列的头部就是想要的元素</p><p>以上代码第一个while是从后开始删除不符合的元素索引(<strong>比新加的元素索引对应的值还小</strong>)，第二个while是从前删除不符合的元素索引(不在滑动窗口的范围以内)，i可以代表滑动窗口的最后的位置</p><h3 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h3><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            map.put(nums[i],map.getOrDefault(nums[i],<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((n1, n2) -&gt;n1[<span class="number">1</span>] - n2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> keyValue : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &lt; k)&#123;</span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;keyValue,map.get(keyValue)&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(map.get(keyValue) &gt; pq.peek()[<span class="number">1</span>])&#123;</span><br><span class="line">                pq.remove();</span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;keyValue,map.get(keyValue)&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> [] tmp = pq.remove();</span><br><span class="line">            res[i++] = tmp[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先遍历整个数组，把数组元素作为key，元素出现的频率作为value，保存到map集合中，然后使用PriorityQueue这个优先队列(底层是用栈来实现的)，泛型指定为数组形式，把map中的每一个键值对的两个数作为一个数组放到队列中，<strong>因为我们要保留出现频率高的，所以使用的是小顶堆</strong>，所以规定好排序规则即按照传入数组索引为1的值进行升序排列，然后放入到队列中，保留前K多的数组即可，最后留在队列中的就是前K个最高频率的</p><h3 id="二叉树的前-x2F-中-x2F-后序遍历"><a href="#二叉树的前-x2F-中-x2F-后序遍历" class="headerlink" title="二叉树的前&#x2F;中&#x2F;后序遍历"></a>二叉树的前&#x2F;中&#x2F;后序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历 - 力扣（LeetCode）</a></p><ul><li>递归法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preorderTraversal(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorderTraversal</span><span class="params">(TreeNode cur,List list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(cur.val);</span><br><span class="line">        preorderTraversal(cur.left,list);</span><br><span class="line">        preorderTraversal(cur.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前序遍历：<strong>中</strong>左右，中序遍历：左<strong>中</strong>右，后序遍历：左右<strong>中</strong>。根据”中”这个字位置来记忆这几个遍历的顺序</p><p>使用递归法遍历的核心代码就三行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.add(cur.val);<span class="comment">//中</span></span><br><span class="line">preorderTraversal(cur.left,list);<span class="comment">//左</span></span><br><span class="line">preorderTraversal(cur.right,list);<span class="comment">//右</span></span><br></pre></td></tr></table></figure><p>不管是哪种遍历只需要调整这三行代码顺序即可</p><ul><li>迭代法前序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; sk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        sk.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!sk.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> sk.pop();</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                list.add(cur.val);<span class="comment">//中</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sk.push(cur.right);<span class="comment">//右</span></span><br><span class="line">            sk.push(cur.left);<span class="comment">//左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的是栈这个数据结构，理论上所以的递归操作都可以用栈来模拟，前序遍历的顺序是中左右，然后栈是先进后出的，所以思路就是中节点先入栈，然后处理中间节点，然后中间节点的右节点和左节点先后入栈，这样在弹出元素的时候就可以左节点先弹出处理，右节点后弹出</p><ul><li>迭代法后序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; sk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        sk.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!sk.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> sk.pop();</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                list.add(cur.val);<span class="comment">//中</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sk.push(cur.left);<span class="comment">//左</span></span><br><span class="line">            sk.push(cur.right);<span class="comment">//右</span></span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历的代码直接在前序遍历的基础上改就行，思路就是在我们处理前序遍历<strong>中左右</strong>的时候，处理和放入栈的顺序是<strong>中右左</strong>，此时遍历的顺序是<strong>左右中</strong>，所以只需要在处理和放入栈的时候把在前序遍历的基础上改为<strong>中左右</strong>，这样放入链表的顺序就是<strong>中右左</strong>，最后再使用reverse方法对链表进行反转就变成了<strong>左右中</strong></p><ul><li>迭代法中序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; sk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>||!sk.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                sk.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = sk.pop();</span><br><span class="line">                res.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路就是从根节点开始，一路向左向栈中添加遍历的节点，当遍历到空的时候，从栈中取出栈顶的元素，让当前指针指向该元素，此时这个元素一定是二叉树最左下角的那一个，把他的值加到链表中，然后让指针再指向当前元素的右节点，进入到下一次循环即可，注意进入循环的条件：当前节点的元素和栈有一个不为空即可</p><ul><li>二叉树层序遍历</li></ul><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            d.addLast(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!d.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> d.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> d.pollFirst();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层序遍历的意思是按照二叉树的每一层的元素顺序放到集合中，思路是使用队列，先把根节点放到队列中，然后记录此时队列的大小，然后进入循环，每次循环的次数根据队列中队开始的元素个数决定，把根节点放入到结果集中，然后先后把根节点的左右节点加入到队列中，循环到队列为空</p><h3 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            d.addLast(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!d.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> d.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> d.pollFirst();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层序遍历就是二叉树每一层从左到右遍历一遍，使用的是ArrayDeque这个队列，每从队列中取出一个元素的时候，就看看该元素是否含有子节点，如果有把子节点放入到队列中，注意每次循环此时是最开始遍历时记录的队列的大小，最后方法的调用pollFirst和addLast</p><h3 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h3><p><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        invert(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invert</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span> || (cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.left;</span><br><span class="line">        cur.left = cur.right;</span><br><span class="line">        cur.right = tmp;</span><br><span class="line">        invert(cur.left);</span><br><span class="line">        invert(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归的写法其实很简答，但是写之前一定先想好自己要使用哪种遍历方式，理论上前中后序遍历都可以，但是推荐前序和后序，因为中序写起来比较绕，举个例子：校长说去年是一年级的学生打扫学校，今年轮到二年级的打扫，乍一听没毛病，但仔细一想还是一批人，中序遍历是左中右，把左孩子处理完了，然后处理中间孩子的时候，右孩子变成左孩子了，然后再处理右孩子的时候其实还是左孩子。所以尽量不要使用中序遍历</p><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p><a href="https://leetcode.cn/problems/symmetric-tree/">101. Symmetric Tree - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left,TreeNode right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left.val != right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">out</span> <span class="operator">=</span> compare(left.left,right.right);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">inside</span> <span class="operator">=</span> compare(left.right,right.left);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> out &amp;&amp; inside;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(left.val != right.val)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过了这四个if的筛选此时后面递归处理的情况一定是左右节点都不为空且值相等的情况</p><p>然后进入递归逻辑</p><ul><li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li><li>比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。</li><li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li></ul><h3 id="最大深度"><a href="#最大深度" class="headerlink" title="最大深度"></a>最大深度</h3><ul><li>递归法</li></ul><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getHight(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHight</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHight</span> <span class="operator">=</span> getHight(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHight</span> <span class="operator">=</span> getHight(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span> + Math.max(leftHight,rightHight);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求一个二叉树的最大深度，就是二叉树的最大高度，所以从最下面的叶子节点开始往上数，碰见空节点说明这个空节点的父节点的高度是1，这样父节点的父节点就知道自己的其中一个孩子高度是1，数数的操作体现在int res &#x3D; 1 + Math.max(leftHight,rightHight)这一行，不好理解建议使用层序遍历</p><ul><li>层序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        d.addLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!d.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> d.size();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> d.pollFirst();</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用层序遍历的原因是二叉树的层数正好是二叉树的最大深度，所以每遍历一层计数器加一</p><h3 id="最小深度"><a href="#最小深度" class="headerlink" title="最小深度"></a>最小深度</h3><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        d.addLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!d.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> d.size();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> d.pollFirst();</span><br><span class="line">                <span class="keyword">if</span>(tmp.left == <span class="literal">null</span> &amp;&amp; tmp .right == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接使用层序遍历比较好理解，从根节点开始遍历遇到左右节点都为空的时候，清空直接返回当前的层数就是最小的深度</p><h3 id="完全二叉树节点个数"><a href="#完全二叉树节点个数" class="headerlink" title="完全二叉树节点个数"></a>完全二叉树节点个数</h3><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数 - 力扣（LeetCode）</a></p><ul><li>层序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        d.addLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!d.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> d.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> d.pollFirst();</span><br><span class="line">                list.add(tmp);</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层序遍历一个个数，时间复杂度有点高</p><ul><li>递归</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNums(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNums</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> getNums(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightNum</span> <span class="operator">=</span> getNums(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> leftNum + rightNum + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用递归分别求出根节点左右子树的的个数最后加上根节点的1就是全部节点的数量</p><ul><li>利用完全二叉树的特性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分别看看左右子树是不是满二叉树</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lef</span> <span class="operator">=</span> getNums(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rig</span> <span class="operator">=</span> getNums(root.right);</span><br><span class="line">        <span class="keyword">return</span> lef + rig + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNums</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftCur</span> <span class="operator">=</span> node.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightCur</span> <span class="operator">=</span> node.right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(leftCur != <span class="literal">null</span>)&#123;</span><br><span class="line">            leftCur = leftCur.left;</span><br><span class="line">            leftNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(rightCur != <span class="literal">null</span>)&#123;</span><br><span class="line">            rightCur = rightCur.right;</span><br><span class="line">            rightNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rightNum == leftNum)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; rightNum) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp1</span> <span class="operator">=</span> getNums(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp2</span> <span class="operator">=</span> getNums(node.right);</span><br><span class="line">        <span class="keyword">return</span> tmp1 + tmp2 + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完全二叉树可能出现其根节点的左子树为满二叉树或者完全二叉树本身就是一棵满二叉树，如果是满二叉树可以利用满二叉树的特性，如果不是满二叉树可以按照之前的遍历方式数数，如果是满二叉树的话节点数量为2^depth - 1 ，完全二叉树判断是不是满二叉树的方法是看左节点个数和右节点个数是否相等，利用这个公式还有一个好处是不用遍历完树的所有节点，上面的层序遍历和递归都需要遍历所有节点，而如果是一个满二叉树只需要遍历最左侧和最右侧的节点</p><h3 id="是否是平衡二叉树"><a href="#是否是平衡二叉树" class="headerlink" title="是否是平衡二叉树"></a>是否是平衡二叉树</h3><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> getHigh(root);</span><br><span class="line">        <span class="keyword">if</span>(res &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHigh</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHigh</span> <span class="operator">=</span> getHigh(node.left);</span><br><span class="line">        <span class="keyword">if</span>(leftHigh == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHigh</span> <span class="operator">=</span> getHigh(node.right);</span><br><span class="line">        <span class="keyword">if</span>(rightHigh == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(rightHigh - leftHigh) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + Math.max(rightHigh,leftHigh);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路很简单，就是判断二叉树的每个节点的高度是否超过了一，这个设计很巧妙，先是自底向上查看每个节点的高度，但是如果发现了某个节点已经不是平衡二叉树了就向上返回-1，这样最后只需判断最后返回的结果是不是-1即可</p><h3 id="二叉树所有路径"><a href="#二叉树所有路径" class="headerlink" title="二叉树所有路径"></a>二叉树所有路径</h3><p><a href="https://leetcode.cn/problems/binary-tree-paths/">257. Binary Tree Paths - 力扣（LeetCode）</a></p><ul><li>使用栈</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Object&gt; sk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        sk.push(root);</span><br><span class="line">        sk.push(root.val + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(!sk.isEmpty())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> (String)sk.pop();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> (TreeNode)sk.pop();</span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                res.add(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                sk.push(node.left);</span><br><span class="line">                sk.push(path + <span class="string">&quot;-&gt;&quot;</span> + node.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                sk.push(node.right);</span><br><span class="line">                sk.push(path + <span class="string">&quot;-&gt;&quot;</span> + node.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把已经拼接到路径和遍历到的当前节点放到一个栈中，注意要同时放入和取出，放入栈的路径便于返回，放入栈的节点为判断该节点是否为叶子节点，如果是叶子节点直接把路径放到集合即可，如果不是先给路径拼接好其左右节点的值，然后连同节点放入到栈中，这样做比较简单好理解，但是时间复杂度较高，还可以使用递归+回溯的方法，但是还没有悟道，等想明白了再补充</p><h3 id="左叶子节点之和"><a href="#左叶子节点之和" class="headerlink" title="左叶子节点之和"></a>左叶子节点之和</h3><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftSum(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leftSum</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> leftSum(node.left);</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span> &amp;&amp; node.left.left == <span class="literal">null</span> &amp;&amp; node.left.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            leftNum = node.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightNum</span> <span class="operator">=</span> leftSum(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> rightNum + leftNum;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意左叶子节点的定义，首先他得是一个叶子节点，其次他是父节点的左孩子。而<strong>不是计算所有的左孩子之和</strong>，然后从跟节点开始递归，遇到空节点返回0，**遇到左右孩子都为空的节点也返回0(因为这样的节点一定是叶子节点，但是现在不确定是不是左叶子节点，所以没有必要向下递归了)**，然后在下面进行判断如果当前节点的左孩子的左右孩子都是空那么记录这个数值即可</p><h3 id="树左下角的值"><a href="#树左下角的值" class="headerlink" title="树左下角的值"></a>树左下角的值</h3><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值 - 力扣（LeetCode）</a></p><ul><li>层序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        d.addLast(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!d.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> d.size();</span><br><span class="line">            res = d.peekFirst().val;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> d.pollFirst();</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    d.addLast(tmp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历每一层之前，把该层的第一个节点的值保存起来，这一定是该层最左边的值</p><ul><li>递归</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> max,res;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        findBottom(root,<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findBottom</span><span class="params">(TreeNode node,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(depth &gt; max)&#123;</span><br><span class="line">            max = depth;</span><br><span class="line">            res = node.val;</span><br><span class="line">        &#125;</span><br><span class="line">        findBottom(node.left,depth + <span class="number">1</span>);</span><br><span class="line">        findBottom(node.right,depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化最大深度为0，然后递归的时候传两个参数，一个是节点一个是当前节点所在的高度，每次向下一层遍历的时候高度要加一，因为不管是前&#x2F;中&#x2F;后序遍历都是左在前，右在后，所以每次修改最大深度max这个参数的都是每层的最左节点，所以此时可以一同修改res的值为该节点的val值</p><h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h3><p><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hasPath(root,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPath</span><span class="params">(TreeNode node,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span>&amp;&amp;node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node.val == target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">leftPath</span> <span class="operator">=</span> hasPath(node.left,target - node.val);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rightPath</span> <span class="operator">=</span> hasPath(node.right,target - node.val);</span><br><span class="line">        <span class="keyword">return</span> leftPath || rightPath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次传入的是根节点和目标值，每次递归传入的是下一个节点和目标值减去当前节点的值，这样在遇到叶子节点时候，可以根据叶子节点值是否等于目标值来判断该路径是否符合要求</p><h3 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h3><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a></p><ul><li>直接构造截开的数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> postorder.length;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">        root.val = postorder[postorder.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="keyword">for</span>(index = <span class="number">0</span>;index &lt; size;index++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[index] == postorder[postorder.length - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] inLeft = <span class="keyword">new</span> <span class="title class_">int</span>[index];</span><br><span class="line">        <span class="type">int</span>[] inRight = <span class="keyword">new</span> <span class="title class_">int</span>[inorder.length - <span class="number">1</span> -index];</span><br><span class="line">        <span class="type">int</span>[] postLeft = <span class="keyword">new</span> <span class="title class_">int</span>[index];</span><br><span class="line">        <span class="type">int</span>[] postRight = <span class="keyword">new</span> <span class="title class_">int</span>[inorder.length - <span class="number">1</span> -index];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; inLeft.length;i++)&#123;</span><br><span class="line">            inLeft[i] = inorder[i];</span><br><span class="line">            postLeft[i] = postorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; inRight.length;i++)&#123;</span><br><span class="line">            inRight[i] = inorder[index + i + <span class="number">1</span>];</span><br><span class="line">            postRight[i] = postorder[inLeft.length + i];</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = buildTree(inLeft,postLeft);</span><br><span class="line">        root.right = buildTree(inRight,postRight);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题思路很简单，但是边界的处理很麻烦，一定注意边界使用的是左闭右开还是左闭右闭，核心思路是通过后序的数组的最后一个元素创建出根节点，然后拿到这个元素在中序遍历的数组中把中序的数组截开，截开后前半部分就是左树的长度，根据这个长度可以在后序的数组中拿到后序的截开后的数组，然后分别剩下的就是中后序遍历的右树的数组</p><ul><li>递归法(思路和上面完全一样)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map;  <span class="comment">// 方便根据数值查找位置</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123; <span class="comment">// 用map保存中序序列的数值对应位置</span></span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> findNode(inorder,  <span class="number">0</span>, inorder.length, postorder,<span class="number">0</span>, postorder.length);  <span class="comment">// 前闭后开</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">findNode</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> inBegin, <span class="type">int</span> inEnd, <span class="type">int</span>[] postorder, <span class="type">int</span> postBegin, <span class="type">int</span> postEnd)</span> &#123;</span><br><span class="line">        <span class="comment">// 参数里的范围都是前闭后开</span></span><br><span class="line">        <span class="keyword">if</span> (inBegin &gt;= inEnd || postBegin &gt;= postEnd) &#123;  <span class="comment">// 不满足左闭右开，说明没有元素，返回空树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> map.get(postorder[postEnd - <span class="number">1</span>]);  <span class="comment">// 找到后序遍历的最后一个元素在中序遍历中的位置</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(inorder[rootIndex]);  <span class="comment">// 构造结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lenOfLeft</span> <span class="operator">=</span> rootIndex - inBegin;  <span class="comment">// 保存中序左子树个数，用来确定后序数列的个数</span></span><br><span class="line">        root.left = findNode(inorder, inBegin, rootIndex,</span><br><span class="line">                            postorder, postBegin, postBegin + lenOfLeft);</span><br><span class="line">        root.right = findNode(inorder, rootIndex + <span class="number">1</span>, inEnd,</span><br><span class="line">                            postorder, postBegin + lenOfLeft, postEnd - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序和中序构造二叉树"><a href="#前序和中序构造二叉树" class="headerlink" title="前序和中序构造二叉树"></a>前序和中序构造二叉树</h3><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; inorder.length;i++)&#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(inorder,<span class="number">0</span>,inorder.length,preorder,<span class="number">0</span>,preorder.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] inorder,<span class="type">int</span> inBegin,<span class="type">int</span> inEnd,<span class="type">int</span>[] preorder,<span class="type">int</span> preBegin,<span class="type">int</span> preEnd)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inBegin &gt;= inEnd || preBegin &gt;= preEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(preorder[preBegin]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index - inBegin;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(inorder[index]);</span><br><span class="line">        root.left = build(inorder,inBegin,index,preorder,preBegin + <span class="number">1</span>,preBegin + <span class="number">1</span> + leftSize);</span><br><span class="line">        root.right = build(inorder,index + <span class="number">1</span>,inEnd,preorder,preBegin + <span class="number">1</span> + leftSize,preEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上一道题思路一模一样，只不过这次从前序数组中的第一个元素在中序数组来截开</p><p>详细分析一下构造二叉树的传参(左闭右开)</p><ul><li>构造左子树的时候：需要前序和中序的左部分<ul><li>中序的左部分<ul><li>开始：其实就是inorder的第一个元素，因为左中右的顺序每次截开后，第一个元素一定是截开后要的左部分的第一个</li><li>结束：直接就是截开位置的索引，因为左中右和左闭右开</li></ul></li><li>前序的左部分<ul><li>开始：每一次都是在上一次开始的基础上加一，因为中左右，每次舍弃掉中也就是第一个即可</li><li>结束：先找到<strong>本次</strong>前序的左部分开始位置的索引，在这个索引的基础上加上左部分的长度</li></ul></li></ul></li><li>构造右子树的时候：需要前序和中序的右部分<ul><li>中序的右部分<ul><li>开始：直接就是截开的索引位置加一</li><li>结束：就是每一次传入的inEnd，这个值其实和中序左部分开始一样是不变的</li></ul></li><li><strong>前序的右部分(这部分最关键，最容易弄错导致数组越界)</strong><ul><li>开始：在<strong>本次</strong>左部分开始位置的索引加上左部分的长度</li><li>就是每一次传入的preEnd</li></ul></li></ul></li></ul><p><strong>防错技巧：记住前序遍历的左部分的结尾就是右部分的开始索引，还是因为左闭右开</strong></p><h3 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h3><p><a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> constructMaximumBinaryTree1(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree1</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> leftIndex, <span class="type">int</span> rightIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rightIndex - leftIndex &lt; <span class="number">1</span>) &#123;<span class="comment">// 没有元素了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightIndex - leftIndex == <span class="number">1</span>) &#123;<span class="comment">// 只有一个元素</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[leftIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> leftIndex;<span class="comment">// 最大值所在位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxVal</span> <span class="operator">=</span> nums[maxIndex];<span class="comment">// 最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> leftIndex + <span class="number">1</span>; i &lt; rightIndex; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; maxVal)&#123;</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxVal);</span><br><span class="line">        <span class="comment">// 根据maxIndex划分左右子树</span></span><br><span class="line">        root.left = constructMaximumBinaryTree1(nums, leftIndex, maxIndex);</span><br><span class="line">        root.right = constructMaximumBinaryTree1(nums, maxIndex + <span class="number">1</span>, rightIndex);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造思路和上两题差不多，都是通过切割数组，注意好传参的边界，提前想好左闭右开还是左闭右闭，不用上两题的map结构，而是递归找最大值和索引的方式可以减少用时</p><h3 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h3><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span> &amp;&amp; root2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1 != <span class="literal">null</span> &amp;&amp; root2 ==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        root1.val += root2.val;</span><br><span class="line">        root1.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">        root1.right = mergeTrees(root1.right,root2.right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时操作两个二叉树，但是不难，如果递归到的两个节点都是null那么向上返回null，两个节点都有值返回相加值很好理解，主要是想明白如果一个为空另一个不为空的时候要直接返回那一个不为null的节点即可</p><h3 id="二叉搜索树搜索"><a href="#二叉搜索树搜索" class="headerlink" title="二叉搜索树搜索"></a>二叉搜索树搜索</h3><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索 - 力扣（LeetCode）</a></p><ul><li>直接递归找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> searchBST(root.left,val);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> searchBST(root.right,val);</span><br><span class="line">        <span class="keyword">if</span>(leftNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用二叉搜索树(左节点小于根节点，右节点大于根节点)的特性找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root.val)&#123;</span><br><span class="line">            res = searchBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root.val)&#123;</span><br><span class="line">            res = searchBST(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用迭代法找，还是根据二叉搜索树的特性，可以根据要得到的val的值的大小，来确定要递归的方向</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val &lt; root.val)&#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &gt; root.val)&#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证是否为二叉搜索树"><a href="#验证是否为二叉搜索树" class="headerlink" title="验证是否为二叉搜索树"></a>验证是否为二叉搜索树</h3><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树 - 力扣（LeetCode）</a></p><ul><li>中序递归遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">leftValid</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; pre.val &gt;= root.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rigthValid</span> <span class="operator">=</span> isValidBST(root.right);</span><br><span class="line">        <span class="keyword">return</span> leftValid &amp;&amp; rigthValid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是死死抓住二叉搜索树的特性进行求解，如果一个二叉树是二叉搜索树那么这个树的中序遍历一定是一个递增的数列，所以这道题直接使用二叉树的中序遍历，比较当前节点的值是否比上一个大即可，注意遍历到空节点的时候直接返回的是true而不是false，这里可以想一个极端的情况，比如这个树的跟节点就是空，那么这个树一定是个二叉搜索树</p><ul><li>中序迭代遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; sk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span> || !sk.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">                sk.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> sk.pop();</span><br><span class="line">            <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; pre.val &gt;= tmp.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = tmp;</span><br><span class="line">            root = tmp.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树最小差值"><a href="#二叉搜索树最小差值" class="headerlink" title="二叉搜索树最小差值"></a>二叉搜索树最小差值</h3><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        getMinimum(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMinimum</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getMinimum(cur.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span>)&#123;</span><br><span class="line">            res = Math.min(res,cur.val - pre.val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        getMinimum(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是利用二叉搜索树的中序遍历的特性，此时最小的插值一定出现在遍历后数组的相邻两个元素中，和上一题的递归法思路很像，仍然使用双指针操作一棵二叉树，每次比较之后把pre指针指向当前节点</p><h3 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h3><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. Find Mode in Binary Search Tree - 力扣（LeetCode）</a></p><ul><li>暴力</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        find(root,map);</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Integer key : map.keySet())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            <span class="keyword">if</span>(tmp == max)&#123;</span><br><span class="line">                list.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(TreeNode root,Map&lt;Integer,Integer&gt; map)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(root.val,map.getOrDefault(root.val,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(map.get(root.val) &gt; max)&#123;</span><br><span class="line">            max = map.get(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        find(root.left,map);</span><br><span class="line">        find(root.right,map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力法，第一遍使用任何一种遍历顺序，把二叉树中的所有元素进行一个统计，以二叉树的值为key，出现的次数作为value放到一个map中，同时不断地更新出现最大次数的值，第二次遍历这个map，如果map的value为最大出现的频率，那么直接放到结果集中</p><ul><li>双指针法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    TreeNode pre ;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        find(root);</span><br><span class="line">        <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        find(cur.left);</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="literal">null</span>)&#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pre.val == cur.val)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="keyword">if</span>(count == max)&#123;</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; max)&#123;</span><br><span class="line">            max = count;</span><br><span class="line">            list.clear();</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">        &#125;</span><br><span class="line">        find(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一些代码技巧可以只遍历一次，此时要维护两个变量，第一个max表示最大出现的频率，第二个count表示当前节点的值出现的频率，同时这种方法必须使用中序遍历，因为只有中序遍历后的顺序才能保证这个二叉树非递减排列，双指针计数的过程是如果pre节点为空，那么说明此时的cur节点指向了叶子节点此时count为1，如果cur和pre相同说明这个值的频率不为1，所以count要加一，如果pre和cur不相等了说明这个数统计完了，此时要统计新的数，把count重新初始为1，放入结果集的时候很有意思，刚放入的时候先不管这个最大频率是不是真正的最大频率，只要出现的频率等于这个最大频率那么就先放入结果集中，然后如果遇到了更大的频率那么把原先的结果集清空，然后修改最大频率，然后将此时的值放到结果集中</p><h3 id="二叉树最近公共祖先"><a href="#二叉树最近公共祖先" class="headerlink" title="二叉树最近公共祖先"></a>二叉树最近公共祖先</h3><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(leftNode != <span class="literal">null</span> &amp;&amp; rightNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(leftNode == <span class="literal">null</span> &amp;&amp; rightNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(leftNode != <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公共祖先一定是要从底向上遍历寻找，所以优先会考虑使用后序遍历，即先看左右孩子的情况再决改向上一层返回什么，核心思路就是碰到了p或q节点直接向上返回，如果一个节点的左右孩子都不是空那么这个节点一定就是想要的公共节点，如果只有一个节点不为空那么直接向上返回不为空的节点，这样处理的话可以考虑到所有情况</p><ol><li>第一种情况：公共节点不是pq本身，再结合题目所说二叉树中一定包含pq节点，这样一定会在</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(leftNode != <span class="literal">null</span> &amp;&amp; rightNode != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个条件中找到想要的公共祖先</p><ol start="2"><li>第二种情况：公共节点是pq本身，那么此时一定会在</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root == p || root == q)&#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个节点找到想要的公共节点，这时哪怕p或q有一个没遍历到也没有关系，因为公共节点已经找到了</p><h3 id="二叉搜索树最近公共祖先"><a href="#二叉搜索树最近公共祖先" class="headerlink" title="二叉搜索树最近公共祖先"></a>二叉搜索树最近公共祖先</h3><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）</a></p><ul><li>递归法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这道题使用上一题的代码完全没有问题，因为二叉搜索树也是二叉树，自底向上递归一定找到最近的公共节点，但是可以狠狠利用二叉搜索树的特性来提升代码的执行效率，再强调一遍什么时二叉搜索树，即根节点的<strong>所有</strong>子节点都比根节点的值要小，跟节点的<strong>所有</strong>右节点都比根节点的值要大，所以当pq的值都比根节点小的时候，此时一定只需要向左递归即可，当pq的值都比根节点的值要大的时候，此时一定只需要向右递归，<strong>当根节点的值处于pq的中间时，此时这个节点就是最大公共节点，因为此时不管是向左遍历还是向右遍历一定会错过pq其中一个节点</strong></p><h3 id="插入二叉搜索树"><a href="#插入二叉搜索树" class="headerlink" title="插入二叉搜索树"></a>插入二叉搜索树</h3><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. Insert into a Binary Search Tree - 力扣（LeetCode）</a></p><ul><li>递归法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题很简单，但是题目的描述很具与迷惑性，他说答案不一定唯一，比如要插入的值可能在叶子节点也可能在根节点，<strong>但是要想明白所有的二叉搜索树再插入一个不同的元素的时候一定可以找到一个叶子节点来插入的</strong>，所以只需要考虑如何找到这个叶子节点即可</p><ul><li>迭代法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">index</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur = root;</span><br><span class="line">            <span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(cur.val &lt; val)&#123;</span><br><span class="line">            cur.right = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.val &gt; val)&#123;</span><br><span class="line">            cur.left = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代法这个地方有个小坑，就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">    root = root.left;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">    root = root.right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方要写成if(){}else if(){}的形式,不能写成两个if，因为第一种形式表示如果第一个条件成立了，那么执行第一个if中的逻辑，同时不会判断第二个else if中的条件更不会执行其中的逻辑，如果是第二种形式会进行第二个if条件的判断，此时如果已经执行完了第一个if中的逻辑可能会发生空指针异常</p><h3 id="有序数组转为二叉搜索树"><a href="#有序数组转为二叉搜索树" class="headerlink" title="有序数组转为二叉搜索树"></a>有序数组转为二叉搜索树</h3><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左闭右开版</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin &gt;= end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(end - begin == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[begin]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (begin + end)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = sortedArrayToBST(nums,begin,mid);</span><br><span class="line">        root.right = sortedArrayToBST(nums,mid + <span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左闭右闭版</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(end == begin)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[begin]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (begin + end)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = sortedArrayToBST(nums,begin,mid - <span class="number">1</span>);</span><br><span class="line">        root.right = sortedArrayToBST(nums,mid + <span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和前面根据中序遍历和后序遍历构造二叉树思路相似，有序数组可以看成二叉搜索树的中序遍历，然后根据题目要求要左右的高度差不超过1，所以可以使用每次传递数组的中间的数值作为根节点，仍然要注意左闭右开和左闭右闭的问题</p><h3 id="二叉搜索树转累加树"><a href="#二叉搜索树转累加树" class="headerlink" title="二叉搜索树转累加树"></a>二叉搜索树转累加树</h3><p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        convert(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        convert(node.right);</span><br><span class="line">        node.val += pre;</span><br><span class="line">        pre = node.val;</span><br><span class="line">        convert(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题最难的是读题，他的意思是要先找到二叉搜索树中最大的节点的值，然后以此节点为基础不断向前累加，因为是一个二叉搜索树，所以遍历的顺序是右中左，使用双指针的思路不断累加即可</p><h3 id="删除二叉搜索树节点"><a href="#删除二叉搜索树节点" class="headerlink" title="删除二叉搜索树节点"></a>删除二叉搜索树节点</h3><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. Delete Node in a BST - 力扣（LeetCode）</a></p><ul><li>暴力删除，先把二叉树中序遍历，得到一个数组，在数组中删除目标节点，然后根据数组构造树二叉搜索树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        getArray(root);</span><br><span class="line">        <span class="keyword">if</span>(list.contains(key))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> list.indexOf(key);</span><br><span class="line">            list.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size();i ++)&#123;</span><br><span class="line">            arr[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> combine(arr,<span class="number">0</span>,arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getArray</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getArray(node.left);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        getArray(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">combine</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin &gt;= end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(end - begin == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(arr[begin]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (begin + end)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(arr[mid]);</span><br><span class="line">        root.left = combine(arr,begin,mid);</span><br><span class="line">        root.right = combine(arr,mid + <span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>递归法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right;</span><br><span class="line">                <span class="keyword">while</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                cur.left = root.left;</span><br><span class="line">                root = root.right;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; key)</span><br><span class="line">            root.left = deleteNode(root.left,key);</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; key)</span><br><span class="line">            root.right = deleteNode(root.right,key);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分五种情况考虑</p><ol><li><p>没有找到要删除的节点</p></li><li><p>要删除的节点左右子树都为空，即根节点不用调整二叉树结构</p></li><li><p>要删除的节点左不为空右为空，直接将该节点的父亲的左子树指向该节点的左子树</p></li><li><p>要删除的节点右不为空左为空，直接将该节点的父亲的右子树指向该节点的右子树</p></li><li><p>要删除的节点左右节点全不为空，可以将该节点的任意左右子节点替换该节点，同时调整二叉树结构，<br>例如：当把右孩子替换该节点的时候可以把左子树放到比要替换的节点大一位的节点的左侧 (即左下角)</p><p>​当把左孩子替换该节点的时候可以把右子树放到比要替换节点为跟的树的最大的位置(即右下角)</p></li></ol><h3 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h3><p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; low)&#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; high)&#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = trimBST(root.left,low,high);</span><br><span class="line">        root.right = trimBST(root.right,low,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>牢记三句话：<ul><li>当前节点的值小于目标范围的时候，只需要处理该节点的右孩子</li><li>当前节点的值大于目标范围的时候，只需要处理该节点的左孩子</li><li>当前节点符合要求范围的时候，直接处理其左右孩子</li></ul></li></ul><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p><a href="https://leetcode.cn/problems/combinations/">77. 组合 - 力扣（LeetCode）</a></p><ul><li>基础版</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        traceBack(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traceBack</span><span class="params">(<span class="type">int</span> length,<span class="type">int</span> size,<span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == size) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= length; i++) &#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            traceBack(length, size, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231023125112589.png" class title="image-20231023125112589"><p>通过递归函数的传参，来确定每一次遍历的次数，每次递归开始的值比上一次大一，因为上一次已经取走一个数了，当path的路径和要求一致的时候，就可以往结果集中放了，然后弹出最后一个元素，这就是回溯的过程，因为如果不弹出的话就会一直往一个集合中放入元素，导致超出要求范围</p><ul><li>剪枝版</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        traceBack(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traceBack</span><span class="params">(<span class="type">int</span> length,<span class="type">int</span> size,<span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == size)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt;= length - (size - path.size()) + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            traceBack(length,size,i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为什么需要剪枝？因为回溯是一个纯暴力的搜索的方式，如果不加以控制那么他会遍历整个树形结构，即便某些情况下条件一定不会成立，但是他还是会进行遍历，例如，当n&#x3D;4，k&#x3D;3的情况，当startIndex&gt;2的时候是没必要遍历的，因为3或者4开头凑不够要求的3个大小</p><p>剪枝操作往往是在每次递归后的for循环条件中做文章</p><p>本题的剪枝是n-(k - path.size())+1,(k - path.size())这部分是为算出还需要往path集合中放入多少元素，n-(k - path.size())+1就可以算出本次循环最多可以从哪个位置开始，+1是因为剪完之后的长度的后一个元素是符合条件的，例如n&#x3D;5，k&#x3D;3，size&#x3D;1，这样k - path.size()的值是2，说明此时path集合还需要两个元素，然后通过n-2+1&#x3D;4，说明4是至多开始的位置</p><h3 id="组合总和Ⅲ"><a href="#组合总和Ⅲ" class="headerlink" title="组合总和Ⅲ"></a>组合总和Ⅲ</h3><p><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        build(k,n,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum == n &amp;&amp; path.size() == k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt;= <span class="number">9</span> - (k - path.size()) + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            build(k,n,i + <span class="number">1</span>,sum);</span><br><span class="line">            sum -= i;</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和组合问题很像，组合问题只需要考虑收集的集合中元素个数，来作为递归终止的条件，但是这道题在组合的基础上加了一个集合内元素之和大小的限制，相当于加了一个递归终止的条件，然后也多了一个剪枝的可能性，即当组合中的和已经大于了目标值即使元素个数还没有达到要求这时也没必要向下递归了</p><h3 id="电话号码字母组合"><a href="#电话号码字母组合" class="headerlink" title="电话号码字母组合"></a>电话号码字母组合</h3><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String[] numString = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        backTracking(digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String digits,<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">            list.add(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> numString[digits.charAt(index) - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            path += String.valueOf(str.charAt(i));</span><br><span class="line">            backTracking(digits, index + <span class="number">1</span>);</span><br><span class="line">            path = path.substring(<span class="number">0</span>,path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是要把字符串的每个数字想象成一个树形结构，字符串的长度是要递归的深度，字符串的每一个数字对应的字符串长度代表每次循环的次数，首先要把每个数字对应的字符串保存到一个一维数组中，其中0和1这两个用空串表示，之所以这次递归使用的是index来表示接下来要遍历的数字而不是startIndex，是因为之前的题目实在同一个集合上进行的组合操作，而这道题是不同集合的组合操作，所以只需要保留要遍历字符串的索引即可，而每当递归到一个新的集合时候一定是从头遍历到尾</p><h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h3><p><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        combination(candidates,target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">combination</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target,<span class="type">int</span> index,<span class="type">int</span> sum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; candidates.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum + candidates[i] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            combination(candidates,target,i,sum);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题比较关键的地方在于数组中的数字可以重复使用，所以每次循环的开始和上一次递归的开始是一样的，这个题比较难想的地方在于如何剪枝，要想到对这个数组进行排序，然后在收集的过程中，如果收集的内容已经超过目标值了，这是就不需要接下来的递归了</p><h3 id="组合总和Ⅱ"><a href="#组合总和Ⅱ" class="headerlink" title="组合总和Ⅱ"></a>组合总和Ⅱ</h3><p><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">  <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">( <span class="type">int</span>[] candidates, <span class="type">int</span> target )</span> &#123;</span><br><span class="line">    <span class="comment">//为了将重复的数字都放到一起，所以先进行排序</span></span><br><span class="line">    Arrays.sort( candidates );</span><br><span class="line">    backTracking( candidates, target, <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">( <span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> start )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( sum == target ) &#123;</span><br><span class="line">      res.add( <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;( path ) );</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++ ) &#123;</span><br><span class="line">      <span class="comment">//正确剔除重复解的办法</span></span><br><span class="line">      <span class="comment">//跳过同一树层使用过的元素</span></span><br><span class="line">      <span class="keyword">if</span> ( i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] ) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      sum += candidates[i];</span><br><span class="line">      path.add( candidates[i] );</span><br><span class="line">      <span class="comment">// i+1 代表当前组内元素只选取一次</span></span><br><span class="line">      backTracking( candidates, target, i + <span class="number">1</span> );</span><br><span class="line">      sum -= candidates[i];</span><br><span class="line">      path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的难点在于给的数组元素含有重复元素，例如[10,1,2,7,6,1,5]，当target&#x3D;8的时候[1,7]这个结果可能会出现两次，所以需要进行去重操作，去重的时候要先对数组进行排序，[1,1,2,5,6,7,10]对于同一条路径不需要去重，因为两个1可以出现在结果中，当不是同一条路径的时候，比如把第一个1放到路径中然后递归完后面的所有元素，当要放第二个1到路径中的时候就需要去重，因为此时以1开头的结果在第一个1的时候已经收集完了，所以也就是candidates[i] &#x3D;&#x3D; candidates[i - 1]的时候，直接进入下一层循环即可</p><h3 id="分割回文子串"><a href="#分割回文子串" class="headerlink" title="分割回文子串"></a>分割回文子串</h3><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        part(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">part</span><span class="params">(String s,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= s.length())&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i  &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(decide(s,index,i))&#123;</span><br><span class="line">                path.add(s.substring(index,i + <span class="number">1</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            part(s,i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">decide</span><span class="params">(String s,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) != s.charAt(right))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的难点在于一定要想清楚这个切割过程的树形结构</p><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231029222404968.png" class title="image-20231029222404968"><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231029222511499.png" class title="image-20231029222511499"><p>例如这种位置，先判断是不是回文串，再放入到path中，判断的方法是固定index不动，改变i的值来确定要切割的长度，如果当前切割出来字符串不符合要求则直接continue，然后注意substring这个方法切割的时候是左闭右开的</p><h3 id="修复IP地址"><a href="#修复IP地址" class="headerlink" title="修复IP地址"></a>修复IP地址</h3><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">        backTracking(sb, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(StringBuilder s, <span class="type">int</span> startIndex, <span class="type">int</span> dotCount)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dotCount == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(s,startIndex,s.length() - <span class="number">1</span>))&#123;</span><br><span class="line">                result.add(s.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(s,startIndex,i))&#123;</span><br><span class="line">                s.insert(i + <span class="number">1</span>,<span class="string">&quot;.&quot;</span>);</span><br><span class="line">                backTracking(s,i + <span class="number">2</span>,dotCount + <span class="number">1</span>);</span><br><span class="line">                s.deleteCharAt(i + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//[start, end]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(StringBuilder s, <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(start) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i &lt;= end;i++)&#123;</span><br><span class="line">            num = num * <span class="number">10</span> + s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; <span class="number">255</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的关键在于，维护一个dotCount变量来记录当前IP地址已经被我们加了多少个”.”,当”.”的个数到了三个的时候，就达到了IP地址的标准，所以此时只需要验证最后一个点后面的部分是否合格即可，还有一个注意点是在进入下一次递归的时候，startIndex是2，因为已经加了一个”.”了</p><p>还有一个注意点就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(num &gt; <span class="number">255</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个判断一定要放在for循环中，因为字符串可能特别长导致超出Integer的最大值</p><h3 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h3><p><a href="https://leetcode.cn/problems/subsets/">78. 子集 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        backtracking(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= nums.length)&#123;<span class="comment">//相当于一个剪枝，可以不写</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; nums.length;i++)&#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtracking(nums,i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们每次递归往结果加入的path集合都是不一样的，而且这些集合一定都是原数组的子集，所以一上来不用判定任何条件直接加入到res集合中即可，</p><h3 id="子集问题Ⅱ"><a href="#子集问题Ⅱ" class="headerlink" title="子集问题Ⅱ"></a>子集问题Ⅱ</h3><p><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtracting(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracting</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= nums.length)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; index &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                backtracting(nums,i + <span class="number">1</span>);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和组合总和Ⅱ的去重思路相同，每次循环的时候，如果不是第一次往里面放元素，那么就要先检查要放入的元素和上一次放入的是不是相同即可，别忘了对数组进行排序</p><h3 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h3><p><a href="https://leetcode.cn/problems/non-decreasing-subsequences/">491. 递增子序列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        find(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!path.isEmpty() &amp;&amp; path.get(path.size() - <span class="number">1</span>) &gt; nums[i] || set.contains(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            find(nums,i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这个题一定不能对数组进行排列，因为排序以后他的子序列就变了</p><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231103212851949.png" class title="image-20231103212851949"><p>同一层的节点不能取相同的值，而同一个数枝上的数可以取相同的，例如[4,7,6,7,8,9]这个数组，同一个树枝指的是每次递归，所以[4，7，7]是可以作为递增子序列的，而同一层节点的时候，如果取了第一个7，那么7后面的所以可能都被第一个7尝试过了，所以同层时候不能取相同数值，即这种地方</p><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231103213600993.png" class title="image-20231103213600993"><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231103213624668.png" class title="image-20231103213624668"><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p><a href="https://leetcode.cn/problems/permutations/">46. 全排列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        find(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(path.contains(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                find(nums);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保证每次递归时候循环都是从零开始遍历的，然后每次向path集合中添加元素的时候，判断是否存在即可，因为原始数组是不重复的</p><h3 id="全排列Ⅱ"><a href="#全排列Ⅱ" class="headerlink" title="全排列Ⅱ"></a>全排列Ⅱ</h3><p><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        Arrays.fill(used,<span class="literal">false</span>);</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrack(nums,used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">boolean</span>[] used)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>&amp;&amp;nums[i] == nums[i - <span class="number">1</span>]&amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="literal">false</span>)&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                backtrack(nums,used);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题首先要明白为什么会出现重复，才能理解应该在什么地方剪枝，例如[1,1,2]，当选完第一个1的时候得到两个结果[1,1,2]和[1,2,1]的时候，回溯以后要选第二个1，此时会出现重复所以要剪枝，也就是说不同深度的元素可以重复，同一层级的元素不可以重复</p><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231105160110922.png" class title="image-20231105160110922"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span>&amp;&amp;nums[i] == nums[i - <span class="number">1</span>]&amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>)&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个判断条件的前两个就是看看要添加的元素和前一个是否相同，第三个判断条件就是看看是不是在同一层，如果是同一层要加入元素的前一个元素对应的使用情况应该是false，因为他刚刚被回溯撤销</p><h3 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h3><p><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[][] checkerboard = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] ch : checkerboard)&#123;</span><br><span class="line">            Arrays.fill(ch,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(<span class="number">0</span>,n,checkerboard);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> n,<span class="type">char</span>[][] checkerboard)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == row)&#123;</span><br><span class="line">            res.add(array2List(checkerboard));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>;col &lt; n;col++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isValid(row,col,n,checkerboard))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            checkerboard[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            backtrack(row + <span class="number">1</span>,n,checkerboard);</span><br><span class="line">            checkerboard[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">array2List</span><span class="params">(<span class="type">char</span>[][] checkerboard)</span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] ch : checkerboard)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">String</span>(ch));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col,<span class="type">int</span> n,<span class="type">char</span>[][] checkerboard)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; row;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(checkerboard[i][col] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span> , j = col - <span class="number">1</span>;i &gt;= <span class="number">0</span>&amp;&amp;j &gt;= <span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(checkerboard[i][j] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>,j = col + <span class="number">1</span>;i &gt;= <span class="number">0</span>&amp;&amp;j &lt;= n - <span class="number">1</span>;i--,j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(checkerboard[i][j] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>维护了一个char类型的二维数组来模拟一个棋盘，初始的时候棋盘里面元素都为’.’，然后进行循环判断，如果当前该位置合法，那么就把当前元素改为’Q’,然后再次递归，每次递归表示要处理的是下一行，所以传参的时候row要加一，for循环表示判断该行的每一个位置是否合法，然后是如何判断是否合法，根据当前遍历到的行和列为基准，进行三次判断分别是 1.该位置的这一列是否包含’Q’,2.该位置45°左上角是否包含’Q’，3.该位置45°右上角是否包含’Q’，如果全不包含那么这就是一个合法的位置</p><h3 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h3><p><a href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        backtrack(board);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; <span class="number">9</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">char</span> <span class="variable">num</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;num &lt;= <span class="string">&#x27;9&#x27;</span>;num++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(isValid(i,j,num,board))&#123;</span><br><span class="line">                            board[i][j] = num;</span><br><span class="line">                            <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> backtrack(board);</span><br><span class="line">                            <span class="keyword">if</span>(res)&#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col,<span class="type">char</span> num,<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] == num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[row][i] == num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startRow</span> <span class="operator">=</span> (row / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startCol</span> <span class="operator">=</span> (col / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startRow;i &lt; startRow + <span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> startCol;j &lt; startCol + <span class="number">3</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == num)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维递归，这道题和N皇后的区别在于，这道题的棋盘上的每一个位置都要填数，所以每一个位置都要遍历到，所以使用双重for循环来定位每一个位置，然后通过该位置是否是’.’来决定要不要处理，如果是’.’那么就需要对该位置进行处理，遍历1-9这九个数然后判断是否符合数独的条件，在判断行和列的时候很简单只需要遍历，看是否重复即可，然后每一个九宫格的话是先进行除3的操作，然后再乘以3可以定位到九宫格开始的位置，比如遍历到的列是第5列，（5&#x2F;3）&#x3D; 1 ，1*3&#x3D;3，3正好是5这一列开始判断合法的列，关于本题的剪枝操作是通过返回一个boolean类型的变量来剪枝的，当1-9这九个数字全部遍历完成后都不能满足要求那么，说明以前的插入就有问题了无需向下遍历，直接进行回溯，当所有的位置都不是’.’的时候说明找到了一个结果，这时直接返回true即可</p><h3 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h3><p><a href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> g.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(index &gt;= <span class="number">0</span>&amp;&amp;s[index] &gt;= g[i])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让更多的孩子吃到饼干，所以让大的饼干尽量给胃口大孩子吃，先对数组排序，饼干和胃口都是从大到小遍历，保证饼干不动胃口向前遍历，直接第一个满足饼干的胃口，这时就找到了这个饼干能满足的最大的胃，然后饼干再向前遍历</p><h3 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h3><p><a href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prediff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curdiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            curdiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="keyword">if</span>((prediff &gt;= <span class="number">0</span>&amp;&amp;curdiff &lt; <span class="number">0</span>)||(prediff &lt;= <span class="number">0</span>&amp;&amp;curdiff &gt; <span class="number">0</span>))&#123;</span><br><span class="line">                count++;</span><br><span class="line">                prediff = curdiff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求摆动序列的最大长度，其实并不需要把不符合的数组元素进行删除，只需要在出现波峰波谷的位置给计数器加一即可。</p><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231111115016474.png" class title="image-20231111115016474"><p>然后会出现三种情况：</p><ol><li>摆动中有平坡</li></ol><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231111115539808.png" class title="image-20231111115539808"><p>这时有两种方法，第一种就是从左向右删除二直到只剩一个二，第二种就是从右向左删除二直到只剩一个二，由于数组是从左向右遍历的，所以这里选择保留最后一个二，体现在代码中就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((prediff &gt;= <span class="number">0</span>&amp;&amp;curdiff &lt; <span class="number">0</span>)||(prediff &lt;= <span class="number">0</span>&amp;&amp;curdiff &gt; <span class="number">0</span>))<span class="comment">//左边是平坡，右边不是的时候，这时需要记录</span></span><br></pre></td></tr></table></figure><ol start="2"><li>波峰&#x2F;波谷出现在数组首尾</li></ol><p>这里的处理方式是默认尾部就是一个峰&#x2F;谷，所以计数器从一开始计数，然后对于第一个元素的判断可以看成第一个元素前面还有一个和第一个元素相同的虚拟值，例如[1,2]是两个，这时想象成[1,1,2]经过代码的判断还是两个</p><ol start="3"><li>单调坡中有平坡</li></ol><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231111120405222.png" class title="image-20231111120405222"><p>这里的处理方式是，不用每次遍历都更新prediff的值，由于平坡的存在导致不知道是摆动还是持续上升，所以只有当出现要记录的时候才更新prediff</p><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h3><p><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; max)&#123;</span><br><span class="line">                max = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思想是，进行求和运算的时候，实时记录最大值的大小，同时当某一个子序列的总和小于零的时候，让下一个元素成为新序列的头节点，因为总和小于零对于后面的元素来说一定是累赘</p><h3 id="买卖股票的最佳时机Ⅱ"><a href="#买卖股票的最佳时机Ⅱ" class="headerlink" title="买卖股票的最佳时机Ⅱ"></a>买卖股票的最佳时机Ⅱ</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++)&#123;</span><br><span class="line">            res += Math.max(prices[i] - prices[i - <span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常思路是在最低点的时候买股票，最高点的时候卖股票，比如prices[2] - prices[0]就是第三天的时候卖，第一天的时候买，这个式子可以拆成prices[2] - prices[1] + prices[1] - prices[0],也就是每一天的利润，我们可以计算出每一天的利润，然后只取赚的时候，最终就是赚的最多的</p><h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h3><p><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= cover;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + i&gt; cover)&#123;</span><br><span class="line">                cover = nums[i] + i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cover &gt;= nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题不需要关系具体是如何跳跃的，只需要记录当前位置可以跳跃到的最大范围，然后依次遍历范围内的所有元素，来寻找更大的范围，如果找到的范围超过了数组的最大索引，说明可以跳跃到，反之则不行</p><h3 id="跳跃游戏Ⅱ"><a href="#跳跃游戏Ⅱ" class="headerlink" title="跳跃游戏Ⅱ"></a>跳跃游戏Ⅱ</h3><p><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            next = Math.max(next,nums[i] + i);</span><br><span class="line">            <span class="comment">//能进到这个if中，说明下一次就可以跳到最后，所以res+1，然后break即可</span></span><br><span class="line">            <span class="keyword">if</span>(next &gt;= nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//到这里说明目前遍历的范围还不能到最后一个，所以还需要继续往前跳，所以当遍历到当前覆盖的最后一个的时候，直接更新下一次覆盖的最大范围，并且向前跳一步</span></span><br><span class="line">            <span class="keyword">if</span>(i == cover)&#123;</span><br><span class="line">                cover = next;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路很简单，就是每次跳到覆盖最远位置的元素，而不是跳到覆盖范围内元素最大的位置，cover表示当前能够覆盖的最大范围，next表示当前覆盖范围内，下一次覆盖的最远位置，res表示要跳的次数</p><h3 id="K-次取反后最大化的数组和"><a href="#K-次取反后最大化的数组和" class="headerlink" title="K 次取反后最大化的数组和"></a>K 次取反后最大化的数组和</h3><p><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> changeIndex(nums);</span><br><span class="line">            nums[index] = -nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">changeIndex</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; min)&#123;</span><br><span class="line">                min = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次符号的改变都找最小的数字，这样的话如果是负数，那么最小的负数变号之后就是最大的，利于求和，如果是正数，最小的正数在变号以后都会变成绝对值小的负数这样也利于求和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span>&amp;&amp;k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums[i] = -nums[i];</span><br><span class="line">                k--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; <span class="number">0</span>&amp;&amp;k % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            nums[<span class="number">0</span>] = -nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种思路是先对数组从小到大进行排序，然后从头开始变号，此时只有当数字小于零的时候，符号改变，如果全是正数那就跳出循环，看k的奇偶性，如果k是偶数那么就不用变号了，如果k是奇数那么就把最小的正数变为负数即可</p><h3 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h3><p><a href="https://leetcode.cn/problems/gas-station/">134. 加油站 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; gas.length; i++) &#123;</span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                index = i + <span class="number">1</span>; </span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于究竟从哪个站开始走，取决于该站对总体的作用是上升还是下降，如果是上升能不能后面的所有站，满足这两个要求就可以保证绕一圈，比如gas&#x3D;[2,5,2,3,5],cos&#x3D;[1,2,8,2,4]的情况下，我们要看对总体的作用就是看油和花费的差值，即[1,3,-6,1,4]这个数组，从头开始累加，如果累加过程中出现了负数，说明跨不过去，这时把累加的数值清零，然后索引记录当前累加到的后一个，然后重新累加，直到累加过程中没有负数</p><h3 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h3><p><a href="https://leetcode.cn/problems/candy/">135. 分发糖果 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] candy = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        Arrays.fill(candy,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; candy.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i - <span class="number">1</span>])&#123;</span><br><span class="line">                candy[i] = candy[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> candy.length - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i + <span class="number">1</span>])&#123;</span><br><span class="line">                candy[i] = Math.max(candy[i + <span class="number">1</span>] + <span class="number">1</span>,candy[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; candy.length;i++)&#123;</span><br><span class="line">            res += candy[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这种需要两边都考虑的题目，解决的策略是先考虑一边，然后再考虑另一边，首先每个孩子最少有一个糖，所以初始化一个值全为1的数组，然后先考虑右边孩子是否比左边孩子评分高，此时数组从左向右遍历，因为右边孩子的糖果是在左边孩子的基础上加的，如果高给对应孩子的糖果加一，然后考虑左边孩子是否比右边孩子评分高，此时需要数组从后向前遍历，因为左边孩子加糖果是在右边孩子糖果的基础上加的，然后加一之后在和这个孩子原本糖果的数量进行比较取最大值，因为最大值一定可以满足既比左边孩子高而且比右边孩子高的条件</p><h3 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h3><p><a href="https://leetcode.cn/problems/lemonade-change/">860. 柠檬水找零 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>[] bills)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">five</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ten</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bills.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bills[i] == <span class="number">5</span>) &#123;</span><br><span class="line">                five++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bills[i] == <span class="number">10</span>) &#123;</span><br><span class="line">                five--;</span><br><span class="line">                ten++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bills[i] == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ten--;</span><br><span class="line">                    five--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    five -= <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (five &lt; <span class="number">0</span> || ten &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题确实简单，记录好每次收到钱的面值即可，5元直接记录，10元只能用5元找零，20元可以用一张10元和一张5元找零或三张五元找零，这样的话在每次遍历以后看剩余的5元，10元是不是负的即可确认是否能找零，这道题贪心贪在20元找零的时候，这时优先使用10元和5元的组合找零，而不是3个五元的，因为5元更万能，既可以找零20，又可以找零10</p><h3 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h3><p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">        Arrays.sort(people,(a,b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> b[<span class="number">0</span>] - a[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] person : people)&#123;</span><br><span class="line">            list.add(person[<span class="number">1</span>],person);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[people.length][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目还是需要两个维度考虑，一个是自身的身高，一个是需要多少个比自己高的人，所以还是要先抓住一个维度，在考虑另外一个维度，比如people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]的时候，先考虑需要多少个比自己高的人的话，排序结果为[[5,0],[7,0],[6,1],[7,1],[5,2],[4,4]] (当需要相同个数高的人站在自己前面的时候身高高的往后站),这时发现再根据身高进行后序调整的时候不好操作了，所以先考虑身高，排序完的people： [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]，身高相同需要前面站的人多的往后站，排序完就会发现“需要多少个比自己高的人”这个条件变成了要插入队列的索引</p><p>插入的过程：</p><ul><li>插入[7,0]：[[7,0]]</li><li>插入[7,1]：[[7,0],[7,1]]</li><li>插入[6,1]：[[7,0],[6,1],[7,1]]</li><li>插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]</li><li>插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]</li><li>插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</li></ul><p>后面的人往中间插是一定不会影响之前的排序结果的，因为身高是降序排列，所以后面的人的位置变动只会影响自己的需要多少个比自己高的人这个元素，然后因为题目要求往队列里面插入的时候一般是中间插入较多，所以使用ArrayList效率要稍高于LinkedList</p><h3 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h3><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        Arrays.sort(points, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; points.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i - <span class="number">1</span>][<span class="number">1</span>] &lt; points[i][<span class="number">0</span>])&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                points[i][<span class="number">1</span>] = Math.min(points[i - <span class="number">1</span>][<span class="number">1</span>],points[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为题目传入的气球位置是乱序的，所以这时需要对气球的左边界进行升序排列，这样有利于对重叠的气球进行统计，<strong>注意这个地方要使用Integer内置的比较函数不会出现数值溢出，</strong>然后就可以判断左边气球的右边界和右边气球的左边界的大小关系，如果左边气球的右边界小于右边气球的左边界这时说明需要再多来一根弓箭，如果左边气球的有边界大于等于右边气球的左边界，说明这时一根弓箭可以直接射穿，此时为了判断下一个气球是不是可以一块射穿，需要更新这两个气球的最小右边界，只有下一个气球的左边界小于等于这俩气球的最小右边界才可以一块射穿</p><h3 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h3><p><a href="https://leetcode.cn/problems/non-overlapping-intervals/description/">435. 无重叠区间 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(intervals,(a,b) -&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt; intervals[i - <span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                count++;</span><br><span class="line"></span><br><span class="line">                intervals[i][<span class="number">1</span>] = Math.min(intervals[i][<span class="number">1</span>],intervals[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上一题很像，上一题是在两个区间不重叠的时候进行计数表示一个箭可以射穿，这道题是在两个区间重叠的时候进行计数，然后同样更新最小右边界方便下一个区间比较</p><h3 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h3><p><a href="https://leetcode.cn/problems/partition-labels/description/">763. 划分字母区间 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] lasIndex = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            lasIndex[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            right = Math.max(right,lasIndex[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span>(i == right)&#123;</span><br><span class="line">                res.add(right - left + <span class="number">1</span>);</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题的意思是同一个字符只能出现在分割之后的同一个字符串，也就说从原字符串的第一个位置开始收集，那么最少要收集到这个字符在字符串中最后一次出现的位置，在遍历的过程中还会收集到的字符，也要遍历到这些字符的最后位置，所以这个最后位置是动态更新的，取这些字符最后位置的最大值，最后放到集合中即可，记录字符最后出现的位置的方法是，遍历整个字符串，然后用每一个字符减去’a’作为字符所在数组的位置，然后不断更新最后一次在字符中出现就是最大值</p><h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><p><a href="https://leetcode.cn/problems/merge-intervals/description/">56. 合并区间 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//按照左边界排序</span></span><br><span class="line">        Arrays.sort(intervals, (x, y) -&gt; Integer.compare(x[<span class="number">0</span>], y[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">//initial start 是最小左边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightmostRightBound</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt; rightmostRightBound)&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start,rightmostRightBound&#125;);</span><br><span class="line">                start = intervals[i][<span class="number">0</span>];</span><br><span class="line">                rightmostRightBound = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                rightmostRightBound = Math.max(rightmostRightBound,intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, rightmostRightBound&#125;);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先按照范围的左边界进行排序，记录第一个元素的左右边界，然后判断下一个元素左边界和当前记录边界的右边界的关系，如果大于直接把当前记录的边界放入到的集合中，并且更新左右边界为当前遍历的元素，反之只需要更新右边界(如果右边界比当前记录的右边界大的话)，最后注意遍历到最后一个边界的时候，不管这个边界和之前记录的边界范围什么关系都需要把这个边界放到集合中，因为intervals[ i ][ 0]  &gt; rightmostRightBound这种情况放入集合的是当前记录边界，而不是最后一个边界</p><h3 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h3><p><a href="https://leetcode.cn/problems/monotone-increasing-digits/description/">738. 单调递增的数字 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(n);</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[i - <span class="number">1</span>] &gt; ch[i])&#123;</span><br><span class="line">                ch[i - <span class="number">1</span>]--;</span><br><span class="line">                flag = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> flag;i &lt; s.length();i++)&#123;</span><br><span class="line">            ch[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(<span class="keyword">new</span> <span class="title class_">String</span>(ch));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题的思路挺牛逼的，当前一位的数字比后一位大的时候，这个时候因为后一位不能变大了，但是为了让后面的大于前面的，所以让前一位减一，然后后一位变成9，例如332，此时个位比十位小，所以让十位减一，让个位等于九，此时是局部最优，然后依次遍历可以达到全局最优，注意要使用一个标记为表示该位后面的所有位都变成9，而不是当出现位数差值的时候才变成9，全部变成9才是全局最优</p><p>至于遍历顺序问题，可以带入模拟一下，如果从前往后遍历332，在遍历结束的时候就会变成329，就不对了，我们是要根据后面的结果来判断前面数字的改变</p><h3 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h3><p><a href="https://leetcode.cn/problems/binary-tree-cameras/description/">968. 监控二叉树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**状态表示：</span></span><br><span class="line"><span class="comment">        0：无覆盖</span></span><br><span class="line"><span class="comment">        1：有摄像头</span></span><br><span class="line"><span class="comment">        2：有覆盖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span>  res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCameraCover</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(getState(root) == <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getState(cur.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getState(cur.right);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">2</span>&amp;&amp;right == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="number">0</span>||right == <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>截至目前最简单的一个hard题，贪心的思路在于要想到叶子节点的个数一定是大于根节点的，为了让摄像头的个数最少，由于叶子节点的特性，不要让叶子节点出现的摄像头，因为他的覆盖范围小，要让叶子节点的父节点放摄像头，所以这里要使用后序遍历，从下往上安放摄像头，通过子节点的状态判断父节点的状态，来判断是否放摄像头</p><ol><li>当左右节点都是有覆盖状态，这时该节点的状态是无覆盖</li><li>当左右节点至少有一个无覆盖，这时该节点必须放一个摄像头，状态为一</li><li>当左右节点至少有一个摄像头，这时该节点的状态是有覆盖</li></ol><p>之所以遇到空节点的时候要返回有覆盖的状态，是为了让叶子节点的父节点来放摄像头，如果返回另外两种状态那么父节点就放不上摄像头了，最后的根节点返回的状态结果记得处理，也就是根节点如果是无覆盖的状态，那么要在跟节点上放一个摄像头</p><h3 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><p><a href="https://leetcode.cn/problems/fibonacci-number/description/">509. 斐波那契数 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">0</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            list.add(list.get(i - <span class="number">2</span>) + list.get(i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动规五部曲：</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p><ol start="2"><li>确定递推公式</li></ol><p>因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] &#x3D; dp[i - 1] + dp[i - 2];</p><ol start="3"><li>dp数组如何初始化</li></ol><p>题目中把如何初始化也直接给我们了，如下：</p><p>dp[0] &#x3D; 0;<br>dp[1] &#x3D; 1;</p><ol start="4"><li>确定遍历顺序</li></ol><p>从递归公式dp[i] &#x3D; dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p><ol start="5"><li>当题目通过不了的时候可以通过打印dp数组的方法，查看打印出来的内容和预想内容有何不同</li></ol><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p><a href="https://leetcode.cn/problems/climbing-stairs/description/">70. 爬楼梯 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;i &lt; dp.length;i++)&#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题最关键的点在于区分开 <em>到达第n阶有几种方法</em> 和 <em>到达第n阶走几步</em> 这两个说法的区别，走到第一阶有一种方法，走到第二节有两种走法，然后从后往前想更易于理解，例如 达到第五阶有几种方法？</p><p>想要达到第五阶至少要达到第三阶或者第四阶，这样才能到第五阶，所以到达第五阶的方法就是到达第四阶和到达第三阶方法的总和，那依次类推到达第四阶就是至少要达到第二阶或者第三阶，也就是到达第四阶需要到达第三阶和第二阶方法的总和，所以这就可以抽象斐波那契数列</p><p>还有一个点是dp数组的意义：dp数组表示到达第i阶的方法有dp[i]种方法，所以在初始化数组的时候dp[0]表示达到第零阶的方法，其实是没有意义的，所以dp数组从dp[1]开始复制即可</p><h3 id="爬楼梯最少消费"><a href="#爬楼梯最少消费" class="headerlink" title="爬楼梯最少消费"></a>爬楼梯最少消费</h3><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/description/">746. 使用最小花费爬楼梯 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cost.length + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt; cost.length + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>],dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先要明确题意，题目中的cost数组表示的是站在某一个台阶上向上跳的时候要花费的钱，而不是站上去就要花钱，因此dp[0]和dp[1]都是0，dp数组的含义是到达第i个台阶需要花费的钱是dp[i]，所以初始化dp数组的时候长度要比cost长度多一个，因为cost数组的最后一个元素表示倒数第一个台阶还没有到顶，想要达到第i个台阶的条件是先要到达第i-1或者i-2个台阶，所以遍历顺序还是从前往后，这个位置取值为从前面两个台阶中选一个小的花费</p><h3 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h3><p><a href="https://leetcode.cn/problems/unique-paths/description/">62. 不同路径 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>||m == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; m;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; m;j++)&#123;</span><br><span class="line">                dp[j][i] = dp[j - <span class="number">1</span>][i] + dp[j][i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显这道题是根据横纵两个方向进行路径的统计，所以dp是一个二维数组，由于这道题只能向下或者向右走，所以要想走到某一个点，必须先到达到他的左边的点或者上边的点，所以递推公式就是上边点的路径总和加上左边点的总和，从而推出递推公式，然后对于数组的初始化，由于递推公式是基于左边和上边的点，所以二维数组的最上边和最左边需要进行初始化，很显然最上面和最下面只有一种走法，不管多长都初始化为1即可，因为结果基于左边和上边，遍历顺序也很自然的从左向右从上向下</p><h3 id="不同路径Ⅱ"><a href="#不同路径Ⅱ" class="headerlink" title="不同路径Ⅱ"></a>不同路径Ⅱ</h3><p><a href="https://leetcode.cn/problems/unique-paths-ii/description/">63. 不同路径 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>||obstacleGrid[m - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>] != <span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i] != <span class="number">1</span>)&#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j] != <span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题就是在前一题的基础上加了障碍，所以递推公式和遍历顺序是不变的，所以只需要调整dp数组的初始化，也就是在初始化最上边和最左边的时候在遇到障碍之前还是1，在遇到障碍之后直接跳出循环即可，因为障碍和障碍后面的位置一定是到达不了的，注意，别忘了判断起始位置和终点位置是不是有障碍，如果有障碍那么一定到达不了终点</p><h3 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h3><p><a href="https://leetcode.cn/problems/integer-break/description/">343. 整数拆分 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;i &lt; n + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; i;j++)&#123;</span><br><span class="line">                dp[i] = Math.max(j * (i - j),Math.max(j * dp[i - j],dp[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由均值不等式可知，当和一定的时候，拆分的数大小越相近，相乘的结果越大，所以定义dp数组为第i个数拆分的最大值是dp[i]，当一个数拆分为i，j两个数时，乘积就是j * (i - j),当拆分的个数大于两个的时候，这时就需要用到dp数组中以前的结果了，j固定不动，j * dp[i - j]即可表示拆分后大于两个的情况，遍历顺序和初始化很简单，关键在于为什么j * dp[i - j]这个地方能代表全部的可能，是因为dp数组的任何一个数都是在经过全部遍历以后取得的最大值，然后固定一个j不动，乘上dp得到的一定是全部结果，最后注意取最大值的时候Math.max(j * (i - j),Math.max(j * dp[i - j],dp[i]))不要忘了dp[i]本身，因为之前记录的dp[i]可能比j * (i - j)和j * dp[i - j]z这两个都大，以防后面遍历的可能结果把之前记录的最大值覆盖掉</p><h3 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h3><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/description/">96. 不同的二叉搜索树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> dp[] = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt; dp.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; i;j++)&#123;</span><br><span class="line">                dp[i] += dp[j] * dp[i - <span class="number">1</span> -j]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一棵二叉树的所有放置方式，无非就是不断更新根节点，然后变动左右子节点数量，所以明确dp[]数组的意义，即有i个节点的时候有dp[i]中不同的节点放置方式，拿n &#x3D; 3(二叉树共三个节点)举例，无非三种情况：</p><ol><li>根节点为1，左子树节点个数为0，右子树节点个数为2，这时就是0个节点对应的放置方式 乘上 2个节点对应的放置方式</li><li>跟节点为2，左子树节点个数为1，右子树节点个数为1，这时就是1个节点对应的放置方式 乘上 1个节点对应的放置方式</li><li>跟节点为3，左子树节点个数为2，右子树节点个数为0，这时就是2个节点对应的放置方式 乘上 0个节点对应的放置方式</li></ol><p>把以上三种情况相加就是3个节点所有的放置方式，由此可以得出递推公式dp[i] +&#x3D; dp[j] * dp[i - 1 -j],其中i表示节点总数，j可以看成左节点的个数，由于根节点也要占一个节点，所以右节点的个数要在减去左节点个数的前提下额外减一，即i - j -1，然后遍历累加，关于数组的初始化，1个节点肯定是一种排列方式，0个也是1种方式，因为0个节点一定是二叉搜索树，这个很关键，遍历顺序很简单了，后面要依赖前面的所以是从前向后遍历</p><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>之所以使用一维数组进行求解的时候，先遍历物品然后遍历背包的时候，背包大小要从大到小进行遍历，是因为往背包里面放这件物品的计算规则是该物品的价值 + 减去该物品剩下的质量对应的最大价值，所以保证减去该物品的质量的那个背包里面没有放该物品，因为每个物品只有一个，使用二维数组的时候都是往左上角进行相加查找这个物品，所以这个时候一定没有放置该物品</p><ul><li>二维数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BagProblem</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划获得结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight  物品的重量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value   物品的价值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bagSize 背包的容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testWeightBagProblem</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] value, <span class="type">int</span> bagSize)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建dp数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">goods</span> <span class="operator">=</span> weight.length;  <span class="comment">// 获取物品的数量</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[goods][bagSize + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化dp数组</span></span><br><span class="line">        <span class="comment">// 创建数组后，其中默认的值就是0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> weight[<span class="number">0</span>]; j &lt;= bagSize; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充dp数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; weight.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= bagSize; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; weight[i]) &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 当前背包的容量都没有当前物品i大的时候，是不放物品i的</span></span><br><span class="line"><span class="comment">                     * 那么前i-1个物品能放下的最大价值就是当前情况的最大价值</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 当前背包的容量可以放下物品i</span></span><br><span class="line"><span class="comment">                     * 那么此时分两种情况：</span></span><br><span class="line"><span class="comment">                     *    1、不放物品i</span></span><br><span class="line"><span class="comment">                     *    2、放物品i</span></span><br><span class="line"><span class="comment">                     * 比较这两种情况下，哪种背包中物品的最大价值最大</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j] , dp[i-<span class="number">1</span>][j-weight[i]] + value[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>一维数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testWeightBagProblem</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] value, <span class="type">int</span> bagWeight)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">wLen</span> <span class="operator">=</span> weight.length;</span><br><span class="line">    <span class="comment">//定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[bagWeight + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//遍历顺序：先遍历物品，再遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; wLen; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagWeight; j &gt;= weight[i]; j--)&#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h3><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">416. 分割等和子集 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target;j &gt;= nums[i];j--)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j],dp[j - nums[i]] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[target] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个思路又很牛逼，要把一个数组完全分成两个等和的数组，那么就是每个数组是原数组之和的一半，然后拿一个最大容量就是原数组之和一半的背包，如果这个背包最大能装的价值就是原数组之和的一半的话(原数组的数值表示其价值)，那么就正好可以分成两个数组，这样就可以把这个问题抽象成01背包，然后每次往背包里放东西的时候都校验一遍是不是达到了原数组的一半，可以起到剪枝的作用</p><h3 id="最后一块石头的重量-II"><a href="#最后一块石头的重量-II" class="headerlink" title="最后一块石头的重量 II"></a>最后一块石头的重量 II</h3><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/description/">1049. 最后一块石头的重量 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; stones.length;i++)&#123;</span><br><span class="line">            sum += stones[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; stones.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> maxSize;j &gt;= stones[i];j--)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j],dp[j - stones[i]] + stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">other</span> <span class="operator">=</span> sum - dp[maxSize];</span><br><span class="line">        <span class="keyword">return</span> other - <span class="number">2</span>*dp[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上一题的牛逼思路一样，这一题要想让碰撞以后剩余石头尽可能小，就把所有的石头分成两堆，让两堆的石头尽量等于总重量的一半，这样两堆碰撞的之后就是最小的，所以就又转化为了01背包</p><h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h3><p><a href="https://leetcode.cn/problems/target-sum/description/">494. 目标和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((sum - target) % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> (sum - target)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[tmp + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> tmp;j &gt;= nums[i];j--)&#123;</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[tmp];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题的思路很简单，无非就是在数组中挑出来几个数，给这几个数加上负号，然后让其数组的数相加得零，计算这些数总和的方式是，原数组的总和减去目标值再除二(如果原数组的和减去目标值为奇数直接返回零即可)，记录这个值为tmp，这道题就转换为装满一个大小为tmp的背包有几种方法，所以难点到了求这个递推公式，举个例子，如果tmp &#x3D; 3，先遍历物品，如果物品的大小是3，这时就要加上dp[3 - 3]，如果物品的大小是2，那就加上dp[3 - 2]，以此类推，所以这样我们就可以得到递推公式，然后注意数组的初始化，dp[0]为什么等于一，因为需要用到dp[0]的地方是当我们遇到了和背包一样大的物品，这时只要把这一个物品直接放到背包中就可以装满，所以初始化dp[0]的时候要为1</p><h3 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h3><p><a href="https://leetcode.cn/problems/ones-and-zeroes/description/">474. 一和零 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; strs.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span>[] count = getCount(strs[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m;j &gt;= count[<span class="number">0</span>];j--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n;k &gt;= count[<span class="number">1</span>];k--)&#123;</span><br><span class="line">                    dp[j][k] = Math.max(dp[j][k],dp[j - count[<span class="number">0</span>]][k - count[<span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getCount(String s)&#123;</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                count[<span class="number">0</span>]++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count[<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>典型的01背包，要找的是装满背包最多可以装多少个物品，但是原来的01背包只需要考虑一个维度，也就是最大容量，但是这个背包需要考虑两个维度，这两个维度都不能超过上限，然后就是经典遍历，先遍历物品，物品无非两种情况，一个是装，就是背包的容量减去物品的容量剩余的容量最多可以装几个物品，然后加一，另一种就是不装，就是直接使用上一轮所装的物品个数，两种情况取最大值即可</p><h3 id="零钱兑换Ⅱ"><a href="#零钱兑换Ⅱ" class="headerlink" title="零钱兑换Ⅱ"></a>零钱兑换Ⅱ</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; coins.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coins[i];j &lt;= amount;j++)&#123;</span><br><span class="line">                dp[j] += dp[j - coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题和目标和的思路是一样的，就是装满背包大小为i的方式有几种，只不过这道题的物品都可以取多次，所以如果先遍历物品在遍历背包，在遍历背包的时候要正序遍历，这样就能保证每个物品取到多次，最关键的点在于物品和背包的遍历顺序，是不能颠倒的，因为本题中，先放2再放1和先放1再放2，这俩结果是一样的，也就是说<strong>先物品后背包得到的是组合，先背包后物品得到的是排列</strong>，本题要求的是组合，所以先物品后背包，加入背包的顺序严格按照物品遍历的顺序</p><h3 id="组合总和Ⅳ"><a href="#组合总和Ⅳ" class="headerlink" title="组合总和Ⅳ"></a>组合总和Ⅳ</h3><p><a href="https://leetcode.cn/problems/combination-sum-iv/description/">377. 组合总和 Ⅳ - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; dp.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i - nums[j] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i] += dp[i - nums[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题和上一题是一样一样的，都是问装满背包有几种方式，但是这道题求的是排列，也就是说拿元素的不同顺序也算不同的方式，所以要先遍历背包后遍历物品，再强调一遍，<strong>先物品后背包得到的是组合，先背包后物品得到的是排列，求装满背包的最大价值的时候遍历顺序无所谓</strong></p><h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h3><p><a href="https://leetcode.cn/problems/coin-change/description/">322. 零钱兑换 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length;i++)&#123;</span><br><span class="line">            dp[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; coins.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coins[i];j &lt;= amount;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j - coins[i]] != max)&#123;</span><br><span class="line">                    dp[j] = Math.min(dp[j - coins[i]] + <span class="number">1</span>,dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == max ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题其实和前面的题是一样的，但是转了一个小弯，前面的题问的都是装满背包最多如何如何，但是本题要求的是装满背包最少需要多少件物品，所以初始化dp数组就要变一下，以前把dp数组都初始化为0，为的是防止使用max方法求最大值的时候，把正确的值覆盖掉，这道题要求最小物品数量，所以为了防止把正确的结果覆盖掉，所以dp初始化的值应该尽可能大（例如Integer.MAX_VALUE - 1），最后别忘了，只有当遍历到的dp数组的值不是Integer.MAX_VALUE - 1的时候，说明才有装满的可能，这时才对数组本身和减去当前物品容量加一取最小值，即dp[j] &#x3D; Math.min(dp[j - coins[i]] + 1,dp[j]);</p><h2 id="hot100"><a href="#hot100" class="headerlink" title="hot100"></a>hot100</h2><h3 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h3><p><a href="https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked">49. 字母异位词分组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        ArrayList&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Map&lt;String,List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; strs.length;i++)&#123;</span><br><span class="line">            <span class="type">char</span>[] ch = strs[i].toCharArray();</span><br><span class="line">            Arrays.sort(ch);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">                map.get(key).add(strs[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ArrayList&lt;String&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                tmp.add(strs[i]);</span><br><span class="line">                map.put(key,tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; list : map.values())&#123;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键点在于字母异位词的特点，就是这些单词在排序以后是一模一样的，那么我们就可以把每一个词排序后的样子作为key放到map中，然后如果这个map中有key，直接就往这个key对应的集合中存放这个字符串即可</p><h3 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h3><p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked">128. 最长连续序列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : set)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> num;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(num - <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">while</span>(set.contains(cur + <span class="number">1</span>))&#123;</span><br><span class="line">                    cur++;</span><br><span class="line">                &#125;</span><br><span class="line">                res = Math.max(res,cur - num + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为要求的是连续序列，所以数组中的相同元素对我来说一定是没用的，所以可以直接使用set集合进行去重，然后遍历set集合中的元素，只有当遍历到的元素num，在集合中不存在num-1这么大的元素，才开始计数，因为这样才有可能最大</p><h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h3><p><a href="https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked">283. 移动零 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[index] = nums[i];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; nums.length;i++)&#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要被题目的名字迷惑，题目说移动零，但是如果真的去移动零，需要操作的次数就比较多，所以我们可以先移动非零元素，然后根据数组的长度进行补零操作即可</p><p>如果真的想要移动零，不要一位一位的动，只有当当前元素不为零的时候才进行移动，如下代码,j指针始终指向的零，当i指针指向不是零时候进行交换即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(nums==<span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两个指针i和j</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line"><span class="comment">//当前元素!=0，就把其交换到左边，等于0的交换到右边</span></span><br><span class="line"><span class="keyword">if</span>(nums[i]!=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">nums[i] = nums[j];</span><br><span class="line">nums[j++] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="盛水最多的容器"><a href="#盛水最多的容器" class="headerlink" title="盛水最多的容器"></a>盛水最多的容器</h3><p><a href="https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-100-liked">11. 盛最多水的容器 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            max = Math.max(max,(right - left) * Math.min(height[left],height[right]));</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用两块板从外向里移动的思路，这样移动不管是移动哪块板，长度一定是减小的，然后如果移动长板此时容量一定减小，因为长度一定减小高度可能不变或者减小，只有移动短板才可能让容量增大，所以每次只移动短板即可，如果两块板相同移动任何一块板都行，因为如果移动以后变短了还会继续移动，如果移动后变大了那么就会保留并移动另一块</p><h3 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h3><p><a href="https://leetcode.cn/problems/trapping-rain-water/description/?envType=study-plan-v2&envId=top-100-liked">42. 接雨水 - 力扣（LeetCode）</a></p><ul><li>单调栈</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        LinkedList&lt;Data&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; height.length;i++)&#123;</span><br><span class="line">            <span class="type">Data</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>(height[i],i);</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;stack.peek().height &lt; right.height)&#123;</span><br><span class="line">                <span class="type">Data</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">Data</span> <span class="variable">left</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">                <span class="keyword">if</span>(left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> right.index - left.index - <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> Math.min(right.height,left.height) - pop.height;</span><br><span class="line">                    sum += width * high; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">        <span class="type">int</span> height;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Data</span><span class="params">(<span class="type">int</span> height,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.height = height;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助栈这个数据结构来帮助解题，但是这个栈是单调的，就是在往栈里面加入柱子的时候，柱子的高度必须是逐渐递减的，因为这样一定接不住水，只有当加入的柱子是比前一个高的时候才可以存住水，所以在每次向栈里面加柱子的时候如果前面的柱子比要加的柱子矮，要全部弹出直到找到第一个比要加的柱子高或者一样高柱子，才把这个柱子加进去，然后就计算接水就是算面积</p><ul><li>双指针</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(height.length &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] leftMax = <span class="keyword">new</span> <span class="title class_">int</span>[height.length];</span><br><span class="line">        <span class="type">int</span>[] rightMax = <span class="keyword">new</span> <span class="title class_">int</span>[height.length];</span><br><span class="line">        leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        rightMax[rightMax.length - <span class="number">1</span>] = height[height.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; leftMax.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            leftMax[i] = Math.max(height[i], leftMax[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> rightMax.length - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            rightMax[i] = Math.max(height[i], rightMax[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= height.length - <span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> Math.min(leftMax[i],rightMax[i]) - height[i];</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sum += tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双指针的思路是遍历统计每一列柱子可以存放的水(第一列和最后一列除外)，他的方法就是找到这个柱子左边的最高柱子和右边的最高的柱子，然后减去自身的高度，就是该列可以存放的水，但是如果每列都分别向右和向左遍历寻找最高的柱子，那么在力扣上面是超时的，所以需要对找最高柱子进行优化，也就是维护两个数组，一个数组记录每个柱子右边的最高高度，一个数组记录每个柱子左边的最高高度，通过自身高度和左&#x2F;右柱子最高高度，进行比较，如果比左&#x2F;右边的最高高度高，那么这个柱子自身就是自己左&#x2F;右边的最高高高度，如果比左&#x2F;右边的最高高度矮，那就沿用左&#x2F;右边的的最高高度，然后进行求解时候直接拿到每列柱子的左右边最高高度，然后拿到这两个高度的最小值，减去自身高度，如果大于零那么就是说明自身不是最高高度，可以存水，直接相加</p><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-100-liked">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                left = Math.max(left,map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i),i);</span><br><span class="line">            max = Math.max(max,i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>滑动窗口的思路，通过不断移动左右边界来获取最大长度，通过一个map帮助我们判断是否含有重复的值，刚开始遍历的时候左右边界都是索引为0，然后右边界开始移动，在移动的过程中如果遇到的值和map中的key都不相同，则以值key索引为value放到map中，通过记录此时的最大边界，如果右边界移动过程中出现和map中的key相同的元素，这时要更新左边界，左边界的值是自身和map中记录的位置的最大值，这是为了防止有其他的元素更新了左边界，然后出现左边界左移的情况</p><h3 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h3><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked">438. 找到字符串中所有字母异位词 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] sArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] pArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; p.length();i++)&#123;</span><br><span class="line">            pArr[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;right &lt; s.length();right++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rigCur</span> <span class="operator">=</span> s.charAt(right) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            sArr[rigCur]++;</span><br><span class="line">            <span class="keyword">while</span>(sArr[rigCur] &gt; pArr[rigCur])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">leftCur</span> <span class="operator">=</span> s.charAt(left) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                sArr[leftCur]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right - left + <span class="number">1</span> == p.length())&#123;</span><br><span class="line">                res.add(left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用两个数组进行是不是异位词进行判断，如果s数组某一个元素对应的值大于p数组对应的值，说明左右指针内的字符串一定不能成为p的异位词，所以此时要移动左指针，直到s数组的值不大于p数组的值，只有这样才有可能成为异位词，然后当左右指针相差3的时候收集即可</p><h3 id="和为k的子数组"><a href="#和为k的子数组" class="headerlink" title="和为k的子数组"></a>和为k的子数组</h3><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked">560. 和为 K 的子数组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] presum = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; presum.length;i++)&#123;</span><br><span class="line">            presum[i] = presum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; presum.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(presum[i] - k))&#123;</span><br><span class="line">                res += map.get(presum[i] - k);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(presum[i],map.getOrDefault(presum[i],<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前缀和 + hashmap的妙用，当求数组连续子序列的时候可以考虑前缀和，前缀和说白了就是高中数列里面的Sn，Sn是数列前n个数的和，当我们要数列中某几个连续数的和的时候，可以让两个Sn相减，比如求第2，3，4个数的和，就是S4 - S1，明白这个道理之后，这道题就变成了两数之和，维护一个presum数组，每个位置表示nums数组第i个数以前的所有数之和(包括i)，这样如果map中数组存在presum[i] - k这个key，那么就在res上进行累加即可，最关键的点在于别忘了map初始化的时候要map.put(0,1),这是为了如果某个前缀和正好是k的时候，说明从nums数组第一个数开始进行累加就能加到k，如果此时map中没有put(0,1)，这时就会少算一种情况</p><h3 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h3><p><a href="https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-100-liked">76.  最小覆盖子串- 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] sa = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">60</span>];</span><br><span class="line">        <span class="type">int</span>[] ta = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">60</span>];</span><br><span class="line">        <span class="type">char</span>[] ch = t.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">tot</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ch.length;i++)&#123;</span><br><span class="line">            ta[getIndex(ch[i])]++;</span><br><span class="line">            <span class="keyword">if</span>(ta[getIndex(ch[i])] == <span class="number">1</span>)&#123;</span><br><span class="line">                tot++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;right &lt; s.length();right++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">indexRight</span> <span class="operator">=</span> getIndex(s.charAt(right));</span><br><span class="line">            sa[indexRight]++;</span><br><span class="line">            <span class="keyword">if</span>(sa[indexRight] == ta[indexRight])&#123;</span><br><span class="line">                tot--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">indexLeft</span> <span class="operator">=</span> getIndex(s.charAt(left));</span><br><span class="line">                <span class="keyword">if</span>(sa[indexLeft] &gt; ta[indexLeft])&#123;</span><br><span class="line">                    sa[indexLeft]--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tot == <span class="number">0</span> &amp;&amp; (ans.length() == <span class="number">0</span>||ans.length() &gt; right - left + <span class="number">1</span>))&#123;</span><br><span class="line">                ans = s.substring(left,right + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span> ? c - <span class="string">&#x27;A&#x27;</span> + <span class="number">26</span> : c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典使用两个数组保存字符串对应字符出现的次数，使用ta数组用来存储目标字符串，使用sa数组用来大字符串，使用tot表示目标字符串不同字符的种类，然后使用左右指针，遍历大字符串，右指针往数组里面添加，如果右指针指向的字符对应的个数大于等于ta数组右指针对应的个数，那么tot的值减一，然后看左指针，如果左指针指针指向的字符对应的个数比ta数组对应位置的值大，这时左指针向右移动，注意不要忘了把sa数组对应左指针的值减一，然后只有当tot &#x3D;&#x3D; 0，并且ans &#x3D;&#x3D; 0或者ans字符串比左右指针包含的字符串长的时候，才对ans的值进行更新</p><h3 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a>轮转数组</h3><p><a href="https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&envId=top-100-liked">189. 轮转数组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">        reverse(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>);</span><br><span class="line">        reverse(nums,<span class="number">0</span>,k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums,k,nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[left];</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            nums[right] = tmp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 nums &#x3D; [1，2，3，4，5，6，7]，k &#x3D; 3，来说，从我们的直观感受来看，就是要把 [5，6，7]这块砍下来挪到数组头部，可是这显然不是原地交换。那有没有什么办法让[5，6，7]这3个元素跑到数组头部呢？那就是将整个数组翻转一次，数组翻转是可以原地实现的，这样 [7，6，5]这3个元素就跑到头部了，我们以下标为k的元素将nums在逻辑上分隔为2个数组，分别是[7，6，5]和[4，3，2，1]，然后分别再进行一次翻转，就可以得到[5，6，7，1，2，3，4]了</p><ol><li>反转整个数组</li></ol><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231207120032469.png" class title="image-20231207120032469"><ol start="2"><li>以k为分界点分别反转</li></ol><img src="/2023/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20231207120101088.png" class title="image-20231207120101088"><h3 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h3><p><a href="https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-100-liked">238. 除自身以外数组的乘积 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">          ans[i] = j;</span><br><span class="line">          j *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>,j = <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">          ans[i] = ans[i] * j;</span><br><span class="line">          j *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前有一道利用前缀和进行求解，而这道题的思路是前缀积，就是两个for循环，第一for循环先将小于i前半部分的nums[i]相乘，第二个for循环将后半部分nums[i]接着相乘，本题看不懂代码的时候可以举个例子带入帮助理解</p><h3 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h3><p><a href="https://leetcode.cn/problems/first-missing-positive/description/?envType=study-plan-v2&envId=top-100-liked">41. 缺失的第一个正数 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] &gt;= <span class="number">1</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">                 <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[nums[i] - <span class="number">1</span>];</span><br><span class="line">                 nums[nums[i] - <span class="number">1</span>] = nums[i];</span><br><span class="line">                 nums[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n ; i++)</span><br><span class="line">            <span class="keyword">if</span>( nums[i] != i + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题，对于一个长度为n的数组，要返回的答案一定在[1，n+1]之间，数组中的数都满足nums[i] &#x3D; nums[nums[i] - 1]的时候，说明此时结果是n + 1,所以需要对原数组的元素的进行重新排序，也就是尽可能保证nums[i] &#x3D; nums[nums[i] - 1]成立，所以这个地方的思路是如果nums[i] &#x3D; nums[nums[i] - 1]不成立，就对nums[i] 和nums[nums[i] - 1]进行交换，直到交换到成立或者交换来的数不在范围内，才交换下一个数</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程笔记</title>
      <link href="/2023/07/23/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/23/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="并发编程笔记"><a href="#并发编程笔记" class="headerlink" title="并发编程笔记"></a>并发编程笔记</h2><h4 id="wait-amp-notify"><a href="#wait-amp-notify" class="headerlink" title="wait&amp;notify"></a>wait&amp;notify</h4><ul><li>原理</li></ul><p>已经获得锁的线程发现后续的运行不满足条件时，会调用wait方法，线程状态变成waiting，此时和等待锁的线程一样处于阻塞状态，不会占用CPU的时间片，只有当其他线获取到锁并且满足此线程运行的条件后，调用**notify(挑一个线程唤醒)或者notifyAll(唤醒所有线程)**方法唤醒该线程，使得该线程重新进入到队列中重新争抢锁</p><img src="/2023/07/23/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20230723173807210.png" class title="image-20230723173807210"><ul><li>wait&amp;sleep</li></ul><ol><li>区别</li></ol><p>①wait是Object的方法，sleep是Thread的方法</p><p>②调用wait会释放掉锁，而sleep还会占用着锁</p><p>③sleep不需要配合synchronized使用，wait必须要获得到锁才能调用，所以必须配合synchronized使用</p><ol start="2"><li>相同点：</li></ol><p>调用wait和sleep都会使线程进入到TIMED_WAITING状态</p><ul><li>wait&amp;notify的正确使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可能不满足条件的线程部分</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    <span class="keyword">while</span>(!条件不成立)&#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//干活代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改条件使以上线程继续运行的线程部分</span></span><br><span class="line">lock.notifyAll();</span><br></pre></td></tr></table></figure><p><strong>wait一般和notifyAll配合使用，如果使用的是notify，且该锁对象中有多个调用了wait方法的线程，此时因为随机唤醒线程的原因，会导致虚假唤醒的发生</strong></p><h4 id="同步模式-保护性暂停"><a href="#同步模式-保护性暂停" class="headerlink" title="同步模式-保护性暂停"></a>同步模式-保护性暂停</h4><p><em>一个线程需要等待另一个线程的执行结果</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">protectStop</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;等待获取&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> guardedObject.get(<span class="number">2000</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;结果为：&#123;&#125;&quot;</span>,o);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行任务&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                guardedObject.complete(res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">        <span class="comment">//记录开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//记录经历时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">passTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (timeout - passTime &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.wait(timeout - passTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                passTime = System.currentTimeMillis() - begin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.response = obj;</span><br><span class="line">            <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="join原理"><a href="#join原理" class="headerlink" title="join原理"></a>join原理</h4><p><em>与保护性暂停的原理相同，都是根据开始时间和经过时间进行判断</em></p><ul><li>源码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深入理解Java虚拟机》阅读笔记</title>
      <link href="/2023/07/03/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/03/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校长书籍推荐</title>
      <link href="/2023/07/03/%E6%A0%A1%E9%95%BF%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"/>
      <url>/2023/07/03/%E6%A0%A1%E9%95%BF%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<img src="/2023/07/03/%E6%A0%A1%E9%95%BF%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/image-20230703172235266.png" class title="image-20230703172235266"><p>MySQL性能优化指南（提高实操性）</p><p>MySQL技术内幕：innodb存储引擎</p><p>深入理解Java虚拟机：看2，3，7，8，12章</p><p>并发编程的艺术</p><p>netty redis zk</p><p>redis设计与实战：5，9，<strong>10</strong>，11，15，16，17</p><p>设计模式：（等校长的书）</p><p>spring源码：先不看了</p><p>springboot技术内幕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二篇博客</title>
      <link href="/2023/07/02/javaweb/"/>
      <url>/2023/07/02/javaweb/</url>
      
        <content type="html"><![CDATA[<h2 id="IDEA工具开发Servlet程序"><a href="#IDEA工具开发Servlet程序" class="headerlink" title="IDEA工具开发Servlet程序"></a>IDEA工具开发Servlet程序</h2><ol><li>第一步：New Project 创建一个空项目，然后在空工程下新建Module模块（这不是必须的，只是一个习惯），可以直接创建一个非空的Project,起名为javaweb（不是必须的）</li><li>第二步：新建模块(File–&gt;new–&gt;Module..)</li></ol><ul><li>这里新建的是一个普通的JavaSE模块(这里先不要新建Java Enterprise模块)</li><li>这个Module自动会被放在Javaweb的project下面</li><li>Module起名：servlet01</li></ul><ol start="3"><li>第三步：让Module变成JavaEE模块(让Module变成javaweb的模块)</li></ol><ul><li>在Module上右键点击:Add Framework Support(添加框架支持)</li><li>在弹出的窗口，选择Web Application(选择的是webapp的支持)</li><li>选择了这个webapp支持后，idea会自动生成一个符合servlet规范的webapp目录结构</li><li><strong>重点，需要注意：在idea工具中根据Web Application模块生成的目录中有一个web目录，这个目录就代表webapp的根</strong></li></ul><ol start="4"><li>第四步（非必须）：根据Web Application生成的资源中有index.jsp文件，这里可以选择删除这个index.jsp文件</li><li>第五步：编写servlet</li></ol><ul><li>class studentServlet implements Servlet</li><li>这个时候发现Servlet.class文件没有，怎么办？将CATALINA_HOME&#x2F;lib&#x2F;servlet-api.jar添加到class.path当中(File–&gt;Project Structrue–&gt;Modules–&gt;+加号–Add jars…)</li><li>实现jakarta.servlet.Servlet接口中的五个方法</li></ul><ol start="6"><li>第六步：在Servlet当中的servlet方法中编写业务代码并连接数据库。</li><li>第七步：在WEB-INF目录下新增了一个子目录：lib(这个目录名不能随意，必须全部小写),并且将连接数据库驱动的jar包放到lib目录下。</li><li>第八步：在web.xml文件中完成StudentServlet类的注册（请求路径和servlet对应起来）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>studentServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.javaweb.servlet.StudentServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>studentServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet/student<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="9"><li>第九步：写一个html页面写一个超链接，用户点击这个超链接，发送请求。Tomcat执行后台的studentServer</li></ol><ul><li>student.html</li><li>这个文件不能放到WEB-INF目录中,只能放到WEB-INF目录外面</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>student list<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/xmm/servlet/student&quot;</span>&gt;</span>第一个servlet<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="10"><li>第十步：让idea工具去关联Tomcat，关联的过程中将webapp部署到Tocmat服务器中。</li></ol><ul><li>idea工具右上角，绿色锤子旁边有一个：Add Configuration</li><li>点击加号，点击Tomcat Server–&gt;local</li><li>在弹出的界面中设置服务器Server的参数(基本不用动)</li><li>在当前窗口中有一个Deployment(点击这个用来部署webapp),继续点击加号，部署即可</li><li>修改Application context为：html页面中的项目名&#x2F;xmm</li></ul><ol start="11"><li>第十一步：启动Tomcat服务器</li></ol><ul><li>点击右上角的小虫子，可以采用debug的模式启动Tomcat服务器</li><li>我们在开发中建议使用debug的方法启动Tomcat</li></ul><ol start="12"><li>打开浏览器在地址栏输入：http:localhost:8080&#x2F;xmm&#x2F;student.html</li></ol><h2 id="servlet的生命周期"><a href="#servlet的生命周期" class="headerlink" title="servlet的生命周期"></a>servlet的生命周期</h2><ol><li>servlet对象是由谁来维护</li></ol><ul><li>servlet对象的创建，对象的方法调用和对象的销毁，java程序员无权干预</li><li>servlet对象的生命周期是由Tomcat服务器负责的</li><li>Tomcat服务器通常称为WEB容器，WEB容器管理Servlet对象的死活</li></ul><ol start="2"><li><p>自己new的servlet的对象不归WEB容器管理(WEB容器创建的Servlet对象，这些对象会被放到一个集合中管理，自己new的对象不在容器当中)</p></li><li><p>Tomcat服务器在默认情况下Servlet对象不会被实例化，这个设计是合理的，如果提前创建出来所有的Servlet对象，必然是耗费内存的，并且如果创建出来的Servlet如果一直没有用户访问，显然这个Servlet是一个废物，没有必要先创建</p></li><li><p>servlet对象生命周期</p></li></ol><ul><li>用户发送第一次请求的时候，servlet对象实例化，并且执行无参构造方法</li><li>对象创建之后，Tomcat立马调用init方法(init方法执行的时候，servlet对象已经存在，已经被创建出来了)</li><li>init方法执行后，Tomcat立马调用了servlet的service方法</li><li>用户第二、三、四……次请求的时候，servlet对象不会新建，还是使用之前新建的servlet对象，此时直接调用service方法，这说明：<ul><li>第一：servlet对象是单例的（单实例的，需要注意：servlet对象是单实例的，但是servlet类并不符合单例模式，我们称之为假单例。之所以单例是因为servlet对象的创建java程序员不管，对象的创建是由Tomcat说了算的，Tomcat只创建了一个，所以导致了单例，但是属于假单例，真单例模式构造方法是私有化的）</li><li>第二：无参数构造方法，init得到只在第一次用户发送请求的时候执行，也就是说无参数构造方法只执行一次，init方法只调用一次</li><li>第三：用户发一次请求service方法必然会被Tomcat服务器调用一次</li></ul></li></ul><ol start="5"><li>关闭服务器</li></ol><ul><li>servlet的destroy方法会被Tomcat调用一次</li><li>destroy方法是在服务器关闭的时候调用的，因为要销毁对象的内存</li><li>销毁对象内存之前，Tomcat服务器会自动调用destroy方法，destroy方法调用之前，对象还在没有销毁，方法执行结束后，对象内存才被Tomcat释放</li></ul><ol start="6"><li>当我们在Servlet类中编写一个有参构造方法，没有手动编写无参构造方法会出现什么问题？</li></ol><ul><li>报500错误，是一个HTTP协议的错误状态码</li><li>500一般情况下是因为服务器端的Java程序出了问题，没有无参构造方法，会导致出现500错误，无法实例化Servlet对象</li><li>所以一般情况下不建议程序员定于构造方法</li></ul><ol start="7"><li>构造方法和init都是在对象创建的时候执行一次，能不能用无参构造方法代替init方法？</li></ol><ul><li>不能，因为作为Java程序员，编写Serclet类的时候，不建议手动编写构造方法，很容易让无参构造方法消失，这个操作很可能使Servlet无法实例化</li></ul><ol start="8"><li>init，destroy，service方法什么时候使用</li></ol><ul><li>使用最多的是service方法，service一定要实现，service方法是处理用户请求的核心方法</li><li>init方法很少用，通常在init方法中做初始化操作，并且这个初始化操作只执行一次，比如初始化数据库连接池，初始化线程池</li><li>destroy方法也很少用，进行资源的关闭，马上对象被销毁，还有什么没有关闭的抓紧时间关闭，还有什么资源没保存的抓紧保存。</li></ul><h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><ul><li><p>servlet是一个接口，是servlet规范中的一员</p></li><li><p>由Tomcat(WEB服务器)实现servletContext接口</p></li><li><p>ServletContext对象由WEB服务器在启动的时候创建的</p></li><li><p>对于一个webapp只有一个ServletContext对象，对象在服务器关闭的时候销毁</p></li><li><p>ServletContext对应的其实是web.xml文件，Tomcat是一个容器，一个webapp中可以放多个webapp，一个webapp对应一个ServletContext对象</p></li><li><p>ServletContext接口中常用的方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getInitParameter</span><span class="params">(String name)</span>;<span class="comment">//通过初始化参数name获取value</span></span><br><span class="line"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title function_">getInitParameterNames</span><span class="params">()</span>;<span class="comment">//获得所有初始化参数的name</span></span><br><span class="line"><span class="comment">//通过ServletContext对象记录日志</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message , Throwable t)</span></span><br><span class="line"><span class="comment">//这些日志记录到C:\Users\ZDKJ\AppData\Local\JetBrains\IntelliJIdea2020.2\tomcat\Unnamed_servlet02</span></span><br><span class="line"><span class="comment">//Tomcat服务器logs目录下的日志文件</span></span><br><span class="line"><span class="comment">//catalina.2022-11-03.log 服务器端的Java程序运行的控制台信息</span></span><br><span class="line"><span class="comment">//localhost.2022-11-03.log ServletContext对象的log方法记录的日志信息存储到这个文件中    </span></span><br><span class="line"><span class="comment">//   localhost_access_log.2022-11-03.txt 访问日志 </span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--以上两方法是获得以下配置信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>pageSize<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>10<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--以上配置信息属于应用级的配置信息，一般一个项目中共享的信息会放到以上的标签中--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果配置信息只是想给某个servlet作为参考，那么你配置到servlet标签中即可，使用ServletConfig获取即可--&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>ServletContext对象还有另一个名字：应用域（后面还有请求域，会话域等）</p></li><li><p>如果所有的用户共享一份数据，并且这个数据很少被修改，数据量很小，可以将这些数据放到ServletContext这个应用域中</p><ul><li>如果不是共享数据没有意义，因为Servlet对象只有一个，只有共享的数据放进去才有意义</li><li>数据量太大的话，太占用内存，并且这个对象的生命周期比较长，服务器关闭的时候才会被销毁，大量数据会影响服务器性能，占用内存较小的时候可以考虑放进去</li><li>所有用户共享的数据，如果涉及到频繁的修改的操作，必然会存在线程并发所带来的安全问题，为了解决线程安全问题只能使用锁机制,锁一旦使用最终会导致性能降低，所有在ServletContext对象中的数据一般都是只读的</li></ul></li><li><p>数据量小，所有用户共享，又不修改，这样放到ServletContext中，会大大提升效率，因为应用域相当于一个缓存，当道缓存中的数据，下次用的时候，不需要再次从数据库中获取，大大提升执行效率</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAttribute</span><span class="params">(String name,Object value)</span>;<span class="comment">//存</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getAtttibute</span><span class="params">(String name)</span>;<span class="comment">//取</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeAttribute</span><span class="params">(String name)</span>;<span class="comment">//删除</span></span><br></pre></td></tr></table></figure><ul><li><strong>注：以后编写Servlet方法的时候，实际上不会直接继承GenericServlet类的，因为我们是B&#x2F;S结构的系统，这种系统是基于HTTP找文本传输协议的，在Servlet规范中，提供了一个类叫做HttpServlet，它是专门为HTTP协议准备的一个Servlet类，我们编写的Servlet要继承HttpServlet。（HttpServlet是HTTP协议专用的）使用HttpServlet处理HTTP的时候更加便捷</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以上内容的继承结构</span></span><br><span class="line">jakarta.servlet.Servlet(接口)【爷爷】</span><br><span class="line">jakarta.servlet.GenericServlet <span class="keyword">implements</span> <span class="title class_">Servlet</span>(抽象类)【儿子】</span><br><span class="line">jakarta.servlet.HttpServlet <span class="keyword">extends</span> <span class="title class_">GenericServlet</span>(抽象类)【孙子】   </span><br></pre></td></tr></table></figure><ul><li><p>连接池</p><ul><li>这里所说的连接池的连接时Java语言连接数据库的连接对象：java.sql.Connection对象</li><li>JVM是一个进程，mysql是一个进程，进程和进程之间建立连接，打开通道是十分费劲的，很消耗资源，可以提前创建好N个Connection对象，将连接对象放到一个集合中，我们把这个放有Connection对象的集合称为连接池。每一次用户连接的时候不需要在新建连接对象，直接从连接池中获取连接对象，大大提升访问效率</li><li>连接池<ul><li>最小连接数</li><li>最大连接数</li><li>连接池可以提高用户访问效率，当然也可以保证数据库的安全性</li></ul></li></ul></li><li><p>线程池</p><ul><li>Tomcat服务器本身就是支持多线程</li><li>Tomcat服务器不是在用户发送一次请求，就新建一个Thread线程对象，会先创建好N个多线程Thread对象，然后将线程对象放到集合当中，称为线程池，用户发送请求过来后，需要有一个对应的线程来处理这个请求，这个时候线程对象会直接从线程池中拿，效率比较高</li><li>所有的WEB服务器，或者应用服务器，都是支持多线程的，都有线程池机制</li></ul></li></ul><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><ul><li>HTTP的响应协议(S–&gt;B)<ul><li>HTTP的响应协议包括四部分<ul><li>状态行</li><li>响应头</li><li>空白行</li><li>响应体</li></ul></li><li>HTTP的请求报文</li><li>状态行<ul><li>第一部分：版本协议号（HTTP&#x2F;1.11）</li><li>第二部分：状态码（HTTP协议中规定的响应状态号，不同的响应结果对应不同的号码）<ul><li>200表示响应成功，正常结束</li><li>404表示访问的资源不存在，通常是因为要么路径写错了，要么是路径写对了，但是服务器中对应的资源并没有启动成功，总之404错误是前端错误</li><li>405表示前端发送的请求方式与后端请求处理方式不一致时发生：<ul><li>比如：前端是POST请求，后端的处理方式按照get方式进行处理时，发生405</li><li>比如：前端是GET请求，后端的处理方式按照post方式进行处理时，发生405</li></ul></li><li>500表示服务器端的程序出现异常，一般会认为都武器端的错误导致的</li><li>以4开始的，一般是浏览器端错误导致的</li><li>以5开始的，一般是服务器端错误导致的</li></ul></li><li>第三部分：状态的描述信息<ul><li>ok表示正常成功结束</li><li>not found表示资源找不到</li></ul></li></ul></li><li>响应头<ul><li>响应的内容类型</li><li>相应的内容长度</li><li>响应的时间</li><li>….</li></ul></li><li>空白行<ul><li>用来分隔响应头和响应体</li></ul></li><li>响应体<ul><li>响应体是响应的正文，这些内容是一个长的字符串，这个字符串被浏览器渲染，解释并执行，最终展示出效果</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 ok                         状态行</span><br><span class="line">Content-Type:text/html;charset=UTF-8    响应头</span><br><span class="line">Content-Length:160</span><br><span class="line">Date:Mon,08 Nov 2021 13:19:36 GMT</span><br><span class="line">Keep-Alive:timeout=20</span><br><span class="line">Connection:keep-alive</span><br><span class="line">                                        空白行</span><br><span class="line">&lt;!doctype html&gt;                         响应体 </span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">       &lt;title&gt;from get servlet&lt;/title&gt;</span><br><span class="line">   &lt;/head&gt;</span><br><span class="line">   &lt;body&gt;</span><br><span class="line">       &lt;h1&gt;from get servlet&lt;/h1&gt;</span><br><span class="line">   &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;    </span><br></pre></td></tr></table></figure><ul><li>HTTP的请求协(B–&gt;S)<ul><li>请求行<ul><li>第一部分：请求方式（七种）<ul><li>get（常用的）</li><li>post（常用的）</li><li>delete</li><li>put</li><li>head</li><li>options</li><li>trace</li></ul></li><li>第二部分：URI<ul><li>URI是统一资源标识符，代表网络中某个资源的名字，但是通过URI是无法定位资源</li><li>URL是统一资源定位符。代表网络中某个资源，同时，通过URL是可以定位到该资源的</li><li>URL包括URI<ul><li><a href="http://localhost:8080/servlet/index.html%E8%BF%99%E6%98%AFURL">http://localhost:8080/servlet/index.html这是URL</a></li><li>&#x2F;servlet&#x2F;index.html这是URI</li></ul></li></ul></li><li>第三部分：HTTP协议版本号</li></ul></li><li>请求头<ul><li>请求的主机</li><li>主机的端口号</li><li>浏览器信息</li><li>平台信息</li><li>cookie</li><li>….</li></ul></li><li>空白行<ul><li>用来区分请求头和请求体</li></ul></li><li>请求体<ul><li>向服务器发送的具体数据</li></ul></li></ul></li><li>使用Chrome浏览器:F12，然后找到network，通过这个面板可以查看协议的具体内容</li><li>怎么向服务器发送GET请求，怎么向服务器发送的POST请求<ul><li>到目前为止，只有一种情况可以发送POST请求：使用form表单，并且在form标签中的method属性值为method&#x3D;”post”</li><li>其他情况一律是get请求：<ul><li>在浏览器地址栏直接输入的URL，敲回车，属于get请求</li><li>在浏览器上直接点击超链接，属于get请求</li><li>使用form表单提交数据时，form标签中没有method属性，默认是get</li><li>使用form的时候，form标签中的method属性值为method&#x3D;”get”</li><li>….</li></ul></li></ul></li><li>GET和POST请求的区别<ul><li>get请求发送数据的时候，数据会挂在URI的后面，并且在URI后面添加一个”?”，”?”后面是数据，这样会导致发送的数据显示在浏览器的地址栏中（get请求在请求行上发送数据）<ul><li><a href="http://localhost:8080/servlet/getServlet?username=dehua&password=666">http://localhost:8080/servlet/getServlet?username=dehua&amp;password=666</a></li></ul></li><li>post请求发送数据的时候，在请求体当中发送，不会回显到浏览器地址栏上，也就是说post发送的数据，在浏览器地址上看不到</li><li>get请求只能发送普通的字符串，并且发送的字符串长度有限制，不同的浏览器限制不同，没有明确规定</li><li>get请求无法发送大数据量</li><li>post请求可以发送任何类型的数据，包括普通字符串，流媒体等信息：视频、声音、图片</li><li>post请求可以发送大数据量，理论上没有长度限制</li><li>get请求在W3C中是这样说的：get请求比较适合从服务器端获取数据</li><li>post请求在W3C中是这样说的：post请求比较适合从浏览器向服务器端传送数据</li><li>get请求是安全的，get请求时绝对安全的，因为get请求只是为了从服务器上获取数据，不会对服务器造成威胁。（get请求本身是安全的，你不要用错了，用错了还冤枉人家get不安全，这好吗，这不好，那是你自己问题，不是get请求的问题）</li><li>post请求是危险的，因为post请求是向服务器提交数据，如果这些数据通过后门的方式进入到服务器当中，服务器是很危险的，另外post是为了提交数据，所以一般情况下拦截请求的时候，大部分会拦截（监听）post请求</li><li>get支持缓存<ul><li><a href="https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg">https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg</a></li><li>任何一个get请求最终的响应结果都会被浏览器存起来，在浏览器当中：<ul><li>一个get请求的路径a对应一个资源</li><li>一个get请求的路径b对应一个资源</li><li>一个get请求的路径c对应一个资源</li><li>…</li></ul></li><li>实际上只要发送了一个get请求，浏览器第一件事就是先从本地浏览器缓存中找，找不到的时候才会去服务器上获取，这种缓存机制目的是为了提高用户体验</li><li>如果有一个需求：不希望get请求走缓存，而是每次请求都去服务器上找资源，不去本地浏览器的缓存中获取<ul><li><a href="https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=948491511">https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=948491511</a></li><li><a href="https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=5661662">https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=5661662</a></li><li><a href="https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=%E7%B3%BB%E7%BB%9F%E6%AF%AB%E7%A7%92%E6%95%B0">https://wx2.sinaimg.cn/mw690/0076a0tuly1h7yyu4u881j30u014046n.jpg?t=系统毫秒数</a></li><li>解决方案：在每个路径的后面加一个时刻都在变化的时间戳，这样每次的路径都不一样，浏览器就不会走缓存了</li></ul></li></ul></li><li>post不支持缓存<ul><li>post请求之后，服务器的响应结果不会被浏览器缓存起来，因为这个缓存没有意义</li></ul></li></ul></li><li>如何选择get请求和post请求<ul><li>如果请求是想获取服务器的数据，建议使用get请求，如果这个给是为了向服务器提交数据，建议使用post请求</li><li>大部分的form表单是向服务器提交用户手机的大量数据，服务器将这些数据保存，使用post请求</li><li>如果表中敏感信息，建议使用post请求，因为get请求会把敏感信息显示到浏览器地址栏上（例如：密码信息）</li><li>做文件上传一定是post请求，因为这不是普通的文本</li><li>其他情况都可以使用get请求</li></ul></li><li>不管使用get请求还是使用post请求，发送数据的格式是完全相同的，只不过位置不同，格式是统一的：<ul><li>name&#x3D;value&amp;name&#x3D;value&amp;name&#x3D;value</li><li>以form表单为例，name是form表单中input标签的name</li><li>以form表单为例，value是form表单中input标签的value</li></ul></li></ul><h2 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">        <span class="type">long</span> lastModified;</span><br><span class="line">        <span class="keyword">if</span> (method.equals(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">            lastModified = <span class="built_in">this</span>.getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span> (lastModified == -<span class="number">1L</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">long</span> ifModifiedSince;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ifModifiedSince = req.getDateHeader(<span class="string">&quot;If-Modified-Since&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">                    ifModifiedSince = -<span class="number">1L</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ifModifiedSince &lt; lastModified / <span class="number">1000L</span> * <span class="number">1000L</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">                    <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp.setStatus(<span class="number">304</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line">            lastModified = <span class="built_in">this</span>.getLastModified(req);</span><br><span class="line">            <span class="built_in">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">            <span class="built_in">this</span>.doHead(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doPost(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;PUT&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doPut(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;DELETE&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doDelete(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;OPTIONS&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doOptions(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;TRACE&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doTrace(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;method&#125;;</span><br><span class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">            resp.sendError(<span class="number">501</span>, errMsg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过源码的分析，</span></span><br><span class="line"><span class="comment">/*假设前端发送的是get请求，后端程序员重写的是doPost方法，或者前端程序员发送的是post请求，后端程序员重写的是doPost方法，会发生405这样一个错误</span></span><br><span class="line"><span class="comment">405表示的是前端的错误，发送请求方式不对，和服务器不一致，不是服务器需要的请求方式，所以可以看出只要HttpServlet类中的doPost或者doGte方法执行了必然会导致405错误</span></span><br><span class="line"><span class="comment">所以只有后端重写了哪个方法，前端发送对应请求才能避免405错误</span></span><br><span class="line"><span class="comment">但是，不能为了避免405错误把doPost方法和doGet方法都重写，这样虽然能避免405错误，因为405错误还是有用的。该报错的时候就让他报错，而且如果你doGet和doPost方法都重写还不如直接重写servlet方法，这样代码量还少一些*/</span></span><br></pre></td></tr></table></figure><h2 id="web欢迎页"><a href="#web欢迎页" class="headerlink" title="web欢迎页"></a>web欢迎页</h2><ul><li><p>访问方式</p><ul><li>如果访问的是<a href="http://localhost:8080/servlet/index.html%E5%B0%B1%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E6%8C%87%E5%AE%9A%E7%9A%84%E8%B5%84%E6%BA%90">http://localhost:8080/servlet/index.html就直接访问指定的资源</a></li><li>如果访问的是<a href="http://localhost:8080/servlet%E6%B2%A1%E6%9C%89%E6%8C%87%E5%AE%9A%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%EF%BC%8C%E4%BC%9A%E8%AE%BF%E9%97%AE%E8%AE%BE%E7%BD%AE%E7%9A%84%E6%AC%A2%E8%BF%8E%E9%A1%B5">http://localhost:8080/servlet没有指定资源路径，会访问设置的欢迎页</a></li></ul></li><li><p>设置欢迎页步骤</p><ul><li><p>第一步：在idea工具的web目录下新建一个login.html</p></li><li><p>第二步：在web.xml文件中进行以下配置</p><ul><li><pre><code class="xml">    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;welcome/login.html&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - **注：设置欢迎页面的时候路径不需要以&quot;/&quot;开始，并且这个路径默认是从webapp的根下开始查找**</span><br><span class="line"></span><br><span class="line">  - 第三步：开启服务器，浏览器地址栏输入地址</span><br><span class="line"></span><br><span class="line">* 一个webapp可以设置多个欢迎页面</span><br><span class="line"></span><br><span class="line">  - ```xml</span><br><span class="line">        &lt;welcome-file-list&gt;</span><br><span class="line">            &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;</span><br><span class="line">            &lt;welcome-file&gt;welcome/login.html&lt;/welcome-file&gt;</span><br><span class="line">        &lt;/welcome-file-list&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>越靠上的优先级越高</p></li></ul></li><li><p>当文件名设置为index.html的时候，不需要再web.xml文件中进行欢迎页面的设置，因为在Tomcat服务器已经设置好了</p><ul><li><p>实际上设置欢迎页面的地方有两个</p><ul><li><p>一个在webapp内部的web.xml文件中(这个地方属于局部配置)</p></li><li><p>一个在CATALINA_HOME&#x2F;conf&#x2F;web.xml文件中进行配置(这个地方的配置属于全局配置)</p><ul><li><pre><code class="xml">    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      - Tomcat服务器的全局观影页面是：index.html,index.htm,index.jsp，如果一个web站点没有设置局部欢迎页面，Tomcat服务器会以index.html,index.htm,index.jsp作为一个web站点的欢迎页面</span><br><span class="line"></span><br><span class="line">      - 注意原则：局部优先原则（就近原则）</span><br><span class="line"></span><br><span class="line">- 欢迎页面也可以是一个Servlet</span><br><span class="line"></span><br><span class="line">## 关于WEB-INF目录</span><br><span class="line"></span><br><span class="line">* 在WEB-INF目录下新建一个welcome.html</span><br><span class="line">* 打开浏览器访问：http:localhost:8080/WEB-INF/welcome.html出现404错误</span><br><span class="line">* 注意：放在WEB-INF目录下的资源是受保护的，在浏览器上不能够通过路径直接访问，所以像html,css,javascrip,image等静态资源一定要放到WEB-INF之外</span><br><span class="line"></span><br><span class="line">## HttpServletRequest接口详解</span><br><span class="line"></span><br><span class="line">* request和response对象生命周期</span><br><span class="line">  - request对象和response对象，一个是请求对象，一个是响应对象。这两个对象只在当前请求中有效</span><br><span class="line">  - 一次请求对应一个request</span><br><span class="line">  - 两次请求对应两个request</span><br><span class="line"></span><br><span class="line">* HttpServletRequest接口常用方法</span><br><span class="line"></span><br><span class="line">  - ````java</span><br><span class="line">    Map&lt;String,String[]&gt; getParameterMap() //这个是获取整个Map</span><br><span class="line">    Enumeration&lt;String&gt; getParameterNames()//这个是获取Map集合中所以的key</span><br><span class="line">    String[] getParamterValues(String name)//根据key获取Map的value</span><br><span class="line">    String getParamter(String name)//获取value这个一维数组的第一个元素，这个方法最常用    </span><br><span class="line">    ````</span><br><span class="line"></span><br><span class="line">  - 前端提交的数据格式：username=kun&amp;password=999&amp;interest=sing&amp;interest=dance&amp;interest=basketBall&amp;interest=Rap</span><br><span class="line"></span><br><span class="line">**请求域对象**</span><br><span class="line"></span><br><span class="line">* 请求域对象的作用范围比应用域小很多，声明周期短很多，请求域只在一次请求内有效</span><br><span class="line"></span><br><span class="line">* 一个请求对象request对应一个请求域对象，一次请求结束之后请求域就销毁了</span><br><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  //请求域也有ServletContext中的三个方法</span><br><span class="line">  void setAttribute(String name,Object obj);</span><br><span class="line">  Object getAttribute(String name);</span><br><span class="line">  void removeAttribute(String name);</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul></li><li><p>请求域和应用域选择的原则一般是，选择内存占用较小的</p></li><li><p>跳转</p><ul><li><p>转发</p><ul><li><pre><code class="java">req.getRequestDispatcher(&quot;/test.html&quot;).forward(req,resp);//获取请求转发器对象，并调用转发器对象的forward方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 两个Servlet共享数据的方法</span><br><span class="line"></span><br><span class="line">  - 直接将数据放到ServletContext应用域当中，虽然可以，但是作用域的范围太大，占用资源太多，不建议使用</span><br><span class="line">  - 可以将数据放到request域当中，然后AServlet转发到BServlet，保证AServlet和BServlet在一次请求当中，这样可以做到两个servlet共享同一份数据</span><br><span class="line"></span><br><span class="line">* 转发的下一个资源不一定是一个servlet，只要是Tomcat服务器当中合法的资源都可以转发，例如：html....</span><br><span class="line"></span><br><span class="line">* **注：转发的时候路径写法要注意，转发的路径以&quot;/&quot;开始，不要加i项目名**</span><br><span class="line"></span><br><span class="line">* 关于两个容易混淆的方法</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  String username = request.getParameter(&quot;username&quot;);</span><br><span class="line">  //这个获取的是用户在浏览器中提交的数据，数据形式为 uri?username=zhangsan&amp;userpwd=123&amp;sex=1</span><br><span class="line">  Object obj = request.getAttribute(&quot;name&quot;);</span><br><span class="line">  //这个获取的是请求域中绑定的数据，在此之前肯定执行过，request.setAttribute(&quot;name&quot;,new Object());</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li><li><p>HttpServletRequest</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">remoteAddr</span> <span class="operator">=</span> request.getRemoteAddr();</span><br><span class="line"><span class="comment">//获取客户端的ip地址</span></span><br><span class="line">request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//设置请求字体字符集，显然这个方法处理的是Post请求乱码问题，不适用于Get请求</span></span><br><span class="line"><span class="comment">//Tomcat10之后，request请求体当中的字符集默认是UTF-8，不需要设置字符集，不会出现乱码问题</span></span><br><span class="line"><span class="comment">//Tomcat9之前，包括Tomcat9，如果前端请求体提交的是中文，后端获取后会出现乱码，要用这个方法解决</span></span><br><span class="line">request.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//在Tomcat9之前，包括Tomcat9,响应中文即输出在控制台的中文也是有乱码的，使用以上方法解决</span></span><br><span class="line"><span class="comment">//在Tomcat10之后，包括Tomcat10，响应中文的时候就不在出现乱码问题，以上代码不需要设置UTF-8</span></span><br><span class="line"><span class="comment">/*    &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span></span><br><span class="line"><span class="comment">               connectionTimeout=&quot;20000&quot;</span></span><br><span class="line"><span class="comment">               redirectPort=&quot;8443&quot; </span></span><br><span class="line"><span class="comment">               URIEncoding=&quot;UTF-8&quot;/&gt;          */</span></span><br><span class="line"><span class="comment">//修改CATALINA_HOME/conf/server.sml配置文件，为以上内容，可以解决get请求乱码问题，get请求发送的时候，数据是在请求行上提交的，不是在请求体上提交的</span></span><br><span class="line"><span class="comment">//从Tomcat8之后，URIEncoding的默认值就是UTF-8，所以get请求也不会有乱码了</span></span><br><span class="line"><span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> request.getContextPath();</span><br><span class="line"><span class="comment">//获取应用的根路径 输出/servlet05即项目名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line"><span class="comment">//获取请求方式 输出get/post....</span></span><br><span class="line"><span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI(); </span><br><span class="line"><span class="comment">//获取请求的URI 输出/servlet05/B这样的URI</span></span><br><span class="line"><span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> request.getServletPath();</span><br><span class="line"><span class="comment">//获取servlet path 输出/B这样的Servlet路径</span></span><br></pre></td></tr></table></figure><h2 id="纯Servlet增删改查项目的一个bug的解决"><a href="#纯Servlet增删改查项目的一个bug的解决" class="headerlink" title="纯Servlet增删改查项目的一个bug的解决"></a>纯Servlet增删改查项目的一个bug的解决</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type = <span class="string">&#x27;text/javascript&#x27;</span>&gt;</span><br><span class="line">         <span class="keyword">function</span> <span class="title function_">del</span> (deptno)&#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&#x27;删除后不可恢复，请慎重选择&#x27;</span>))&#123;</span><br><span class="line">             <span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;&quot;+contextPath+&quot;/dept/delete?deptno=&#x27;</span>+deptno</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;javascript:void(0)&#x27;</span> <span class="attr">onclick</span> = <span class="string">&#x27;del(&quot;+deptno+&quot;)&#x27;</span> &gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>这样写，当鼠标单击删除的时候，会报del方法未定义的错误</li><li>正确写法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type = <span class="string">&#x27;text/javascript&#x27;</span>&gt;</span><br><span class="line">         del = <span class="keyword">function</span> (<span class="params">deptno</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&#x27;删除后不可恢复，请慎重选择&#x27;</span>))&#123;</span><br><span class="line">             <span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;&quot;+contextPath+&quot;/dept/delete?deptno=&#x27;</span>+deptno</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>如果函数写在$(functiong{ })或者$().ready(function () {});内部，那么 οnclick&#x3D;”del(“+deptno+”)”; 时 ,不能写成  function del(){}，也不能写成var del&#x3D; function(){}，只能写成del &#x3D; function(){}。</strong></p><h2 id="在一个web应用中如何完成资源跳转"><a href="#在一个web应用中如何完成资源跳转" class="headerlink" title="在一个web应用中如何完成资源跳转"></a>在一个web应用中如何完成资源跳转</h2><ul><li><p>两种完成跳转的方式</p><ul><li>转发</li><li>重定向</li></ul></li><li><p>两种方式的区别</p></li><li><p>代码上的区别</p><p>​    转发</p><ul><li><pre><code class="java">RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;/dept/list&quot;);dispatcher.forward(&quot;request,response&quot;);//转发的时候是一次请求，不管转发了多少次，都是一次请求//AServlet转发到BServlet，再转发到CServlet不管转发了多少次都是一次request//这就是为什么调用forward方法的时候会将当前的request和response对象传给下一次Sevlet<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  重定向</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  response.sendRedirect(req.getContextPath()+&quot;/dept/list&quot;);</span><br><span class="line">  //注意：路径上要加上项目名，因为相当于浏览器发送请求</span><br><span class="line">  //以上代码会将请求路径：/oa/dept/list发送给浏览器，浏览器向服务器发一次全新的请求</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>形式上的区别</p><ul><li>转发（一次请求）<ul><li>在浏览器地址栏上的请求是<a href="http://localhost:8080/Servlet/a,%E6%9C%80%E7%BB%88%E8%AF%B7%E6%B1%82%E7%BB%93%E6%9D%9F%E5%90%8E%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BF%98%E6%98%AF%E8%BF%99%E4%B8%AA">http://localhost:8080/Servlet/a,最终请求结束后，浏览器地址栏还是这个</a></li></ul></li><li>重定向（两次请求）<ul><li>在浏览器地址栏上发送的请求是：<a href="http://localhost:8080/Servlet/a,%E6%9C%80%E7%BB%88%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E4%B8%8A%E6%98%BE%E7%A4%BA%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%AF%EF%BC%9Ahttp://localhost:8080/Servlet/b">http://localhost:8080/Servlet/a,最终在浏览器地址栏上显示的地址是：http://localhost:8080/Servlet/b</a></li></ul></li></ul></li><li><p>转发和重定向的本质区别</p><ul><li>转发：是由WEB服务器控制的，A资源跳转到B资源，这个跳转动作是Tomcat服务器内部完成的</li><li>重定向：是浏览器完成的，具体跳转到哪个资源，浏览器说了算</li></ul></li><li><p>转发和重定向如何选择</p><ul><li>如果在上一个Servlet中向request域中绑定了数据，希望在下一个Servlet当中把request域的数据取出来，使用转发机制</li><li>剩下所有的请求均使用重定向</li></ul></li><li><p>跳转的下一个资源没有要求，可以是Servlet，jsp，html…..</p></li></ul><h2 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h2><ul><li><p>在web.xml文件中进行Servlet信息的配置，显然效率开发比较低，而且对于一个大项目来说，最终的web.xml可能会达到几十兆</p></li><li><p>而且web.xml文件中的配置信息是很少修改的，所有在Servlet3.0版本之后推出注解开发，将配置信息写到Java类</p><ul><li>并不是不需要写配置文件了，一般是注释+配置文件的开发模式</li><li>一些不常修改的配置信息建议使用注解，一些可能会修改的信息建议写到配置文件中</li></ul></li><li><p>第一个注解</p><ul><li><pre><code class="java">import jakarta.servlet.annotation.WebServlet;@WebServlet(&quot;/wel&quot;)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 在Servlet类上使用：</span><br><span class="line"></span><br><span class="line">    - name：用来指定Servlet的名字，相当于&lt;servlet-name&gt;</span><br><span class="line">    - urlPatterns：用来指定Servlet的映射路径，可以指定多个字符串，相当于&lt;url-pattern&gt;</span><br><span class="line">    - loadOnStartUp：用来指定在服务器启动阶段是否加载该Servlet,相当于&lt;load-on-startup&gt;</span><br><span class="line">    - value：同样用来映射路径，可以指定多个字符串，注解属性名为value的时候，使用注解的时候，value属性名是可以忽略的</span><br><span class="line">    - 注意：不是必须将所有属性都写上，只需要提供需要的，属性是一个数组的时候，如果数组中只有一个元素，使用该注解的时候，属性值的大括号可以省略</span><br><span class="line"></span><br><span class="line">* 注解对象的使用格式</span><br><span class="line"></span><br><span class="line">  - @注解名称(属性名=属性值，属性名=属性值.....)</span><br><span class="line"></span><br><span class="line">## jsp</span><br><span class="line"></span><br><span class="line">* jsp的基本语法</span><br><span class="line"></span><br><span class="line">  - 在jsp文件中直接编写文字，会被翻译到Servlet类的service方法的out.write(&quot;&quot;)的双引号中，被Java程序当作普通字符串输出到浏览器</span><br><span class="line">- 在jsp文件中编写html，css，js代码，这些代码对于jsp来说也是一个普通字符串，但是把这些普通字符串一旦输出浏览器，浏览器会对这些html，css，js代码进行解释执行，呈现出对应效果</span><br><span class="line">  - 乱码问题的解决</span><br><span class="line"></span><br><span class="line">    - 通过page指令设置相应的内容类型，在内容类型的后面添加：charset=UTF-8</span><br><span class="line">    - &lt;%@page contentType=&quot;text/html;charset=UTF-8&quot;%&gt;,表示响应的内容是text/html采用的字符集是UTF-8</span><br><span class="line">  - 在jsp中编写Java代码</span><br><span class="line">  </span><br><span class="line">  - &lt;% Java语句 %&gt;</span><br><span class="line">      - 在这个符号中编写的被视为Java程序，被编译到Servlet类的service方法内部</span><br><span class="line">    - 时刻记住此时此刻，你正在一个方法体的内部编写代码，想清楚什么能写，什么不能写，例如：不能写静态代码块，不能写方法，不能定义成员变量</span><br><span class="line">      - 在service方法中编写的的代码是有顺序的，方法体当中的代码遵循自上而下顺序进行执行</span><br><span class="line">      - 一个jsp文件中可以出现多个&lt;%%&gt;符号</span><br><span class="line">    - &lt;!%%&gt;</span><br><span class="line">      - 在这个符号中编写的Java程序会自动翻译到service方法之外</span><br><span class="line">      - 这个语法很少用，因为在service方法编写静态变量和实例变量，都会存在线程安全问题，jsp就是servlet，servlet是单例的，多线程并发的环境下，这个静态的变量和实例变量一旦有修改操作，必然会存在线程安全问题</span><br><span class="line">    - jsp输出语句</span><br><span class="line">      - 输出语句是像浏览器输出一个Java变量</span><br><span class="line">      - 语法&lt;% String name = &quot;dehau&quot;; out.write(&quot;name=&quot; + name) %&gt;</span><br><span class="line">      - 注意：以上代码中out是jsp的九大内置对象之一，可以直接拿来调用，必须在service方法内部</span><br><span class="line">  - &lt;%= %&gt;，等号后面写上输出的内容，会被翻译到service方法中，翻译成out.print();（输出的内容含有Java变量，输出的内容是一个动态内容，而输出一个死的字符串就直接在jsp中写就能输出）</span><br><span class="line">  </span><br><span class="line">* JSP指令</span><br><span class="line"></span><br><span class="line">  - 指令的作用：指导JSP的翻译引擎，如何工作(指导当前jsp翻译引擎如何翻译jsp文件)</span><br><span class="line"></span><br><span class="line">  - 指令包括：</span><br><span class="line"></span><br><span class="line">    - include：包含指令，在jsp中完成静态包含，很少用了</span><br><span class="line">    - taglib：引入标签库的指令，先不管</span><br><span class="line">    - page：重点</span><br><span class="line"></span><br><span class="line">  - 指令语法：</span><br><span class="line"></span><br><span class="line">    - &lt;%@指令名 属性名=属性值 属性名=属性值 属性名=属性值....%&gt;</span><br><span class="line"></span><br><span class="line">  - page指令中常用属性</span><br><span class="line"></span><br><span class="line">    - ```jsp</span><br><span class="line">      &lt;%@page session=&quot;true/false&quot;%&gt;</span><br><span class="line">      true表示启用jsp内置对象session，表示一定启动session对象，没有会创建，如果没有设置，默认值是session=&quot;true&quot;</span><br><span class="line">      session=&quot;false&quot;表示不启动内置对象session，当前jsp页面无法使用内置对象</span><br></pre></td></tr></table></figure>- ```jsp  &lt;%@page contentType=&quot;text/json&quot;%&gt;  contentType属性用来设置响应内容的类型  同样可以设置字符集  &lt;%@page contentType=&quot;text/json;charset=&quot;UTF-8&quot;%&gt;  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```jsp</span><br><span class="line">  &lt;%@page pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">  pageEncoding=&quot;UTF-8&quot;表示设置响应时采用的字符集</span><br></pre></td></tr></table></figure>- ```jsp  &lt;%@page import=&quot;java.util.*&quot;%&gt;  import语句，导包  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```jsp</span><br><span class="line">  &lt;%@page errorPage=&quot;/error.jsp&quot;%&gt;</span><br><span class="line">  当页面出现错误的时候，跳转到error.jsp页面</span><br><span class="line">  errorPage属性用来指定出错之后跳转的错误位置</span><br></pre></td></tr></table></figure>- ```jsp  &lt;%@page isErrorPage=&quot;true&quot;%&gt;  表示启用jsp九大内置对象之一：exception  默认值是false  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">  - jsp九大内置对象</span><br><span class="line"></span><br><span class="line">    - jakarta.servlet.jsp.PageContext  pageContext 页面作用域</span><br><span class="line">    - jakarta.servlet.http.HttpServletRequest  request 请求作用域</span><br><span class="line">    - jakarta.servlet.http.HttpSession  session 会话作用域</span><br><span class="line">    - jakarta.servlet.ServletContext  application 应用作用域</span><br><span class="line">      - pagecontext&lt;request&lt;session&lt;application</span><br><span class="line">      - 以上四个作用域都有：setAttribute,getAttribute,removeAttribute方法</span><br><span class="line">      - 以上作用域尽可能使用最小的</span><br><span class="line">    - jakarta.lang.Throwable  expection</span><br><span class="line">    - jakarta.servlet.ServletConfig  config</span><br><span class="line">    - jakarta.lang.Object  page(其实是this，当前的servlet对象)</span><br><span class="line">    - jakarta.servlet.jsp.jspWriter out(输出语句)</span><br><span class="line">    - jakarta.servlet.http.HttpServletResponse  response(负责响应)</span><br><span class="line"></span><br><span class="line">* jsp本质是一个servlet，和servlet到底有什么区别</span><br><span class="line">  - servlet的职责：擅长收集数据(强项是逻辑处理，然后连接数据库，获取/收集数据)</span><br><span class="line">  - jsp的职责：展示数据(强项是做数据的展示)</span><br><span class="line"></span><br><span class="line">## session 会话机制</span><br><span class="line"></span><br><span class="line">* 什么是会话</span><br><span class="line"></span><br><span class="line">  - 打开浏览器，进行一系列操作，然后最终将浏览器关闭，这个整个过程叫做一个会话，会话在服务器端也有一个Java对象，这个Java对象叫做session</span><br><span class="line">  - 在浏览器点击了一下，然后到页面停下来，可以粗略认为是一次请求，请求对应的服务器对象是request</span><br><span class="line">  - 一个会话中包含多次请求</span><br><span class="line"></span><br><span class="line">* session对象最主要的作用是：保存会话状态。（用户登录成功了，这是一种登陆成功的状态，使用session对象可以保留会话状态，把登陆状态一直保存住）</span><br><span class="line"></span><br><span class="line">* 为什么需要session对象保存会话状态</span><br><span class="line"></span><br><span class="line">  - 因为HTTP协议是一种无状态协议(请求的时候，B和S是连接的，但请求结束之后连接就断了，这样服务器压力小)</span><br><span class="line">  - 只要B和S断开了，关闭浏览器的动作，服务器是不知道的</span><br><span class="line"></span><br><span class="line">* 为什么不使用request对象保存会话状态，为什么不用ServletContext对象保存状态</span><br><span class="line"></span><br><span class="line">  - request是一次请求一个对象，作用域太小</span><br><span class="line">  - ServletContext对象是服务器启动的时候创建，服务器关闭的时候销毁，而且这个ServletContext对象只要一个，作用域太大</span><br><span class="line">  - request请求域(HttpServletRequest)&lt;session会话域(HttpSession)&lt;application域(ServletContext)</span><br><span class="line"></span><br><span class="line">* session对象</span><br><span class="line"></span><br><span class="line">  - session对象是存储在服务器中的</span><br><span class="line"></span><br><span class="line">  - 一个session对象对应一个会话，一次会话对应多个请求</span><br><span class="line"></span><br><span class="line">  - 获取方式：</span><br><span class="line"></span><br><span class="line">    - HttpSession session = request.getSession();从服务器中获取当前的session对象，如果没有则新建一个session对象</span><br><span class="line">    - HttpSession session  =  request.getSession(false);从服务器中获取当前session对象，如果没有不新建返回一个null</span><br><span class="line"></span><br><span class="line">  - 实现原理：</span><br><span class="line"></span><br><span class="line">    - 在web服务器中有一个session列表，类似于map集合，这个map集合的key存储的是sessionid，value存储的是session对象</span><br><span class="line">    - 用户第一次发送请求的时候，服务器会创建一个新的session对象，同时给session对象生成一个id，然后web服务器会将session对象的id发送给浏览器，浏览器将session的id保存在浏览器的缓存中</span><br><span class="line">    - 用户第二次发送请求的时候，会自动将浏览器缓存中的session对象的id自动发送给服务器，服务器获取到id，然后根据id查找对应的session对象</span><br><span class="line"></span><br><span class="line">  - session的两种销毁</span><br><span class="line"></span><br><span class="line">    - 超时销毁</span><br><span class="line"></span><br><span class="line">      - ```xml</span><br><span class="line">            &lt;session-config&gt;</span><br><span class="line">                &lt;session-timeout&gt;30&lt;/session-timeout&gt;</span><br><span class="line">            &lt;/session-config&gt;</span><br></pre></td></tr></table></figure>  - 在web.xml文件中的配置信息写上以上内容即可，表示超过三十分钟后session对象销毁- 手动销毁  - 例如，网银的安全退出的操作，就是手动销毁session对象</code></pre></li><li><p><strong>注：关闭浏览器后，浏览器中保存的sessionid消失，下次重新打开浏览器的时候，浏览器的缓存中没有这个sessionid，自然找不到对应的session对象，等同于会话结束</strong></p></li></ul></li><li><p>jsessionid &#x3D; xxxxxxxxx 是以Cookie的形式存在保存在浏览器中的</p></li><li><p>Cookie禁用了，每次请求都会新建一个session对象，此时服务器会正常发送cookie给浏览器，但是浏览器拒收</p><ul><li><p>为了实现session机制，需要使用URL重写机制</p></li><li><p><a href="http://localhost:8080/servlet08/dehua/tuji;JSESSIONID=A532F1125D878307C726D025E547492E">http://localhost:8080/servlet08/dehua/tuji;JSESSIONID=A532F1125D878307C726D025E547492E</a></p></li><li><p>URL重写机制会提高开发成本，开发人员在编写任何请求路径的时候，后面都添加一个sessionid，给开发提高难度，所以，大部分网站的设计是，如果你禁用了cookie就别用了</p></li></ul></li></ul><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul><li><p>session的实现原理中，每一个session对象都会关联一个对应的sessionid，例如：</p><ul><li>JSESSIONID&#x3D;A532F1125D878307C726D025E547492E</li><li>以上这个键值对数据其实就是cookie数据</li><li>对于session关联的cookie来说，这个cookie是被保存在浏览器的运行内存中</li><li>只要浏览器不关闭，用户再次发送请求的时候，会自动将运行内存中的cookie数据发送给服务器</li><li>服务器通过键值对的值A532F1125D878307C726D025E547492E来找到对应的session对象</li></ul></li><li><p>cookie最终是保存在浏览器客户端上的</p><ul><li>可以保存在运行内存中(浏览器只要关闭cookie就消失了)</li><li>也可以保存在硬盘文件中(永久保存)</li></ul></li><li><p>cookie的作用</p><ul><li>cookie和session机制其实都是为了保存会话状态</li><li>cookie是将会话的状态保存在浏览器客户端上(cookie将数据存储在浏览器客户端上)</li><li>session是将会话的状态保存在服务器端(session对象是存储在服务器上)</li></ul></li><li><p>在Java的servlet中，对cookie提供了哪些支持</p><ul><li>提供了一个cookie类专门表示cookie数据：jakarta.servlet.http.Cookie</li><li>java程序把cookie数据发送给浏览器:request.addCookie(cookis)</li></ul></li><li><p>在Http协议中是这样规定的：当浏览器发送请求时，会自动携带path下的cookie数据给服务器(通过URL)</p></li><li><p>关于cookie的有效时间</p><ul><li>用Java设置有效时间：cookie.setMaxAge(60*60)设置cookie在一小时之后失效，所以数字的单位是秒</li><li>没有设置有效时间，，默认保存在浏览器的运行内存中，浏览器关闭则cookie消失</li><li>设置时间大于零，cookie一定会存储在硬盘文件当中</li><li>设置时间等于零，cookie会被删除，同名cookie被删除</li><li>设置时间小于零，保存在浏览器的运行内存中，和没写cookie.setMaxAge(-1)这行代码效果相同</li></ul></li><li><p>关于cookie的path，cookie的相关路径</p><ul><li>假设现在发送的请求是<a href="http://localhost:8080/servlet/cookie/generate%E7%94%9F%E6%88%90%E7%9A%84cookie%EF%BC%8C%E5%A6%82%E6%9E%9Ccookie%E6%B2%A1%E6%9C%89%E8%AE%BE%E7%BD%AEpath%EF%BC%8C%E9%BB%98%E8%AE%A4%E7%9A%84path%E6%98%AF%EF%BC%9Ahttp://localhost:8080/servlet/cookie/%E4%BB%A5%E5%8F%8A%E5%AE%83%E7%9A%84%E5%AD%90%E8%B7%AF%E5%BE%84%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%AA%E8%A6%81%E5%8F%91%E9%80%81%E8%BF%99%E4%B8%AA%E8%B7%AF%E5%BE%84%E5%8F%8A%E5%85%B6%E5%AD%90%E8%B7%AF%E5%BE%84%EF%BC%8Ccookie%E9%83%BD%E4%BC%9A%E8%A2%AB%E5%8F%91%E9%80%81%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8">http://localhost:8080/servlet/cookie/generate生成的cookie，如果cookie没有设置path，默认的path是：http://localhost:8080/servlet/cookie/以及它的子路径，也就是说浏览器只要发送这个路径及其子路径，cookie都会被发送到服务器</a></li><li>手动设置cookie的path：cookie.serPath(“&#x2F;servlet13”),表示只要是servlet13项目的请求路径都会提交这个cookie</li></ul></li><li><p>浏览器发送cookie给服务器，服务器中Java程序接收</p><ul><li><pre><code class="java">Cookie[] cookies = request.getCookie();//如果没有则返回nullif(cookies != null)&#123;        for(Cookie cookie : cookies)&#123;        String name = cookie.getName();        String value = cookie.getValue();    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">## EL表达式</span><br><span class="line"></span><br><span class="line">* EL表达式出现在jsp的作用</span><br><span class="line"></span><br><span class="line">  - 从某个域中取数据，然后将其转换为字符串，然后输出到浏览器，这就是EL浏览器的三大功效</span><br><span class="line"></span><br><span class="line">* 语法  $&#123;key&#125;</span><br><span class="line"></span><br><span class="line">* EL表达式使用：</span><br><span class="line"></span><br><span class="line">  - ```jsp</span><br><span class="line">    &lt;%</span><br><span class="line">      User user = new user();</span><br><span class="line">      user.setName(&quot;jack&quot;);</span><br><span class="line">      user.setAge(66)</span><br><span class="line">      request.setAttribute(&quot;userdetial&quot;,user);</span><br><span class="line">    %&gt;</span><br><span class="line">    $&#123;userdetial&#125;//大括号里面必须写存储到域对象中name，不能写成$&#123;&quot;userdetial&quot;&#125;,这样是直接输出&quot;userdetial&quot;这个字符串</span><br><span class="line">    $&#123;userdetial&#125;的底层是先从域中取数据，即user对象，然后调用user的toString方法，转换成字符串，输出到浏览器</span><br><span class="line">    //直接输出对象的某一个属性</span><br><span class="line">    $&#123;user.name&#125;</span><br><span class="line">    $&#123;user.age&#125;</span><br><span class="line">    //使用这个两个语法的前提是，userd对象有getName()和getAge()这两个方法，这样写底层其实调用了get方法</span><br><span class="line">    //如果在不同的域中，存上相同名字的key，然后使用$&#123;&#125;调用的时候，在没有指定范围的情况下，取出的顺序是先从小的域中取，然后再是大的域</span><br><span class="line">    //指定域的语法,key相同时，优先从哪个域取数据的语法</span><br><span class="line">    $&#123;pageScopr.userdetial&#125;</span><br><span class="line">    $&#123;requestScope.userdetial&#125;</span><br><span class="line">    $&#123;session.userdetial&#125;</span><br><span class="line">    $&#123;applicationScope.userdetial&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>EL表达式对null进行了预处理，如果是null，则输出一个空字符串到浏览器</p></li><li><p>EL表达式取数据的时候有两种形式：</p><ul><li>第一种：${user.userdetial}(大部分是使用这种形式)</li><li>第二种：${user[“userdetial”]}(如果存储到域中的key含有特殊字符，可以使用[]),例如：<ul><li>request.setAttribute(“abc.def”,”fhaishdu”)</li><li>${requestScope.abc.def}这样是无法取值的</li><li>应该写成这样：${requestScope[“abc.def”]}</li><li><strong>注意：中括号里面必须加双引号</strong></li></ul></li></ul></li><li><p>使用EL表达式从Map中取数据</p><ul><li>${map.key}</li></ul></li><li><p>使用EL表达式从List和数组中取数据</p><ul><li>${list[索引]}</li><li>${数组[索引]}</li></ul></li><li><p>page指令忽略EL表达式</p><ul><li><pre><code class="jsp">&lt;%@page contentType=&quot;html/text;charset=UTF-8&quot; isELIgnored=&quot;true&quot;%&gt;isELIgnored=&quot;true&quot;表示忽略EL表达式isELIgnored=&quot;false&quot;表示不忽略EL表示式（这是默认值）//以上指令是忽略所有的EL表达式可以使用反斜杠局部控制：\$&#123;username&#125;，这样也可以忽略EL表达式，只忽略这一行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- EL中的隐式对象</span><br><span class="line"></span><br><span class="line">  - ```jsp</span><br><span class="line">    //pageContext</span><br><span class="line">    //EL表示式中没有request这个隐式对象，EL表达式中有一个隐式对象：pageContext，EL表达式中的pageContext和jsp中的九大内置对象pageContext是同一个对象</span><br><span class="line">    $&#123;pageContext.request.contextPath&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="jsp">//param//如果用户提交的请求是：http://localhost:8080/jsp?aihao=smoke&amp;aihao=drink&amp;aihao=tangtou$&#123;param.aihao&#125;这样可以获取请求参数一维数组当中的第一个元素$&#123;paramValues.aihao[索引]&#125;可以获得数组中指定的元素//在web.xml文件中配置以下数据    &lt;context-param&gt;        &lt;param-name&gt;pageSize&lt;/param-name&gt;        &lt;param-value&gt;20&lt;/param-value&gt;    &lt;/context-param&gt;$&#123;initParam.pageSize&#125;相当于&lt;%application.getInitParameter(&quot;pageSize&quot;)%&gt;获取上下文对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - EL表达式的运算符</span><br><span class="line">    - 算数运算符(+ - * /)只能做数值运算，不能做字符串的运算，如果是“123”这样的字符串，先把字符串转成数字，然后进行数值的运算，其他字符串直接报错</span><br><span class="line">    - 比较运算符(= , !=  , eq)都会调用equal方法</span><br><span class="line">    - empty 判断后面的内容是否为空</span><br><span class="line"></span><br><span class="line">## JSTL标签库</span><br><span class="line"></span><br><span class="line">* 在jsp中引入JSTL标签库(使用taglib指令)</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    &lt;%@taglib prefix=&quot;这里随便起一个名字即可，一般是c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line">    //这个就是核心标签库</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li><li><p>JSTL标签的原理</p><ul><li><pre><code>&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;//以上uri后面的路径实际上指向了一个xxx.tld文件，tld文件其实是一个xml文件，在tld文件中描述了标签和java类的关系//以上核心标签库对应tld文件是：c.tld文件，在jakarta.servlet.jsp.jstl-2.0.0.jar里面META-INF目录下有一个c.tld文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 源码解析</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">      &lt;tag&gt;</span><br><span class="line">        &lt;description&gt;对标签的描述&lt;/description&gt;</span><br><span class="line">        &lt;name&gt;catch&lt;/name&gt;标签的名字</span><br><span class="line">        &lt;tag-class&gt;org.apache.taglibs.standard.tag.common.core.CatchTag&lt;/tag-class&gt;标签对应的Java类</span><br><span class="line">        &lt;body-content&gt;JSP&lt;/body-content&gt;标签体当中可以出现的内容，如果是jsp就表示，就表示标签体中可以出现符合jsp所有语法的代码，例如EL表达式</span><br><span class="line">        &lt;attribute&gt;//属性</span><br><span class="line">            &lt;description&gt;对属性的描述&lt;/description&gt;</span><br><span class="line">            &lt;name&gt;var&lt;/name&gt;属性名</span><br><span class="line">            &lt;required&gt;false&lt;/required&gt;false表示该属性不是必须的，true表示该属性是必须的</span><br><span class="line">            &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt;这个描述说明了该属性是否支持EL表达式，false表示不支持，true表示支持</span><br><span class="line">        &lt;/attribute&gt;</span><br><span class="line">      &lt;/tag&gt;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>jstl中的核心标签库core中的常用标签</p><ul><li><p>c:if</p><ul><li>&lt;c:if test&#x3D;”boolean类型，支持EL表达式”&gt;&lt;&gt;</li></ul></li><li><p>c:forEach</p><ul><li>&lt;c:forEach items&#x3D;”集合，支持EL表达式” var&#x3D;”集合中的元素” varStatus&#x3D;”元素状态对象”&gt;${元素状态对象.count}&lt;&gt;</li><li>count可以实现自增，常用于编号</li><li>&lt;c:forEach var&#x3D;”i” begin &#x3D;”1” end&#x3D;”10” step&#x3D;”1”&gt;${i}&lt;&gt;</li></ul></li><li><p>c:choose c:when c:otherwise</p><ul><li><pre><code>&lt;c:choose&gt;  &lt;c:when test=&quot;$&#123;age&lt;18&#125;&quot;&gt;  未成年  &lt;/c:when&gt;  &lt;c:otherwise&gt;  成年  &lt;/c:otherwise&gt;&lt;/c:choose&gt;  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## Filter过滤器</span><br><span class="line"></span><br><span class="line">* Filter是过滤器，可以在Servlet这个目标程序执行之前添加代码，也可以在目标Servlet程序执行之后添加代码，一般情况下将公共代码编写到过滤器当中</span><br><span class="line"></span><br><span class="line">* 过滤器写法</span><br><span class="line"></span><br><span class="line">  - 第一步：编写一个Java类实现一个接口：jakarta.servlet.Filter并实现这个接口所有方法</span><br><span class="line"></span><br><span class="line">    - init方法：在Filter对象第一次被创建的时候调用，并且只调用一次</span><br><span class="line">    - doFilter方法：只要用户发送一次请求，则执行一次，发送n次请求则执行n次</span><br><span class="line">    - destroy方法：在Filter对象被释放销毁之前被调用，并且只调用一次</span><br><span class="line"></span><br><span class="line">  - 第二步：在类上写注解@WebFilter(&quot;路径&quot;)，或者在web.xml文件中配置和Servlet类似</span><br><span class="line"></span><br><span class="line">    - ```xml</span><br><span class="line">          &lt;filter&gt;</span><br><span class="line">              &lt;filter-name&gt;filter1&lt;/filter-name&gt;</span><br><span class="line">              &lt;filter-class&gt;com.nipowenode.servlet.Filter.Filter1&lt;/filter-class&gt;</span><br><span class="line">          &lt;/filter&gt;</span><br><span class="line">          &lt;filter-mapping&gt;</span><br><span class="line">              &lt;filter-name&gt;filter1&lt;/filter-name&gt;</span><br><span class="line">              &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">          &lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul></li><li><p><strong>注意</strong></p><ul><li>Servlet对象默认情况下，在服务启动的时候不会新建对象</li><li>Filter对象默认情况下，在服务器启动的时候会新建对象</li><li>Servlet是单例的，Filter也是单例的</li></ul></li><li><p>目标Servlet是否执行取决于两个条件</p><ul><li>第一：在过滤器中是否编写了chain.doFilter(request,response);代码(这行代码表示执行下一个过滤器，如果没有下一个过滤器则执行最终的Servlet)</li><li>第二：用户发送的请求是否和Servlet请求路径一致</li></ul></li><li><p>注意：Filter的优先级，天生就比Servlet的优先级高</p><ul><li>&#x2F;a.do对应一个Filter，也对应一个Servlet，那么一定是先执行Filter，然后执行Servlet</li></ul></li><li><p>Filter的配置路径</p><ul><li>&#x2F;a.do,&#x2F;b.do,&#x2F;dept&#x2F;save 这些配置方式都是精确配置</li><li>&#x2F;* 匹配所有路径</li><li>*.do 后缀匹配，不要以&#x2F;开始</li><li>&#x2F;dept&#x2F;* 前缀匹配</li></ul></li><li><p>在web.xml文件中进行配置的时候，Filter的执行顺序是<filter-mapping>标签越靠前的，执行优先级越高</filter-mapping></p></li><li><p>过滤器的调用顺序，遵行栈的数据结构，先进后出</p></li><li><p>使用注,Filter的执行顺序</p><ul><li>比较Filter这个类名</li><li>比如：FilterA和FilterB，先执行FilterA</li><li>比如：Filter1和Filter2，先执行Filter1</li></ul></li><li><p>Filter的生命周期</p><ul><li>和Servlet生命周期相同</li><li>唯一的区别：Filter默认情况下，在服务器启动的情况下就会实例化，Servlet不会</li></ul></li><li><p>责任链设计模式</p><ul><li>过滤器的优点：在程序编译阶段不会确定调用对象，因为Filter的调用顺序是配置到web.xml文件中的，只要修改web.xml配置文件中的filter-mapping的顺序就可以调整Filter的执行顺序，显然Filter的执行顺序是在程序运行阶段动态组合的，这种设计模式被称为责任链设计模式</li><li>责任链模式的最大核心思想：在程序运行阶段，动态的组合程序的调用顺序</li></ul></li></ul><h2 id="Listener-监听器"><a href="#Listener-监听器" class="headerlink" title="Listener 监听器"></a>Listener 监听器</h2><ul><li><p>监听器有什么用</p><ul><li>监听器实际上是Servlet规范留给我们javaweb程序员的特殊时机</li><li>特殊时刻如果想执行这段代码，你需要想到使用对应的监听器</li></ul></li><li><p>Servlet规范中提供的监听器：</p><ul><li>jakarta.servlet包下：<ul><li>ServletContextListener</li><li>ServletContextAttributeListener</li><li>ServletRequestListener</li><li>ServletRequestAttributeListener</li></ul></li><li>jakarta.servlet.http包下：<ul><li>HttpSessionListener</li><li>HttpSessionAttributeListener<ul><li>该监听器需要使用@WebListener注解进行标注</li><li>主要在session中存入数据都会出发该监听器并执行方法</li></ul></li><li>HttpSessionBindingListener<ul><li>该监听器不需要@WebListener注解标注</li><li>只要某个类实现了HttpSessionBindingListener这个监听器，然后这个类对象放入到session的时候触发bind事件，类对象从session中删除的时候，会触发unbind事件</li></ul></li><li>HttpSessionIdListener(不重要)<ul><li>session的id发生改变的时候，监听器中的唯一一个方法就会被调用</li></ul></li><li>HttpSessionActivationListener<ul><li>监听session对象的钝化和活化</li><li>钝化：session对象从内存存到硬盘文件</li><li>活化：session对象从硬盘存到内存</li></ul></li></ul></li></ul></li><li><p>实现一个监听器的步骤：</p><ul><li><p>第一步：编写一个类实现ServletContextListener接口，并实现里面方法</p><ul><li><pre><code class="java">void contextInitialized(ServletContextEvent sce)&#123;&#125;void contextDestroyed(ServletContextEvent sce)</code></pre></li></ul></li><li><p>第二步：在web.xml文件中配置，或者在类上面加上注解@WebListener</p></li></ul></li><li><p>注意：所有监听器中的方法都是不需要javaweb程序员调用的，当某个特殊的事件发生之后，被web服务器自动调用</p></li></ul><h2 id="MVC架构模式"><a href="#MVC架构模式" class="headerlink" title="MVC架构模式"></a>MVC架构模式</h2><p><img src="/2023/07/02/javaweb/Users\ZDKJ\AppData\Roaming\Typora\typora-user-images\image-20221130193806151.png" alt="image-20221130193806151"></p><ul><li>表示层：web包<ul><li>写servlet</li></ul></li><li>业务逻辑层：service包<ul><li>写业务逻辑代码</li></ul></li><li>持久层：dao包<ul><li>做数据库的增删改查</li></ul></li><li>pojo包：封装数据</li><li>utils包：放工具的</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
